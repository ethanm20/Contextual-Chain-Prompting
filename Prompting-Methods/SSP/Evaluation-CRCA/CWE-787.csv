,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,F1_Clarity_C5,F2_Relevance_C5,F3_Completeness_C5,F4_Actionability_C5
0,0,50214,50214,,Remote,Not required,Partial,CVE-2016-7126,https://www.cvedetails.com/cve/CVE-2016-7126/,CWE-787,Low,Partial,Partial,,2016-09-11,7.5,"The imagetruecolortopalette function in ext/gd/gd.c in PHP before 5.6.25 and 7.x before 7.0.10 does not properly validate the number of colors, which allows remote attackers to cause a denial of service (select_colors allocation error and out-of-bounds write) or possibly have unspecified other impact via a large value in the third argument.",2018-01-04,DoS ,0,https://github.com/php/php-src/commit/b6f13a5ef9d6280cf984826a5de012a32c396cd4?w=1,b6f13a5ef9d6280cf984826a5de012a32c396cd4?w=1,Fix bug#72697 - select_colors write out-of-bounds,0,ext/gd/gd.c,"{""sha"": ""cdfbaa2c4e4d2c543d8deba6e36ecb1ba8fcadd9"", ""filename"": ""ext/gd/gd.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/php/php-src/blob/b6f13a5ef9d6280cf984826a5de012a32c396cd4/ext/gd/gd.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b6f13a5ef9d6280cf984826a5de012a32c396cd4/ext/gd/gd.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/gd.c?ref=b6f13a5ef9d6280cf984826a5de012a32c396cd4"", ""patch"": ""@@ -99,7 +99,7 @@ static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int, int);\n \n #include \""gd_ctx.c\""\n \n-/* as it is not really public, duplicate declaration here to avoid \n+/* as it is not really public, duplicate declaration here to avoid\n    pointless warnings */\n int overflow2(int a, int b);\n \n@@ -1197,7 +1197,7 @@ PHP_MINIT_FUNCTION(gd)\n \tREGISTER_LONG_CONSTANT(\""IMG_CROP_SIDES\"", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\""IMG_CROP_THRESHOLD\"", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);\n \n-\t\n+\n \tREGISTER_LONG_CONSTANT(\""IMG_BELL\"", GD_BELL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\""IMG_BESSEL\"", GD_BESSEL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\""IMG_BILINEAR_FIXED\"", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);\n@@ -1651,11 +1651,11 @@ PHP_FUNCTION(imagetruecolortopalette)\n \n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n \n-\tif (ncolors <= 0) {\n-\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Number of colors has to be greater than zero\"");\n+\tif (ncolors <= 0 || ncolors > INT_MAX) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Number of colors has to be greater than zero and no more than %d\"", INT_MAX);\n \t\tRETURN_FALSE;\n \t}\n-\tgdImageTrueColorToPalette(im, dither, ncolors);\n+\tgdImageTrueColorToPalette(im, dither, (int)ncolors);\n \n \tRETURN_TRUE;\n }\n@@ -3906,7 +3906,7 @@ static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int\n #endif /* VIRTUAL_DIR */\n \n \tPHP_GD_CHECK_OPEN_BASEDIR(fontname, \""Invalid font filename\"");\n-\t\n+\n #ifdef HAVE_GD_FREETYPE\n \tif (extended) {\n \t\terror = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);\n@@ -4484,7 +4484,7 @@ static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n \tint x, y;\n \tfloat x_ratio, y_ratio;\n     long ignore_warning;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""pplll\"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n \t\treturn;\n \t}\n@@ -5367,7 +5367,7 @@ PHP_FUNCTION(imageaffinematrixget)\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing y position\"");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tif (type == GD_AFFINE_TRANSLATE) {\n \t\t\t\tres = gdAffineTranslate(affine, x, y);\n \t\t\t} else {""}<_**next**_>{""sha"": ""6110385fcb8077cce80508f58a66da37e4d97549"", ""filename"": ""ext/gd/tests/bug72697.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/b6f13a5ef9d6280cf984826a5de012a32c396cd4/ext/gd/tests/bug72697.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/b6f13a5ef9d6280cf984826a5de012a32c396cd4/ext/gd/tests/bug72697.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/tests/bug72697.phpt?ref=b6f13a5ef9d6280cf984826a5de012a32c396cd4"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72697: select_colors write out-of-bounds\n+--SKIPIF--\n+<?php \n+if (!function_exists(\""imagecreatetruecolor\"")) die(\""skip\"");\n+if (PHP_INT_MAX !== 9223372036854775807) die(\""skip for 64-bit long systems only\"");\n+?>\n+--FILE--\n+<?php\n+\n+$img=imagecreatetruecolor(10, 10);\n+imagetruecolortopalette($img, false, PHP_INT_MAX / 8);\n+?>\n+DONE\n+--EXPECTF--\n+Warning: imagetruecolortopalette(): Number of colors has to be greater than zero and no more than 2147483647 in %sbug72697.php on line %d\n+DONE\n\\ No newline at end of file""}","PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		if (Z_TYPE_PP(item) != IS_LONG) {
			zval lval;
			lval = **item;
			zval_copy_ctor(&lval);
			convert_to_long(&lval);
			stylearr[index++] = Z_LVAL(lval);
		} else {
			stylearr[index++] = Z_LVAL_PP(item);
		}
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}
","PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		if (Z_TYPE_PP(item) != IS_LONG) {
			zval lval;
			lval = **item;
			zval_copy_ctor(&lval);
			convert_to_long(&lval);
			stylearr[index++] = Z_LVAL(lval);
		} else {
			stylearr[index++] = Z_LVAL_PP(item);
		}
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}
",C,,,,"@@ -99,7 +99,7 @@ static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int, int);
 
 #include ""gd_ctx.c""
 
-/* as it is not really public, duplicate declaration here to avoid 
+/* as it is not really public, duplicate declaration here to avoid
    pointless warnings */
 int overflow2(int a, int b);
 
@@ -1197,7 +1197,7 @@ PHP_MINIT_FUNCTION(gd)
 	REGISTER_LONG_CONSTANT(""IMG_CROP_SIDES"", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_CROP_THRESHOLD"", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);
 
-	
+
 	REGISTER_LONG_CONSTANT(""IMG_BELL"", GD_BELL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_BESSEL"", GD_BESSEL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_BILINEAR_FIXED"", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);
@@ -1651,11 +1651,11 @@ PHP_FUNCTION(imagetruecolortopalette)
 
 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
-	if (ncolors <= 0) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Number of colors has to be greater than zero"");
+	if (ncolors <= 0 || ncolors > INT_MAX) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Number of colors has to be greater than zero and no more than %d"", INT_MAX);
 		RETURN_FALSE;
 	}
-	gdImageTrueColorToPalette(im, dither, ncolors);
+	gdImageTrueColorToPalette(im, dither, (int)ncolors);
 
 	RETURN_TRUE;
 }
@@ -3906,7 +3906,7 @@ static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int
 #endif /* VIRTUAL_DIR */
 
 	PHP_GD_CHECK_OPEN_BASEDIR(fontname, ""Invalid font filename"");
-	
+
 #ifdef HAVE_GD_FREETYPE
 	if (extended) {
 		error = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);
@@ -4484,7 +4484,7 @@ static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )
 	int x, y;
 	float x_ratio, y_ratio;
     long ignore_warning;
-	
+
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pplll"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {
 		return;
 	}
@@ -5367,7 +5367,7 @@ PHP_FUNCTION(imageaffinematrixget)
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
 				RETURN_FALSE;
 			}
-			
+
 			if (type == GD_AFFINE_TRANSLATE) {
 				res = gdAffineTranslate(affine, x, y);
 			} else {",php-src,b6f13a5ef9d6280cf984826a5de012a32c396cd4?w=1,620b01337cc39f856ca68c34c35e154f5f0682fc,0,"PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		if (Z_TYPE_PP(item) != IS_LONG) {
			zval lval;
			lval = **item;
			zval_copy_ctor(&lval);
			convert_to_long(&lval);
			stylearr[index++] = Z_LVAL(lval);
		} else {
			stylearr[index++] = Z_LVAL_PP(item);
		}
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}
",50214,"PHP_FUNCTION(imagetruecolortopalette)
{
	zval *IM;
	zend_bool dither;
	long ncolors;
	gdImagePtr im;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rbl"", &IM, &dither, &ncolors) == FAILURE)  {
		return;
	}
 
 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
	if (ncolors <= 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Number of colors has to be greater than zero"");
 		RETURN_FALSE;
 	}
	gdImageTrueColorToPalette(im, dither, ncolors);
 
 	RETURN_TRUE;
 }
","PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		if (Z_TYPE_PP(item) != IS_LONG) {
			zval lval;
			lval = **item;
			zval_copy_ctor(&lval);
			convert_to_long(&lval);
			stylearr[index++] = Z_LVAL(lval);
		} else {
			stylearr[index++] = Z_LVAL_PP(item);
		}
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}
","The vulnerability in the original `imagetruecolortopalette` function arises from the lack of validation for the `ncolors` parameter, which could allow an attacker to pass a negative or excessively large value, potentially leading to memory corruption or denial of service when `gdImageTrueColorToPalette` is called. In the revised `imagesetstyle` function, the code improves safety by using `safe_emalloc` to allocate memory for `stylearr`, ensuring that the allocation is secure and prevents buffer overflows. Additionally, it checks the type of each item in the `styles` array, converting them to long only if they are not already, thus enhancing type safety and preventing unexpected behavior.","The vulnerability in the original code stems from inadequate validation of input parameters, particularly allowing a negative or excessively large value for the number of colors, which could lead to memory corruption or crashes when processing images. This lack of checks could be exploited by an attacker to manipulate the program's behavior. In the revised code, the vulnerability is addressed by implementing safer memory allocation techniques and ensuring that the input data is properly validated and converted before use. This enhances the overall robustness of the function, preventing potential exploitation and ensuring that only valid data is processed.",1,0,3,2
1,1,177918,177918,,Remote,Not required,Partial,CVE-2018-14600,https://www.cvedetails.com/cve/CVE-2018-14600/,CWE-787,Low,Partial,Partial,,2018-08-24,7.5,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c interprets a variable as signed instead of unsigned, resulting in an out-of-bounds write (of up to 128 bytes), leading to DoS or remote code execution.",2019-08-06,Exec Code,2,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,,2,,,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}
","char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}
",C,"	    length = *(unsigned char *)ch;
		    length = *(unsigned char *)ch;
","	    length = *ch;
		    length = *ch;
",b469da1430cdcee06e31c6251b83aede072a1ff0,"@@ -75,12 +75,12 @@ char **XListExtensions(
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
-	    length = *ch;
+	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
-		    length = *ch;
+		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else",libx11,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/ListExt.c?id=dbf72805fd9d7b1846fe9a11b46f3994bfc27fea,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/ListExt.c?id=b469da1430cdcee06e31c6251b83aede072a1ff0,1,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
//flaw_line_below:
	    length = *ch;
//fix_flaw_line_below:
//	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
//flaw_line_below:
		    length = *ch;
//fix_flaw_line_below:
//		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}
",177918,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}
","char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
 	     * unpack into null terminated strings.
 	     */
 	    chend = ch + rlen;
	    length = *(unsigned char *)ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *(unsigned char *)ch;
 		    *ch = '\0'; /* and replace with null-termination */
 		    count++;
 		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}
","The vulnerability in the original code arises from the use of the variable `length`, which is assigned the value of `*ch`, potentially leading to incorrect memory access if `ch` does not point to a valid length byte. This could result in buffer overflows or reading beyond allocated memory. In the fixed code, the assignment is changed to `length = *(unsigned char *)ch`, ensuring that `length` is correctly interpreted as an unsigned character. This change mitigates the risk of accessing invalid memory and enhances the overall safety of the function by ensuring proper type handling.","The vulnerability in the original code stems from improper handling of data types, which could lead to incorrect memory access and potential buffer overflows. Specifically, the code retrieves a length value from a pointer without ensuring it is treated as the correct type, risking the reading of unintended memory locations. The fixed code addresses this issue by explicitly casting the pointer to the appropriate type before dereferencing it, ensuring that the length is accurately interpreted. This change enhances memory safety by preventing out-of-bounds access and ensuring that the program behaves as intended without risking corruption or crashes.",3,5,3,4
2,2,178056,178056,,Remote,Not required,Partial,CVE-2017-8105,https://www.cvedetails.com/cve/CVE-2017-8105/,CWE-787,Low,Partial,Partial,,2017-04-24,7.5,FreeType 2 before 2017-03-24 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_decoder_parse_charstrings function in psaux/t1decode.c.,2019-04-23,Overflow,9,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f958c48ee431bef8d4d466b40c9cb2d4dbcb7791,f958c48ee431bef8d4d466b40c9cb2d4dbcb7791,,0,,,"  t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                FT_Byte*    charstring_base,
                                FT_UInt     charstring_len )
  {
    FT_Error         error;
    T1_Decoder_Zone  zone;
    FT_Byte*         ip;
    FT_Byte*         limit;
    T1_Builder       builder = &decoder->builder;
    FT_Pos           x, y, orig_x, orig_y;
    FT_Int           known_othersubr_result_cnt   = 0;
    FT_Int           unknown_othersubr_result_cnt = 0;
    FT_Bool          large_int;
    FT_Fixed         seed;

    T1_Hints_Funcs   hinter;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_Bool          bol = TRUE;
#endif


    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* First of all, initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;

    builder->parse_state = T1_Parse_Start;

    hinter = (T1_Hints_Funcs)builder->hints_funcs;

    /* a font that reads BuildCharArray without setting */
    /* its values first is buggy, but ...               */
    FT_ASSERT( ( decoder->len_buildchar == 0 ) ==
               ( decoder->buildchar == NULL )  );

    if ( decoder->buildchar && decoder->len_buildchar > 0 )
      FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );

    FT_TRACE4(( ""\n""
                ""Start charstring\n"" ));

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = orig_x = builder->pos_x;
    y = orig_y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    large_int = FALSE;

    /* now, execute loop */
    while ( ip < limit )
    {
      FT_Long*     top   = decoder->top;
      T1_Operator  op    = op_none;
      FT_Int32     value = 0;


      FT_ASSERT( known_othersubr_result_cnt == 0   ||
                 unknown_othersubr_result_cnt == 0 );

#ifdef FT_DEBUG_LEVEL_TRACE
      if ( bol )
      {
        FT_TRACE5(( "" (%d)"", decoder->top - decoder->stack ));
        bol = FALSE;
      }
#endif

      /*********************************************************************/
      /*                                                                   */
      /* Decode operator or operand                                        */
      /*                                                                   */
      /*                                                                   */

      /* first of all, decompress operator or value */
      switch ( *ip++ )
      {
      case 1:
        op = op_hstem;
        break;

      case 3:
        op = op_vstem;
        break;
      case 4:
        op = op_vmoveto;
        break;
      case 5:
        op = op_rlineto;
        break;
      case 6:
        op = op_hlineto;
        break;
      case 7:
        op = op_vlineto;
        break;
      case 8:
        op = op_rrcurveto;
        break;
      case 9:
        op = op_closepath;
        break;
      case 10:
        op = op_callsubr;
        break;
      case 11:
        op = op_return;
        break;

      case 13:
        op = op_hsbw;
        break;
      case 14:
        op = op_endchar;
        break;

      case 15:          /* undocumented, obsolete operator */
        op = op_unknown15;
        break;

      case 21:
        op = op_rmoveto;
        break;
      case 22:
        op = op_hmoveto;
        break;

      case 30:
        op = op_vhcurveto;
        break;
      case 31:
        op = op_hvcurveto;
        break;

      case 12:
        if ( ip >= limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+EOF)\n"" ));
          goto Syntax_Error;
        }

        switch ( *ip++ )
        {
        case 0:
          op = op_dotsection;
          break;
        case 1:
          op = op_vstem3;
          break;
        case 2:
          op = op_hstem3;
          break;
        case 6:
          op = op_seac;
          break;
        case 7:
          op = op_sbw;
          break;
        case 12:
          op = op_div;
          break;
        case 16:
          op = op_callothersubr;
          break;
        case 17:
          op = op_pop;
          break;
        case 33:
          op = op_setcurrentpoint;
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+%d)\n"",
                     ip[-1] ));
          goto Syntax_Error;
        }
        break;

      case 255:    /* four bytes integer */
        if ( ip + 4 > limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unexpected EOF in integer\n"" ));
          goto Syntax_Error;
        }

        value = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] << 8  ) |
                              (FT_UInt32)ip[3]         );
        ip += 4;

        /* According to the specification, values > 32000 or < -32000 must */
        /* be followed by a `div' operator to make the result be in the    */
        /* range [-32000;32000].  We expect that the second argument of    */
        /* `div' is not a large number.  Additionally, we don't handle     */
        /* stuff like `<large1> <large2> <num> div <num> div' or           */
        /* <large1> <large2> <num> div div'.  This is probably not allowed */
        /* anyway.                                                         */
        if ( value > 32000 || value < -32000 )
        {
          if ( large_int )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no `div' after large integer\n"" ));
          }
          else
            large_int = TRUE;
        }
        else
        {
          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }

        break;

      default:
        if ( ip[-1] >= 32 )
        {
          if ( ip[-1] < 247 )
            value = (FT_Int32)ip[-1] - 139;
          else
          {
            if ( ++ip > limit )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected EOF in integer\n"" ));
              goto Syntax_Error;
            }

            if ( ip[-2] < 251 )
              value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
            else
              value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
          }

          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }
        else
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid byte (%d)\n"", ip[-1] ));
          goto Syntax_Error;
        }
      }

      if ( unknown_othersubr_result_cnt > 0 )
      {
        switch ( op )
        {
        case op_callsubr:
        case op_return:
        case op_none:
        case op_pop:
          break;

        default:
          /* all operands have been transferred by previous pops */
          unknown_othersubr_result_cnt = 0;
          break;
        }
      }

      if ( large_int && !( op == op_none || op == op_div ) )
      {
        FT_ERROR(( ""t1_decoder_parse_charstrings:""
                   "" no `div' after large integer\n"" ));

        large_int = FALSE;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Push value on stack, or process operator                         */
      /*                                                                   */
      /*                                                                   */
      if ( op == op_none )
      {
        if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings: stack overflow\n"" ));
          goto Syntax_Error;
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( large_int )
          FT_TRACE4(( "" %d"", value ));
        else
          FT_TRACE4(( "" %d"", value / 65536 ));
#endif

        *top++       = value;
        decoder->top = top;
      }
      else if ( op == op_callothersubr )  /* callothersubr */
      {
        FT_Int  subr_no;
        FT_Int  arg_cnt;


#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( "" callothersubr\n"" ));
        bol = TRUE;
#endif

        if ( top - decoder->stack < 2 )
          goto Stack_Underflow;

        top -= 2;

        subr_no = Fix2Int( top[1] );
        arg_cnt = Fix2Int( top[0] );

        /***********************************************************/
        /*                                                         */
        /* remove all operands to callothersubr from the stack     */
        /*                                                         */
        /* for handled othersubrs, where we know the number of     */
        /* arguments, we increase the stack by the value of        */
        /* known_othersubr_result_cnt                              */
        /*                                                         */
        /* for unhandled othersubrs the following pops adjust the  */
        /* stack pointer as necessary                              */

        if ( arg_cnt > top - decoder->stack )
          goto Stack_Underflow;

        top -= arg_cnt;

        known_othersubr_result_cnt   = 0;
        unknown_othersubr_result_cnt = 0;

        /* XXX TODO: The checks to `arg_count == <whatever>'       */
        /* might not be correct; an othersubr expects a certain    */
        /* number of operands on the PostScript stack (as opposed  */
        /* to the T1 stack) but it doesn't have to put them there  */
        /* by itself; previous othersubrs might have left the      */
        /* operands there if they were not followed by an          */
        /* appropriate number of pops                              */
        /*                                                         */
        /* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
        /* accept a font that contains charstrings like            */
        /*                                                         */
        /*     100 200 2 20 callothersubr                          */
        /*     300 1 20 callothersubr pop                          */
        /*                                                         */
        /* Perhaps this is the reason why BuildCharArray exists.   */

        switch ( subr_no )
        {
        case 0:                     /* end flex feature */
          if ( arg_cnt != 3 )
            goto Unexpected_OtherSubr;

          if ( !decoder->flex_state           ||
               decoder->num_flex_vectors != 7 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected flex end\n"" ));
            goto Syntax_Error;
          }

          /* the two `results' are popped by the following setcurrentpoint */
          top[0] = x;
          top[1] = y;
          known_othersubr_result_cnt = 2;
          break;

        case 1:                     /* start flex feature */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 6 ) )   )
            goto Fail;

          decoder->flex_state        = 1;
          decoder->num_flex_vectors  = 0;
          break;

        case 2:                     /* add flex vectors */
          {
            FT_Int  idx;


            if ( arg_cnt != 0 )
              goto Unexpected_OtherSubr;

            if ( !decoder->flex_state )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" missing flex start\n"" ));
              goto Syntax_Error;
            }

            /* note that we should not add a point for index 0; */
            /* this will move our current position to the flex  */
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
            {
              /* in malformed fonts it is possible to have other */
              /* opcodes in the middle of a flex (which don't    */
              /* increase `num_flex_vectors'); we thus have to   */
              /* check whether we can add a point                */
              if ( FT_SET_ERROR( t1_builder_check_points( builder, 1 ) ) )
                goto Syntax_Error;

               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
            }
           }
           break;
          break;

        case 12:
        case 13:
          /* counter control hints, clear stack */
          top = decoder->stack;
          break;

        case 14:
        case 15:
        case 16:
        case 17:
        case 18:                    /* multiple masters */
          {
            PS_Blend  blend = decoder->blend;
            FT_UInt   num_points, nn, mm;
            FT_Long*  delta;
            FT_Long*  values;


            if ( !blend )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected multiple masters operator\n"" ));
              goto Syntax_Error;
            }

            num_points = (FT_UInt)subr_no - 13 + ( subr_no == 18 );
            if ( arg_cnt != (FT_Int)( num_points * blend->num_designs ) )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" incorrect number of multiple masters arguments\n"" ));
              goto Syntax_Error;
            }

            /* We want to compute                                    */
            /*                                                       */
            /*   a0*w0 + a1*w1 + ... + ak*wk                         */
            /*                                                       */
            /* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
            /*                                                       */
            /* However, given that w0 + w1 + ... + wk == 1, we can   */
            /* rewrite it easily as                                  */
            /*                                                       */
            /*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
            /*                                                       */
            /* where k == num_designs-1.                             */
            /*                                                       */
            /* I guess that's why it's written in this `compact'     */
            /* form.                                                 */
            /*                                                       */
            delta  = top + num_points;
            values = top;
            for ( nn = 0; nn < num_points; nn++ )
            {
              FT_Long  tmp = values[0];


              for ( mm = 1; mm < blend->num_designs; mm++ )
                tmp += FT_MulFix( *delta++, blend->weight_vector[mm] );

              *values++ = tmp;
            }

            known_othersubr_result_cnt = (FT_Int)num_points;
            break;
          }

        case 19:
          /* <idx> 1 19 callothersubr                             */
          /* => replace elements starting from index cvi( <idx> ) */
          /*    of BuildCharArray with WeightVector               */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0                                                    ||
                 (FT_UInt)idx + blend->num_designs > decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            ft_memcpy( &decoder->buildchar[idx],
                       blend->weight_vector,
                       blend->num_designs *
                         sizeof ( blend->weight_vector[0] ) );
          }
          break;

        case 20:
          /* <arg1> <arg2> 2 20 callothersubr pop   */
          /* ==> push <arg1> + <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] += top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 21:
          /* <arg1> <arg2> 2 21 callothersubr pop   */
          /* ==> push <arg1> - <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] -= top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 22:
          /* <arg1> <arg2> 2 22 callothersubr pop   */
          /* ==> push <arg1> * <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] = FT_MulFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 23:
          /* <arg1> <arg2> 2 23 callothersubr pop   */
          /* ==> push <arg1> / <arg2> onto T1 stack */
          if ( arg_cnt != 2 || top[1] == 0 )
            goto Unexpected_OtherSubr;

          top[0] = FT_DivFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 24:
          /* <val> <idx> 2 24 callothersubr               */
          /* ==> set BuildCharArray[cvi( <idx> )] = <val> */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 2 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[1] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            decoder->buildchar[idx] = top[0];
          }
          break;

        case 25:
          /* <idx> 1 25 callothersubr pop        */
          /* ==> push BuildCharArray[cvi( idx )] */
          /*     onto T1 stack                   */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            top[0] = decoder->buildchar[idx];
          }

          known_othersubr_result_cnt = 1;
          break;

#if 0
        case 26:
          /* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
          /*                      leave mark on T1 stack                    */
          /* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
          XXX which routine has left its mark on the (PostScript) stack?;
          break;
#endif

        case 27:
          /* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
          /* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
          /*     otherwise push <res2>                          */
          if ( arg_cnt != 4 )
            goto Unexpected_OtherSubr;

          if ( top[2] > top[3] )
            top[0] = top[1];

          known_othersubr_result_cnt = 1;
          break;

        case 28:
          /* 0 28 callothersubr pop                               */
          /* => push random value from interval [0, 1) onto stack */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          {
            FT_Fixed  Rand;


            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            top[0] = Rand;

            seed = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
          }

          known_othersubr_result_cnt = 1;
          break;

        default:
          if ( arg_cnt >= 0 && subr_no >= 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unknown othersubr [%d %d], wish me luck\n"",
                       arg_cnt, subr_no ));
            unknown_othersubr_result_cnt = arg_cnt;
            break;
          }
          /* fall through */

        Unexpected_OtherSubr:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid othersubr [%d %d]\n"", arg_cnt, subr_no ));
          goto Syntax_Error;
        }

        top += known_othersubr_result_cnt;

        decoder->top = top;
      }
      else  /* general operator */
      {
        FT_Int  num_args = t1_args_count[op];


        FT_ASSERT( num_args >= 0 );

        if ( top - decoder->stack < num_args )
          goto Stack_Underflow;

        /* XXX Operators usually take their operands from the        */
        /*     bottom of the stack, i.e., the operands are           */
        /*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
        /*     only div, callsubr, and callothersubr are different.  */
        /*     In practice it doesn't matter (?).                    */

#ifdef FT_DEBUG_LEVEL_TRACE

        switch ( op )
        {
        case op_callsubr:
        case op_div:
        case op_callothersubr:
        case op_pop:
        case op_return:
          break;

        default:
          if ( top - decoder->stack != num_args )
            FT_TRACE0(( ""t1_decoder_parse_charstrings:""
                        "" too much operands on the stack""
                        "" (seen %d, expected %d)\n"",
                        top - decoder->stack, num_args ));
            break;
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        top -= num_args;

        switch ( op )
        {
        case op_endchar:
          FT_TRACE4(( "" endchar\n"" ));

          t1_builder_close_contour( builder );

          /* close hints recording session */
          if ( hinter )
          {
            if ( hinter->close( hinter->hints,
                                (FT_UInt)builder->current->n_points ) )
              goto Syntax_Error;

            /* apply hints to the loaded glyph outline now */
            error = hinter->apply( hinter->hints,
                                   builder->current,
                                   (PSH_Globals)builder->hints_globals,
                                   decoder->hint_mode );
            if ( error )
              goto Fail;
          }

          /* add current outline to the glyph slot */
          FT_GlyphLoader_Add( builder->loader );

          /* the compiler should optimize away this empty loop but ... */

#ifdef FT_DEBUG_LEVEL_TRACE

          if ( decoder->len_buildchar > 0 )
          {
            FT_UInt  i;


            FT_TRACE4(( ""BuildCharArray = [ "" ));

            for ( i = 0; i < decoder->len_buildchar; i++ )
              FT_TRACE4(( ""%d "", decoder->buildchar[i] ));

            FT_TRACE4(( ""]\n"" ));
          }

#endif /* FT_DEBUG_LEVEL_TRACE */

          FT_TRACE4(( ""\n"" ));

          /* return now! */
          return FT_Err_Ok;

        case op_hsbw:
          FT_TRACE4(( "" hsbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->advance.x       = top[1];
          builder->advance.y       = 0;

          orig_x = x = builder->pos_x + top[0];
          orig_y = y = builder->pos_y;

          FT_UNUSED( orig_y );

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_seac:
          return t1operator_seac( decoder,
                                  top[0],
                                  top[1],
                                  top[2],
                                  Fix2Int( top[3] ),
                                  Fix2Int( top[4] ) );

        case op_sbw:
          FT_TRACE4(( "" sbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->left_bearing.y += top[1];
          builder->advance.x       = top[2];
          builder->advance.y       = top[3];

          x = builder->pos_x + top[0];
          y = builder->pos_y + top[1];

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_closepath:
          FT_TRACE4(( "" closepath"" ));

          /* if there is no path, `closepath' is a no-op */
          if ( builder->parse_state == T1_Parse_Have_Path   ||
               builder->parse_state == T1_Parse_Have_Moveto )
            t1_builder_close_contour( builder );

          builder->parse_state = T1_Parse_Have_Width;
          break;

        case op_hlineto:
          FT_TRACE4(( "" hlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          goto Add_Line;

        case op_hmoveto:
          FT_TRACE4(( "" hmoveto"" ));

          x += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_hvcurveto:
          FT_TRACE4(( "" hvcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          y += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_rlineto:
          FT_TRACE4(( "" rlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          y += top[1];

        Add_Line:
          if ( FT_SET_ERROR( t1_builder_add_point1( builder, x, y ) ) )
            goto Fail;
          break;

        case op_rmoveto:
          FT_TRACE4(( "" rmoveto"" ));

          x += top[0];
          y += top[1];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_rrcurveto:
          FT_TRACE4(( "" rrcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          y += top[1];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[2];
          y += top[3];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[4];
          y += top[5];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vhcurveto:
          FT_TRACE4(( "" vhcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          y += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vlineto:
          FT_TRACE4(( "" vlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          y += top[0];
          goto Add_Line;

        case op_vmoveto:
          FT_TRACE4(( "" vmoveto"" ));

          y += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_div:
          FT_TRACE4(( "" div"" ));

          /* if `large_int' is set, we divide unscaled numbers; */
          /* otherwise, we divide numbers in 16.16 format --    */
          /* in both cases, it is the same operation            */
          *top = FT_DivFix( top[0], top[1] );
          top++;

          large_int = FALSE;
          break;

        case op_callsubr:
          {
            FT_Int  idx;


            FT_TRACE4(( "" callsubr"" ));

            idx = Fix2Int( top[0] );

            if ( decoder->subrs_hash )
            {
              size_t*  val = ft_hash_num_lookup( idx,
                                                 decoder->subrs_hash );


              if ( val )
                idx = *val;
              else
                idx = -1;
            }

            if ( idx < 0 || idx >= decoder->num_subrs )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invalid subrs index\n"" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= T1_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" too many nested subrs\n"" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;

            /* The Type 1 driver stores subroutines without the seed bytes. */
            /* The CID driver stores subroutines with seed bytes.  This     */
            /* case is taken care of when decoder->subrs_len == 0.          */
            zone->base = decoder->subrs[idx];

            if ( decoder->subrs_len )
              zone->limit = zone->base + decoder->subrs_len[idx];
            else
            {
              /* We are using subroutines from a CID font.  We must adjust */
              /* for the seed bytes.                                       */
              zone->base  += ( decoder->lenIV >= 0 ? decoder->lenIV : 0 );
              zone->limit  = decoder->subrs[idx + 1];
            }

            zone->cursor = zone->base;

            if ( !zone->base )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invoking empty subrs\n"" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
            break;
          }

        case op_pop:
          FT_TRACE4(( "" pop"" ));

          if ( known_othersubr_result_cnt > 0 )
          {
            known_othersubr_result_cnt--;
            /* ignore, we pushed the operands ourselves */
            break;
          }

          if ( unknown_othersubr_result_cnt == 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no more operands for othersubr\n"" ));
            goto Syntax_Error;
          }

          unknown_othersubr_result_cnt--;
          top++;   /* `push' the operand to callothersubr onto the stack */
          break;

        case op_return:
          FT_TRACE4(( "" return"" ));

          if ( zone <= decoder->zones )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected return\n"" ));
            goto Syntax_Error;
          }

          zone--;
          ip            = zone->cursor;
          limit         = zone->limit;
          decoder->zone = zone;
          break;

        case op_dotsection:
          FT_TRACE4(( "" dotsection"" ));

          break;

        case op_hstem:
          FT_TRACE4(( "" hstem"" ));

          /* record horizontal hint */
          if ( hinter )
          {
            /* top[0] += builder->left_bearing.y; */
            hinter->stem( hinter->hints, 1, top );
          }
          break;

        case op_hstem3:
          FT_TRACE4(( "" hstem3"" ));

          /* record horizontal counter-controlled hints */
          if ( hinter )
            hinter->stem3( hinter->hints, 1, top );
          break;

        case op_vstem:
          FT_TRACE4(( "" vstem"" ));

          /* record vertical hint */
          if ( hinter )
          {
            top[0] += orig_x;
            hinter->stem( hinter->hints, 0, top );
          }
          break;

        case op_vstem3:
          FT_TRACE4(( "" vstem3"" ));

          /* record vertical counter-controlled hints */
          if ( hinter )
          {
            FT_Pos  dx = orig_x;


            top[0] += dx;
            top[2] += dx;
            top[4] += dx;
            hinter->stem3( hinter->hints, 0, top );
          }
          break;

        case op_setcurrentpoint:
          FT_TRACE4(( "" setcurrentpoint"" ));

          /* From the T1 specification, section 6.4:                */
          /*                                                        */
          /*   The setcurrentpoint command is used only in          */
          /*   conjunction with results from OtherSubrs procedures. */

          /* known_othersubr_result_cnt != 0 is already handled     */
          /* above.                                                 */

          /* Note, however, that both Ghostscript and Adobe         */
          /* Distiller handle this situation by silently ignoring   */
          /* the inappropriate `setcurrentpoint' instruction.  So   */
          /* we do the same.                                        */
#if 0

          if ( decoder->flex_state != 1 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected `setcurrentpoint'\n"" ));
            goto Syntax_Error;
          }
          else
            ...
#endif

          x = top[0];
          y = top[1];
          decoder->flex_state = 0;
          break;

        case op_unknown15:
          FT_TRACE4(( "" opcode_15"" ));
          /* nothing to do except to pop the two arguments */
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unhandled opcode %d\n"", op ));
          goto Syntax_Error;
        }

        /* XXX Operators usually clear the operand stack;  */
        /*     only div, callsubr, callothersubr, pop, and */
        /*     return are different.                       */
        /*     In practice it doesn't matter (?).          */

        decoder->top = top;

#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( ""\n"" ));
        bol = TRUE;
#endif

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( ""..end..\n\n"" ));

  Fail:
    return error;

  Syntax_Error:
    return FT_THROW( Syntax_Error );

  Stack_Underflow:
    return FT_THROW( Stack_Underflow );
  }
","  t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                FT_Byte*    charstring_base,
                                FT_UInt     charstring_len )
  {
    FT_Error         error;
    T1_Decoder_Zone  zone;
    FT_Byte*         ip;
    FT_Byte*         limit;
    T1_Builder       builder = &decoder->builder;
    FT_Pos           x, y, orig_x, orig_y;
    FT_Int           known_othersubr_result_cnt   = 0;
    FT_Int           unknown_othersubr_result_cnt = 0;
    FT_Bool          large_int;
    FT_Fixed         seed;

    T1_Hints_Funcs   hinter;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_Bool          bol = TRUE;
#endif


    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* First of all, initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;

    builder->parse_state = T1_Parse_Start;

    hinter = (T1_Hints_Funcs)builder->hints_funcs;

    /* a font that reads BuildCharArray without setting */
    /* its values first is buggy, but ...               */
    FT_ASSERT( ( decoder->len_buildchar == 0 ) ==
               ( decoder->buildchar == NULL )  );

    if ( decoder->buildchar && decoder->len_buildchar > 0 )
      FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );

    FT_TRACE4(( ""\n""
                ""Start charstring\n"" ));

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = orig_x = builder->pos_x;
    y = orig_y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    large_int = FALSE;

    /* now, execute loop */
    while ( ip < limit )
    {
      FT_Long*     top   = decoder->top;
      T1_Operator  op    = op_none;
      FT_Int32     value = 0;


      FT_ASSERT( known_othersubr_result_cnt == 0   ||
                 unknown_othersubr_result_cnt == 0 );

#ifdef FT_DEBUG_LEVEL_TRACE
      if ( bol )
      {
        FT_TRACE5(( "" (%d)"", decoder->top - decoder->stack ));
        bol = FALSE;
      }
#endif

      /*********************************************************************/
      /*                                                                   */
      /* Decode operator or operand                                        */
      /*                                                                   */
      /*                                                                   */

      /* first of all, decompress operator or value */
      switch ( *ip++ )
      {
      case 1:
        op = op_hstem;
        break;

      case 3:
        op = op_vstem;
        break;
      case 4:
        op = op_vmoveto;
        break;
      case 5:
        op = op_rlineto;
        break;
      case 6:
        op = op_hlineto;
        break;
      case 7:
        op = op_vlineto;
        break;
      case 8:
        op = op_rrcurveto;
        break;
      case 9:
        op = op_closepath;
        break;
      case 10:
        op = op_callsubr;
        break;
      case 11:
        op = op_return;
        break;

      case 13:
        op = op_hsbw;
        break;
      case 14:
        op = op_endchar;
        break;

      case 15:          /* undocumented, obsolete operator */
        op = op_unknown15;
        break;

      case 21:
        op = op_rmoveto;
        break;
      case 22:
        op = op_hmoveto;
        break;

      case 30:
        op = op_vhcurveto;
        break;
      case 31:
        op = op_hvcurveto;
        break;

      case 12:
        if ( ip >= limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+EOF)\n"" ));
          goto Syntax_Error;
        }

        switch ( *ip++ )
        {
        case 0:
          op = op_dotsection;
          break;
        case 1:
          op = op_vstem3;
          break;
        case 2:
          op = op_hstem3;
          break;
        case 6:
          op = op_seac;
          break;
        case 7:
          op = op_sbw;
          break;
        case 12:
          op = op_div;
          break;
        case 16:
          op = op_callothersubr;
          break;
        case 17:
          op = op_pop;
          break;
        case 33:
          op = op_setcurrentpoint;
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+%d)\n"",
                     ip[-1] ));
          goto Syntax_Error;
        }
        break;

      case 255:    /* four bytes integer */
        if ( ip + 4 > limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unexpected EOF in integer\n"" ));
          goto Syntax_Error;
        }

        value = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] << 8  ) |
                              (FT_UInt32)ip[3]         );
        ip += 4;

        /* According to the specification, values > 32000 or < -32000 must */
        /* be followed by a `div' operator to make the result be in the    */
        /* range [-32000;32000].  We expect that the second argument of    */
        /* `div' is not a large number.  Additionally, we don't handle     */
        /* stuff like `<large1> <large2> <num> div <num> div' or           */
        /* <large1> <large2> <num> div div'.  This is probably not allowed */
        /* anyway.                                                         */
        if ( value > 32000 || value < -32000 )
        {
          if ( large_int )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no `div' after large integer\n"" ));
          }
          else
            large_int = TRUE;
        }
        else
        {
          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }

        break;

      default:
        if ( ip[-1] >= 32 )
        {
          if ( ip[-1] < 247 )
            value = (FT_Int32)ip[-1] - 139;
          else
          {
            if ( ++ip > limit )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected EOF in integer\n"" ));
              goto Syntax_Error;
            }

            if ( ip[-2] < 251 )
              value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
            else
              value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
          }

          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }
        else
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid byte (%d)\n"", ip[-1] ));
          goto Syntax_Error;
        }
      }

      if ( unknown_othersubr_result_cnt > 0 )
      {
        switch ( op )
        {
        case op_callsubr:
        case op_return:
        case op_none:
        case op_pop:
          break;

        default:
          /* all operands have been transferred by previous pops */
          unknown_othersubr_result_cnt = 0;
          break;
        }
      }

      if ( large_int && !( op == op_none || op == op_div ) )
      {
        FT_ERROR(( ""t1_decoder_parse_charstrings:""
                   "" no `div' after large integer\n"" ));

        large_int = FALSE;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Push value on stack, or process operator                         */
      /*                                                                   */
      /*                                                                   */
      if ( op == op_none )
      {
        if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings: stack overflow\n"" ));
          goto Syntax_Error;
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( large_int )
          FT_TRACE4(( "" %d"", value ));
        else
          FT_TRACE4(( "" %d"", value / 65536 ));
#endif

        *top++       = value;
        decoder->top = top;
      }
      else if ( op == op_callothersubr )  /* callothersubr */
      {
        FT_Int  subr_no;
        FT_Int  arg_cnt;


#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( "" callothersubr\n"" ));
        bol = TRUE;
#endif

        if ( top - decoder->stack < 2 )
          goto Stack_Underflow;

        top -= 2;

        subr_no = Fix2Int( top[1] );
        arg_cnt = Fix2Int( top[0] );

        /***********************************************************/
        /*                                                         */
        /* remove all operands to callothersubr from the stack     */
        /*                                                         */
        /* for handled othersubrs, where we know the number of     */
        /* arguments, we increase the stack by the value of        */
        /* known_othersubr_result_cnt                              */
        /*                                                         */
        /* for unhandled othersubrs the following pops adjust the  */
        /* stack pointer as necessary                              */

        if ( arg_cnt > top - decoder->stack )
          goto Stack_Underflow;

        top -= arg_cnt;

        known_othersubr_result_cnt   = 0;
        unknown_othersubr_result_cnt = 0;

        /* XXX TODO: The checks to `arg_count == <whatever>'       */
        /* might not be correct; an othersubr expects a certain    */
        /* number of operands on the PostScript stack (as opposed  */
        /* to the T1 stack) but it doesn't have to put them there  */
        /* by itself; previous othersubrs might have left the      */
        /* operands there if they were not followed by an          */
        /* appropriate number of pops                              */
        /*                                                         */
        /* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
        /* accept a font that contains charstrings like            */
        /*                                                         */
        /*     100 200 2 20 callothersubr                          */
        /*     300 1 20 callothersubr pop                          */
        /*                                                         */
        /* Perhaps this is the reason why BuildCharArray exists.   */

        switch ( subr_no )
        {
        case 0:                     /* end flex feature */
          if ( arg_cnt != 3 )
            goto Unexpected_OtherSubr;

          if ( !decoder->flex_state           ||
               decoder->num_flex_vectors != 7 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected flex end\n"" ));
            goto Syntax_Error;
          }

          /* the two `results' are popped by the following setcurrentpoint */
          top[0] = x;
          top[1] = y;
          known_othersubr_result_cnt = 2;
          break;

        case 1:                     /* start flex feature */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 6 ) )   )
            goto Fail;

          decoder->flex_state        = 1;
          decoder->num_flex_vectors  = 0;
          break;

        case 2:                     /* add flex vectors */
          {
            FT_Int  idx;


            if ( arg_cnt != 0 )
              goto Unexpected_OtherSubr;

            if ( !decoder->flex_state )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" missing flex start\n"" ));
              goto Syntax_Error;
            }

            /* note that we should not add a point for index 0; */
            /* this will move our current position to the flex  */
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
           }
           break;
          break;

        case 12:
        case 13:
          /* counter control hints, clear stack */
          top = decoder->stack;
          break;

        case 14:
        case 15:
        case 16:
        case 17:
        case 18:                    /* multiple masters */
          {
            PS_Blend  blend = decoder->blend;
            FT_UInt   num_points, nn, mm;
            FT_Long*  delta;
            FT_Long*  values;


            if ( !blend )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected multiple masters operator\n"" ));
              goto Syntax_Error;
            }

            num_points = (FT_UInt)subr_no - 13 + ( subr_no == 18 );
            if ( arg_cnt != (FT_Int)( num_points * blend->num_designs ) )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" incorrect number of multiple masters arguments\n"" ));
              goto Syntax_Error;
            }

            /* We want to compute                                    */
            /*                                                       */
            /*   a0*w0 + a1*w1 + ... + ak*wk                         */
            /*                                                       */
            /* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
            /*                                                       */
            /* However, given that w0 + w1 + ... + wk == 1, we can   */
            /* rewrite it easily as                                  */
            /*                                                       */
            /*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
            /*                                                       */
            /* where k == num_designs-1.                             */
            /*                                                       */
            /* I guess that's why it's written in this `compact'     */
            /* form.                                                 */
            /*                                                       */
            delta  = top + num_points;
            values = top;
            for ( nn = 0; nn < num_points; nn++ )
            {
              FT_Long  tmp = values[0];


              for ( mm = 1; mm < blend->num_designs; mm++ )
                tmp += FT_MulFix( *delta++, blend->weight_vector[mm] );

              *values++ = tmp;
            }

            known_othersubr_result_cnt = (FT_Int)num_points;
            break;
          }

        case 19:
          /* <idx> 1 19 callothersubr                             */
          /* => replace elements starting from index cvi( <idx> ) */
          /*    of BuildCharArray with WeightVector               */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0                                                    ||
                 (FT_UInt)idx + blend->num_designs > decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            ft_memcpy( &decoder->buildchar[idx],
                       blend->weight_vector,
                       blend->num_designs *
                         sizeof ( blend->weight_vector[0] ) );
          }
          break;

        case 20:
          /* <arg1> <arg2> 2 20 callothersubr pop   */
          /* ==> push <arg1> + <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] += top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 21:
          /* <arg1> <arg2> 2 21 callothersubr pop   */
          /* ==> push <arg1> - <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] -= top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 22:
          /* <arg1> <arg2> 2 22 callothersubr pop   */
          /* ==> push <arg1> * <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] = FT_MulFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 23:
          /* <arg1> <arg2> 2 23 callothersubr pop   */
          /* ==> push <arg1> / <arg2> onto T1 stack */
          if ( arg_cnt != 2 || top[1] == 0 )
            goto Unexpected_OtherSubr;

          top[0] = FT_DivFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 24:
          /* <val> <idx> 2 24 callothersubr               */
          /* ==> set BuildCharArray[cvi( <idx> )] = <val> */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 2 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[1] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            decoder->buildchar[idx] = top[0];
          }
          break;

        case 25:
          /* <idx> 1 25 callothersubr pop        */
          /* ==> push BuildCharArray[cvi( idx )] */
          /*     onto T1 stack                   */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            top[0] = decoder->buildchar[idx];
          }

          known_othersubr_result_cnt = 1;
          break;

#if 0
        case 26:
          /* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
          /*                      leave mark on T1 stack                    */
          /* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
          XXX which routine has left its mark on the (PostScript) stack?;
          break;
#endif

        case 27:
          /* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
          /* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
          /*     otherwise push <res2>                          */
          if ( arg_cnt != 4 )
            goto Unexpected_OtherSubr;

          if ( top[2] > top[3] )
            top[0] = top[1];

          known_othersubr_result_cnt = 1;
          break;

        case 28:
          /* 0 28 callothersubr pop                               */
          /* => push random value from interval [0, 1) onto stack */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          {
            FT_Fixed  Rand;


            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            top[0] = Rand;

            seed = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
          }

          known_othersubr_result_cnt = 1;
          break;

        default:
          if ( arg_cnt >= 0 && subr_no >= 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unknown othersubr [%d %d], wish me luck\n"",
                       arg_cnt, subr_no ));
            unknown_othersubr_result_cnt = arg_cnt;
            break;
          }
          /* fall through */

        Unexpected_OtherSubr:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid othersubr [%d %d]\n"", arg_cnt, subr_no ));
          goto Syntax_Error;
        }

        top += known_othersubr_result_cnt;

        decoder->top = top;
      }
      else  /* general operator */
      {
        FT_Int  num_args = t1_args_count[op];


        FT_ASSERT( num_args >= 0 );

        if ( top - decoder->stack < num_args )
          goto Stack_Underflow;

        /* XXX Operators usually take their operands from the        */
        /*     bottom of the stack, i.e., the operands are           */
        /*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
        /*     only div, callsubr, and callothersubr are different.  */
        /*     In practice it doesn't matter (?).                    */

#ifdef FT_DEBUG_LEVEL_TRACE

        switch ( op )
        {
        case op_callsubr:
        case op_div:
        case op_callothersubr:
        case op_pop:
        case op_return:
          break;

        default:
          if ( top - decoder->stack != num_args )
            FT_TRACE0(( ""t1_decoder_parse_charstrings:""
                        "" too much operands on the stack""
                        "" (seen %d, expected %d)\n"",
                        top - decoder->stack, num_args ));
            break;
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        top -= num_args;

        switch ( op )
        {
        case op_endchar:
          FT_TRACE4(( "" endchar\n"" ));

          t1_builder_close_contour( builder );

          /* close hints recording session */
          if ( hinter )
          {
            if ( hinter->close( hinter->hints,
                                (FT_UInt)builder->current->n_points ) )
              goto Syntax_Error;

            /* apply hints to the loaded glyph outline now */
            error = hinter->apply( hinter->hints,
                                   builder->current,
                                   (PSH_Globals)builder->hints_globals,
                                   decoder->hint_mode );
            if ( error )
              goto Fail;
          }

          /* add current outline to the glyph slot */
          FT_GlyphLoader_Add( builder->loader );

          /* the compiler should optimize away this empty loop but ... */

#ifdef FT_DEBUG_LEVEL_TRACE

          if ( decoder->len_buildchar > 0 )
          {
            FT_UInt  i;


            FT_TRACE4(( ""BuildCharArray = [ "" ));

            for ( i = 0; i < decoder->len_buildchar; i++ )
              FT_TRACE4(( ""%d "", decoder->buildchar[i] ));

            FT_TRACE4(( ""]\n"" ));
          }

#endif /* FT_DEBUG_LEVEL_TRACE */

          FT_TRACE4(( ""\n"" ));

          /* return now! */
          return FT_Err_Ok;

        case op_hsbw:
          FT_TRACE4(( "" hsbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->advance.x       = top[1];
          builder->advance.y       = 0;

          orig_x = x = builder->pos_x + top[0];
          orig_y = y = builder->pos_y;

          FT_UNUSED( orig_y );

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_seac:
          return t1operator_seac( decoder,
                                  top[0],
                                  top[1],
                                  top[2],
                                  Fix2Int( top[3] ),
                                  Fix2Int( top[4] ) );

        case op_sbw:
          FT_TRACE4(( "" sbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->left_bearing.y += top[1];
          builder->advance.x       = top[2];
          builder->advance.y       = top[3];

          x = builder->pos_x + top[0];
          y = builder->pos_y + top[1];

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_closepath:
          FT_TRACE4(( "" closepath"" ));

          /* if there is no path, `closepath' is a no-op */
          if ( builder->parse_state == T1_Parse_Have_Path   ||
               builder->parse_state == T1_Parse_Have_Moveto )
            t1_builder_close_contour( builder );

          builder->parse_state = T1_Parse_Have_Width;
          break;

        case op_hlineto:
          FT_TRACE4(( "" hlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          goto Add_Line;

        case op_hmoveto:
          FT_TRACE4(( "" hmoveto"" ));

          x += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_hvcurveto:
          FT_TRACE4(( "" hvcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          y += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_rlineto:
          FT_TRACE4(( "" rlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          y += top[1];

        Add_Line:
          if ( FT_SET_ERROR( t1_builder_add_point1( builder, x, y ) ) )
            goto Fail;
          break;

        case op_rmoveto:
          FT_TRACE4(( "" rmoveto"" ));

          x += top[0];
          y += top[1];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_rrcurveto:
          FT_TRACE4(( "" rrcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          y += top[1];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[2];
          y += top[3];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[4];
          y += top[5];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vhcurveto:
          FT_TRACE4(( "" vhcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          y += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vlineto:
          FT_TRACE4(( "" vlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          y += top[0];
          goto Add_Line;

        case op_vmoveto:
          FT_TRACE4(( "" vmoveto"" ));

          y += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_div:
          FT_TRACE4(( "" div"" ));

          /* if `large_int' is set, we divide unscaled numbers; */
          /* otherwise, we divide numbers in 16.16 format --    */
          /* in both cases, it is the same operation            */
          *top = FT_DivFix( top[0], top[1] );
          top++;

          large_int = FALSE;
          break;

        case op_callsubr:
          {
            FT_Int  idx;


            FT_TRACE4(( "" callsubr"" ));

            idx = Fix2Int( top[0] );

            if ( decoder->subrs_hash )
            {
              size_t*  val = ft_hash_num_lookup( idx,
                                                 decoder->subrs_hash );


              if ( val )
                idx = *val;
              else
                idx = -1;
            }

            if ( idx < 0 || idx >= decoder->num_subrs )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invalid subrs index\n"" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= T1_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" too many nested subrs\n"" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;

            /* The Type 1 driver stores subroutines without the seed bytes. */
            /* The CID driver stores subroutines with seed bytes.  This     */
            /* case is taken care of when decoder->subrs_len == 0.          */
            zone->base = decoder->subrs[idx];

            if ( decoder->subrs_len )
              zone->limit = zone->base + decoder->subrs_len[idx];
            else
            {
              /* We are using subroutines from a CID font.  We must adjust */
              /* for the seed bytes.                                       */
              zone->base  += ( decoder->lenIV >= 0 ? decoder->lenIV : 0 );
              zone->limit  = decoder->subrs[idx + 1];
            }

            zone->cursor = zone->base;

            if ( !zone->base )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invoking empty subrs\n"" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
            break;
          }

        case op_pop:
          FT_TRACE4(( "" pop"" ));

          if ( known_othersubr_result_cnt > 0 )
          {
            known_othersubr_result_cnt--;
            /* ignore, we pushed the operands ourselves */
            break;
          }

          if ( unknown_othersubr_result_cnt == 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no more operands for othersubr\n"" ));
            goto Syntax_Error;
          }

          unknown_othersubr_result_cnt--;
          top++;   /* `push' the operand to callothersubr onto the stack */
          break;

        case op_return:
          FT_TRACE4(( "" return"" ));

          if ( zone <= decoder->zones )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected return\n"" ));
            goto Syntax_Error;
          }

          zone--;
          ip            = zone->cursor;
          limit         = zone->limit;
          decoder->zone = zone;
          break;

        case op_dotsection:
          FT_TRACE4(( "" dotsection"" ));

          break;

        case op_hstem:
          FT_TRACE4(( "" hstem"" ));

          /* record horizontal hint */
          if ( hinter )
          {
            /* top[0] += builder->left_bearing.y; */
            hinter->stem( hinter->hints, 1, top );
          }
          break;

        case op_hstem3:
          FT_TRACE4(( "" hstem3"" ));

          /* record horizontal counter-controlled hints */
          if ( hinter )
            hinter->stem3( hinter->hints, 1, top );
          break;

        case op_vstem:
          FT_TRACE4(( "" vstem"" ));

          /* record vertical hint */
          if ( hinter )
          {
            top[0] += orig_x;
            hinter->stem( hinter->hints, 0, top );
          }
          break;

        case op_vstem3:
          FT_TRACE4(( "" vstem3"" ));

          /* record vertical counter-controlled hints */
          if ( hinter )
          {
            FT_Pos  dx = orig_x;


            top[0] += dx;
            top[2] += dx;
            top[4] += dx;
            hinter->stem3( hinter->hints, 0, top );
          }
          break;

        case op_setcurrentpoint:
          FT_TRACE4(( "" setcurrentpoint"" ));

          /* From the T1 specification, section 6.4:                */
          /*                                                        */
          /*   The setcurrentpoint command is used only in          */
          /*   conjunction with results from OtherSubrs procedures. */

          /* known_othersubr_result_cnt != 0 is already handled     */
          /* above.                                                 */

          /* Note, however, that both Ghostscript and Adobe         */
          /* Distiller handle this situation by silently ignoring   */
          /* the inappropriate `setcurrentpoint' instruction.  So   */
          /* we do the same.                                        */
#if 0

          if ( decoder->flex_state != 1 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected `setcurrentpoint'\n"" ));
            goto Syntax_Error;
          }
          else
            ...
#endif

          x = top[0];
          y = top[1];
          decoder->flex_state = 0;
          break;

        case op_unknown15:
          FT_TRACE4(( "" opcode_15"" ));
          /* nothing to do except to pop the two arguments */
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unhandled opcode %d\n"", op ));
          goto Syntax_Error;
        }

        /* XXX Operators usually clear the operand stack;  */
        /*     only div, callsubr, callothersubr, pop, and */
        /*     return are different.                       */
        /*     In practice it doesn't matter (?).          */

        decoder->top = top;

#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( ""\n"" ));
        bol = TRUE;
#endif

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( ""..end..\n\n"" ));

  Fail:
    return error;

  Syntax_Error:
    return FT_THROW( Syntax_Error );

  Stack_Underflow:
    return FT_THROW( Stack_Underflow );
  }
",C,"            {
              /* in malformed fonts it is possible to have other */
              /* opcodes in the middle of a flex (which don't    */
              /* increase `num_flex_vectors'); we thus have to   */
              /* check whether we can add a point                */
              if ( FT_SET_ERROR( t1_builder_check_points( builder, 1 ) ) )
                goto Syntax_Error;

            }
",,913f436d12dfe682c349eff8bf4cdd9065ff117d,"@@ -780,10 +780,19 @@
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
+            {
+              /* in malformed fonts it is possible to have other */
+              /* opcodes in the middle of a flex (which don't    */
+              /* increase `num_flex_vectors'); we thus have to   */
+              /* check whether we can add a point                */
+              if ( FT_SET_ERROR( t1_builder_check_points( builder, 1 ) ) )
+                goto Syntax_Error;
+
               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
+            }
           }
           break;",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/psaux/t1decode.c?id=f958c48ee431bef8d4d466b40c9cb2d4dbcb7791,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/psaux/t1decode.c?id=913f436d12dfe682c349eff8bf4cdd9065ff117d,1,"  t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                FT_Byte*    charstring_base,
                                FT_UInt     charstring_len )
  {
    FT_Error         error;
    T1_Decoder_Zone  zone;
    FT_Byte*         ip;
    FT_Byte*         limit;
    T1_Builder       builder = &decoder->builder;
    FT_Pos           x, y, orig_x, orig_y;
    FT_Int           known_othersubr_result_cnt   = 0;
    FT_Int           unknown_othersubr_result_cnt = 0;
    FT_Bool          large_int;
    FT_Fixed         seed;

    T1_Hints_Funcs   hinter;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_Bool          bol = TRUE;
#endif


    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* First of all, initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;

    builder->parse_state = T1_Parse_Start;

    hinter = (T1_Hints_Funcs)builder->hints_funcs;

    /* a font that reads BuildCharArray without setting */
    /* its values first is buggy, but ...               */
    FT_ASSERT( ( decoder->len_buildchar == 0 ) ==
               ( decoder->buildchar == NULL )  );

    if ( decoder->buildchar && decoder->len_buildchar > 0 )
      FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );

    FT_TRACE4(( ""\n""
                ""Start charstring\n"" ));

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = orig_x = builder->pos_x;
    y = orig_y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    large_int = FALSE;

    /* now, execute loop */
    while ( ip < limit )
    {
      FT_Long*     top   = decoder->top;
      T1_Operator  op    = op_none;
      FT_Int32     value = 0;


      FT_ASSERT( known_othersubr_result_cnt == 0   ||
                 unknown_othersubr_result_cnt == 0 );

#ifdef FT_DEBUG_LEVEL_TRACE
      if ( bol )
      {
        FT_TRACE5(( "" (%d)"", decoder->top - decoder->stack ));
        bol = FALSE;
      }
#endif

      /*********************************************************************/
      /*                                                                   */
      /* Decode operator or operand                                        */
      /*                                                                   */
      /*                                                                   */

      /* first of all, decompress operator or value */
      switch ( *ip++ )
      {
      case 1:
        op = op_hstem;
        break;

      case 3:
        op = op_vstem;
        break;
      case 4:
        op = op_vmoveto;
        break;
      case 5:
        op = op_rlineto;
        break;
      case 6:
        op = op_hlineto;
        break;
      case 7:
        op = op_vlineto;
        break;
      case 8:
        op = op_rrcurveto;
        break;
      case 9:
        op = op_closepath;
        break;
      case 10:
        op = op_callsubr;
        break;
      case 11:
        op = op_return;
        break;

      case 13:
        op = op_hsbw;
        break;
      case 14:
        op = op_endchar;
        break;

      case 15:          /* undocumented, obsolete operator */
        op = op_unknown15;
        break;

      case 21:
        op = op_rmoveto;
        break;
      case 22:
        op = op_hmoveto;
        break;

      case 30:
        op = op_vhcurveto;
        break;
      case 31:
        op = op_hvcurveto;
        break;

      case 12:
        if ( ip >= limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+EOF)\n"" ));
          goto Syntax_Error;
        }

        switch ( *ip++ )
        {
        case 0:
          op = op_dotsection;
          break;
        case 1:
          op = op_vstem3;
          break;
        case 2:
          op = op_hstem3;
          break;
        case 6:
          op = op_seac;
          break;
        case 7:
          op = op_sbw;
          break;
        case 12:
          op = op_div;
          break;
        case 16:
          op = op_callothersubr;
          break;
        case 17:
          op = op_pop;
          break;
        case 33:
          op = op_setcurrentpoint;
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+%d)\n"",
                     ip[-1] ));
          goto Syntax_Error;
        }
        break;

      case 255:    /* four bytes integer */
        if ( ip + 4 > limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unexpected EOF in integer\n"" ));
          goto Syntax_Error;
        }

        value = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] << 8  ) |
                              (FT_UInt32)ip[3]         );
        ip += 4;

        /* According to the specification, values > 32000 or < -32000 must */
        /* be followed by a `div' operator to make the result be in the    */
        /* range [-32000;32000].  We expect that the second argument of    */
        /* `div' is not a large number.  Additionally, we don't handle     */
        /* stuff like `<large1> <large2> <num> div <num> div' or           */
        /* <large1> <large2> <num> div div'.  This is probably not allowed */
        /* anyway.                                                         */
        if ( value > 32000 || value < -32000 )
        {
          if ( large_int )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no `div' after large integer\n"" ));
          }
          else
            large_int = TRUE;
        }
        else
        {
          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }

        break;

      default:
        if ( ip[-1] >= 32 )
        {
          if ( ip[-1] < 247 )
            value = (FT_Int32)ip[-1] - 139;
          else
          {
            if ( ++ip > limit )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected EOF in integer\n"" ));
              goto Syntax_Error;
            }

            if ( ip[-2] < 251 )
              value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
            else
              value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
          }

          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }
        else
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid byte (%d)\n"", ip[-1] ));
          goto Syntax_Error;
        }
      }

      if ( unknown_othersubr_result_cnt > 0 )
      {
        switch ( op )
        {
        case op_callsubr:
        case op_return:
        case op_none:
        case op_pop:
          break;

        default:
          /* all operands have been transferred by previous pops */
          unknown_othersubr_result_cnt = 0;
          break;
        }
      }

      if ( large_int && !( op == op_none || op == op_div ) )
      {
        FT_ERROR(( ""t1_decoder_parse_charstrings:""
                   "" no `div' after large integer\n"" ));

        large_int = FALSE;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Push value on stack, or process operator                         */
      /*                                                                   */
      /*                                                                   */
      if ( op == op_none )
      {
        if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings: stack overflow\n"" ));
          goto Syntax_Error;
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( large_int )
          FT_TRACE4(( "" %d"", value ));
        else
          FT_TRACE4(( "" %d"", value / 65536 ));
#endif

        *top++       = value;
        decoder->top = top;
      }
      else if ( op == op_callothersubr )  /* callothersubr */
      {
        FT_Int  subr_no;
        FT_Int  arg_cnt;


#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( "" callothersubr\n"" ));
        bol = TRUE;
#endif

        if ( top - decoder->stack < 2 )
          goto Stack_Underflow;

        top -= 2;

        subr_no = Fix2Int( top[1] );
        arg_cnt = Fix2Int( top[0] );

        /***********************************************************/
        /*                                                         */
        /* remove all operands to callothersubr from the stack     */
        /*                                                         */
        /* for handled othersubrs, where we know the number of     */
        /* arguments, we increase the stack by the value of        */
        /* known_othersubr_result_cnt                              */
        /*                                                         */
        /* for unhandled othersubrs the following pops adjust the  */
        /* stack pointer as necessary                              */

        if ( arg_cnt > top - decoder->stack )
          goto Stack_Underflow;

        top -= arg_cnt;

        known_othersubr_result_cnt   = 0;
        unknown_othersubr_result_cnt = 0;

        /* XXX TODO: The checks to `arg_count == <whatever>'       */
        /* might not be correct; an othersubr expects a certain    */
        /* number of operands on the PostScript stack (as opposed  */
        /* to the T1 stack) but it doesn't have to put them there  */
        /* by itself; previous othersubrs might have left the      */
        /* operands there if they were not followed by an          */
        /* appropriate number of pops                              */
        /*                                                         */
        /* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
        /* accept a font that contains charstrings like            */
        /*                                                         */
        /*     100 200 2 20 callothersubr                          */
        /*     300 1 20 callothersubr pop                          */
        /*                                                         */
        /* Perhaps this is the reason why BuildCharArray exists.   */

        switch ( subr_no )
        {
        case 0:                     /* end flex feature */
          if ( arg_cnt != 3 )
            goto Unexpected_OtherSubr;

          if ( !decoder->flex_state           ||
               decoder->num_flex_vectors != 7 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected flex end\n"" ));
            goto Syntax_Error;
          }

          /* the two `results' are popped by the following setcurrentpoint */
          top[0] = x;
          top[1] = y;
          known_othersubr_result_cnt = 2;
          break;

        case 1:                     /* start flex feature */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 6 ) )   )
            goto Fail;

          decoder->flex_state        = 1;
          decoder->num_flex_vectors  = 0;
          break;

        case 2:                     /* add flex vectors */
          {
            FT_Int  idx;


            if ( arg_cnt != 0 )
              goto Unexpected_OtherSubr;

            if ( !decoder->flex_state )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" missing flex start\n"" ));
              goto Syntax_Error;
            }

            /* note that we should not add a point for index 0; */
            /* this will move our current position to the flex  */
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
//fix_flaw_line_below:
//            {
//fix_flaw_line_below:
//              /* in malformed fonts it is possible to have other */
//fix_flaw_line_below:
//              /* opcodes in the middle of a flex (which don't    */
//fix_flaw_line_below:
//              /* increase `num_flex_vectors'); we thus have to   */
//fix_flaw_line_below:
//              /* check whether we can add a point                */
//fix_flaw_line_below:
//              if ( FT_SET_ERROR( t1_builder_check_points( builder, 1 ) ) )
//fix_flaw_line_below:
//                goto Syntax_Error;
//fix_flaw_line_below:
//
               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
//fix_flaw_line_below:
//            }
           }
           break;
          break;

        case 12:
        case 13:
          /* counter control hints, clear stack */
          top = decoder->stack;
          break;

        case 14:
        case 15:
        case 16:
        case 17:
        case 18:                    /* multiple masters */
          {
            PS_Blend  blend = decoder->blend;
            FT_UInt   num_points, nn, mm;
            FT_Long*  delta;
            FT_Long*  values;


            if ( !blend )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected multiple masters operator\n"" ));
              goto Syntax_Error;
            }

            num_points = (FT_UInt)subr_no - 13 + ( subr_no == 18 );
            if ( arg_cnt != (FT_Int)( num_points * blend->num_designs ) )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" incorrect number of multiple masters arguments\n"" ));
              goto Syntax_Error;
            }

            /* We want to compute                                    */
            /*                                                       */
            /*   a0*w0 + a1*w1 + ... + ak*wk                         */
            /*                                                       */
            /* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
            /*                                                       */
            /* However, given that w0 + w1 + ... + wk == 1, we can   */
            /* rewrite it easily as                                  */
            /*                                                       */
            /*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
            /*                                                       */
            /* where k == num_designs-1.                             */
            /*                                                       */
            /* I guess that's why it's written in this `compact'     */
            /* form.                                                 */
            /*                                                       */
            delta  = top + num_points;
            values = top;
            for ( nn = 0; nn < num_points; nn++ )
            {
              FT_Long  tmp = values[0];


              for ( mm = 1; mm < blend->num_designs; mm++ )
                tmp += FT_MulFix( *delta++, blend->weight_vector[mm] );

              *values++ = tmp;
            }

            known_othersubr_result_cnt = (FT_Int)num_points;
            break;
          }

        case 19:
          /* <idx> 1 19 callothersubr                             */
          /* => replace elements starting from index cvi( <idx> ) */
          /*    of BuildCharArray with WeightVector               */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0                                                    ||
                 (FT_UInt)idx + blend->num_designs > decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            ft_memcpy( &decoder->buildchar[idx],
                       blend->weight_vector,
                       blend->num_designs *
                         sizeof ( blend->weight_vector[0] ) );
          }
          break;

        case 20:
          /* <arg1> <arg2> 2 20 callothersubr pop   */
          /* ==> push <arg1> + <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] += top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 21:
          /* <arg1> <arg2> 2 21 callothersubr pop   */
          /* ==> push <arg1> - <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] -= top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 22:
          /* <arg1> <arg2> 2 22 callothersubr pop   */
          /* ==> push <arg1> * <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] = FT_MulFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 23:
          /* <arg1> <arg2> 2 23 callothersubr pop   */
          /* ==> push <arg1> / <arg2> onto T1 stack */
          if ( arg_cnt != 2 || top[1] == 0 )
            goto Unexpected_OtherSubr;

          top[0] = FT_DivFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 24:
          /* <val> <idx> 2 24 callothersubr               */
          /* ==> set BuildCharArray[cvi( <idx> )] = <val> */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 2 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[1] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            decoder->buildchar[idx] = top[0];
          }
          break;

        case 25:
          /* <idx> 1 25 callothersubr pop        */
          /* ==> push BuildCharArray[cvi( idx )] */
          /*     onto T1 stack                   */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            top[0] = decoder->buildchar[idx];
          }

          known_othersubr_result_cnt = 1;
          break;

#if 0
        case 26:
          /* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
          /*                      leave mark on T1 stack                    */
          /* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
          XXX which routine has left its mark on the (PostScript) stack?;
          break;
#endif

        case 27:
          /* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
          /* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
          /*     otherwise push <res2>                          */
          if ( arg_cnt != 4 )
            goto Unexpected_OtherSubr;

          if ( top[2] > top[3] )
            top[0] = top[1];

          known_othersubr_result_cnt = 1;
          break;

        case 28:
          /* 0 28 callothersubr pop                               */
          /* => push random value from interval [0, 1) onto stack */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          {
            FT_Fixed  Rand;


            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            top[0] = Rand;

            seed = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
          }

          known_othersubr_result_cnt = 1;
          break;

        default:
          if ( arg_cnt >= 0 && subr_no >= 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unknown othersubr [%d %d], wish me luck\n"",
                       arg_cnt, subr_no ));
            unknown_othersubr_result_cnt = arg_cnt;
            break;
          }
          /* fall through */

        Unexpected_OtherSubr:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid othersubr [%d %d]\n"", arg_cnt, subr_no ));
          goto Syntax_Error;
        }

        top += known_othersubr_result_cnt;

        decoder->top = top;
      }
      else  /* general operator */
      {
        FT_Int  num_args = t1_args_count[op];


        FT_ASSERT( num_args >= 0 );

        if ( top - decoder->stack < num_args )
          goto Stack_Underflow;

        /* XXX Operators usually take their operands from the        */
        /*     bottom of the stack, i.e., the operands are           */
        /*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
        /*     only div, callsubr, and callothersubr are different.  */
        /*     In practice it doesn't matter (?).                    */

#ifdef FT_DEBUG_LEVEL_TRACE

        switch ( op )
        {
        case op_callsubr:
        case op_div:
        case op_callothersubr:
        case op_pop:
        case op_return:
          break;

        default:
          if ( top - decoder->stack != num_args )
            FT_TRACE0(( ""t1_decoder_parse_charstrings:""
                        "" too much operands on the stack""
                        "" (seen %d, expected %d)\n"",
                        top - decoder->stack, num_args ));
            break;
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        top -= num_args;

        switch ( op )
        {
        case op_endchar:
          FT_TRACE4(( "" endchar\n"" ));

          t1_builder_close_contour( builder );

          /* close hints recording session */
          if ( hinter )
          {
            if ( hinter->close( hinter->hints,
                                (FT_UInt)builder->current->n_points ) )
              goto Syntax_Error;

            /* apply hints to the loaded glyph outline now */
            error = hinter->apply( hinter->hints,
                                   builder->current,
                                   (PSH_Globals)builder->hints_globals,
                                   decoder->hint_mode );
            if ( error )
              goto Fail;
          }

          /* add current outline to the glyph slot */
          FT_GlyphLoader_Add( builder->loader );

          /* the compiler should optimize away this empty loop but ... */

#ifdef FT_DEBUG_LEVEL_TRACE

          if ( decoder->len_buildchar > 0 )
          {
            FT_UInt  i;


            FT_TRACE4(( ""BuildCharArray = [ "" ));

            for ( i = 0; i < decoder->len_buildchar; i++ )
              FT_TRACE4(( ""%d "", decoder->buildchar[i] ));

            FT_TRACE4(( ""]\n"" ));
          }

#endif /* FT_DEBUG_LEVEL_TRACE */

          FT_TRACE4(( ""\n"" ));

          /* return now! */
          return FT_Err_Ok;

        case op_hsbw:
          FT_TRACE4(( "" hsbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->advance.x       = top[1];
          builder->advance.y       = 0;

          orig_x = x = builder->pos_x + top[0];
          orig_y = y = builder->pos_y;

          FT_UNUSED( orig_y );

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_seac:
          return t1operator_seac( decoder,
                                  top[0],
                                  top[1],
                                  top[2],
                                  Fix2Int( top[3] ),
                                  Fix2Int( top[4] ) );

        case op_sbw:
          FT_TRACE4(( "" sbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->left_bearing.y += top[1];
          builder->advance.x       = top[2];
          builder->advance.y       = top[3];

          x = builder->pos_x + top[0];
          y = builder->pos_y + top[1];

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_closepath:
          FT_TRACE4(( "" closepath"" ));

          /* if there is no path, `closepath' is a no-op */
          if ( builder->parse_state == T1_Parse_Have_Path   ||
               builder->parse_state == T1_Parse_Have_Moveto )
            t1_builder_close_contour( builder );

          builder->parse_state = T1_Parse_Have_Width;
          break;

        case op_hlineto:
          FT_TRACE4(( "" hlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          goto Add_Line;

        case op_hmoveto:
          FT_TRACE4(( "" hmoveto"" ));

          x += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_hvcurveto:
          FT_TRACE4(( "" hvcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          y += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_rlineto:
          FT_TRACE4(( "" rlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          y += top[1];

        Add_Line:
          if ( FT_SET_ERROR( t1_builder_add_point1( builder, x, y ) ) )
            goto Fail;
          break;

        case op_rmoveto:
          FT_TRACE4(( "" rmoveto"" ));

          x += top[0];
          y += top[1];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_rrcurveto:
          FT_TRACE4(( "" rrcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          y += top[1];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[2];
          y += top[3];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[4];
          y += top[5];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vhcurveto:
          FT_TRACE4(( "" vhcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          y += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vlineto:
          FT_TRACE4(( "" vlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          y += top[0];
          goto Add_Line;

        case op_vmoveto:
          FT_TRACE4(( "" vmoveto"" ));

          y += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_div:
          FT_TRACE4(( "" div"" ));

          /* if `large_int' is set, we divide unscaled numbers; */
          /* otherwise, we divide numbers in 16.16 format --    */
          /* in both cases, it is the same operation            */
          *top = FT_DivFix( top[0], top[1] );
          top++;

          large_int = FALSE;
          break;

        case op_callsubr:
          {
            FT_Int  idx;


            FT_TRACE4(( "" callsubr"" ));

            idx = Fix2Int( top[0] );

            if ( decoder->subrs_hash )
            {
              size_t*  val = ft_hash_num_lookup( idx,
                                                 decoder->subrs_hash );


              if ( val )
                idx = *val;
              else
                idx = -1;
            }

            if ( idx < 0 || idx >= decoder->num_subrs )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invalid subrs index\n"" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= T1_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" too many nested subrs\n"" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;

            /* The Type 1 driver stores subroutines without the seed bytes. */
            /* The CID driver stores subroutines with seed bytes.  This     */
            /* case is taken care of when decoder->subrs_len == 0.          */
            zone->base = decoder->subrs[idx];

            if ( decoder->subrs_len )
              zone->limit = zone->base + decoder->subrs_len[idx];
            else
            {
              /* We are using subroutines from a CID font.  We must adjust */
              /* for the seed bytes.                                       */
              zone->base  += ( decoder->lenIV >= 0 ? decoder->lenIV : 0 );
              zone->limit  = decoder->subrs[idx + 1];
            }

            zone->cursor = zone->base;

            if ( !zone->base )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invoking empty subrs\n"" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
            break;
          }

        case op_pop:
          FT_TRACE4(( "" pop"" ));

          if ( known_othersubr_result_cnt > 0 )
          {
            known_othersubr_result_cnt--;
            /* ignore, we pushed the operands ourselves */
            break;
          }

          if ( unknown_othersubr_result_cnt == 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no more operands for othersubr\n"" ));
            goto Syntax_Error;
          }

          unknown_othersubr_result_cnt--;
          top++;   /* `push' the operand to callothersubr onto the stack */
          break;

        case op_return:
          FT_TRACE4(( "" return"" ));

          if ( zone <= decoder->zones )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected return\n"" ));
            goto Syntax_Error;
          }

          zone--;
          ip            = zone->cursor;
          limit         = zone->limit;
          decoder->zone = zone;
          break;

        case op_dotsection:
          FT_TRACE4(( "" dotsection"" ));

          break;

        case op_hstem:
          FT_TRACE4(( "" hstem"" ));

          /* record horizontal hint */
          if ( hinter )
          {
            /* top[0] += builder->left_bearing.y; */
            hinter->stem( hinter->hints, 1, top );
          }
          break;

        case op_hstem3:
          FT_TRACE4(( "" hstem3"" ));

          /* record horizontal counter-controlled hints */
          if ( hinter )
            hinter->stem3( hinter->hints, 1, top );
          break;

        case op_vstem:
          FT_TRACE4(( "" vstem"" ));

          /* record vertical hint */
          if ( hinter )
          {
            top[0] += orig_x;
            hinter->stem( hinter->hints, 0, top );
          }
          break;

        case op_vstem3:
          FT_TRACE4(( "" vstem3"" ));

          /* record vertical counter-controlled hints */
          if ( hinter )
          {
            FT_Pos  dx = orig_x;


            top[0] += dx;
            top[2] += dx;
            top[4] += dx;
            hinter->stem3( hinter->hints, 0, top );
          }
          break;

        case op_setcurrentpoint:
          FT_TRACE4(( "" setcurrentpoint"" ));

          /* From the T1 specification, section 6.4:                */
          /*                                                        */
          /*   The setcurrentpoint command is used only in          */
          /*   conjunction with results from OtherSubrs procedures. */

          /* known_othersubr_result_cnt != 0 is already handled     */
          /* above.                                                 */

          /* Note, however, that both Ghostscript and Adobe         */
          /* Distiller handle this situation by silently ignoring   */
          /* the inappropriate `setcurrentpoint' instruction.  So   */
          /* we do the same.                                        */
#if 0

          if ( decoder->flex_state != 1 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected `setcurrentpoint'\n"" ));
            goto Syntax_Error;
          }
          else
            ...
#endif

          x = top[0];
          y = top[1];
          decoder->flex_state = 0;
          break;

        case op_unknown15:
          FT_TRACE4(( "" opcode_15"" ));
          /* nothing to do except to pop the two arguments */
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unhandled opcode %d\n"", op ));
          goto Syntax_Error;
        }

        /* XXX Operators usually clear the operand stack;  */
        /*     only div, callsubr, callothersubr, pop, and */
        /*     return are different.                       */
        /*     In practice it doesn't matter (?).          */

        decoder->top = top;

#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( ""\n"" ));
        bol = TRUE;
#endif

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( ""..end..\n\n"" ));

  Fail:
    return error;

  Syntax_Error:
    return FT_THROW( Syntax_Error );

  Stack_Underflow:
    return FT_THROW( Stack_Underflow );
  }
",178056,"  t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                FT_Byte*    charstring_base,
                                FT_UInt     charstring_len )
  {
    FT_Error         error;
    T1_Decoder_Zone  zone;
    FT_Byte*         ip;
    FT_Byte*         limit;
    T1_Builder       builder = &decoder->builder;
    FT_Pos           x, y, orig_x, orig_y;
    FT_Int           known_othersubr_result_cnt   = 0;
    FT_Int           unknown_othersubr_result_cnt = 0;
    FT_Bool          large_int;
    FT_Fixed         seed;

    T1_Hints_Funcs   hinter;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_Bool          bol = TRUE;
#endif


    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* First of all, initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;

    builder->parse_state = T1_Parse_Start;

    hinter = (T1_Hints_Funcs)builder->hints_funcs;

    /* a font that reads BuildCharArray without setting */
    /* its values first is buggy, but ...               */
    FT_ASSERT( ( decoder->len_buildchar == 0 ) ==
               ( decoder->buildchar == NULL )  );

    if ( decoder->buildchar && decoder->len_buildchar > 0 )
      FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );

    FT_TRACE4(( ""\n""
                ""Start charstring\n"" ));

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = orig_x = builder->pos_x;
    y = orig_y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    large_int = FALSE;

    /* now, execute loop */
    while ( ip < limit )
    {
      FT_Long*     top   = decoder->top;
      T1_Operator  op    = op_none;
      FT_Int32     value = 0;


      FT_ASSERT( known_othersubr_result_cnt == 0   ||
                 unknown_othersubr_result_cnt == 0 );

#ifdef FT_DEBUG_LEVEL_TRACE
      if ( bol )
      {
        FT_TRACE5(( "" (%d)"", decoder->top - decoder->stack ));
        bol = FALSE;
      }
#endif

      /*********************************************************************/
      /*                                                                   */
      /* Decode operator or operand                                        */
      /*                                                                   */
      /*                                                                   */

      /* first of all, decompress operator or value */
      switch ( *ip++ )
      {
      case 1:
        op = op_hstem;
        break;

      case 3:
        op = op_vstem;
        break;
      case 4:
        op = op_vmoveto;
        break;
      case 5:
        op = op_rlineto;
        break;
      case 6:
        op = op_hlineto;
        break;
      case 7:
        op = op_vlineto;
        break;
      case 8:
        op = op_rrcurveto;
        break;
      case 9:
        op = op_closepath;
        break;
      case 10:
        op = op_callsubr;
        break;
      case 11:
        op = op_return;
        break;

      case 13:
        op = op_hsbw;
        break;
      case 14:
        op = op_endchar;
        break;

      case 15:          /* undocumented, obsolete operator */
        op = op_unknown15;
        break;

      case 21:
        op = op_rmoveto;
        break;
      case 22:
        op = op_hmoveto;
        break;

      case 30:
        op = op_vhcurveto;
        break;
      case 31:
        op = op_hvcurveto;
        break;

      case 12:
        if ( ip >= limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+EOF)\n"" ));
          goto Syntax_Error;
        }

        switch ( *ip++ )
        {
        case 0:
          op = op_dotsection;
          break;
        case 1:
          op = op_vstem3;
          break;
        case 2:
          op = op_hstem3;
          break;
        case 6:
          op = op_seac;
          break;
        case 7:
          op = op_sbw;
          break;
        case 12:
          op = op_div;
          break;
        case 16:
          op = op_callothersubr;
          break;
        case 17:
          op = op_pop;
          break;
        case 33:
          op = op_setcurrentpoint;
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+%d)\n"",
                     ip[-1] ));
          goto Syntax_Error;
        }
        break;

      case 255:    /* four bytes integer */
        if ( ip + 4 > limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unexpected EOF in integer\n"" ));
          goto Syntax_Error;
        }

        value = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] << 8  ) |
                              (FT_UInt32)ip[3]         );
        ip += 4;

        /* According to the specification, values > 32000 or < -32000 must */
        /* be followed by a `div' operator to make the result be in the    */
        /* range [-32000;32000].  We expect that the second argument of    */
        /* `div' is not a large number.  Additionally, we don't handle     */
        /* stuff like `<large1> <large2> <num> div <num> div' or           */
        /* <large1> <large2> <num> div div'.  This is probably not allowed */
        /* anyway.                                                         */
        if ( value > 32000 || value < -32000 )
        {
          if ( large_int )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no `div' after large integer\n"" ));
          }
          else
            large_int = TRUE;
        }
        else
        {
          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }

        break;

      default:
        if ( ip[-1] >= 32 )
        {
          if ( ip[-1] < 247 )
            value = (FT_Int32)ip[-1] - 139;
          else
          {
            if ( ++ip > limit )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected EOF in integer\n"" ));
              goto Syntax_Error;
            }

            if ( ip[-2] < 251 )
              value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
            else
              value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
          }

          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }
        else
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid byte (%d)\n"", ip[-1] ));
          goto Syntax_Error;
        }
      }

      if ( unknown_othersubr_result_cnt > 0 )
      {
        switch ( op )
        {
        case op_callsubr:
        case op_return:
        case op_none:
        case op_pop:
          break;

        default:
          /* all operands have been transferred by previous pops */
          unknown_othersubr_result_cnt = 0;
          break;
        }
      }

      if ( large_int && !( op == op_none || op == op_div ) )
      {
        FT_ERROR(( ""t1_decoder_parse_charstrings:""
                   "" no `div' after large integer\n"" ));

        large_int = FALSE;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Push value on stack, or process operator                         */
      /*                                                                   */
      /*                                                                   */
      if ( op == op_none )
      {
        if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings: stack overflow\n"" ));
          goto Syntax_Error;
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( large_int )
          FT_TRACE4(( "" %d"", value ));
        else
          FT_TRACE4(( "" %d"", value / 65536 ));
#endif

        *top++       = value;
        decoder->top = top;
      }
      else if ( op == op_callothersubr )  /* callothersubr */
      {
        FT_Int  subr_no;
        FT_Int  arg_cnt;


#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( "" callothersubr\n"" ));
        bol = TRUE;
#endif

        if ( top - decoder->stack < 2 )
          goto Stack_Underflow;

        top -= 2;

        subr_no = Fix2Int( top[1] );
        arg_cnt = Fix2Int( top[0] );

        /***********************************************************/
        /*                                                         */
        /* remove all operands to callothersubr from the stack     */
        /*                                                         */
        /* for handled othersubrs, where we know the number of     */
        /* arguments, we increase the stack by the value of        */
        /* known_othersubr_result_cnt                              */
        /*                                                         */
        /* for unhandled othersubrs the following pops adjust the  */
        /* stack pointer as necessary                              */

        if ( arg_cnt > top - decoder->stack )
          goto Stack_Underflow;

        top -= arg_cnt;

        known_othersubr_result_cnt   = 0;
        unknown_othersubr_result_cnt = 0;

        /* XXX TODO: The checks to `arg_count == <whatever>'       */
        /* might not be correct; an othersubr expects a certain    */
        /* number of operands on the PostScript stack (as opposed  */
        /* to the T1 stack) but it doesn't have to put them there  */
        /* by itself; previous othersubrs might have left the      */
        /* operands there if they were not followed by an          */
        /* appropriate number of pops                              */
        /*                                                         */
        /* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
        /* accept a font that contains charstrings like            */
        /*                                                         */
        /*     100 200 2 20 callothersubr                          */
        /*     300 1 20 callothersubr pop                          */
        /*                                                         */
        /* Perhaps this is the reason why BuildCharArray exists.   */

        switch ( subr_no )
        {
        case 0:                     /* end flex feature */
          if ( arg_cnt != 3 )
            goto Unexpected_OtherSubr;

          if ( !decoder->flex_state           ||
               decoder->num_flex_vectors != 7 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected flex end\n"" ));
            goto Syntax_Error;
          }

          /* the two `results' are popped by the following setcurrentpoint */
          top[0] = x;
          top[1] = y;
          known_othersubr_result_cnt = 2;
          break;

        case 1:                     /* start flex feature */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 6 ) )   )
            goto Fail;

          decoder->flex_state        = 1;
          decoder->num_flex_vectors  = 0;
          break;

        case 2:                     /* add flex vectors */
          {
            FT_Int  idx;


            if ( arg_cnt != 0 )
              goto Unexpected_OtherSubr;

            if ( !decoder->flex_state )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" missing flex start\n"" ));
              goto Syntax_Error;
            }

            /* note that we should not add a point for index 0; */
            /* this will move our current position to the flex  */
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
           }
           break;
          break;

        case 12:
        case 13:
          /* counter control hints, clear stack */
          top = decoder->stack;
          break;

        case 14:
        case 15:
        case 16:
        case 17:
        case 18:                    /* multiple masters */
          {
            PS_Blend  blend = decoder->blend;
            FT_UInt   num_points, nn, mm;
            FT_Long*  delta;
            FT_Long*  values;


            if ( !blend )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected multiple masters operator\n"" ));
              goto Syntax_Error;
            }

            num_points = (FT_UInt)subr_no - 13 + ( subr_no == 18 );
            if ( arg_cnt != (FT_Int)( num_points * blend->num_designs ) )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" incorrect number of multiple masters arguments\n"" ));
              goto Syntax_Error;
            }

            /* We want to compute                                    */
            /*                                                       */
            /*   a0*w0 + a1*w1 + ... + ak*wk                         */
            /*                                                       */
            /* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
            /*                                                       */
            /* However, given that w0 + w1 + ... + wk == 1, we can   */
            /* rewrite it easily as                                  */
            /*                                                       */
            /*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
            /*                                                       */
            /* where k == num_designs-1.                             */
            /*                                                       */
            /* I guess that's why it's written in this `compact'     */
            /* form.                                                 */
            /*                                                       */
            delta  = top + num_points;
            values = top;
            for ( nn = 0; nn < num_points; nn++ )
            {
              FT_Long  tmp = values[0];


              for ( mm = 1; mm < blend->num_designs; mm++ )
                tmp += FT_MulFix( *delta++, blend->weight_vector[mm] );

              *values++ = tmp;
            }

            known_othersubr_result_cnt = (FT_Int)num_points;
            break;
          }

        case 19:
          /* <idx> 1 19 callothersubr                             */
          /* => replace elements starting from index cvi( <idx> ) */
          /*    of BuildCharArray with WeightVector               */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0                                                    ||
                 (FT_UInt)idx + blend->num_designs > decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            ft_memcpy( &decoder->buildchar[idx],
                       blend->weight_vector,
                       blend->num_designs *
                         sizeof ( blend->weight_vector[0] ) );
          }
          break;

        case 20:
          /* <arg1> <arg2> 2 20 callothersubr pop   */
          /* ==> push <arg1> + <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] += top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 21:
          /* <arg1> <arg2> 2 21 callothersubr pop   */
          /* ==> push <arg1> - <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] -= top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 22:
          /* <arg1> <arg2> 2 22 callothersubr pop   */
          /* ==> push <arg1> * <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] = FT_MulFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 23:
          /* <arg1> <arg2> 2 23 callothersubr pop   */
          /* ==> push <arg1> / <arg2> onto T1 stack */
          if ( arg_cnt != 2 || top[1] == 0 )
            goto Unexpected_OtherSubr;

          top[0] = FT_DivFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 24:
          /* <val> <idx> 2 24 callothersubr               */
          /* ==> set BuildCharArray[cvi( <idx> )] = <val> */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 2 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[1] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            decoder->buildchar[idx] = top[0];
          }
          break;

        case 25:
          /* <idx> 1 25 callothersubr pop        */
          /* ==> push BuildCharArray[cvi( idx )] */
          /*     onto T1 stack                   */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            top[0] = decoder->buildchar[idx];
          }

          known_othersubr_result_cnt = 1;
          break;

#if 0
        case 26:
          /* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
          /*                      leave mark on T1 stack                    */
          /* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
          XXX which routine has left its mark on the (PostScript) stack?;
          break;
#endif

        case 27:
          /* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
          /* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
          /*     otherwise push <res2>                          */
          if ( arg_cnt != 4 )
            goto Unexpected_OtherSubr;

          if ( top[2] > top[3] )
            top[0] = top[1];

          known_othersubr_result_cnt = 1;
          break;

        case 28:
          /* 0 28 callothersubr pop                               */
          /* => push random value from interval [0, 1) onto stack */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          {
            FT_Fixed  Rand;


            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            top[0] = Rand;

            seed = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
          }

          known_othersubr_result_cnt = 1;
          break;

        default:
          if ( arg_cnt >= 0 && subr_no >= 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unknown othersubr [%d %d], wish me luck\n"",
                       arg_cnt, subr_no ));
            unknown_othersubr_result_cnt = arg_cnt;
            break;
          }
          /* fall through */

        Unexpected_OtherSubr:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid othersubr [%d %d]\n"", arg_cnt, subr_no ));
          goto Syntax_Error;
        }

        top += known_othersubr_result_cnt;

        decoder->top = top;
      }
      else  /* general operator */
      {
        FT_Int  num_args = t1_args_count[op];


        FT_ASSERT( num_args >= 0 );

        if ( top - decoder->stack < num_args )
          goto Stack_Underflow;

        /* XXX Operators usually take their operands from the        */
        /*     bottom of the stack, i.e., the operands are           */
        /*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
        /*     only div, callsubr, and callothersubr are different.  */
        /*     In practice it doesn't matter (?).                    */

#ifdef FT_DEBUG_LEVEL_TRACE

        switch ( op )
        {
        case op_callsubr:
        case op_div:
        case op_callothersubr:
        case op_pop:
        case op_return:
          break;

        default:
          if ( top - decoder->stack != num_args )
            FT_TRACE0(( ""t1_decoder_parse_charstrings:""
                        "" too much operands on the stack""
                        "" (seen %d, expected %d)\n"",
                        top - decoder->stack, num_args ));
            break;
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        top -= num_args;

        switch ( op )
        {
        case op_endchar:
          FT_TRACE4(( "" endchar\n"" ));

          t1_builder_close_contour( builder );

          /* close hints recording session */
          if ( hinter )
          {
            if ( hinter->close( hinter->hints,
                                (FT_UInt)builder->current->n_points ) )
              goto Syntax_Error;

            /* apply hints to the loaded glyph outline now */
            error = hinter->apply( hinter->hints,
                                   builder->current,
                                   (PSH_Globals)builder->hints_globals,
                                   decoder->hint_mode );
            if ( error )
              goto Fail;
          }

          /* add current outline to the glyph slot */
          FT_GlyphLoader_Add( builder->loader );

          /* the compiler should optimize away this empty loop but ... */

#ifdef FT_DEBUG_LEVEL_TRACE

          if ( decoder->len_buildchar > 0 )
          {
            FT_UInt  i;


            FT_TRACE4(( ""BuildCharArray = [ "" ));

            for ( i = 0; i < decoder->len_buildchar; i++ )
              FT_TRACE4(( ""%d "", decoder->buildchar[i] ));

            FT_TRACE4(( ""]\n"" ));
          }

#endif /* FT_DEBUG_LEVEL_TRACE */

          FT_TRACE4(( ""\n"" ));

          /* return now! */
          return FT_Err_Ok;

        case op_hsbw:
          FT_TRACE4(( "" hsbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->advance.x       = top[1];
          builder->advance.y       = 0;

          orig_x = x = builder->pos_x + top[0];
          orig_y = y = builder->pos_y;

          FT_UNUSED( orig_y );

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_seac:
          return t1operator_seac( decoder,
                                  top[0],
                                  top[1],
                                  top[2],
                                  Fix2Int( top[3] ),
                                  Fix2Int( top[4] ) );

        case op_sbw:
          FT_TRACE4(( "" sbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->left_bearing.y += top[1];
          builder->advance.x       = top[2];
          builder->advance.y       = top[3];

          x = builder->pos_x + top[0];
          y = builder->pos_y + top[1];

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_closepath:
          FT_TRACE4(( "" closepath"" ));

          /* if there is no path, `closepath' is a no-op */
          if ( builder->parse_state == T1_Parse_Have_Path   ||
               builder->parse_state == T1_Parse_Have_Moveto )
            t1_builder_close_contour( builder );

          builder->parse_state = T1_Parse_Have_Width;
          break;

        case op_hlineto:
          FT_TRACE4(( "" hlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          goto Add_Line;

        case op_hmoveto:
          FT_TRACE4(( "" hmoveto"" ));

          x += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_hvcurveto:
          FT_TRACE4(( "" hvcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          y += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_rlineto:
          FT_TRACE4(( "" rlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          y += top[1];

        Add_Line:
          if ( FT_SET_ERROR( t1_builder_add_point1( builder, x, y ) ) )
            goto Fail;
          break;

        case op_rmoveto:
          FT_TRACE4(( "" rmoveto"" ));

          x += top[0];
          y += top[1];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_rrcurveto:
          FT_TRACE4(( "" rrcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          y += top[1];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[2];
          y += top[3];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[4];
          y += top[5];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vhcurveto:
          FT_TRACE4(( "" vhcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          y += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vlineto:
          FT_TRACE4(( "" vlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          y += top[0];
          goto Add_Line;

        case op_vmoveto:
          FT_TRACE4(( "" vmoveto"" ));

          y += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_div:
          FT_TRACE4(( "" div"" ));

          /* if `large_int' is set, we divide unscaled numbers; */
          /* otherwise, we divide numbers in 16.16 format --    */
          /* in both cases, it is the same operation            */
          *top = FT_DivFix( top[0], top[1] );
          top++;

          large_int = FALSE;
          break;

        case op_callsubr:
          {
            FT_Int  idx;


            FT_TRACE4(( "" callsubr"" ));

            idx = Fix2Int( top[0] );

            if ( decoder->subrs_hash )
            {
              size_t*  val = ft_hash_num_lookup( idx,
                                                 decoder->subrs_hash );


              if ( val )
                idx = *val;
              else
                idx = -1;
            }

            if ( idx < 0 || idx >= decoder->num_subrs )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invalid subrs index\n"" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= T1_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" too many nested subrs\n"" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;

            /* The Type 1 driver stores subroutines without the seed bytes. */
            /* The CID driver stores subroutines with seed bytes.  This     */
            /* case is taken care of when decoder->subrs_len == 0.          */
            zone->base = decoder->subrs[idx];

            if ( decoder->subrs_len )
              zone->limit = zone->base + decoder->subrs_len[idx];
            else
            {
              /* We are using subroutines from a CID font.  We must adjust */
              /* for the seed bytes.                                       */
              zone->base  += ( decoder->lenIV >= 0 ? decoder->lenIV : 0 );
              zone->limit  = decoder->subrs[idx + 1];
            }

            zone->cursor = zone->base;

            if ( !zone->base )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invoking empty subrs\n"" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
            break;
          }

        case op_pop:
          FT_TRACE4(( "" pop"" ));

          if ( known_othersubr_result_cnt > 0 )
          {
            known_othersubr_result_cnt--;
            /* ignore, we pushed the operands ourselves */
            break;
          }

          if ( unknown_othersubr_result_cnt == 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no more operands for othersubr\n"" ));
            goto Syntax_Error;
          }

          unknown_othersubr_result_cnt--;
          top++;   /* `push' the operand to callothersubr onto the stack */
          break;

        case op_return:
          FT_TRACE4(( "" return"" ));

          if ( zone <= decoder->zones )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected return\n"" ));
            goto Syntax_Error;
          }

          zone--;
          ip            = zone->cursor;
          limit         = zone->limit;
          decoder->zone = zone;
          break;

        case op_dotsection:
          FT_TRACE4(( "" dotsection"" ));

          break;

        case op_hstem:
          FT_TRACE4(( "" hstem"" ));

          /* record horizontal hint */
          if ( hinter )
          {
            /* top[0] += builder->left_bearing.y; */
            hinter->stem( hinter->hints, 1, top );
          }
          break;

        case op_hstem3:
          FT_TRACE4(( "" hstem3"" ));

          /* record horizontal counter-controlled hints */
          if ( hinter )
            hinter->stem3( hinter->hints, 1, top );
          break;

        case op_vstem:
          FT_TRACE4(( "" vstem"" ));

          /* record vertical hint */
          if ( hinter )
          {
            top[0] += orig_x;
            hinter->stem( hinter->hints, 0, top );
          }
          break;

        case op_vstem3:
          FT_TRACE4(( "" vstem3"" ));

          /* record vertical counter-controlled hints */
          if ( hinter )
          {
            FT_Pos  dx = orig_x;


            top[0] += dx;
            top[2] += dx;
            top[4] += dx;
            hinter->stem3( hinter->hints, 0, top );
          }
          break;

        case op_setcurrentpoint:
          FT_TRACE4(( "" setcurrentpoint"" ));

          /* From the T1 specification, section 6.4:                */
          /*                                                        */
          /*   The setcurrentpoint command is used only in          */
          /*   conjunction with results from OtherSubrs procedures. */

          /* known_othersubr_result_cnt != 0 is already handled     */
          /* above.                                                 */

          /* Note, however, that both Ghostscript and Adobe         */
          /* Distiller handle this situation by silently ignoring   */
          /* the inappropriate `setcurrentpoint' instruction.  So   */
          /* we do the same.                                        */
#if 0

          if ( decoder->flex_state != 1 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected `setcurrentpoint'\n"" ));
            goto Syntax_Error;
          }
          else
            ...
#endif

          x = top[0];
          y = top[1];
          decoder->flex_state = 0;
          break;

        case op_unknown15:
          FT_TRACE4(( "" opcode_15"" ));
          /* nothing to do except to pop the two arguments */
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unhandled opcode %d\n"", op ));
          goto Syntax_Error;
        }

        /* XXX Operators usually clear the operand stack;  */
        /*     only div, callsubr, callothersubr, pop, and */
        /*     return are different.                       */
        /*     In practice it doesn't matter (?).          */

        decoder->top = top;

#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( ""\n"" ));
        bol = TRUE;
#endif

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( ""..end..\n\n"" ));

  Fail:
    return error;

  Syntax_Error:
    return FT_THROW( Syntax_Error );

  Stack_Underflow:
    return FT_THROW( Stack_Underflow );
  }
","  t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                FT_Byte*    charstring_base,
                                FT_UInt     charstring_len )
  {
    FT_Error         error;
    T1_Decoder_Zone  zone;
    FT_Byte*         ip;
    FT_Byte*         limit;
    T1_Builder       builder = &decoder->builder;
    FT_Pos           x, y, orig_x, orig_y;
    FT_Int           known_othersubr_result_cnt   = 0;
    FT_Int           unknown_othersubr_result_cnt = 0;
    FT_Bool          large_int;
    FT_Fixed         seed;

    T1_Hints_Funcs   hinter;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_Bool          bol = TRUE;
#endif


    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* First of all, initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;

    builder->parse_state = T1_Parse_Start;

    hinter = (T1_Hints_Funcs)builder->hints_funcs;

    /* a font that reads BuildCharArray without setting */
    /* its values first is buggy, but ...               */
    FT_ASSERT( ( decoder->len_buildchar == 0 ) ==
               ( decoder->buildchar == NULL )  );

    if ( decoder->buildchar && decoder->len_buildchar > 0 )
      FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );

    FT_TRACE4(( ""\n""
                ""Start charstring\n"" ));

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = orig_x = builder->pos_x;
    y = orig_y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    large_int = FALSE;

    /* now, execute loop */
    while ( ip < limit )
    {
      FT_Long*     top   = decoder->top;
      T1_Operator  op    = op_none;
      FT_Int32     value = 0;


      FT_ASSERT( known_othersubr_result_cnt == 0   ||
                 unknown_othersubr_result_cnt == 0 );

#ifdef FT_DEBUG_LEVEL_TRACE
      if ( bol )
      {
        FT_TRACE5(( "" (%d)"", decoder->top - decoder->stack ));
        bol = FALSE;
      }
#endif

      /*********************************************************************/
      /*                                                                   */
      /* Decode operator or operand                                        */
      /*                                                                   */
      /*                                                                   */

      /* first of all, decompress operator or value */
      switch ( *ip++ )
      {
      case 1:
        op = op_hstem;
        break;

      case 3:
        op = op_vstem;
        break;
      case 4:
        op = op_vmoveto;
        break;
      case 5:
        op = op_rlineto;
        break;
      case 6:
        op = op_hlineto;
        break;
      case 7:
        op = op_vlineto;
        break;
      case 8:
        op = op_rrcurveto;
        break;
      case 9:
        op = op_closepath;
        break;
      case 10:
        op = op_callsubr;
        break;
      case 11:
        op = op_return;
        break;

      case 13:
        op = op_hsbw;
        break;
      case 14:
        op = op_endchar;
        break;

      case 15:          /* undocumented, obsolete operator */
        op = op_unknown15;
        break;

      case 21:
        op = op_rmoveto;
        break;
      case 22:
        op = op_hmoveto;
        break;

      case 30:
        op = op_vhcurveto;
        break;
      case 31:
        op = op_hvcurveto;
        break;

      case 12:
        if ( ip >= limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+EOF)\n"" ));
          goto Syntax_Error;
        }

        switch ( *ip++ )
        {
        case 0:
          op = op_dotsection;
          break;
        case 1:
          op = op_vstem3;
          break;
        case 2:
          op = op_hstem3;
          break;
        case 6:
          op = op_seac;
          break;
        case 7:
          op = op_sbw;
          break;
        case 12:
          op = op_div;
          break;
        case 16:
          op = op_callothersubr;
          break;
        case 17:
          op = op_pop;
          break;
        case 33:
          op = op_setcurrentpoint;
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid escape (12+%d)\n"",
                     ip[-1] ));
          goto Syntax_Error;
        }
        break;

      case 255:    /* four bytes integer */
        if ( ip + 4 > limit )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unexpected EOF in integer\n"" ));
          goto Syntax_Error;
        }

        value = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] << 8  ) |
                              (FT_UInt32)ip[3]         );
        ip += 4;

        /* According to the specification, values > 32000 or < -32000 must */
        /* be followed by a `div' operator to make the result be in the    */
        /* range [-32000;32000].  We expect that the second argument of    */
        /* `div' is not a large number.  Additionally, we don't handle     */
        /* stuff like `<large1> <large2> <num> div <num> div' or           */
        /* <large1> <large2> <num> div div'.  This is probably not allowed */
        /* anyway.                                                         */
        if ( value > 32000 || value < -32000 )
        {
          if ( large_int )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no `div' after large integer\n"" ));
          }
          else
            large_int = TRUE;
        }
        else
        {
          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }

        break;

      default:
        if ( ip[-1] >= 32 )
        {
          if ( ip[-1] < 247 )
            value = (FT_Int32)ip[-1] - 139;
          else
          {
            if ( ++ip > limit )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected EOF in integer\n"" ));
              goto Syntax_Error;
            }

            if ( ip[-2] < 251 )
              value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
            else
              value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
          }

          if ( !large_int )
            value = (FT_Int32)( (FT_UInt32)value << 16 );
        }
        else
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid byte (%d)\n"", ip[-1] ));
          goto Syntax_Error;
        }
      }

      if ( unknown_othersubr_result_cnt > 0 )
      {
        switch ( op )
        {
        case op_callsubr:
        case op_return:
        case op_none:
        case op_pop:
          break;

        default:
          /* all operands have been transferred by previous pops */
          unknown_othersubr_result_cnt = 0;
          break;
        }
      }

      if ( large_int && !( op == op_none || op == op_div ) )
      {
        FT_ERROR(( ""t1_decoder_parse_charstrings:""
                   "" no `div' after large integer\n"" ));

        large_int = FALSE;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Push value on stack, or process operator                         */
      /*                                                                   */
      /*                                                                   */
      if ( op == op_none )
      {
        if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
        {
          FT_ERROR(( ""t1_decoder_parse_charstrings: stack overflow\n"" ));
          goto Syntax_Error;
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( large_int )
          FT_TRACE4(( "" %d"", value ));
        else
          FT_TRACE4(( "" %d"", value / 65536 ));
#endif

        *top++       = value;
        decoder->top = top;
      }
      else if ( op == op_callothersubr )  /* callothersubr */
      {
        FT_Int  subr_no;
        FT_Int  arg_cnt;


#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( "" callothersubr\n"" ));
        bol = TRUE;
#endif

        if ( top - decoder->stack < 2 )
          goto Stack_Underflow;

        top -= 2;

        subr_no = Fix2Int( top[1] );
        arg_cnt = Fix2Int( top[0] );

        /***********************************************************/
        /*                                                         */
        /* remove all operands to callothersubr from the stack     */
        /*                                                         */
        /* for handled othersubrs, where we know the number of     */
        /* arguments, we increase the stack by the value of        */
        /* known_othersubr_result_cnt                              */
        /*                                                         */
        /* for unhandled othersubrs the following pops adjust the  */
        /* stack pointer as necessary                              */

        if ( arg_cnt > top - decoder->stack )
          goto Stack_Underflow;

        top -= arg_cnt;

        known_othersubr_result_cnt   = 0;
        unknown_othersubr_result_cnt = 0;

        /* XXX TODO: The checks to `arg_count == <whatever>'       */
        /* might not be correct; an othersubr expects a certain    */
        /* number of operands on the PostScript stack (as opposed  */
        /* to the T1 stack) but it doesn't have to put them there  */
        /* by itself; previous othersubrs might have left the      */
        /* operands there if they were not followed by an          */
        /* appropriate number of pops                              */
        /*                                                         */
        /* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
        /* accept a font that contains charstrings like            */
        /*                                                         */
        /*     100 200 2 20 callothersubr                          */
        /*     300 1 20 callothersubr pop                          */
        /*                                                         */
        /* Perhaps this is the reason why BuildCharArray exists.   */

        switch ( subr_no )
        {
        case 0:                     /* end flex feature */
          if ( arg_cnt != 3 )
            goto Unexpected_OtherSubr;

          if ( !decoder->flex_state           ||
               decoder->num_flex_vectors != 7 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected flex end\n"" ));
            goto Syntax_Error;
          }

          /* the two `results' are popped by the following setcurrentpoint */
          top[0] = x;
          top[1] = y;
          known_othersubr_result_cnt = 2;
          break;

        case 1:                     /* start flex feature */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 6 ) )   )
            goto Fail;

          decoder->flex_state        = 1;
          decoder->num_flex_vectors  = 0;
          break;

        case 2:                     /* add flex vectors */
          {
            FT_Int  idx;


            if ( arg_cnt != 0 )
              goto Unexpected_OtherSubr;

            if ( !decoder->flex_state )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" missing flex start\n"" ));
              goto Syntax_Error;
            }

            /* note that we should not add a point for index 0; */
            /* this will move our current position to the flex  */
             /* point without adding any point to the outline    */
             idx = decoder->num_flex_vectors++;
             if ( idx > 0 && idx < 7 )
            {
              /* in malformed fonts it is possible to have other */
              /* opcodes in the middle of a flex (which don't    */
              /* increase `num_flex_vectors'); we thus have to   */
              /* check whether we can add a point                */
              if ( FT_SET_ERROR( t1_builder_check_points( builder, 1 ) ) )
                goto Syntax_Error;

               t1_builder_add_point( builder,
                                     x,
                                     y,
                                     (FT_Byte)( idx == 3 || idx == 6 ) );
            }
           }
           break;
          break;

        case 12:
        case 13:
          /* counter control hints, clear stack */
          top = decoder->stack;
          break;

        case 14:
        case 15:
        case 16:
        case 17:
        case 18:                    /* multiple masters */
          {
            PS_Blend  blend = decoder->blend;
            FT_UInt   num_points, nn, mm;
            FT_Long*  delta;
            FT_Long*  values;


            if ( !blend )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" unexpected multiple masters operator\n"" ));
              goto Syntax_Error;
            }

            num_points = (FT_UInt)subr_no - 13 + ( subr_no == 18 );
            if ( arg_cnt != (FT_Int)( num_points * blend->num_designs ) )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" incorrect number of multiple masters arguments\n"" ));
              goto Syntax_Error;
            }

            /* We want to compute                                    */
            /*                                                       */
            /*   a0*w0 + a1*w1 + ... + ak*wk                         */
            /*                                                       */
            /* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
            /*                                                       */
            /* However, given that w0 + w1 + ... + wk == 1, we can   */
            /* rewrite it easily as                                  */
            /*                                                       */
            /*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
            /*                                                       */
            /* where k == num_designs-1.                             */
            /*                                                       */
            /* I guess that's why it's written in this `compact'     */
            /* form.                                                 */
            /*                                                       */
            delta  = top + num_points;
            values = top;
            for ( nn = 0; nn < num_points; nn++ )
            {
              FT_Long  tmp = values[0];


              for ( mm = 1; mm < blend->num_designs; mm++ )
                tmp += FT_MulFix( *delta++, blend->weight_vector[mm] );

              *values++ = tmp;
            }

            known_othersubr_result_cnt = (FT_Int)num_points;
            break;
          }

        case 19:
          /* <idx> 1 19 callothersubr                             */
          /* => replace elements starting from index cvi( <idx> ) */
          /*    of BuildCharArray with WeightVector               */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0                                                    ||
                 (FT_UInt)idx + blend->num_designs > decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            ft_memcpy( &decoder->buildchar[idx],
                       blend->weight_vector,
                       blend->num_designs *
                         sizeof ( blend->weight_vector[0] ) );
          }
          break;

        case 20:
          /* <arg1> <arg2> 2 20 callothersubr pop   */
          /* ==> push <arg1> + <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] += top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 21:
          /* <arg1> <arg2> 2 21 callothersubr pop   */
          /* ==> push <arg1> - <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] -= top[1]; /* XXX (over|under)flow */

          known_othersubr_result_cnt = 1;
          break;

        case 22:
          /* <arg1> <arg2> 2 22 callothersubr pop   */
          /* ==> push <arg1> * <arg2> onto T1 stack */
          if ( arg_cnt != 2 )
            goto Unexpected_OtherSubr;

          top[0] = FT_MulFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 23:
          /* <arg1> <arg2> 2 23 callothersubr pop   */
          /* ==> push <arg1> / <arg2> onto T1 stack */
          if ( arg_cnt != 2 || top[1] == 0 )
            goto Unexpected_OtherSubr;

          top[0] = FT_DivFix( top[0], top[1] );

          known_othersubr_result_cnt = 1;
          break;

        case 24:
          /* <val> <idx> 2 24 callothersubr               */
          /* ==> set BuildCharArray[cvi( <idx> )] = <val> */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 2 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[1] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            decoder->buildchar[idx] = top[0];
          }
          break;

        case 25:
          /* <idx> 1 25 callothersubr pop        */
          /* ==> push BuildCharArray[cvi( idx )] */
          /*     onto T1 stack                   */
          {
            FT_Int    idx;
            PS_Blend  blend = decoder->blend;


            if ( arg_cnt != 1 || !blend )
              goto Unexpected_OtherSubr;

            idx = Fix2Int( top[0] );

            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )
              goto Unexpected_OtherSubr;

            top[0] = decoder->buildchar[idx];
          }

          known_othersubr_result_cnt = 1;
          break;

#if 0
        case 26:
          /* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
          /*                      leave mark on T1 stack                    */
          /* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
          XXX which routine has left its mark on the (PostScript) stack?;
          break;
#endif

        case 27:
          /* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
          /* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
          /*     otherwise push <res2>                          */
          if ( arg_cnt != 4 )
            goto Unexpected_OtherSubr;

          if ( top[2] > top[3] )
            top[0] = top[1];

          known_othersubr_result_cnt = 1;
          break;

        case 28:
          /* 0 28 callothersubr pop                               */
          /* => push random value from interval [0, 1) onto stack */
          if ( arg_cnt != 0 )
            goto Unexpected_OtherSubr;

          {
            FT_Fixed  Rand;


            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            top[0] = Rand;

            seed = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
          }

          known_othersubr_result_cnt = 1;
          break;

        default:
          if ( arg_cnt >= 0 && subr_no >= 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unknown othersubr [%d %d], wish me luck\n"",
                       arg_cnt, subr_no ));
            unknown_othersubr_result_cnt = arg_cnt;
            break;
          }
          /* fall through */

        Unexpected_OtherSubr:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" invalid othersubr [%d %d]\n"", arg_cnt, subr_no ));
          goto Syntax_Error;
        }

        top += known_othersubr_result_cnt;

        decoder->top = top;
      }
      else  /* general operator */
      {
        FT_Int  num_args = t1_args_count[op];


        FT_ASSERT( num_args >= 0 );

        if ( top - decoder->stack < num_args )
          goto Stack_Underflow;

        /* XXX Operators usually take their operands from the        */
        /*     bottom of the stack, i.e., the operands are           */
        /*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
        /*     only div, callsubr, and callothersubr are different.  */
        /*     In practice it doesn't matter (?).                    */

#ifdef FT_DEBUG_LEVEL_TRACE

        switch ( op )
        {
        case op_callsubr:
        case op_div:
        case op_callothersubr:
        case op_pop:
        case op_return:
          break;

        default:
          if ( top - decoder->stack != num_args )
            FT_TRACE0(( ""t1_decoder_parse_charstrings:""
                        "" too much operands on the stack""
                        "" (seen %d, expected %d)\n"",
                        top - decoder->stack, num_args ));
            break;
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        top -= num_args;

        switch ( op )
        {
        case op_endchar:
          FT_TRACE4(( "" endchar\n"" ));

          t1_builder_close_contour( builder );

          /* close hints recording session */
          if ( hinter )
          {
            if ( hinter->close( hinter->hints,
                                (FT_UInt)builder->current->n_points ) )
              goto Syntax_Error;

            /* apply hints to the loaded glyph outline now */
            error = hinter->apply( hinter->hints,
                                   builder->current,
                                   (PSH_Globals)builder->hints_globals,
                                   decoder->hint_mode );
            if ( error )
              goto Fail;
          }

          /* add current outline to the glyph slot */
          FT_GlyphLoader_Add( builder->loader );

          /* the compiler should optimize away this empty loop but ... */

#ifdef FT_DEBUG_LEVEL_TRACE

          if ( decoder->len_buildchar > 0 )
          {
            FT_UInt  i;


            FT_TRACE4(( ""BuildCharArray = [ "" ));

            for ( i = 0; i < decoder->len_buildchar; i++ )
              FT_TRACE4(( ""%d "", decoder->buildchar[i] ));

            FT_TRACE4(( ""]\n"" ));
          }

#endif /* FT_DEBUG_LEVEL_TRACE */

          FT_TRACE4(( ""\n"" ));

          /* return now! */
          return FT_Err_Ok;

        case op_hsbw:
          FT_TRACE4(( "" hsbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->advance.x       = top[1];
          builder->advance.y       = 0;

          orig_x = x = builder->pos_x + top[0];
          orig_y = y = builder->pos_y;

          FT_UNUSED( orig_y );

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_seac:
          return t1operator_seac( decoder,
                                  top[0],
                                  top[1],
                                  top[2],
                                  Fix2Int( top[3] ),
                                  Fix2Int( top[4] ) );

        case op_sbw:
          FT_TRACE4(( "" sbw"" ));

          builder->parse_state = T1_Parse_Have_Width;

          builder->left_bearing.x += top[0];
          builder->left_bearing.y += top[1];
          builder->advance.x       = top[2];
          builder->advance.y       = top[3];

          x = builder->pos_x + top[0];
          y = builder->pos_y + top[1];

          /* the `metrics_only' indicates that we only want to compute */
          /* the glyph's metrics (lsb + advance width), not load the   */
          /* rest of it; so exit immediately                           */
          if ( builder->metrics_only )
            return FT_Err_Ok;

          break;

        case op_closepath:
          FT_TRACE4(( "" closepath"" ));

          /* if there is no path, `closepath' is a no-op */
          if ( builder->parse_state == T1_Parse_Have_Path   ||
               builder->parse_state == T1_Parse_Have_Moveto )
            t1_builder_close_contour( builder );

          builder->parse_state = T1_Parse_Have_Width;
          break;

        case op_hlineto:
          FT_TRACE4(( "" hlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          goto Add_Line;

        case op_hmoveto:
          FT_TRACE4(( "" hmoveto"" ));

          x += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_hvcurveto:
          FT_TRACE4(( "" hvcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          y += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_rlineto:
          FT_TRACE4(( "" rlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          x += top[0];
          y += top[1];

        Add_Line:
          if ( FT_SET_ERROR( t1_builder_add_point1( builder, x, y ) ) )
            goto Fail;
          break;

        case op_rmoveto:
          FT_TRACE4(( "" rmoveto"" ));

          x += top[0];
          y += top[1];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_rrcurveto:
          FT_TRACE4(( "" rrcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          x += top[0];
          y += top[1];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[2];
          y += top[3];
          t1_builder_add_point( builder, x, y, 0 );

          x += top[4];
          y += top[5];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vhcurveto:
          FT_TRACE4(( "" vhcurveto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) ||
               FT_SET_ERROR( t1_builder_check_points( builder, 3 ) )   )
            goto Fail;

          y += top[0];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[1];
          y += top[2];
          t1_builder_add_point( builder, x, y, 0 );
          x += top[3];
          t1_builder_add_point( builder, x, y, 1 );
          break;

        case op_vlineto:
          FT_TRACE4(( "" vlineto"" ));

          if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
            goto Fail;

          y += top[0];
          goto Add_Line;

        case op_vmoveto:
          FT_TRACE4(( "" vmoveto"" ));

          y += top[0];
          if ( !decoder->flex_state )
          {
            if ( builder->parse_state == T1_Parse_Start )
              goto Syntax_Error;
            builder->parse_state = T1_Parse_Have_Moveto;
          }
          break;

        case op_div:
          FT_TRACE4(( "" div"" ));

          /* if `large_int' is set, we divide unscaled numbers; */
          /* otherwise, we divide numbers in 16.16 format --    */
          /* in both cases, it is the same operation            */
          *top = FT_DivFix( top[0], top[1] );
          top++;

          large_int = FALSE;
          break;

        case op_callsubr:
          {
            FT_Int  idx;


            FT_TRACE4(( "" callsubr"" ));

            idx = Fix2Int( top[0] );

            if ( decoder->subrs_hash )
            {
              size_t*  val = ft_hash_num_lookup( idx,
                                                 decoder->subrs_hash );


              if ( val )
                idx = *val;
              else
                idx = -1;
            }

            if ( idx < 0 || idx >= decoder->num_subrs )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invalid subrs index\n"" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= T1_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" too many nested subrs\n"" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;

            /* The Type 1 driver stores subroutines without the seed bytes. */
            /* The CID driver stores subroutines with seed bytes.  This     */
            /* case is taken care of when decoder->subrs_len == 0.          */
            zone->base = decoder->subrs[idx];

            if ( decoder->subrs_len )
              zone->limit = zone->base + decoder->subrs_len[idx];
            else
            {
              /* We are using subroutines from a CID font.  We must adjust */
              /* for the seed bytes.                                       */
              zone->base  += ( decoder->lenIV >= 0 ? decoder->lenIV : 0 );
              zone->limit  = decoder->subrs[idx + 1];
            }

            zone->cursor = zone->base;

            if ( !zone->base )
            {
              FT_ERROR(( ""t1_decoder_parse_charstrings:""
                         "" invoking empty subrs\n"" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
            break;
          }

        case op_pop:
          FT_TRACE4(( "" pop"" ));

          if ( known_othersubr_result_cnt > 0 )
          {
            known_othersubr_result_cnt--;
            /* ignore, we pushed the operands ourselves */
            break;
          }

          if ( unknown_othersubr_result_cnt == 0 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" no more operands for othersubr\n"" ));
            goto Syntax_Error;
          }

          unknown_othersubr_result_cnt--;
          top++;   /* `push' the operand to callothersubr onto the stack */
          break;

        case op_return:
          FT_TRACE4(( "" return"" ));

          if ( zone <= decoder->zones )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected return\n"" ));
            goto Syntax_Error;
          }

          zone--;
          ip            = zone->cursor;
          limit         = zone->limit;
          decoder->zone = zone;
          break;

        case op_dotsection:
          FT_TRACE4(( "" dotsection"" ));

          break;

        case op_hstem:
          FT_TRACE4(( "" hstem"" ));

          /* record horizontal hint */
          if ( hinter )
          {
            /* top[0] += builder->left_bearing.y; */
            hinter->stem( hinter->hints, 1, top );
          }
          break;

        case op_hstem3:
          FT_TRACE4(( "" hstem3"" ));

          /* record horizontal counter-controlled hints */
          if ( hinter )
            hinter->stem3( hinter->hints, 1, top );
          break;

        case op_vstem:
          FT_TRACE4(( "" vstem"" ));

          /* record vertical hint */
          if ( hinter )
          {
            top[0] += orig_x;
            hinter->stem( hinter->hints, 0, top );
          }
          break;

        case op_vstem3:
          FT_TRACE4(( "" vstem3"" ));

          /* record vertical counter-controlled hints */
          if ( hinter )
          {
            FT_Pos  dx = orig_x;


            top[0] += dx;
            top[2] += dx;
            top[4] += dx;
            hinter->stem3( hinter->hints, 0, top );
          }
          break;

        case op_setcurrentpoint:
          FT_TRACE4(( "" setcurrentpoint"" ));

          /* From the T1 specification, section 6.4:                */
          /*                                                        */
          /*   The setcurrentpoint command is used only in          */
          /*   conjunction with results from OtherSubrs procedures. */

          /* known_othersubr_result_cnt != 0 is already handled     */
          /* above.                                                 */

          /* Note, however, that both Ghostscript and Adobe         */
          /* Distiller handle this situation by silently ignoring   */
          /* the inappropriate `setcurrentpoint' instruction.  So   */
          /* we do the same.                                        */
#if 0

          if ( decoder->flex_state != 1 )
          {
            FT_ERROR(( ""t1_decoder_parse_charstrings:""
                       "" unexpected `setcurrentpoint'\n"" ));
            goto Syntax_Error;
          }
          else
            ...
#endif

          x = top[0];
          y = top[1];
          decoder->flex_state = 0;
          break;

        case op_unknown15:
          FT_TRACE4(( "" opcode_15"" ));
          /* nothing to do except to pop the two arguments */
          break;

        default:
          FT_ERROR(( ""t1_decoder_parse_charstrings:""
                     "" unhandled opcode %d\n"", op ));
          goto Syntax_Error;
        }

        /* XXX Operators usually clear the operand stack;  */
        /*     only div, callsubr, callothersubr, pop, and */
        /*     return are different.                       */
        /*     In practice it doesn't matter (?).          */

        decoder->top = top;

#ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE4(( ""\n"" ));
        bol = TRUE;
#endif

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( ""..end..\n\n"" ));

  Fail:
    return error;

  Syntax_Error:
    return FT_THROW( Syntax_Error );

  Stack_Underflow:
    return FT_THROW( Stack_Underflow );
  }
","The vulnerability in the original code lies in the handling of large integers during the parsing of charstrings, specifically in the section where it checks for values exceeding 32000. If a large integer is encountered without a subsequent `div` operator, the code could erroneously process the input, leading to potential stack overflows or undefined behavior. The fix in the modified code introduces a check within the `callothersubr` case for adding flex vectors, ensuring that the `t1_builder_check_points(builder, 1)` function is called before adding points. This prevents malformed fonts from causing unexpected behavior, thereby enhancing the robustness of the parsing logic.","The vulnerability in the original code arises from inadequate handling of large integers during the parsing process, particularly when values exceed a specified range without the necessary follow-up operation. This oversight can lead to stack overflows or undefined behavior, as the code does not properly validate the conditions under which large integers are processed. The fix in the modified code addresses this issue by implementing additional checks before adding points, ensuring that the parsing logic correctly verifies the integrity of the input data. This enhancement significantly improves the robustness and security of the parsing mechanism.","2

The explanation and repair description lacks sufficient clarity and organization, making it difficult to fully understand the purpose and functionality of the code. While the code appears to be a parser for character strings in fonts, the lack of high-level documentation and clear section separation makes it challenging to follow. The abundance of technical details without proper context reduces its understandability.

The rating of 2 reflects that while some aspects of the code's functionality can be inferred, the overall explanation could benefit from:

1. Better organization and structure
2. More descriptive comments explaining the overall purpose
3. Clear documentation of parameters and return values
4. Better separation between different functional sections
5. Higher-level explanation of what the code aims to accomplish","5

The explanation and repair description appears to be highly relevant to the code snippet context. It shows a complex code function for parsing CharStrings in a font format with detailed explanation of how each part works, including the operators and error handling. The code and explanation are very specific to this context and shows deep understanding of the font parsing implementation details.","3

The explanation is somewhat complete in detailing the buffer overflow vulnerability and its potential consequences, but has a few gaps:

Positives:
1. Shows the problematic code where array bound checking is missing
2. Points out how the vulnerability could be exploited via malformed font files
3. Provides details about the affected components and code paths

Missing or incomplete aspects:
1. Could provide more specific details about root cause analysis
2. Impact assessment is not fully detailed
3. Specifics around exploitation scenarios are limited 
4. Repair strategy and solution validation details are not comprehensively covered
5. Best practices for preventing similar issues are not discussed

The explanation provides good technical details but lacks some broader context and preventative guidance that would make it more complete. Therefore, I rate it a 3 out of 5 for completeness.","4

The explanation and repair description provides specific code detailing how the parsing of Type 1 charstrings works, including handling of operators, operands, error conditions, and stack management. It includes detailed comments explaining the logic and includes explicit error handling. The code shows how to properly validate inputs, manage state, and perform parsing operations safely. While fairly complex, the code provides enough detail to understand and implement the charstring parsing functionality in a secure way.

The actionability score is 4 out of 5 because:

1. The code provides concrete implementation details
2. The error handling paths are clearly defined
3. The comments explain the logic and edge cases
4. The processing flow is well documented

However, it falls short of a perfect 5 because some parts could benefit from additional explanation of the security implications and potential attack vectors that need to be considered during implementation."
3,3,178059,178059,,Remote,Not required,Partial,CVE-2017-7864,https://www.cvedetails.com/cve/CVE-2017-7864/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FreeType 2 before 2017-02-02 has an out-of-bounds write caused by a heap-based buffer overflow related to the tt_size_reset function in truetype/ttobjs.c.,2017-06-30,Overflow,6,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=e6699596af5c5d6f0ae0ea06e19df87dce088df8,e6699596af5c5d6f0ae0ea06e19df87dce088df8,,1,,,"  tt_size_reset( TT_Size  size,
                 FT_Bool  only_height )
  {
    TT_Face           face;
     FT_Size_Metrics*  metrics;
 
 
     face = (TT_Face)size->root.face;
 
    /* nothing to do for CFF2 */
    if ( face->isCFF2 )
      return FT_Err_Ok;

    size->ttmetrics.valid = FALSE;

     metrics = &size->metrics;
 
     /* copy the result from base layer */

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
    }

    size->ttmetrics.valid = TRUE;

    if ( only_height )
      return FT_Err_Ok;

    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }
","  tt_size_reset( TT_Size  size,
                 FT_Bool  only_height )
  {
    TT_Face           face;
     FT_Size_Metrics*  metrics;
 
 
    size->ttmetrics.valid = FALSE;
     face = (TT_Face)size->root.face;
 
     metrics = &size->metrics;
 
     /* copy the result from base layer */

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
    }

    size->ttmetrics.valid = TRUE;

    if ( only_height )
      return FT_Err_Ok;

    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }
",C,"    /* nothing to do for CFF2 */
    if ( face->isCFF2 )
      return FT_Err_Ok;

    size->ttmetrics.valid = FALSE;

","    size->ttmetrics.valid = FALSE;
",dadc50a4679c74ead5a283dd48a4164bc4a27cdd,"@@ -1212,10 +1212,14 @@
     FT_Size_Metrics*  metrics;
 
 
-    size->ttmetrics.valid = FALSE;
-
     face = (TT_Face)size->root.face;
 
+    /* nothing to do for CFF2 */
+    if ( face->isCFF2 )
+      return FT_Err_Ok;
+
+    size->ttmetrics.valid = FALSE;
+
     metrics = &size->metrics;
 
     /* copy the result from base layer */",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/truetype/ttobjs.c?id=e6699596af5c5d6f0ae0ea06e19df87dce088df8,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/truetype/ttobjs.c?id=dadc50a4679c74ead5a283dd48a4164bc4a27cdd,1,"  tt_size_reset( TT_Size  size,
                 FT_Bool  only_height )
  {
    TT_Face           face;
     FT_Size_Metrics*  metrics;
 
 
//flaw_line_below:
    size->ttmetrics.valid = FALSE;
//flaw_line_below:

     face = (TT_Face)size->root.face;
 
//fix_flaw_line_below:
//    /* nothing to do for CFF2 */
//fix_flaw_line_below:
//    if ( face->isCFF2 )
//fix_flaw_line_below:
//      return FT_Err_Ok;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    size->ttmetrics.valid = FALSE;
//fix_flaw_line_below:
//
     metrics = &size->metrics;
 
     /* copy the result from base layer */

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
    }

    size->ttmetrics.valid = TRUE;

    if ( only_height )
      return FT_Err_Ok;

    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }
",178059,"  tt_size_reset( TT_Size  size,
                 FT_Bool  only_height )
  {
    TT_Face           face;
     FT_Size_Metrics*  metrics;
 
 
    size->ttmetrics.valid = FALSE;
     face = (TT_Face)size->root.face;
 
     metrics = &size->metrics;
 
     /* copy the result from base layer */

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
    }

    size->ttmetrics.valid = TRUE;

    if ( only_height )
      return FT_Err_Ok;

    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }
","  tt_size_reset( TT_Size  size,
                 FT_Bool  only_height )
  {
    TT_Face           face;
     FT_Size_Metrics*  metrics;
 
 
     face = (TT_Face)size->root.face;
 
    /* nothing to do for CFF2 */
    if ( face->isCFF2 )
      return FT_Err_Ok;

    size->ttmetrics.valid = FALSE;

     metrics = &size->metrics;
 
     /* copy the result from base layer */

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
    }

    size->ttmetrics.valid = TRUE;

    if ( only_height )
      return FT_Err_Ok;

    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }
","The vulnerability in the original code arises from the lack of a check for the `isCFF2` flag in the `face` structure before processing font metrics. This oversight could lead to incorrect handling of CFF2 fonts, potentially causing undefined behavior or crashes. The fixed code addresses this vulnerability by introducing a conditional check: `if ( face->isCFF2 ) return FT_Err_Ok;`. This ensures that if the font is identified as CFF2, the function exits early without attempting to manipulate the metrics, thereby preventing any erroneous operations on unsupported font types and enhancing overall stability.","The vulnerability in the original code stems from the absence of a check for a specific font type before processing font metrics, which could lead to improper handling and potential crashes when dealing with unsupported fonts. This oversight allows the function to proceed with operations that are not applicable, risking undefined behavior. The fixed code rectifies this issue by introducing a conditional check that ensures the function exits early if the font type is unsupported. This modification prevents erroneous operations and enhances the stability and reliability of the code when handling different font formats.",4,5,3,1
4,4,178060,178060,,Remote,Not required,Partial,CVE-2017-7857,https://www.cvedetails.com/cve/CVE-2017-7857/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FreeType 2 before 2017-03-08 has an out-of-bounds write caused by a heap-based buffer overflow related to the TT_Get_MM_Var function in truetype/ttgxvar.c and the sfnt_init_face function in sfnt/sfobjs.c.,2017-06-30,Overflow,3,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7bbb91fbf47fc0775cc9705673caf0c47a81f94b,7bbb91fbf47fc0775cc9705673caf0c47a81f94b,,1,,,"  sfnt_init_face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_instance_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Memory     memory = face->root.memory;
    FT_Library    library = face->root.driver->root.library;
    SFNT_Service  sfnt;
    FT_Int        face_index;


    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    sfnt = (SFNT_Service)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" );
      if ( !sfnt )
      {
        FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" ));
        return FT_THROW( Missing_Module );
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( !face->mm )
    {
      /* we want the MM interface from the `truetype' module only */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->mm = ft_module_get_service( tt_module,
                                        FT_SERVICE_ID_MULTI_MASTERS,
                                        0 );
    }

    if ( !face->var )
    {
      /* we want the metrics variations interface */
      /* from the `truetype' module only          */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->var = ft_module_get_service( tt_module,
                                         FT_SERVICE_ID_METRICS_VARIATIONS,
                                         0 );
    }
#endif

    FT_TRACE2(( ""SFNT driver\n"" ));

    error = sfnt_open_font( stream, face );
    if ( error )
      return error;

    /* Stream may have changed in sfnt_open_font. */
    stream = face->root.stream;

    FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index ));

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* value -(N+1) requests information on index N */
    if ( face_instance_index < 0 )
      face_index--;

    if ( face_index >= face->ttc_header.count )
    {
      if ( face_instance_index >= 0 )
        return FT_THROW( Invalid_Argument );
      else
        face_index = 0;
    }

    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )
      return error;

    /* check whether we have a valid TrueType file */
    error = sfnt->load_font_dir( face, stream );
    if ( error )
      return error;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    {
      FT_ULong  fvar_len;

      FT_ULong  version;
      FT_ULong  offset;

      FT_UShort  num_axes;
      FT_UShort  axis_size;
      FT_UShort  num_instances;
      FT_UShort  instance_size;

      FT_Int  instance_index;

      FT_Byte*  default_values  = NULL;
      FT_Byte*  instance_values = NULL;


      face->is_default_instance = 1;

      instance_index = FT_ABS( face_instance_index ) >> 16;

      /* test whether current face is a GX font with named instances */
      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||
           fvar_len < 20                                          ||
           FT_READ_ULONG( version )                               ||
           FT_READ_USHORT( offset )                               ||
           FT_STREAM_SKIP( 2 ) /* reserved */                     ||
           FT_READ_USHORT( num_axes )                             ||
           FT_READ_USHORT( axis_size )                            ||
           FT_READ_USHORT( num_instances )                        ||
           FT_READ_USHORT( instance_size )                        )
      {
        version       = 0;
        offset        = 0;
        num_axes      = 0;
        axis_size     = 0;
        num_instances = 0;
        instance_size = 0;
      }

      /* check that the data is bound by the table length */
      if ( version != 0x00010000UL                    ||
           axis_size != 20                            ||
           num_axes == 0                              ||
           /* `num_axes' limit implied by 16-bit `instance_size' */
           num_axes > 0x3FFE                          ||
           !( instance_size == 4 + 4 * num_axes ||
              instance_size == 6 + 4 * num_axes )     ||
           /* `num_instances' limit implied by limited range of name IDs */
           num_instances > 0x7EFF                     ||
           offset                          +
             axis_size * num_axes          +
             instance_size * num_instances > fvar_len )
        num_instances = 0;
      else
        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;

      /*
       *  As documented in the OpenType specification, an entry for the
       *  default instance may be omitted in the named instance table.  In
       *  particular this means that even if there is no named instance
       *  table in the font we actually do have a named instance, namely the
       *  default instance.
       *
       *  For consistency, we always want the default instance in our list
       *  of named instances.  If it is missing, we try to synthesize it
       *  later on.  Here, we have to adjust `num_instances' accordingly.
       */

      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||
              FT_ALLOC( instance_values, num_axes * 2 ) ) )
      {
        /* the current stream position is 16 bytes after the table start */
        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
        FT_ULong  default_value_offset, instance_offset;

        FT_Byte*  p;
        FT_UInt   i;


        default_value_offset = array_start + 8;
        p                    = default_values;

        for ( i = 0; i < num_axes; i++ )
        {
          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );

          default_value_offset += axis_size;
          p                    += 2;
        }

        instance_offset = array_start + axis_size * num_axes + 4;

        for ( i = 0; i < num_instances; i++ )
        {
          (void)FT_STREAM_READ_AT( instance_offset,
                                   instance_values,
                                   num_axes * 2 );

          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )
            break;

          instance_offset += instance_size;
        }

        if ( i == num_instances )
        {
          /* no default instance in named instance table; */
          /* we thus have to synthesize it                */
          num_instances++;
        }
      }

       FT_FREE( default_values );
       FT_FREE( instance_values );
 
      /* we don't support Multiple Master CFFs yet; */
      /* note that `glyf' or `CFF2' have precedence */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;
      if ( instance_index > num_instances )
      {
        if ( face_instance_index >= 0 )
          return FT_THROW( Invalid_Argument );
        else
          num_instances = 0;
      }

      face->root.style_flags = (FT_Long)num_instances << 16;
    }
#endif

    face->root.num_faces  = face->ttc_header.count;
    face->root.face_index = face_instance_index;

    return error;
  }
","  sfnt_init_face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_instance_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Memory     memory = face->root.memory;
    FT_Library    library = face->root.driver->root.library;
    SFNT_Service  sfnt;
    FT_Int        face_index;


    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    sfnt = (SFNT_Service)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" );
      if ( !sfnt )
      {
        FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" ));
        return FT_THROW( Missing_Module );
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( !face->mm )
    {
      /* we want the MM interface from the `truetype' module only */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->mm = ft_module_get_service( tt_module,
                                        FT_SERVICE_ID_MULTI_MASTERS,
                                        0 );
    }

    if ( !face->var )
    {
      /* we want the metrics variations interface */
      /* from the `truetype' module only          */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->var = ft_module_get_service( tt_module,
                                         FT_SERVICE_ID_METRICS_VARIATIONS,
                                         0 );
    }
#endif

    FT_TRACE2(( ""SFNT driver\n"" ));

    error = sfnt_open_font( stream, face );
    if ( error )
      return error;

    /* Stream may have changed in sfnt_open_font. */
    stream = face->root.stream;

    FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index ));

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* value -(N+1) requests information on index N */
    if ( face_instance_index < 0 )
      face_index--;

    if ( face_index >= face->ttc_header.count )
    {
      if ( face_instance_index >= 0 )
        return FT_THROW( Invalid_Argument );
      else
        face_index = 0;
    }

    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )
      return error;

    /* check whether we have a valid TrueType file */
    error = sfnt->load_font_dir( face, stream );
    if ( error )
      return error;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    {
      FT_ULong  fvar_len;

      FT_ULong  version;
      FT_ULong  offset;

      FT_UShort  num_axes;
      FT_UShort  axis_size;
      FT_UShort  num_instances;
      FT_UShort  instance_size;

      FT_Int  instance_index;

      FT_Byte*  default_values  = NULL;
      FT_Byte*  instance_values = NULL;


      face->is_default_instance = 1;

      instance_index = FT_ABS( face_instance_index ) >> 16;

      /* test whether current face is a GX font with named instances */
      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||
           fvar_len < 20                                          ||
           FT_READ_ULONG( version )                               ||
           FT_READ_USHORT( offset )                               ||
           FT_STREAM_SKIP( 2 ) /* reserved */                     ||
           FT_READ_USHORT( num_axes )                             ||
           FT_READ_USHORT( axis_size )                            ||
           FT_READ_USHORT( num_instances )                        ||
           FT_READ_USHORT( instance_size )                        )
      {
        version       = 0;
        offset        = 0;
        num_axes      = 0;
        axis_size     = 0;
        num_instances = 0;
        instance_size = 0;
      }

      /* check that the data is bound by the table length */
      if ( version != 0x00010000UL                    ||
           axis_size != 20                            ||
           num_axes == 0                              ||
           /* `num_axes' limit implied by 16-bit `instance_size' */
           num_axes > 0x3FFE                          ||
           !( instance_size == 4 + 4 * num_axes ||
              instance_size == 6 + 4 * num_axes )     ||
           /* `num_instances' limit implied by limited range of name IDs */
           num_instances > 0x7EFF                     ||
           offset                          +
             axis_size * num_axes          +
             instance_size * num_instances > fvar_len )
        num_instances = 0;
      else
        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;

      /*
       *  As documented in the OpenType specification, an entry for the
       *  default instance may be omitted in the named instance table.  In
       *  particular this means that even if there is no named instance
       *  table in the font we actually do have a named instance, namely the
       *  default instance.
       *
       *  For consistency, we always want the default instance in our list
       *  of named instances.  If it is missing, we try to synthesize it
       *  later on.  Here, we have to adjust `num_instances' accordingly.
       */

      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||
              FT_ALLOC( instance_values, num_axes * 2 ) ) )
      {
        /* the current stream position is 16 bytes after the table start */
        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
        FT_ULong  default_value_offset, instance_offset;

        FT_Byte*  p;
        FT_UInt   i;


        default_value_offset = array_start + 8;
        p                    = default_values;

        for ( i = 0; i < num_axes; i++ )
        {
          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );

          default_value_offset += axis_size;
          p                    += 2;
        }

        instance_offset = array_start + axis_size * num_axes + 4;

        for ( i = 0; i < num_instances; i++ )
        {
          (void)FT_STREAM_READ_AT( instance_offset,
                                   instance_values,
                                   num_axes * 2 );

          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )
            break;

          instance_offset += instance_size;
        }

        if ( i == num_instances )
        {
          /* no default instance in named instance table; */
          /* we thus have to synthesize it                */
          num_instances++;
        }
      }

       FT_FREE( default_values );
       FT_FREE( instance_values );
 
      /* we don't support Multiple Master CFFs yet */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;
      if ( instance_index > num_instances )
      {
        if ( face_instance_index >= 0 )
          return FT_THROW( Invalid_Argument );
        else
          num_instances = 0;
      }

      face->root.style_flags = (FT_Long)num_instances << 16;
    }
#endif

    face->root.num_faces  = face->ttc_header.count;
    face->root.face_index = face_instance_index;

    return error;
  }
",C,"      /* we don't support Multiple Master CFFs yet; */
      /* note that `glyf' or `CFF2' have precedence */
           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&
","      /* we don't support Multiple Master CFFs yet */
",7d7aae1de3e2aea5bad2e92b0f9d074bd5130ecd,"@@ -1058,8 +1058,10 @@
       FT_FREE( default_values );
       FT_FREE( instance_values );
 
-      /* we don't support Multiple Master CFFs yet */
+      /* we don't support Multiple Master CFFs yet; */
+      /* note that `glyf' or `CFF2' have precedence */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
+           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/sfnt/sfobjs.c?id=7bbb91fbf47fc0775cc9705673caf0c47a81f94b,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/sfnt/sfobjs.c?id=7d7aae1de3e2aea5bad2e92b0f9d074bd5130ecd,1,"  sfnt_init_face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_instance_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Memory     memory = face->root.memory;
    FT_Library    library = face->root.driver->root.library;
    SFNT_Service  sfnt;
    FT_Int        face_index;


    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    sfnt = (SFNT_Service)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" );
      if ( !sfnt )
      {
        FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" ));
        return FT_THROW( Missing_Module );
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( !face->mm )
    {
      /* we want the MM interface from the `truetype' module only */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->mm = ft_module_get_service( tt_module,
                                        FT_SERVICE_ID_MULTI_MASTERS,
                                        0 );
    }

    if ( !face->var )
    {
      /* we want the metrics variations interface */
      /* from the `truetype' module only          */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->var = ft_module_get_service( tt_module,
                                         FT_SERVICE_ID_METRICS_VARIATIONS,
                                         0 );
    }
#endif

    FT_TRACE2(( ""SFNT driver\n"" ));

    error = sfnt_open_font( stream, face );
    if ( error )
      return error;

    /* Stream may have changed in sfnt_open_font. */
    stream = face->root.stream;

    FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index ));

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* value -(N+1) requests information on index N */
    if ( face_instance_index < 0 )
      face_index--;

    if ( face_index >= face->ttc_header.count )
    {
      if ( face_instance_index >= 0 )
        return FT_THROW( Invalid_Argument );
      else
        face_index = 0;
    }

    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )
      return error;

    /* check whether we have a valid TrueType file */
    error = sfnt->load_font_dir( face, stream );
    if ( error )
      return error;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    {
      FT_ULong  fvar_len;

      FT_ULong  version;
      FT_ULong  offset;

      FT_UShort  num_axes;
      FT_UShort  axis_size;
      FT_UShort  num_instances;
      FT_UShort  instance_size;

      FT_Int  instance_index;

      FT_Byte*  default_values  = NULL;
      FT_Byte*  instance_values = NULL;


      face->is_default_instance = 1;

      instance_index = FT_ABS( face_instance_index ) >> 16;

      /* test whether current face is a GX font with named instances */
      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||
           fvar_len < 20                                          ||
           FT_READ_ULONG( version )                               ||
           FT_READ_USHORT( offset )                               ||
           FT_STREAM_SKIP( 2 ) /* reserved */                     ||
           FT_READ_USHORT( num_axes )                             ||
           FT_READ_USHORT( axis_size )                            ||
           FT_READ_USHORT( num_instances )                        ||
           FT_READ_USHORT( instance_size )                        )
      {
        version       = 0;
        offset        = 0;
        num_axes      = 0;
        axis_size     = 0;
        num_instances = 0;
        instance_size = 0;
      }

      /* check that the data is bound by the table length */
      if ( version != 0x00010000UL                    ||
           axis_size != 20                            ||
           num_axes == 0                              ||
           /* `num_axes' limit implied by 16-bit `instance_size' */
           num_axes > 0x3FFE                          ||
           !( instance_size == 4 + 4 * num_axes ||
              instance_size == 6 + 4 * num_axes )     ||
           /* `num_instances' limit implied by limited range of name IDs */
           num_instances > 0x7EFF                     ||
           offset                          +
             axis_size * num_axes          +
             instance_size * num_instances > fvar_len )
        num_instances = 0;
      else
        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;

      /*
       *  As documented in the OpenType specification, an entry for the
       *  default instance may be omitted in the named instance table.  In
       *  particular this means that even if there is no named instance
       *  table in the font we actually do have a named instance, namely the
       *  default instance.
       *
       *  For consistency, we always want the default instance in our list
       *  of named instances.  If it is missing, we try to synthesize it
       *  later on.  Here, we have to adjust `num_instances' accordingly.
       */

      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||
              FT_ALLOC( instance_values, num_axes * 2 ) ) )
      {
        /* the current stream position is 16 bytes after the table start */
        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
        FT_ULong  default_value_offset, instance_offset;

        FT_Byte*  p;
        FT_UInt   i;


        default_value_offset = array_start + 8;
        p                    = default_values;

        for ( i = 0; i < num_axes; i++ )
        {
          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );

          default_value_offset += axis_size;
          p                    += 2;
        }

        instance_offset = array_start + axis_size * num_axes + 4;

        for ( i = 0; i < num_instances; i++ )
        {
          (void)FT_STREAM_READ_AT( instance_offset,
                                   instance_values,
                                   num_axes * 2 );

          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )
            break;

          instance_offset += instance_size;
        }

        if ( i == num_instances )
        {
          /* no default instance in named instance table; */
          /* we thus have to synthesize it                */
          num_instances++;
        }
      }

       FT_FREE( default_values );
       FT_FREE( instance_values );
 
//flaw_line_below:
      /* we don't support Multiple Master CFFs yet */
//fix_flaw_line_below:
//      /* we don't support Multiple Master CFFs yet; */
//fix_flaw_line_below:
//      /* note that `glyf' or `CFF2' have precedence */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
//fix_flaw_line_below:
//           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;
      if ( instance_index > num_instances )
      {
        if ( face_instance_index >= 0 )
          return FT_THROW( Invalid_Argument );
        else
          num_instances = 0;
      }

      face->root.style_flags = (FT_Long)num_instances << 16;
    }
#endif

    face->root.num_faces  = face->ttc_header.count;
    face->root.face_index = face_instance_index;

    return error;
  }
",178060,"  sfnt_init_face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_instance_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Memory     memory = face->root.memory;
    FT_Library    library = face->root.driver->root.library;
    SFNT_Service  sfnt;
    FT_Int        face_index;


    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    sfnt = (SFNT_Service)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" );
      if ( !sfnt )
      {
        FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" ));
        return FT_THROW( Missing_Module );
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( !face->mm )
    {
      /* we want the MM interface from the `truetype' module only */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->mm = ft_module_get_service( tt_module,
                                        FT_SERVICE_ID_MULTI_MASTERS,
                                        0 );
    }

    if ( !face->var )
    {
      /* we want the metrics variations interface */
      /* from the `truetype' module only          */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->var = ft_module_get_service( tt_module,
                                         FT_SERVICE_ID_METRICS_VARIATIONS,
                                         0 );
    }
#endif

    FT_TRACE2(( ""SFNT driver\n"" ));

    error = sfnt_open_font( stream, face );
    if ( error )
      return error;

    /* Stream may have changed in sfnt_open_font. */
    stream = face->root.stream;

    FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index ));

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* value -(N+1) requests information on index N */
    if ( face_instance_index < 0 )
      face_index--;

    if ( face_index >= face->ttc_header.count )
    {
      if ( face_instance_index >= 0 )
        return FT_THROW( Invalid_Argument );
      else
        face_index = 0;
    }

    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )
      return error;

    /* check whether we have a valid TrueType file */
    error = sfnt->load_font_dir( face, stream );
    if ( error )
      return error;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    {
      FT_ULong  fvar_len;

      FT_ULong  version;
      FT_ULong  offset;

      FT_UShort  num_axes;
      FT_UShort  axis_size;
      FT_UShort  num_instances;
      FT_UShort  instance_size;

      FT_Int  instance_index;

      FT_Byte*  default_values  = NULL;
      FT_Byte*  instance_values = NULL;


      face->is_default_instance = 1;

      instance_index = FT_ABS( face_instance_index ) >> 16;

      /* test whether current face is a GX font with named instances */
      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||
           fvar_len < 20                                          ||
           FT_READ_ULONG( version )                               ||
           FT_READ_USHORT( offset )                               ||
           FT_STREAM_SKIP( 2 ) /* reserved */                     ||
           FT_READ_USHORT( num_axes )                             ||
           FT_READ_USHORT( axis_size )                            ||
           FT_READ_USHORT( num_instances )                        ||
           FT_READ_USHORT( instance_size )                        )
      {
        version       = 0;
        offset        = 0;
        num_axes      = 0;
        axis_size     = 0;
        num_instances = 0;
        instance_size = 0;
      }

      /* check that the data is bound by the table length */
      if ( version != 0x00010000UL                    ||
           axis_size != 20                            ||
           num_axes == 0                              ||
           /* `num_axes' limit implied by 16-bit `instance_size' */
           num_axes > 0x3FFE                          ||
           !( instance_size == 4 + 4 * num_axes ||
              instance_size == 6 + 4 * num_axes )     ||
           /* `num_instances' limit implied by limited range of name IDs */
           num_instances > 0x7EFF                     ||
           offset                          +
             axis_size * num_axes          +
             instance_size * num_instances > fvar_len )
        num_instances = 0;
      else
        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;

      /*
       *  As documented in the OpenType specification, an entry for the
       *  default instance may be omitted in the named instance table.  In
       *  particular this means that even if there is no named instance
       *  table in the font we actually do have a named instance, namely the
       *  default instance.
       *
       *  For consistency, we always want the default instance in our list
       *  of named instances.  If it is missing, we try to synthesize it
       *  later on.  Here, we have to adjust `num_instances' accordingly.
       */

      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||
              FT_ALLOC( instance_values, num_axes * 2 ) ) )
      {
        /* the current stream position is 16 bytes after the table start */
        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
        FT_ULong  default_value_offset, instance_offset;

        FT_Byte*  p;
        FT_UInt   i;


        default_value_offset = array_start + 8;
        p                    = default_values;

        for ( i = 0; i < num_axes; i++ )
        {
          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );

          default_value_offset += axis_size;
          p                    += 2;
        }

        instance_offset = array_start + axis_size * num_axes + 4;

        for ( i = 0; i < num_instances; i++ )
        {
          (void)FT_STREAM_READ_AT( instance_offset,
                                   instance_values,
                                   num_axes * 2 );

          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )
            break;

          instance_offset += instance_size;
        }

        if ( i == num_instances )
        {
          /* no default instance in named instance table; */
          /* we thus have to synthesize it                */
          num_instances++;
        }
      }

       FT_FREE( default_values );
       FT_FREE( instance_values );
 
      /* we don't support Multiple Master CFFs yet */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;
      if ( instance_index > num_instances )
      {
        if ( face_instance_index >= 0 )
          return FT_THROW( Invalid_Argument );
        else
          num_instances = 0;
      }

      face->root.style_flags = (FT_Long)num_instances << 16;
    }
#endif

    face->root.num_faces  = face->ttc_header.count;
    face->root.face_index = face_instance_index;

    return error;
  }
","  sfnt_init_face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_instance_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Memory     memory = face->root.memory;
    FT_Library    library = face->root.driver->root.library;
    SFNT_Service  sfnt;
    FT_Int        face_index;


    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    sfnt = (SFNT_Service)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" );
      if ( !sfnt )
      {
        FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" ));
        return FT_THROW( Missing_Module );
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( !face->mm )
    {
      /* we want the MM interface from the `truetype' module only */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->mm = ft_module_get_service( tt_module,
                                        FT_SERVICE_ID_MULTI_MASTERS,
                                        0 );
    }

    if ( !face->var )
    {
      /* we want the metrics variations interface */
      /* from the `truetype' module only          */
      FT_Module  tt_module = FT_Get_Module( library, ""truetype"" );


      face->var = ft_module_get_service( tt_module,
                                         FT_SERVICE_ID_METRICS_VARIATIONS,
                                         0 );
    }
#endif

    FT_TRACE2(( ""SFNT driver\n"" ));

    error = sfnt_open_font( stream, face );
    if ( error )
      return error;

    /* Stream may have changed in sfnt_open_font. */
    stream = face->root.stream;

    FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index ));

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* value -(N+1) requests information on index N */
    if ( face_instance_index < 0 )
      face_index--;

    if ( face_index >= face->ttc_header.count )
    {
      if ( face_instance_index >= 0 )
        return FT_THROW( Invalid_Argument );
      else
        face_index = 0;
    }

    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )
      return error;

    /* check whether we have a valid TrueType file */
    error = sfnt->load_font_dir( face, stream );
    if ( error )
      return error;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    {
      FT_ULong  fvar_len;

      FT_ULong  version;
      FT_ULong  offset;

      FT_UShort  num_axes;
      FT_UShort  axis_size;
      FT_UShort  num_instances;
      FT_UShort  instance_size;

      FT_Int  instance_index;

      FT_Byte*  default_values  = NULL;
      FT_Byte*  instance_values = NULL;


      face->is_default_instance = 1;

      instance_index = FT_ABS( face_instance_index ) >> 16;

      /* test whether current face is a GX font with named instances */
      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||
           fvar_len < 20                                          ||
           FT_READ_ULONG( version )                               ||
           FT_READ_USHORT( offset )                               ||
           FT_STREAM_SKIP( 2 ) /* reserved */                     ||
           FT_READ_USHORT( num_axes )                             ||
           FT_READ_USHORT( axis_size )                            ||
           FT_READ_USHORT( num_instances )                        ||
           FT_READ_USHORT( instance_size )                        )
      {
        version       = 0;
        offset        = 0;
        num_axes      = 0;
        axis_size     = 0;
        num_instances = 0;
        instance_size = 0;
      }

      /* check that the data is bound by the table length */
      if ( version != 0x00010000UL                    ||
           axis_size != 20                            ||
           num_axes == 0                              ||
           /* `num_axes' limit implied by 16-bit `instance_size' */
           num_axes > 0x3FFE                          ||
           !( instance_size == 4 + 4 * num_axes ||
              instance_size == 6 + 4 * num_axes )     ||
           /* `num_instances' limit implied by limited range of name IDs */
           num_instances > 0x7EFF                     ||
           offset                          +
             axis_size * num_axes          +
             instance_size * num_instances > fvar_len )
        num_instances = 0;
      else
        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;

      /*
       *  As documented in the OpenType specification, an entry for the
       *  default instance may be omitted in the named instance table.  In
       *  particular this means that even if there is no named instance
       *  table in the font we actually do have a named instance, namely the
       *  default instance.
       *
       *  For consistency, we always want the default instance in our list
       *  of named instances.  If it is missing, we try to synthesize it
       *  later on.  Here, we have to adjust `num_instances' accordingly.
       */

      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||
              FT_ALLOC( instance_values, num_axes * 2 ) ) )
      {
        /* the current stream position is 16 bytes after the table start */
        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
        FT_ULong  default_value_offset, instance_offset;

        FT_Byte*  p;
        FT_UInt   i;


        default_value_offset = array_start + 8;
        p                    = default_values;

        for ( i = 0; i < num_axes; i++ )
        {
          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );

          default_value_offset += axis_size;
          p                    += 2;
        }

        instance_offset = array_start + axis_size * num_axes + 4;

        for ( i = 0; i < num_instances; i++ )
        {
          (void)FT_STREAM_READ_AT( instance_offset,
                                   instance_values,
                                   num_axes * 2 );

          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )
            break;

          instance_offset += instance_size;
        }

        if ( i == num_instances )
        {
          /* no default instance in named instance table; */
          /* we thus have to synthesize it                */
          num_instances++;
        }
      }

       FT_FREE( default_values );
       FT_FREE( instance_values );
 
      /* we don't support Multiple Master CFFs yet; */
      /* note that `glyf' or `CFF2' have precedence */
       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&
           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&
            !face->goto_table( face, TTAG_CFF, stream, 0 ) )
         num_instances = 0;
      if ( instance_index > num_instances )
      {
        if ( face_instance_index >= 0 )
          return FT_THROW( Invalid_Argument );
        else
          num_instances = 0;
      }

      face->root.style_flags = (FT_Long)num_instances << 16;
    }
#endif

    face->root.num_faces  = face->ttc_header.count;
    face->root.face_index = face_instance_index;

    return error;
  }
","The vulnerability in the original code lies in the handling of font instances, particularly in the section where it checks for the presence of a valid TrueType file. The code does not adequately validate the `num_instances` variable, which could lead to out-of-bounds access when accessing `face->ttc_header.offsets[face_index]`. This could result in a buffer overflow or memory corruption. The fix addresses this by adding a check for the `TTAG_CFF2` table in the condition that determines if `num_instances` should be set to zero, thereby ensuring that the code does not attempt to access invalid memory locations.","The vulnerability in the original code stems from inadequate validation of font instance data, particularly when determining the number of instances and their offsets. This oversight could lead to out-of-bounds memory access, potentially causing buffer overflows or memory corruption. The fix enhances the validation process by introducing additional checks to ensure that the number of instances is correctly assessed and that any access to memory is within safe bounds. This adjustment prevents the code from attempting to read or write to invalid memory locations, thereby improving overall stability and security.",2,5,4,4
5,5,178095,178095,,Remote,Not required,Partial,CVE-2016-7943,https://www.cvedetails.com/cve/CVE-2016-7943/,CWE-787,Low,Partial,Partial,,2016-12-13,7.5,"The XListFonts function in X.org libX11 before 1.6.4 might allow remote X servers to gain privileges via vectors involving length fields, which trigger out-of-bounds write operations.",2018-09-13,+Priv,17,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=8c29f1607a31dac0911e45a0dd3d74173822b3c9,8c29f1607a31dac0911e45a0dd3d74173822b3c9,,6,,,"XListFonts(
register Display *dpy,
_Xconst char *pattern,  /* null-terminated */
int maxNames,
int *actualCount)	/* RETURN */
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    /* use _XSend instead of Data, since following _XReply will flush buffer */

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	/*
	 * unpack into null terminated strings.
	 */
	chend = ch + (rlen + 1);
	length = *(unsigned char *)ch;
	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
		if (ch <= chend) {
		    length = *(unsigned char *)ch;
		    *ch = '\0';  /* and replace with null-termination */
		    count++;
		} else {
                    Xfree(flist);
                    flist = NULL;
                    count = 0;
                    break;
		}
	    } else {
                Xfree(flist);
                flist = NULL;
                count = 0;
                break;
            }
 	}
     }
     *actualCount = count;
			for (names = list+1; *names; names++)
				Xfree (*names);
		}
","XListFonts(
register Display *dpy,
_Xconst char *pattern,  /* null-terminated */
int maxNames,
int *actualCount)	/* RETURN */
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    /* use _XSend instead of Data, since following _XReply will flush buffer */

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
	if (rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	/*
	 * unpack into null terminated strings.
	 */
	chend = ch + (rlen + 1);
	length = *(unsigned char *)ch;
	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
		length = *(unsigned char *)ch;
		*ch = '\0';  /* and replace with null-termination */
		count++;
	    } else
		flist[i] = NULL;
 	}
     }
     *actualCount = count;
			for (names = list+1; *names; names++)
				Xfree (*names);
		}
",C,"	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		if (ch <= chend) {
		    length = *(unsigned char *)ch;
		    *ch = '\0';  /* and replace with null-termination */
		    count++;
		} else {
                    Xfree(flist);
                    flist = NULL;
                    count = 0;
                    break;
		}
	    } else {
                Xfree(flist);
                flist = NULL;
                count = 0;
                break;
            }
","	if (rep.length < (INT_MAX >> 2)) {
		length = *(unsigned char *)ch;
		*ch = '\0';  /* and replace with null-termination */
		count++;
	    } else
		flist[i] = NULL;
",78851f6a03130e3c720b60c3cbf96f8eb216d741,"@@ -66,7 +66,7 @@ int *actualCount)	/* RETURN */
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
-	if (rep.length < (INT_MAX >> 2)) {
+	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
@@ -93,11 +93,22 @@ int *actualCount)	/* RETURN */
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
-		length = *(unsigned char *)ch;
-		*ch = '\0';  /* and replace with null-termination */
-		count++;
-	    } else
-		flist[i] = NULL;
+		if (ch <= chend) {
+		    length = *(unsigned char *)ch;
+		    *ch = '\0';  /* and replace with null-termination */
+		    count++;
+		} else {
+                    Xfree(flist);
+                    flist = NULL;
+                    count = 0;
+                    break;
+		}
+	    } else {
+                Xfree(flist);
+                flist = NULL;
+                count = 0;
+                break;
+            }
 	}
     }
     *actualCount = count;",libx11,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/FontNames.c?id=8c29f1607a31dac0911e45a0dd3d74173822b3c9,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/FontNames.c?id=78851f6a03130e3c720b60c3cbf96f8eb216d741,1,"XListFonts(
register Display *dpy,
_Xconst char *pattern,  /* null-terminated */
int maxNames,
int *actualCount)	/* RETURN */
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    /* use _XSend instead of Data, since following _XReply will flush buffer */

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
//flaw_line_below:
	if (rep.length < (INT_MAX >> 2)) {
//fix_flaw_line_below:
//	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	/*
	 * unpack into null terminated strings.
	 */
	chend = ch + (rlen + 1);
	length = *(unsigned char *)ch;
	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
//flaw_line_below:
		length = *(unsigned char *)ch;
//flaw_line_below:
		*ch = '\0';  /* and replace with null-termination */
//flaw_line_below:
		count++;
//flaw_line_below:
	    } else
//flaw_line_below:
		flist[i] = NULL;
//fix_flaw_line_below:
//		if (ch <= chend) {
//fix_flaw_line_below:
//		    length = *(unsigned char *)ch;
//fix_flaw_line_below:
//		    *ch = '\0';  /* and replace with null-termination */
//fix_flaw_line_below:
//		    count++;
//fix_flaw_line_below:
//		} else {
//fix_flaw_line_below:
//                    Xfree(flist);
//fix_flaw_line_below:
//                    flist = NULL;
//fix_flaw_line_below:
//                    count = 0;
//fix_flaw_line_below:
//                    break;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	    } else {
//fix_flaw_line_below:
//                Xfree(flist);
//fix_flaw_line_below:
//                flist = NULL;
//fix_flaw_line_below:
//                count = 0;
//fix_flaw_line_below:
//                break;
//fix_flaw_line_below:
//            }
 	}
     }
     *actualCount = count;
			for (names = list+1; *names; names++)
				Xfree (*names);
		}
",178095,"XListFonts(
register Display *dpy,
_Xconst char *pattern,  /* null-terminated */
int maxNames,
int *actualCount)	/* RETURN */
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    /* use _XSend instead of Data, since following _XReply will flush buffer */

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
	if (rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	/*
	 * unpack into null terminated strings.
	 */
	chend = ch + (rlen + 1);
	length = *(unsigned char *)ch;
	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
		length = *(unsigned char *)ch;
		*ch = '\0';  /* and replace with null-termination */
		count++;
	    } else
		flist[i] = NULL;
 	}
     }
     *actualCount = count;
			for (names = list+1; *names; names++)
				Xfree (*names);
		}
","XListFonts(
register Display *dpy,
_Xconst char *pattern,  /* null-terminated */
int maxNames,
int *actualCount)	/* RETURN */
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    /* use _XSend instead of Data, since following _XReply will flush buffer */

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }
 
     if (rep.nFonts) {
 	flist = Xmalloc (rep.nFonts * sizeof(char *));
	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
 	    rlen = rep.length << 2;
 	    ch = Xmalloc(rlen + 1);
 	    /* +1 to leave room for last null-terminator */
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	/*
	 * unpack into null terminated strings.
	 */
	chend = ch + (rlen + 1);
	length = *(unsigned char *)ch;
	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  /* skip over length */
 		ch += length + 1;  /* find next length ... */
		if (ch <= chend) {
		    length = *(unsigned char *)ch;
		    *ch = '\0';  /* and replace with null-termination */
		    count++;
		} else {
                    Xfree(flist);
                    flist = NULL;
                    count = 0;
                    break;
		}
	    } else {
                Xfree(flist);
                flist = NULL;
                count = 0;
                break;
            }
 	}
     }
     *actualCount = count;
			for (names = list+1; *names; names++)
				Xfree (*names);
		}
","The vulnerability in the original code lies in the handling of the `ch` pointer and the unpacking of font names, which could lead to a buffer overflow if the data read exceeds the allocated memory. Specifically, the code did not adequately check if `ch + length` was within bounds of `chend`, potentially allowing for out-of-bounds access. The fix in the modified code introduces additional checks to ensure that `ch + length` does not exceed `chend` before accessing it. If the condition fails, it safely frees the allocated `flist` and sets it to `NULL`, preventing potential memory corruption or crashes.","The vulnerability in the original code stems from inadequate boundary checks when unpacking data, which could lead to buffer overflows. Specifically, the code did not verify whether the calculated position for reading data exceeded the allocated memory, risking out-of-bounds access and potential memory corruption. The revised code addresses this issue by implementing additional checks to ensure that the read position remains within the allocated memory limits. If the checks fail, the code safely frees any allocated resources and resets pointers, thereby preventing crashes and enhancing overall stability and security.",2,5,4,4
6,6,178100,178100,,Local,Not required,Partial,CVE-2016-7423,https://www.cvedetails.com/cve/CVE-2016-7423/,CWE-787,Low,,,,2016-10-10,2.1,"The mptsas_process_scsi_io_request function in QEMU (aka Quick Emulator), when built with LSI SAS1068 Host Bus emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors involving MPTSASRequest objects.",2017-06-30,DoS,1,https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5,670e56d3ed2918b3861d9216f2c0540d9e9ae0d5,,1,,,"static int mptsas_process_scsi_io_request(MPTSASState *s,
                                          MPIMsgSCSIIORequest *scsi_io,
                                          hwaddr addr)
{
    MPTSASRequest *req;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;

    mptsas_fix_scsi_io_endianness(scsi_io);

    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN[1], scsi_io->DataLength);

    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
                                     scsi_io->LUN, &sdev);
    if (status) {
         goto bad;
     }
 
    req = g_new0(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;

    status = mptsas_build_sgl(s, req, addr);
    if (status) {
        goto free_bad;
    }

    if (req->qsg.size < scsi_io->DataLength) {
        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
                                  req->qsg.size);
        status = MPI_IOCSTATUS_INVALID_SGL;
        goto free_bad;
    }

    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
                            scsi_io->LUN[1], scsi_io->CDB, req);

    if (req->sreq->cmd.xfer > scsi_io->DataLength) {
        goto overrun;
    }
    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
    case MPI_SCSIIO_CONTROL_NODATATRANSFER:
        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_WRITE:
        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_READ:
        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
            goto overrun;
        }
        break;
    }

    if (scsi_req_enqueue(req->sreq)) {
        scsi_req_continue(req->sreq);
    }
    return 0;

overrun:
    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
                               scsi_io->DataLength);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
    mptsas_free_request(req);
bad:
    memset(&reply, 0, sizeof(reply));
    reply.TargetID          = scsi_io->TargetID;
    reply.Bus               = scsi_io->Bus;
    reply.MsgLength         = sizeof(reply) / 4;
    reply.Function          = scsi_io->Function;
    reply.CDBLength         = scsi_io->CDBLength;
    reply.SenseBufferLength = scsi_io->SenseBufferLength;
    reply.MsgContext        = scsi_io->MsgContext;
    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
    reply.IOCStatus         = status;

    mptsas_fix_scsi_io_reply_endianness(&reply);
    mptsas_reply(s, (MPIDefaultReply *)&reply);

    return 0;
}
","static int mptsas_process_scsi_io_request(MPTSASState *s,
                                          MPIMsgSCSIIORequest *scsi_io,
                                          hwaddr addr)
{
    MPTSASRequest *req;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;

    mptsas_fix_scsi_io_endianness(scsi_io);

    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN[1], scsi_io->DataLength);

    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
                                     scsi_io->LUN, &sdev);
    if (status) {
         goto bad;
     }
 
    req = g_new(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;

    status = mptsas_build_sgl(s, req, addr);
    if (status) {
        goto free_bad;
    }

    if (req->qsg.size < scsi_io->DataLength) {
        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
                                  req->qsg.size);
        status = MPI_IOCSTATUS_INVALID_SGL;
        goto free_bad;
    }

    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
                            scsi_io->LUN[1], scsi_io->CDB, req);

    if (req->sreq->cmd.xfer > scsi_io->DataLength) {
        goto overrun;
    }
    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
    case MPI_SCSIIO_CONTROL_NODATATRANSFER:
        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_WRITE:
        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_READ:
        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
            goto overrun;
        }
        break;
    }

    if (scsi_req_enqueue(req->sreq)) {
        scsi_req_continue(req->sreq);
    }
    return 0;

overrun:
    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
                               scsi_io->DataLength);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
    mptsas_free_request(req);
bad:
    memset(&reply, 0, sizeof(reply));
    reply.TargetID          = scsi_io->TargetID;
    reply.Bus               = scsi_io->Bus;
    reply.MsgLength         = sizeof(reply) / 4;
    reply.Function          = scsi_io->Function;
    reply.CDBLength         = scsi_io->CDBLength;
    reply.SenseBufferLength = scsi_io->SenseBufferLength;
    reply.MsgContext        = scsi_io->MsgContext;
    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
    reply.IOCStatus         = status;

    mptsas_fix_scsi_io_reply_endianness(&reply);
    mptsas_reply(s, (MPIDefaultReply *)&reply);

    return 0;
}
",C,"    req = g_new0(MPTSASRequest, 1);
","    req = g_new(MPTSASRequest, 1);
",2a2d69f490c1b1dc6b6d2aef385ee7b654497a77,"@@ -304,7 +304,7 @@ static int mptsas_process_scsi_io_request(MPTSASState *s,
         goto bad;
     }
 
-    req = g_new(MPTSASRequest, 1);
+    req = g_new0(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/mptsas.c;h=eaae1bb182583882704d92005098c40f83769db9;hb=eaae1bb182583882704d92005098c40f83769db9,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/mptsas.c;h=0e0a22f6968bb5899c1501c5116dfd60d561f828;hb=0e0a22f6968bb5899c1501c5116dfd60d561f828,1,"static int mptsas_process_scsi_io_request(MPTSASState *s,
                                          MPIMsgSCSIIORequest *scsi_io,
                                          hwaddr addr)
{
    MPTSASRequest *req;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;

    mptsas_fix_scsi_io_endianness(scsi_io);

    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN[1], scsi_io->DataLength);

    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
                                     scsi_io->LUN, &sdev);
    if (status) {
         goto bad;
     }
 
//flaw_line_below:
    req = g_new(MPTSASRequest, 1);
//fix_flaw_line_below:
//    req = g_new0(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;

    status = mptsas_build_sgl(s, req, addr);
    if (status) {
        goto free_bad;
    }

    if (req->qsg.size < scsi_io->DataLength) {
        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
                                  req->qsg.size);
        status = MPI_IOCSTATUS_INVALID_SGL;
        goto free_bad;
    }

    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
                            scsi_io->LUN[1], scsi_io->CDB, req);

    if (req->sreq->cmd.xfer > scsi_io->DataLength) {
        goto overrun;
    }
    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
    case MPI_SCSIIO_CONTROL_NODATATRANSFER:
        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_WRITE:
        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_READ:
        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
            goto overrun;
        }
        break;
    }

    if (scsi_req_enqueue(req->sreq)) {
        scsi_req_continue(req->sreq);
    }
    return 0;

overrun:
    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
                               scsi_io->DataLength);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
    mptsas_free_request(req);
bad:
    memset(&reply, 0, sizeof(reply));
    reply.TargetID          = scsi_io->TargetID;
    reply.Bus               = scsi_io->Bus;
    reply.MsgLength         = sizeof(reply) / 4;
    reply.Function          = scsi_io->Function;
    reply.CDBLength         = scsi_io->CDBLength;
    reply.SenseBufferLength = scsi_io->SenseBufferLength;
    reply.MsgContext        = scsi_io->MsgContext;
    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
    reply.IOCStatus         = status;

    mptsas_fix_scsi_io_reply_endianness(&reply);
    mptsas_reply(s, (MPIDefaultReply *)&reply);

    return 0;
}
",178100,"static int mptsas_process_scsi_io_request(MPTSASState *s,
                                          MPIMsgSCSIIORequest *scsi_io,
                                          hwaddr addr)
{
    MPTSASRequest *req;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;

    mptsas_fix_scsi_io_endianness(scsi_io);

    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN[1], scsi_io->DataLength);

    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
                                     scsi_io->LUN, &sdev);
    if (status) {
         goto bad;
     }
 
    req = g_new(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;

    status = mptsas_build_sgl(s, req, addr);
    if (status) {
        goto free_bad;
    }

    if (req->qsg.size < scsi_io->DataLength) {
        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
                                  req->qsg.size);
        status = MPI_IOCSTATUS_INVALID_SGL;
        goto free_bad;
    }

    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
                            scsi_io->LUN[1], scsi_io->CDB, req);

    if (req->sreq->cmd.xfer > scsi_io->DataLength) {
        goto overrun;
    }
    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
    case MPI_SCSIIO_CONTROL_NODATATRANSFER:
        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_WRITE:
        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_READ:
        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
            goto overrun;
        }
        break;
    }

    if (scsi_req_enqueue(req->sreq)) {
        scsi_req_continue(req->sreq);
    }
    return 0;

overrun:
    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
                               scsi_io->DataLength);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
    mptsas_free_request(req);
bad:
    memset(&reply, 0, sizeof(reply));
    reply.TargetID          = scsi_io->TargetID;
    reply.Bus               = scsi_io->Bus;
    reply.MsgLength         = sizeof(reply) / 4;
    reply.Function          = scsi_io->Function;
    reply.CDBLength         = scsi_io->CDBLength;
    reply.SenseBufferLength = scsi_io->SenseBufferLength;
    reply.MsgContext        = scsi_io->MsgContext;
    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
    reply.IOCStatus         = status;

    mptsas_fix_scsi_io_reply_endianness(&reply);
    mptsas_reply(s, (MPIDefaultReply *)&reply);

    return 0;
}
","static int mptsas_process_scsi_io_request(MPTSASState *s,
                                          MPIMsgSCSIIORequest *scsi_io,
                                          hwaddr addr)
{
    MPTSASRequest *req;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;

    mptsas_fix_scsi_io_endianness(scsi_io);

    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN[1], scsi_io->DataLength);

    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
                                     scsi_io->LUN, &sdev);
    if (status) {
         goto bad;
     }
 
    req = g_new0(MPTSASRequest, 1);
     QTAILQ_INSERT_TAIL(&s->pending, req, next);
     req->scsi_io = *scsi_io;
     req->dev = s;

    status = mptsas_build_sgl(s, req, addr);
    if (status) {
        goto free_bad;
    }

    if (req->qsg.size < scsi_io->DataLength) {
        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
                                  req->qsg.size);
        status = MPI_IOCSTATUS_INVALID_SGL;
        goto free_bad;
    }

    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
                            scsi_io->LUN[1], scsi_io->CDB, req);

    if (req->sreq->cmd.xfer > scsi_io->DataLength) {
        goto overrun;
    }
    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
    case MPI_SCSIIO_CONTROL_NODATATRANSFER:
        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_WRITE:
        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
            goto overrun;
        }
        break;

    case MPI_SCSIIO_CONTROL_READ:
        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
            goto overrun;
        }
        break;
    }

    if (scsi_req_enqueue(req->sreq)) {
        scsi_req_continue(req->sreq);
    }
    return 0;

overrun:
    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
                               scsi_io->DataLength);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
    mptsas_free_request(req);
bad:
    memset(&reply, 0, sizeof(reply));
    reply.TargetID          = scsi_io->TargetID;
    reply.Bus               = scsi_io->Bus;
    reply.MsgLength         = sizeof(reply) / 4;
    reply.Function          = scsi_io->Function;
    reply.CDBLength         = scsi_io->CDBLength;
    reply.SenseBufferLength = scsi_io->SenseBufferLength;
    reply.MsgContext        = scsi_io->MsgContext;
    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
    reply.IOCStatus         = status;

    mptsas_fix_scsi_io_reply_endianness(&reply);
    mptsas_reply(s, (MPIDefaultReply *)&reply);

    return 0;
}
","The vulnerability in the original code arises from the use of `g_new(MPTSASRequest, 1)`, which allocates memory without initializing it, potentially leading to undefined behavior if any fields are accessed before being set. This could allow for exploitation through uninitialized memory. The fix in the modified code replaces `g_new` with `g_new0(MPTSASRequest, 1)`, which allocates and zeroes out the memory for `req`. This ensures that all fields in the `MPTSASRequest` structure are initialized to zero, mitigating the risk of accessing uninitialized data and enhancing overall stability and security.","The vulnerability in the original code stems from the allocation of memory without initialization, which can lead to undefined behavior if any uninitialized fields are accessed. This situation poses a risk of exploitation, as attackers could potentially manipulate the uninitialized memory to gain control or cause crashes. The fix in the modified code addresses this issue by using a memory allocation function that not only allocates the required space but also initializes all allocated memory to zero. This change ensures that all fields are set to a known state, thereby enhancing security and preventing unintended behavior from uninitialized data.",4,5,4,4
7,7,178104,178104,,Local,Not required,Partial,CVE-2016-7170,https://www.cvedetails.com/cve/CVE-2016-7170/,CWE-787,Low,,,,2016-12-09,2.1,The vmsvga_fifo_run function in hw/display/vmware_vga.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors related to cursor.mask[] and cursor.image[] array sizes when processing a DEFINE_CURSOR svga command.,2018-12-01,DoS,7,https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db,167d97a3def77ee2dbf6e908b0ecbfe2103977db,,5,,,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
            if (cursor.width > 256
                || cursor.height > 256
                || cursor.bpp > 32
                || SVGA_BITMAP_SIZE(x, y)
                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                     goto badcmd;
             }
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }
","static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
            if (cursor.width > 256 ||
                cursor.height > 256 ||
                cursor.bpp > 32 ||
                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
                     goto badcmd;
             }
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }
",C,"            if (cursor.width > 256
                || cursor.height > 256
                || cursor.bpp > 32
                || SVGA_BITMAP_SIZE(x, y)
                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
","            if (cursor.width > 256 ||
                cursor.height > 256 ||
                cursor.bpp > 32 ||
                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
",7263da78045dc91cc207f350911efe4259e99b3c,"@@ -676,11 +676,13 @@ static void vmsvga_fifo_run(struct vmsvga_state_s *s)
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
-            if (cursor.width > 256 ||
-                cursor.height > 256 ||
-                cursor.bpp > 32 ||
-                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
-                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
+            if (cursor.width > 256
+                || cursor.height > 256
+                || cursor.bpp > 32
+                || SVGA_BITMAP_SIZE(x, y)
+                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
+                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
+                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                     goto badcmd;
             }",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/vmware_vga.c;h=6599cf078d22f794e9eb54450f602ce022136fe8;hb=6599cf078d22f794e9eb54450f602ce022136fe8,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/vmware_vga.c;h=e51a05ea7e48505af029ae9e5e9b0a243812d1d0;hb=e51a05ea7e48505af029ae9e5e9b0a243812d1d0,1,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
//flaw_line_below:
            if (cursor.width > 256 ||
//flaw_line_below:
                cursor.height > 256 ||
//flaw_line_below:
                cursor.bpp > 32 ||
//flaw_line_below:
                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
//flaw_line_below:
                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
//fix_flaw_line_below:
//            if (cursor.width > 256
//fix_flaw_line_below:
//                || cursor.height > 256
//fix_flaw_line_below:
//                || cursor.bpp > 32
//fix_flaw_line_below:
//                || SVGA_BITMAP_SIZE(x, y)
//fix_flaw_line_below:
//                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
//fix_flaw_line_below:
//                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
//fix_flaw_line_below:
//                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                     goto badcmd;
             }
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }
",178104,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            cursor.bpp = vmsvga_fifo_read(s);

            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
            if (cursor.width > 256 ||
                cursor.height > 256 ||
                cursor.bpp > 32 ||
                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
                    goto badcmd;
            }

            len -= args;
            if (len < 0) {
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }

    s->syncing = 0;
}","static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
            if (cursor.width > 256
                || cursor.height > 256
                || cursor.bpp > 32
                || SVGA_BITMAP_SIZE(x, y)
                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                     goto badcmd;
             }
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }
","The vulnerability in the original code lies in the lack of proper bounds checking for the cursor dimensions and bits per pixel (bpp) in the `SVGA_CMD_DEFINE_CURSOR` case. Specifically, the code did not adequately verify that the sizes of `cursor.mask` and `cursor.image` were sufficient to hold the data being read, which could lead to buffer overflows. In the fixed code, the checks for `cursor.width`, `cursor.height`, and `cursor.bpp` now ensure that these values do not exceed the allocated sizes of `cursor.mask` and `cursor.image`, thus preventing potential memory corruption and enhancing the overall security of the function.","The vulnerability in the original code stems from inadequate validation of input parameters, particularly regarding the dimensions and bits per pixel for cursor definitions. This oversight could lead to buffer overflows, as the code did not ensure that the allocated memory for storing cursor data was sufficient to accommodate the incoming values. In the revised code, additional checks were implemented to verify that the specified dimensions and bits per pixel do not exceed the allocated memory sizes, effectively mitigating the risk of memory corruption and enhancing the overall robustness and security of the function.",3,5,4,3
8,8,178133,178133,,Local,Not required,Complete,CVE-2016-6351,https://www.cvedetails.com/cve/CVE-2016-6351/,CWE-787,Low,Complete,Complete,,2016-09-07,7.2,"The esp_do_dma function in hw/scsi/esp.c in QEMU (aka Quick Emulator), when built with ESP/NCR53C9x controller emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) or execute arbitrary code on the QEMU host via vectors involving DMA read into ESP command buffer.",2018-12-01,DoS Exec Code,2,https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11,926cde5f3e4d2504ed161ed0cb771ac7cad6fd11,,0,,,"static void esp_do_dma(ESPState *s)
{
    uint32_t len;
    int to_device;

     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
        assert (s->cmdlen <= sizeof(s->cmdbuf) &&
                len <= sizeof(s->cmdbuf) - s->cmdlen);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
        return;
    }
","static void esp_do_dma(ESPState *s)
{
    uint32_t len;
    int to_device;

     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
        return;
    }
",C,"        assert (s->cmdlen <= sizeof(s->cmdbuf) &&
                len <= sizeof(s->cmdbuf) - s->cmdlen);
",,7f0b6e114ae4e142e2b3dfc9fac138f4a30edc4f,"@@ -248,6 +248,8 @@ static void esp_do_dma(ESPState *s)
     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
+        assert (s->cmdlen <= sizeof(s->cmdbuf) &&
+                len <= sizeof(s->cmdbuf) - s->cmdlen);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
@@ -345,7 +347,7 @@ static void handle_ti(ESPState *s)
     s->dma_counter = dmalen;
 
     if (s->do_cmd)
-        minlen = (dmalen < 32) ? dmalen : 32;
+        minlen = (dmalen < ESP_CMDBUF_SZ) ? dmalen : ESP_CMDBUF_SZ;
     else if (s->ti_size < 0)
         minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;
     else
@@ -449,7 +451,7 @@ void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)
         break;
     case ESP_FIFO:
         if (s->do_cmd) {
-            if (s->cmdlen < TI_BUFSZ) {
+            if (s->cmdlen < ESP_CMDBUF_SZ) {
                 s->cmdbuf[s->cmdlen++] = val & 0xff;
             } else {
                 trace_esp_error_fifo_overrun();",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/esp.c;h=baa0a2cfdfcf89cdb8c3aac7facaedb3142b09d7;hb=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/esp.c;h=64680b3809e6a64dc82693644fe847ea7faebd66,1,"static void esp_do_dma(ESPState *s)
{
    uint32_t len;
    int to_device;

     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
//fix_flaw_line_below:
//        assert (s->cmdlen <= sizeof(s->cmdbuf) &&
//fix_flaw_line_below:
//                len <= sizeof(s->cmdbuf) - s->cmdlen);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
        return;
    }
",178133,"static void esp_do_dma(ESPState *s)
{
    uint32_t len;
    int to_device;

     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
        return;
    }
","static void esp_do_dma(ESPState *s)
{
    uint32_t len;
    int to_device;

     len = s->dma_left;
     if (s->do_cmd) {
         trace_esp_do_dma(s->cmdlen, len);
        assert (s->cmdlen <= sizeof(s->cmdbuf) &&
                len <= sizeof(s->cmdbuf) - s->cmdlen);
         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
         return;
     }
        return;
    }
","The vulnerability in the original code arises from a lack of bounds checking on the `s->cmdbuf` array, which could lead to a buffer overflow if `s->cmdlen` plus `len` exceeds the size of `s->cmdbuf`. This could allow an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution or data corruption. The fixed code addresses this vulnerability by adding an `assert` statement that checks whether `s->cmdlen` is within the bounds of `s->cmdbuf` and ensures that the total length (`s->cmdlen + len`) does not exceed the buffer size, thus preventing the overflow.","The vulnerability in the original code stems from the absence of checks on the size of a buffer before writing data to it, which can lead to a buffer overflow. This occurs when the amount of data being written exceeds the allocated space, potentially allowing an attacker to overwrite adjacent memory. The fixed code mitigates this risk by introducing assertions that verify the size of the buffer and ensure that the total data being written does not exceed its capacity. This additional validation effectively prevents the overflow, enhancing the overall security of the code.",2,0,2,2
9,9,178137,178137,,Remote,Not required,Partial,CVE-2016-6303,https://www.cvedetails.com/cve/CVE-2016-6303/,CWE-787,Low,Partial,Partial,,2016-09-16,7.5,Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors.,2018-04-19,DoS Overflow,1,https://git.openssl.org/?p=openssl.git;a=commit;h=55d83bf7c10c7b205fffa23fa7c3977491e56c07,55d83bf7c10c7b205fffa23fa7c3977491e56c07,,1,,,"int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
{
    size_t i, j;
 
     i = c->num;
     if (i != 0) {
        if (len < MDC2_BLOCK - i) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;
            return 1;
        } else {
            /* filled one */
            j = MDC2_BLOCK - i;
            memcpy(&(c->data[i]), in, j);
            len -= j;
            in += j;
            c->num = 0;
            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);
        }
    }
    i = len & ~((size_t)MDC2_BLOCK - 1);
    if (i > 0)
        mdc2_body(c, in, i);
    j = len - i;
    if (j > 0) {
        memcpy(&(c->data[0]), &(in[i]), j);
        c->num = (int)j;
    }
    return 1;
}
","int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
{
    size_t i, j;
 
     i = c->num;
     if (i != 0) {
        if (i + len < MDC2_BLOCK) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;
            return 1;
        } else {
            /* filled one */
            j = MDC2_BLOCK - i;
            memcpy(&(c->data[i]), in, j);
            len -= j;
            in += j;
            c->num = 0;
            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);
        }
    }
    i = len & ~((size_t)MDC2_BLOCK - 1);
    if (i > 0)
        mdc2_body(c, in, i);
    j = len - i;
    if (j > 0) {
        memcpy(&(c->data[0]), &(in[i]), j);
        c->num = (int)j;
    }
    return 1;
}
",C,"        if (len < MDC2_BLOCK - i) {
","        if (i + len < MDC2_BLOCK) {
",ef28891bab7054667f2f6739f6d376c38b3ca1cc,"@@ -42,7 +42,7 @@ int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
 
     i = c->num;
     if (i != 0) {
-        if (i + len < MDC2_BLOCK) {
+        if (len < MDC2_BLOCK - i) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/mdc2/mdc2dgst.c;h=37d99f48a5ebcae9f5e16b52ab73e2ed3c24fae2;hb=37d99f48a5ebcae9f5e16b52ab73e2ed3c24fae2,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/mdc2/mdc2dgst.c;h=6397a47e92dc22d08eda4f556019d1f2e816cc55;hb=6397a47e92dc22d08eda4f556019d1f2e816cc55,1,"int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
{
    size_t i, j;
 
     i = c->num;
     if (i != 0) {
//flaw_line_below:
        if (i + len < MDC2_BLOCK) {
//fix_flaw_line_below:
//        if (len < MDC2_BLOCK - i) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;
            return 1;
        } else {
            /* filled one */
            j = MDC2_BLOCK - i;
            memcpy(&(c->data[i]), in, j);
            len -= j;
            in += j;
            c->num = 0;
            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);
        }
    }
    i = len & ~((size_t)MDC2_BLOCK - 1);
    if (i > 0)
        mdc2_body(c, in, i);
    j = len - i;
    if (j > 0) {
        memcpy(&(c->data[0]), &(in[i]), j);
        c->num = (int)j;
    }
    return 1;
}
",178137,"int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
{
    size_t i, j;
 
     i = c->num;
     if (i != 0) {
        if (i + len < MDC2_BLOCK) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;
            return 1;
        } else {
            /* filled one */
            j = MDC2_BLOCK - i;
            memcpy(&(c->data[i]), in, j);
            len -= j;
            in += j;
            c->num = 0;
            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);
        }
    }
    i = len & ~((size_t)MDC2_BLOCK - 1);
    if (i > 0)
        mdc2_body(c, in, i);
    j = len - i;
    if (j > 0) {
        memcpy(&(c->data[0]), &(in[i]), j);
        c->num = (int)j;
    }
    return 1;
}
","int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)
{
    size_t i, j;
 
     i = c->num;
     if (i != 0) {
        if (len < MDC2_BLOCK - i) {
             /* partial block */
             memcpy(&(c->data[i]), in, len);
             c->num += (int)len;
            return 1;
        } else {
            /* filled one */
            j = MDC2_BLOCK - i;
            memcpy(&(c->data[i]), in, j);
            len -= j;
            in += j;
            c->num = 0;
            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);
        }
    }
    i = len & ~((size_t)MDC2_BLOCK - 1);
    if (i > 0)
        mdc2_body(c, in, i);
    j = len - i;
    if (j > 0) {
        memcpy(&(c->data[0]), &(in[i]), j);
        c->num = (int)j;
    }
    return 1;
}
","The vulnerability in the original code lies in the condition `if (i + len < MDC2_BLOCK)`, which could allow for a buffer overflow if `len` is large enough to exceed the bounds of `c->data`. This could lead to unintended memory access and potential exploitation. The fix modifies the condition to `if (len < MDC2_BLOCK - i)`, ensuring that the total length of data being copied does not exceed the available space in `c->data`. This change effectively prevents buffer overflow by ensuring that the remaining space in the buffer is always respected before performing the `memcpy`.","The vulnerability in the original code arises from an inadequate check on the length of data being processed, which could lead to a buffer overflow. Specifically, the condition allowed for the possibility of copying more data than the allocated buffer could handle, risking memory corruption and potential exploitation. The fix addresses this issue by modifying the condition to ensure that the length of incoming data, combined with the current buffer state, does not exceed the buffer's capacity. This change effectively safeguards against overflow by enforcing stricter limits on the amount of data that can be copied into the buffer.",2,5,4,2
10,10,178324,178324,,Remote,Single system,Partial,CVE-2018-5388,https://www.cvedetails.com/cve/CVE-2018-5388/,CWE-787,Low,,,,2018-05-31,4.0,"In stroke_socket.c in strongSwan before 5.6.3, a missing packet length check could allow a buffer underflow, which may lead to resource exhaustion and denial of service while reading from the socket.",2019-10-09,DoS,5,https://git.strongswan.org/?p=strongswan.git;a=commitdiff;h=0acd1ab4,0acd1ab4d08d53d80393b1a37b8781f6e7b2b996,,0,,,"static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
{
	stroke_msg_t *msg;
	uint16_t len;
	FILE *out;

	/* read length */
	if (!stream->read_all(stream, &len, sizeof(len)))
	{
		if (errno != EWOULDBLOCK)
		{
			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
				 strerror(errno));
                }
                return FALSE;
        }
       if (len < offsetof(stroke_msg_t, buffer))
       {
               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
               return FALSE;
       }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);
			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
		}
","static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
{
	stroke_msg_t *msg;
	uint16_t len;
	FILE *out;

	/* read length */
	if (!stream->read_all(stream, &len, sizeof(len)))
	{
		if (errno != EWOULDBLOCK)
		{
			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
				 strerror(errno));
                }
                return FALSE;
        }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);
			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
		}
",C,"       if (len < offsetof(stroke_msg_t, buffer))
       {
               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
               return FALSE;
       }
",,04ede658c85211e537a2ce379b8f09f33f3d6438,"@@ -627,6 +627,11 @@ static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
                }
                return FALSE;
        }
+       if (len < offsetof(stroke_msg_t, buffer))
+       {
+               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
+               return FALSE;
+       }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);",strongswan,https://git.strongswan.org/?p=strongswan.git;a=blob;f=src/libcharon/plugins/stroke/stroke_socket.c;h=1e7f210e940abec158391fe266a03088b5603ea4;hb=0acd1ab4,https://git.strongswan.org/?p=strongswan.git;a=blob;f=src/libcharon/plugins/stroke/stroke_socket.c;h=c568440b7ae275fac2f832eddfa0563a98d9ee99,1,"static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
{
	stroke_msg_t *msg;
	uint16_t len;
	FILE *out;

	/* read length */
	if (!stream->read_all(stream, &len, sizeof(len)))
	{
		if (errno != EWOULDBLOCK)
		{
			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
				 strerror(errno));
                }
                return FALSE;
        }
//fix_flaw_line_below:
//       if (len < offsetof(stroke_msg_t, buffer))
//fix_flaw_line_below:
//       {
//fix_flaw_line_below:
//               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
//fix_flaw_line_below:
//               return FALSE;
//fix_flaw_line_below:
//       }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);
			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
		}
",178324,"static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
{
	stroke_msg_t *msg;
	uint16_t len;
	FILE *out;

	/* read length */
	if (!stream->read_all(stream, &len, sizeof(len)))
	{
		if (errno != EWOULDBLOCK)
		{
			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
				 strerror(errno));
                }
                return FALSE;
        }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);
			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
		}
","static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
{
	stroke_msg_t *msg;
	uint16_t len;
	FILE *out;

	/* read length */
	if (!stream->read_all(stream, &len, sizeof(len)))
	{
		if (errno != EWOULDBLOCK)
		{
			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
				 strerror(errno));
                }
                return FALSE;
        }
       if (len < offsetof(stroke_msg_t, buffer))
       {
               DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
               return FALSE;
       }
 
        /* read message (we need an additional byte to terminate the buffer) */
        msg = malloc(len + 1);
			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
		}
","The vulnerability in the original code arises from the lack of validation for the `len` variable, which is derived from the incoming stream. If an attacker sends a maliciously crafted message with a length smaller than the expected size of `stroke_msg_t`, it could lead to a buffer overflow when allocating memory with `malloc(len + 1)`. The fixed code addresses this vulnerability by adding a check to ensure that `len` is at least as large as `offsetof(stroke_msg_t, buffer)`, thereby preventing the allocation of insufficient memory and mitigating the risk of buffer overflow attacks.","The vulnerability in the original code stems from the absence of validation for the length of the incoming message, which could allow an attacker to specify a length that is too small. This oversight could lead to a buffer overflow when memory is allocated based on this unverified length, potentially allowing for arbitrary code execution or data corruption. The revised code mitigates this risk by introducing a check to ensure that the specified length meets a minimum requirement, thereby preventing the allocation of insufficient memory and enhancing the overall security of the application.",2,4,3,3
11,11,178406,178406,,Remote,Not required,Partial,CVE-2016-10328,https://www.cvedetails.com/cve/CVE-2016-10328/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FreeType 2 before 2016-12-16 has an out-of-bounds write caused by a heap-based buffer overflow related to the cff_parser_run function in cff/cffparse.c.,2017-06-30,Overflow,7,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=beecf80a6deecbaf5d264d4f864451bde4fe98b8,beecf80a6deecbaf5d264d4f864451bde4fe98b8,,3,,,"  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
        FT_UInt                   num_args;
         const CFF_Field_Handler*  field;
 
 
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        num_args     = (FT_UInt)( parser->top - parser->stack );
         *parser->top = p;
        code         = v;

         if ( v == 12 )
         {
           /* two byte operator */
          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }
","  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
        FT_UInt                   num_args = (FT_UInt)
                                             ( parser->top - parser->stack );
         const CFF_Field_Handler*  field;
 
 
         *parser->top = p;
        code = v;
         if ( v == 12 )
         {
           /* two byte operator */
          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }
",C,"        FT_UInt                   num_args;
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        num_args     = (FT_UInt)( parser->top - parser->stack );
        code         = v;

","        FT_UInt                   num_args = (FT_UInt)
                                             ( parser->top - parser->stack );
        code = v;
",01658be6fbda2ff17616158ae5df5dc240a4347c,"@@ -1422,13 +1422,17 @@
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
-        FT_UInt                   num_args = (FT_UInt)
-                                             ( parser->top - parser->stack );
+        FT_UInt                   num_args;
         const CFF_Field_Handler*  field;
 
 
+        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
+          goto Stack_Overflow;
+
+        num_args     = (FT_UInt)( parser->top - parser->stack );
         *parser->top = p;
-        code = v;
+        code         = v;
+
         if ( v == 12 )
         {
           /* two byte operator */",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/cff/cffparse.c?id=beecf80a6deecbaf5d264d4f864451bde4fe98b8,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/cff/cffparse.c?id=01658be6fbda2ff17616158ae5df5dc240a4347c,1,"  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
//flaw_line_below:
        FT_UInt                   num_args = (FT_UInt)
//flaw_line_below:
                                             ( parser->top - parser->stack );
//fix_flaw_line_below:
//        FT_UInt                   num_args;
         const CFF_Field_Handler*  field;
 
 
//fix_flaw_line_below:
//        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
//fix_flaw_line_below:
//          goto Stack_Overflow;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        num_args     = (FT_UInt)( parser->top - parser->stack );
         *parser->top = p;
//flaw_line_below:
        code = v;
//fix_flaw_line_below:
//        code         = v;
//fix_flaw_line_below:
//
         if ( v == 12 )
         {
           /* two byte operator */
          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }
",178406,"  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
        FT_UInt                   num_args = (FT_UInt)
                                             ( parser->top - parser->stack );
         const CFF_Field_Handler*  field;
 
 
         *parser->top = p;
        code = v;
         if ( v == 12 )
         {
           /* two byte operator */
          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }
","  cff_parser_run( CFF_Parser  parser,
                  FT_Byte*    start,
                  FT_Byte*    limit )
  {
    FT_Byte*    p       = start;
    FT_Error    error   = FT_Err_Ok;
    FT_Library  library = parser->library;
    FT_UNUSED( library );


    parser->top    = parser->stack;
    parser->start  = start;
    parser->limit  = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt  v = *p;

      /* Opcode 31 is legacy MM T2 operator, not a number.      */
      /* Opcode 255 is reserved and should not appear in fonts; */
      /* it is used internally for CFF2 blends.                 */
      if ( v >= 27 && v != 31 && v != 255 )
      {
        /* it's a number; we will push its position on the stack */
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        *parser->top++ = p;

        /* now, skip it */
        if ( v == 30 )
        {
          /* skip real number */
          p++;
          for (;;)
          {
            /* An unterminated floating point number at the */
            /* end of a dictionary is invalid but harmless. */
            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      else if ( v == 31 )
      {
        /* a Type 2 charstring */

        CFF_Decoder  decoder;
        CFF_FontRec  cff_rec;
        FT_Byte*     charstring_base;
        FT_ULong     charstring_len;

        FT_Fixed*  stack;
        FT_Byte*   q;


        charstring_base = ++p;

        /* search `endchar' operator */
        for (;;)
        {
          if ( p >= limit )
            goto Exit;
          if ( *p == 14 )
            break;
          p++;
        }

        charstring_len = (FT_ULong)( p - charstring_base ) + 1;

        /* construct CFF_Decoder object */
        FT_ZERO( &decoder );
        FT_ZERO( &cff_rec );

        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
        decoder.cff                            = &cff_rec;

        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring_base,
                                               charstring_len,
                                               1 );

        /* Now copy the stack data in the temporary decoder object,    */
        /* converting it back to charstring number representations     */
        /* (this is ugly, I know).                                     */
        /*                                                             */
        /* We overwrite the original top DICT charstring under the     */
        /* assumption that the charstring representation of the result */
        /* of `cff_decoder_parse_charstrings' is shorter, which should */
        /* be always true.                                             */

        q     = charstring_base - 1;
        stack = decoder.stack;

        while ( stack < decoder.top )
        {
          FT_ULong  num;
          FT_Bool   neg;


          if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
            goto Stack_Overflow;

          *parser->top++ = q;

          if ( *stack < 0 )
          {
            num = (FT_ULong)-*stack;
            neg = 1;
          }
          else
          {
            num = (FT_ULong)*stack;
            neg = 0;
          }

          if ( num & 0xFFFFU )
          {
            if ( neg )
              num = (FT_ULong)-num;

            *q++ = 255;
            *q++ = ( num & 0xFF000000U ) >> 24;
            *q++ = ( num & 0x00FF0000U ) >> 16;
            *q++ = ( num & 0x0000FF00U ) >>  8;
            *q++ =   num & 0x000000FFU;
          }
          else
          {
            num >>= 16;

            if ( neg )
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( 139 - num );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                num = (FT_ULong)-num;

                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
            else
            {
              if ( num <= 107 )
                *q++ = (FT_Byte)( num + 139 );
              else if ( num <= 1131 )
              {
                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
              }
              else
              {
                *q++ = 28;
                *q++ = (FT_Byte)( num >> 8 );
                *q++ = (FT_Byte)( num & 0xFF );
              }
            }
          }

          stack++;
        }
      }
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
      else
      {
        /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
        FT_UInt                   num_args;
         const CFF_Field_Handler*  field;
 
 
        if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
          goto Stack_Overflow;

        num_args     = (FT_UInt)( parser->top - parser->stack );
         *parser->top = p;
        code         = v;

         if ( v == 12 )
         {
           /* two byte operator */
          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {
            /* we found our field's handler; read it */
            FT_Long   val;
            FT_Byte*  q = (FT_Byte*)parser->object + field->offset;


#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE4(( ""  %s"", field->id ));
#endif

            /* check that we have enough arguments -- except for */
            /* delta encoded arrays, which can be empty          */
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser, parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser, parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / FT_CHAR_BIT):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / FT_CHAR_BIT):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / FT_CHAR_BIT):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:  /* for 64-bit systems */
                *(FT_Long*)q = val;
              }

#ifdef FT_DEBUG_LEVEL_TRACE
              switch ( field->kind )
              {
              case cff_kind_bool:
                FT_TRACE4(( "" %s\n"", val ? ""true"" : ""false"" ));
                break;

              case cff_kind_string:
                FT_TRACE4(( "" %ld (SID)\n"", val ));
                break;

              case cff_kind_num:
                FT_TRACE4(( "" %ld\n"", val ));
                break;

              case cff_kind_fixed:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 ));
                break;

              case cff_kind_fixed_thousand:
                FT_TRACE4(( "" %f\n"", (double)val / 65536 / 1000 ));

              default:
                ; /* never reached */
              }
#endif

              break;

            case cff_kind_delta:
              {
                FT_Byte*   qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte**  data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                FT_TRACE4(( "" ["" ));

                /* store count */
                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( parser, data++ );
                  switch ( field->size )
                  {
                  case (8 / FT_CHAR_BIT):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / FT_CHAR_BIT):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / FT_CHAR_BIT):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:  /* for 64-bit systems */
                    *(FT_Long*)q = val;
                  }

                  FT_TRACE4(( "" %ld"", val ));

                  q += field->size;
                  num_args--;
                }

                FT_TRACE4(( ""]\n"" ));
              }
              break;

            default:  /* callback or blend */
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }

        /* this is an unknown operator, or it is unsupported; */
        /* we will ignore it for now.                         */

      Found:
        /* clear stack */
        /* TODO: could clear blend stack here,       */
        /*       but we don't have access to subFont */
        if ( field->kind != cff_kind_blend )
          parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Stack_Underflow:
    error = FT_THROW( Invalid_Argument );
    goto Exit;

  Syntax_Error:
    error = FT_THROW( Invalid_Argument );
    goto Exit;
  }
","The vulnerability in the original code lies in the handling of the `parser->top` variable, which could lead to a stack overflow if the number of elements pushed onto the stack exceeds `parser->stackSize`. Specifically, the check `(FT_UInt)(parser->top - parser->stack) >= parser->stackSize` is performed after incrementing `parser->top`, allowing for potential overflow before the check. In the fixed code, this check is moved to occur before any increment of `parser->top`, ensuring that the stack size is validated before any new elements are added, thus preventing stack overflow vulnerabilities.","The vulnerability in the original code arises from inadequate checks on the stack size, which could lead to a stack overflow if too many elements are pushed onto it. Specifically, the code allows for the increment of the stack pointer before verifying whether it exceeds the allocated size, creating a risk of overwriting memory. The fix addresses this issue by repositioning the stack size check to occur before any modifications to the stack pointer. This ensures that the code validates the available space before adding new elements, effectively preventing potential overflow and enhancing overall stability.",3,5,4,4
12,12,178410,178410,,Remote,Not required,Partial,CVE-2016-10164,https://www.cvedetails.com/cve/CVE-2016-10164/,CWE-787,Low,Partial,Partial,,2017-02-01,7.5,"Multiple integer overflows in libXpm before 3.5.12, when a program requests parsing XPM extensions on a 64-bit platform, allow remote attackers to cause a denial of service (out-of-bounds write) or execute arbitrary code via (1) the number of extensions or (2) their concatenated length in a crafted XPM file, which triggers a heap-based buffer overflow.",2018-01-04,DoS Exec Code Overflow,7,https://cgit.freedesktop.org/xorg/lib/libXpm/commit/?id=d1167418f0fd02a27f617ec5afd6db053afbe185,d1167418f0fd02a27f617ec5afd6db053afbe185,,4,,,"XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;
 
     /* compute the number of extensions lines and size */
     if (extensions)
	if (CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines))
	    return(XpmNoMemory);
 
     /*
      * alloc a temporary array of char pointer for the header section which
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
    if (image->height > UINT_MAX - ext_nlines ||
	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
	RETURN(XpmNoMemory);
    data_size += image->height * offset;
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
    if (header_size > UINT_MAX - ext_size ||
	header_size + ext_size >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}
","XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;
 
     /* compute the number of extensions lines and size */
     if (extensions)
	CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines);
 
     /*
      * alloc a temporary array of char pointer for the header section which
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
	RETURN(XpmNoMemory);
    data_size += image->height * offset;
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}
",C,"	if (CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines))
	    return(XpmNoMemory);
    if (image->height > UINT_MAX - ext_nlines ||
	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
    if (header_size > UINT_MAX - ext_size ||
	header_size + ext_size >= (UINT_MAX - data_size) )
","	CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines);
    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
",1ec33006a9e4214b390045b820464e24297dc6c0,"@@ -48,7 +48,7 @@ LFUNC(CreatePixels, void, (char **dataptr, unsigned int data_size,
 			   unsigned int height, unsigned int cpp,
 			   unsigned int *pixels, XpmColor *colors));
 
-LFUNC(CountExtensions, void, (XpmExtension *ext, unsigned int num,
+LFUNC(CountExtensions, int, (XpmExtension *ext, unsigned int num,
 			      unsigned int *ext_size,
 			      unsigned int *ext_nlines));
 
@@ -122,8 +122,9 @@ XpmCreateDataFromXpmImage(
 
     /* compute the number of extensions lines and size */
     if (extensions)
-	CountExtensions(info->extensions, info->nextensions,
-			&ext_size, &ext_nlines);
+	if (CountExtensions(info->extensions, info->nextensions,
+			&ext_size, &ext_nlines))
+	    return(XpmNoMemory);
 
     /*
      * alloc a temporary array of char pointer for the header section which
@@ -187,7 +188,8 @@ XpmCreateDataFromXpmImage(
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
-    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
+    if (image->height > UINT_MAX - ext_nlines ||
+	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
@@ -196,7 +198,8 @@ XpmCreateDataFromXpmImage(
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
-    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
+    if (header_size > UINT_MAX - ext_size ||
+	header_size + ext_size >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 
@@ -343,13 +346,14 @@ CreatePixels(
     *s = '\0';
 }
 
-static void
+static int
 CountExtensions(
     XpmExtension	*ext,
     unsigned int	 num,
     unsigned int	*ext_size,
     unsigned int	*ext_nlines)
 {
+    size_t len;
     unsigned int x, y, a, size, nlines;
     char **line;
 
@@ -357,16 +361,28 @@ CountExtensions(
     nlines = 0;
     for (x = 0; x < num; x++, ext++) {
 	/* 1 for the name */
+	if (ext->nlines == UINT_MAX || nlines > UINT_MAX - ext->nlines - 1)
+	    return (1);
 	nlines += ext->nlines + 1;
 	/* 8 = 7 (for ""XPMEXT "") + 1 (for 0) */
-	size += strlen(ext->name) + 8;
+	len = strlen(ext->name) + 8;
+	if (len > UINT_MAX - size)
+	    return (1);
+	size += len;
 	a = ext->nlines;
-	for (y = 0, line = ext->lines; y < a; y++, line++)
-	    size += strlen(*line) + 1;
+	for (y = 0, line = ext->lines; y < a; y++, line++) {
+	    len = strlen(*line) + 1;
+	    if (len > UINT_MAX - size)
+		return (1);
+	    size += len;
+	}
     }
+    if (size > UINT_MAX - 10 || nlines > UINT_MAX - 1)
+	return (1);
     /* 10 and 1 are for the ending ""XPMENDEXT"" */
     *ext_size = size + 10;
     *ext_nlines = nlines + 1;
+    return (0);
 }
 
 static void",libXpm,https://cgit.freedesktop.org/xorg/lib/libXpm/tree/src/CrDatFrI.c?id=d1167418f0fd02a27f617ec5afd6db053afbe185,https://cgit.freedesktop.org/xorg/lib/libXpm/tree/src/CrDatFrI.c?id=1ec33006a9e4214b390045b820464e24297dc6c0,1,"XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;
 
     /* compute the number of extensions lines and size */
     if (extensions)
//flaw_line_below:
	CountExtensions(info->extensions, info->nextensions,
//flaw_line_below:
			&ext_size, &ext_nlines);
//fix_flaw_line_below:
//	if (CountExtensions(info->extensions, info->nextensions,
//fix_flaw_line_below:
//			&ext_size, &ext_nlines))
//fix_flaw_line_below:
//	    return(XpmNoMemory);
 
     /*
      * alloc a temporary array of char pointer for the header section which
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
//flaw_line_below:
    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
//fix_flaw_line_below:
//    if (image->height > UINT_MAX - ext_nlines ||
//fix_flaw_line_below:
//	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
	RETURN(XpmNoMemory);
    data_size += image->height * offset;
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
//flaw_line_below:
    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
//fix_flaw_line_below:
//    if (header_size > UINT_MAX - ext_size ||
//fix_flaw_line_below:
//	header_size + ext_size >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}
",178410,"XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;
 
     /* compute the number of extensions lines and size */
     if (extensions)
	CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines);
 
     /*
      * alloc a temporary array of char pointer for the header section which
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
    if( (image->height + ext_nlines) >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
	RETURN(XpmNoMemory);
    data_size += image->height * offset;
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
    if( (header_size + ext_size) >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}
","XpmCreateDataFromXpmImage(
    char	***data_return,
    XpmImage	  *image,
    XpmInfo	  *info)
{
    /* calculation variables */
    int ErrorStatus;
    char buf[BUFSIZ];
    char **header = NULL, **data, **sptr, **sptr2, *s;
    unsigned int header_size, header_nlines;
    unsigned int data_size, data_nlines;
    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
    unsigned int offset, l, n;

    *data_return = NULL;

    extensions = info && (info->valuemask & XpmExtensions)
	&& info->nextensions;
 
     /* compute the number of extensions lines and size */
     if (extensions)
	if (CountExtensions(info->extensions, info->nextensions,
			&ext_size, &ext_nlines))
	    return(XpmNoMemory);
 
     /*
      * alloc a temporary array of char pointer for the header section which
     */
    header_nlines = 1 + image->ncolors; /* this may wrap and/or become 0 */

    /* 2nd check superfluous if we do not need header_nlines any further */
    if(header_nlines <= image->ncolors ||
       header_nlines >= UINT_MAX / sizeof(char *))
    	return(XpmNoMemory);

    header_size = sizeof(char *) * header_nlines;
    if (header_size >= UINT_MAX / sizeof(char *))
	return (XpmNoMemory);
    header = (char **) XpmCalloc(header_size, sizeof(char *)); /* can we trust image->ncolors */
    if (!header)
	return (XpmNoMemory);

    /* print the hints line */
    s = buf;
#ifndef VOID_SPRINTF
    s +=
#endif
    sprintf(s, ""%d %d %d %d"", image->width, image->height,
	    image->ncolors, image->cpp);
#ifdef VOID_SPRINTF
    s += strlen(s);
#endif

    if (info && (info->valuemask & XpmHotspot)) {
#ifndef VOID_SPRINTF
	s +=
#endif
	sprintf(s, "" %d %d"", info->x_hotspot, info->y_hotspot);
#ifdef VOID_SPRINTF
	s += strlen(s);
#endif
    }
    if (extensions) {
	strcpy(s, "" XPMEXT"");
	s += 7;
    }
    l = s - buf + 1;
    *header = (char *) XpmMalloc(l);
    if (!*header)
	RETURN(XpmNoMemory);
    header_size += l;
    strcpy(*header, buf);

    /* print colors */
    ErrorStatus = CreateColors(header + 1, &header_size,
			       image->colorTable, image->ncolors, image->cpp);

    if (ErrorStatus != XpmSuccess)
	RETURN(ErrorStatus);

    /* now we know the size needed, alloc the data and copy the header lines */
    offset = image->width * image->cpp + 1;

    if(offset <= image->width || offset <= image->cpp)
     if(offset <= image->width || offset <= image->cpp)
 	RETURN(XpmNoMemory);
 
    if (image->height > UINT_MAX - ext_nlines ||
	image->height + ext_nlines >= UINT_MAX / sizeof(char *))
 	RETURN(XpmNoMemory);
     data_size = (image->height + ext_nlines) * sizeof(char *);
 
	RETURN(XpmNoMemory);
    data_size += image->height * offset;
 	RETURN(XpmNoMemory);
     data_size += image->height * offset;
 
    if (header_size > UINT_MAX - ext_size ||
	header_size + ext_size >= (UINT_MAX - data_size) )
 	RETURN(XpmNoMemory);
     data_size += header_size + ext_size;
 

    data_nlines = header_nlines + image->height + ext_nlines;
    *data = (char *) (data + data_nlines);

    /* can header have less elements then n suggests? */
    n = image->ncolors;
    for (l = 0, sptr = data, sptr2 = header; l <= n && sptr && sptr2; l++, sptr++, sptr2++) {
	strcpy(*sptr, *sptr2);
	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
    }

    /* print pixels */
    data[header_nlines] = (char *) data + header_size
	+ (image->height + ext_nlines) * sizeof(char *);

    CreatePixels(data + header_nlines, data_size-header_nlines, image->width, image->height,
		 image->cpp, image->data, image->colorTable);

    /* print extensions */
    if (extensions)
	CreateExtensions(data + header_nlines + image->height - 1,
			 data_size - header_nlines - image->height + 1, offset,
			 info->extensions, info->nextensions,
			 ext_nlines);

    *data_return = data;
    ErrorStatus = XpmSuccess;

/* exit point, free only locally allocated variables */
exit:
    if (header) {
	for (l = 0; l < header_nlines; l++)
	    if (header[l])
		XpmFree(header[l]);
		XpmFree(header);
    }
    return(ErrorStatus);
}
","The vulnerability in the original code lies in the improper handling of memory allocation and size calculations, particularly in the checks for integer overflows when calculating `header_nlines`, `data_size`, and `offset`. For instance, the code does not adequately verify that `header_nlines` and `data_size` do not exceed `UINT_MAX`, which could lead to buffer overflows or memory corruption. The fixed code addresses these vulnerabilities by adding explicit checks for potential overflows, such as ensuring `image->height` and `ext_nlines` do not exceed `UINT_MAX` before performing calculations, thus enhancing the overall safety and stability of the memory management.","The vulnerability in the original code stems from inadequate checks for integer overflows during memory allocation and size calculations, which could lead to buffer overflows or memory corruption. Specifically, the code fails to ensure that calculated sizes do not exceed maximum allowable limits, potentially allowing for unsafe memory operations. The revised code mitigates this risk by implementing additional checks to verify that all size calculations remain within safe bounds before proceeding with memory allocation. This enhancement significantly improves the robustness of the code by preventing potential exploitation through improper memory handling.",1,4,4,4
13,13,180022,180022,,Local,Not required,Partial,CVE-2016-9755,https://www.cvedetails.com/cve/CVE-2016-9755/,CWE-787,Low,Partial,Partial,,2016-12-28,4.6,"The netfilter subsystem in the Linux kernel before 4.9 mishandles IPv6 reassembly, which allows local users to cause a denial of service (integer overflow, out-of-bounds write, and GPF) or possibly have unspecified other impact via a crafted application that makes socket, connect, and writev system calls, related to net/ipv6/netfilter/nf_conntrack_reasm.c and net/ipv6/netfilter/nf_defrag_ipv6_hooks.c.",2018-08-13,DoS Overflow ,2,https://github.com/torvalds/linux/commit/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,"netfilter: ipv6: nf_defrag: drop mangled skb on ream error

Dmitry Vyukov reported GPF in network stack that Andrey traced down to
negative nh offset in nf_ct_frag6_queue().

Problem is that all network headers before fragment header are pulled.
Normal ipv6 reassembly will drop the skb when errors occur further down
the line.

netfilter doesn't do this, and instead passed the original fragment
along.  That was also fine back when netfilter ipv6 defrag worked with
cloned fragments, as the original, pristine fragment was passed on.

So we either have to undo the pull op, or discard such fragments.
Since they're malformed after all (e.g. overlapping fragment) it seems
preferrable to just drop them.

Same for temporary errors -- it doesn't make sense to accept (and
perhaps forward!) only some fragments of same datagram.

Fixes: 029f7f3b8701cc7ac (""netfilter: ipv6: nf_defrag: avoid/free clone operations"")
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Debugged-by: Andrey Konovalov <andreyknvl@google.com>
Diagnosed-by: Eric Dumazet <Eric Dumazet <edumazet@google.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",2,net/ipv6/netfilter/nf_conntrack_reasm.c,"{""sha"": ""9948b5ce52dad3a823edede517f17069bd7226dc"", ""filename"": ""net/ipv6/netfilter/nf_conntrack_reasm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/nf_conntrack_reasm.c?ref=9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa"", ""patch"": ""@@ -576,11 +576,11 @@ int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n \t/* Jumbo payload inhibits frag. header */\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\""payload len = 0\\n\"");\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \t}\n \n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;""}<_**next**_>{""sha"": ""f06b0471f39fc0130f9db69e6c05330e8d5c6909"", ""filename"": ""net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c?ref=9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa"", ""patch"": ""@@ -69,7 +69,7 @@ static unsigned int ipv6_defrag(void *priv,\n \tif (err == -EINPROGRESS)\n \t\treturn NF_STOLEN;\n \n-\treturn NF_ACCEPT;\n+\treturn err == 0 ? NF_ACCEPT : NF_DROP;\n }\n \n static struct nf_hook_ops ipv6_defrag_ops[] = {""}","int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
{
	struct net_device *dev = skb->dev;
	int fhoff, nhoff, ret;
	struct frag_hdr *fhdr;
	struct frag_queue *fq;
	struct ipv6hdr *hdr;
	u8 prevhdr;

 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
		return 0;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;

	skb_set_transport_header(skb, fhoff);
	hdr = ipv6_hdr(skb);
	fhdr = (struct frag_hdr *)skb_transport_header(skb);

	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
	if (fq == NULL) {
		pr_debug(""Can't find and can't create new queue\n"");
		return -ENOMEM;
	}

	spin_lock_bh(&fq->q.lock);

	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
		ret = -EINVAL;
		goto out_unlock;
	}

	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
	 * must be returned.
	 */
	ret = -EINPROGRESS;
	if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
	    fq->q.meat == fq->q.len &&
	    nf_ct_frag6_reasm(fq, skb, dev))
		ret = 0;

out_unlock:
	spin_unlock_bh(&fq->q.lock);
	inet_frag_put(&fq->q, &nf_frags);
	return ret;
}
","int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
{
	struct net_device *dev = skb->dev;
	int fhoff, nhoff, ret;
	struct frag_hdr *fhdr;
	struct frag_queue *fq;
	struct ipv6hdr *hdr;
	u8 prevhdr;

 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
		return -EINVAL;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
		return -EINVAL;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;

	skb_set_transport_header(skb, fhoff);
	hdr = ipv6_hdr(skb);
	fhdr = (struct frag_hdr *)skb_transport_header(skb);

	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
	if (fq == NULL) {
		pr_debug(""Can't find and can't create new queue\n"");
		return -ENOMEM;
	}

	spin_lock_bh(&fq->q.lock);

	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
		ret = -EINVAL;
		goto out_unlock;
	}

	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
	 * must be returned.
	 */
	ret = -EINPROGRESS;
	if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
	    fq->q.meat == fq->q.len &&
	    nf_ct_frag6_reasm(fq, skb, dev))
		ret = 0;

out_unlock:
	spin_unlock_bh(&fq->q.lock);
	inet_frag_put(&fq->q, &nf_frags);
	return ret;
}
",C,"		return 0;
		return 0;
","		return -EINVAL;
		return -EINVAL;
",,"@@ -576,11 +576,11 @@ int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
-		return -EINVAL;
+		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
-		return -EINVAL;
+		return 0;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;",linux,9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,5173bc679dec881120df109a6a2b39143235382c,1,"int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
{
	struct net_device *dev = skb->dev;
	int fhoff, nhoff, ret;
	struct frag_hdr *fhdr;
	struct frag_queue *fq;
	struct ipv6hdr *hdr;
	u8 prevhdr;

 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
//flaw_line_below:
		return -EINVAL;
//fix_flaw_line_below:
//		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
//flaw_line_below:
		return -EINVAL;
//fix_flaw_line_below:
//		return 0;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;

	skb_set_transport_header(skb, fhoff);
	hdr = ipv6_hdr(skb);
	fhdr = (struct frag_hdr *)skb_transport_header(skb);

	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
	if (fq == NULL) {
		pr_debug(""Can't find and can't create new queue\n"");
		return -ENOMEM;
	}

	spin_lock_bh(&fq->q.lock);

	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
		ret = -EINVAL;
		goto out_unlock;
	}

	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
	 * must be returned.
	 */
	ret = -EINPROGRESS;
	if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
	    fq->q.meat == fq->q.len &&
	    nf_ct_frag6_reasm(fq, skb, dev))
		ret = 0;

out_unlock:
	spin_unlock_bh(&fq->q.lock);
	inet_frag_put(&fq->q, &nf_frags);
	return ret;
}
",180022,"int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
{
	struct net_device *dev = skb->dev;
	int fhoff, nhoff, ret;
	struct frag_hdr *fhdr;
	struct frag_queue *fq;
	struct ipv6hdr *hdr;
	u8 prevhdr;

 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
		return -EINVAL;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
		return -EINVAL;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;

	skb_set_transport_header(skb, fhoff);
	hdr = ipv6_hdr(skb);
	fhdr = (struct frag_hdr *)skb_transport_header(skb);

	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
	if (fq == NULL) {
		pr_debug(""Can't find and can't create new queue\n"");
		return -ENOMEM;
	}

	spin_lock_bh(&fq->q.lock);

	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
		ret = -EINVAL;
		goto out_unlock;
	}

	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
	 * must be returned.
	 */
	ret = -EINPROGRESS;
	if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
	    fq->q.meat == fq->q.len &&
	    nf_ct_frag6_reasm(fq, skb, dev))
		ret = 0;

out_unlock:
	spin_unlock_bh(&fq->q.lock);
	inet_frag_put(&fq->q, &nf_frags);
	return ret;
}
","int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
{
	struct net_device *dev = skb->dev;
	int fhoff, nhoff, ret;
	struct frag_hdr *fhdr;
	struct frag_queue *fq;
	struct ipv6hdr *hdr;
	u8 prevhdr;

 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
		return 0;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;

	skb_set_transport_header(skb, fhoff);
	hdr = ipv6_hdr(skb);
	fhdr = (struct frag_hdr *)skb_transport_header(skb);

	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
	if (fq == NULL) {
		pr_debug(""Can't find and can't create new queue\n"");
		return -ENOMEM;
	}

	spin_lock_bh(&fq->q.lock);

	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
		ret = -EINVAL;
		goto out_unlock;
	}

	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
	 * must be returned.
	 */
	ret = -EINPROGRESS;
	if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
	    fq->q.meat == fq->q.len &&
	    nf_ct_frag6_reasm(fq, skb, dev))
		ret = 0;

out_unlock:
	spin_unlock_bh(&fq->q.lock);
	inet_frag_put(&fq->q, &nf_frags);
	return ret;
}
","The vulnerability in the original code lies in the handling of the return values for the checks on `ipv6_hdr(skb)->payload_len` and `find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff)`. Returning `-EINVAL` in these cases could lead to improper error handling, potentially allowing the function to proceed with invalid data. In the fixed code, these return statements have been changed to return `0` instead, which indicates successful execution. This change prevents the function from erroneously signaling an error when it encounters a zero payload length or fails to find a previous fragment header, thus improving robustness.","The vulnerability in the original code arises from improper error handling when certain conditions are met, specifically when the payload length is zero or when a previous fragment header cannot be found. Returning an error code in these scenarios could lead to unintended behavior, allowing the function to continue processing with invalid or incomplete data. In the revised code, these return statements have been modified to indicate success instead of failure, ensuring that the function does not erroneously terminate due to these conditions. This change enhances the overall stability and reliability of the code by preventing premature exits.",3,5,3,4
14,14,180023,180023,,Local,Not required,Partial,CVE-2016-9755,https://www.cvedetails.com/cve/CVE-2016-9755/,CWE-787,Low,Partial,Partial,,2016-12-28,4.6,"The netfilter subsystem in the Linux kernel before 4.9 mishandles IPv6 reassembly, which allows local users to cause a denial of service (integer overflow, out-of-bounds write, and GPF) or possibly have unspecified other impact via a crafted application that makes socket, connect, and writev system calls, related to net/ipv6/netfilter/nf_conntrack_reasm.c and net/ipv6/netfilter/nf_defrag_ipv6_hooks.c.",2018-08-13,DoS Overflow ,1,https://github.com/torvalds/linux/commit/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,"netfilter: ipv6: nf_defrag: drop mangled skb on ream error

Dmitry Vyukov reported GPF in network stack that Andrey traced down to
negative nh offset in nf_ct_frag6_queue().

Problem is that all network headers before fragment header are pulled.
Normal ipv6 reassembly will drop the skb when errors occur further down
the line.

netfilter doesn't do this, and instead passed the original fragment
along.  That was also fine back when netfilter ipv6 defrag worked with
cloned fragments, as the original, pristine fragment was passed on.

So we either have to undo the pull op, or discard such fragments.
Since they're malformed after all (e.g. overlapping fragment) it seems
preferrable to just drop them.

Same for temporary errors -- it doesn't make sense to accept (and
perhaps forward!) only some fragments of same datagram.

Fixes: 029f7f3b8701cc7ac (""netfilter: ipv6: nf_defrag: avoid/free clone operations"")
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Debugged-by: Andrey Konovalov <andreyknvl@google.com>
Diagnosed-by: Eric Dumazet <Eric Dumazet <edumazet@google.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/ipv6/netfilter/nf_defrag_ipv6_hooks.c,"{""sha"": ""9948b5ce52dad3a823edede517f17069bd7226dc"", ""filename"": ""net/ipv6/netfilter/nf_conntrack_reasm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/nf_conntrack_reasm.c?ref=9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa"", ""patch"": ""@@ -576,11 +576,11 @@ int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n \t/* Jumbo payload inhibits frag. header */\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\""payload len = 0\\n\"");\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \t}\n \n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;""}<_**next**_>{""sha"": ""f06b0471f39fc0130f9db69e6c05330e8d5c6909"", ""filename"": ""net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c?ref=9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa"", ""patch"": ""@@ -69,7 +69,7 @@ static unsigned int ipv6_defrag(void *priv,\n \tif (err == -EINPROGRESS)\n \t\treturn NF_STOLEN;\n \n-\treturn NF_ACCEPT;\n+\treturn err == 0 ? NF_ACCEPT : NF_DROP;\n }\n \n static struct nf_hook_ops ipv6_defrag_ops[] = {""}","static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	/* Previously seen (loopback)?	*/
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	/* queued */
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
","static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	/* Previously seen (loopback)?	*/
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	/* queued */
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
	return NF_ACCEPT;
 }
",C,"	return err == 0 ? NF_ACCEPT : NF_DROP;
","	return NF_ACCEPT;
",,"@@ -69,7 +69,7 @@ static unsigned int ipv6_defrag(void *priv,
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
-	return NF_ACCEPT;
+	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
 
 static struct nf_hook_ops ipv6_defrag_ops[] = {",linux,9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,5173bc679dec881120df109a6a2b39143235382c,1,"static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	/* Previously seen (loopback)?	*/
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	/* queued */
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
//flaw_line_below:
	return NF_ACCEPT;
//fix_flaw_line_below:
//	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
",180023,"static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	/* Previously seen (loopback)?	*/
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	/* queued */
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
	return NF_ACCEPT;
 }
","static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	/* Previously seen (loopback)?	*/
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	/* queued */
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
","The vulnerability in the original code lies in the return statement, which always returns `NF_ACCEPT` if the fragmentation gathering process does not indicate an in-progress state (`-EINPROGRESS`). This could lead to accepting packets that should be dropped due to fragmentation issues. In the fixed code, the return statement has been modified to check the value of `err`. Now, it returns `NF_ACCEPT` only if `err` is zero, indicating successful processing; otherwise, it returns `NF_DROP`, effectively preventing the acceptance of problematic packets and enhancing the robustness of the IPv6 defragmentation process.","The vulnerability in the original code stems from its unconditional acceptance of packets, regardless of whether fragmentation processing was successful. This could allow malformed or incomplete packets to be processed, potentially leading to security issues or system instability. The fix addresses this by introducing a conditional check that evaluates the outcome of the fragmentation gathering process. Now, the code only accepts packets if the processing is successful, while any errors result in the packets being dropped. This change enhances the overall security and reliability of the packet handling mechanism by ensuring that only valid packets are accepted.",1,4,4,1
15,15,180821,180821,,Local,Not required,Complete,CVE-2017-17806,https://www.cvedetails.com/cve/CVE-2017-17806/,CWE-787,Low,Complete,Complete,,2017-12-20,7.2,"The HMAC implementation (crypto/hmac.c) in the Linux kernel before 4.14.8 does not validate that the underlying cryptographic hash algorithm is unkeyed, allowing a local attacker able to use the AF_ALG-based hash interface (CONFIG_CRYPTO_USER_API_HASH) and the SHA-3 hash algorithm (CONFIG_CRYPTO_SHA3) to cause a kernel stack buffer overflow by executing a crafted sequence of system calls that encounter a missing SHA-3 initialization.",2019-10-02,Overflow ,5,https://github.com/torvalds/linux/commit/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,"crypto: hmac - require that the underlying hash algorithm is unkeyed

Because the HMAC template didn't check that its underlying hash
algorithm is unkeyed, trying to use ""hmac(hmac(sha3-512-generic))""
through AF_ALG or through KEYCTL_DH_COMPUTE resulted in the inner HMAC
being used without having been keyed, resulting in sha3_update() being
called without sha3_init(), causing a stack buffer overflow.

This is a very old bug, but it seems to have only started causing real
problems when SHA-3 support was added (requires CONFIG_CRYPTO_SHA3)
because the innermost hash's state is ->import()ed from a zeroed buffer,
and it just so happens that other hash algorithms are fine with that,
but SHA-3 is not.  However, there could be arch or hardware-dependent
hash algorithms also affected; I couldn't test everything.

Fix the bug by introducing a function crypto_shash_alg_has_setkey()
which tests whether a shash algorithm is keyed.  Then update the HMAC
template to require that its underlying hash algorithm is unkeyed.

Here is a reproducer:

    #include <linux/if_alg.h>
    #include <sys/socket.h>

    int main()
    {
        int algfd;
        struct sockaddr_alg addr = {
            .salg_type = ""hash"",
            .salg_name = ""hmac(hmac(sha3-512-generic))"",
        };
        char key[4096] = { 0 };

        algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
        bind(algfd, (const struct sockaddr *)&addr, sizeof(addr));
        setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));
    }

Here was the KASAN report from syzbot:

    BUG: KASAN: stack-out-of-bounds in memcpy include/linux/string.h:341  [inline]
    BUG: KASAN: stack-out-of-bounds in sha3_update+0xdf/0x2e0  crypto/sha3_generic.c:161
    Write of size 4096 at addr ffff8801cca07c40 by task syzkaller076574/3044

    CPU: 1 PID: 3044 Comm: syzkaller076574 Not tainted 4.14.0-mm1+ #25
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS  Google 01/01/2011
    Call Trace:
      __dump_stack lib/dump_stack.c:17 [inline]
      dump_stack+0x194/0x257 lib/dump_stack.c:53
      print_address_description+0x73/0x250 mm/kasan/report.c:252
      kasan_report_error mm/kasan/report.c:351 [inline]
      kasan_report+0x25b/0x340 mm/kasan/report.c:409
      check_memory_region_inline mm/kasan/kasan.c:260 [inline]
      check_memory_region+0x137/0x190 mm/kasan/kasan.c:267
      memcpy+0x37/0x50 mm/kasan/kasan.c:303
      memcpy include/linux/string.h:341 [inline]
      sha3_update+0xdf/0x2e0 crypto/sha3_generic.c:161
      crypto_shash_update+0xcb/0x220 crypto/shash.c:109
      shash_finup_unaligned+0x2a/0x60 crypto/shash.c:151
      crypto_shash_finup+0xc4/0x120 crypto/shash.c:165
      hmac_finup+0x182/0x330 crypto/hmac.c:152
      crypto_shash_finup+0xc4/0x120 crypto/shash.c:165
      shash_digest_unaligned+0x9e/0xd0 crypto/shash.c:172
      crypto_shash_digest+0xc4/0x120 crypto/shash.c:186
      hmac_setkey+0x36a/0x690 crypto/hmac.c:66
      crypto_shash_setkey+0xad/0x190 crypto/shash.c:64
      shash_async_setkey+0x47/0x60 crypto/shash.c:207
      crypto_ahash_setkey+0xaf/0x180 crypto/ahash.c:200
      hash_setkey+0x40/0x90 crypto/algif_hash.c:446
      alg_setkey crypto/af_alg.c:221 [inline]
      alg_setsockopt+0x2a1/0x350 crypto/af_alg.c:254
      SYSC_setsockopt net/socket.c:1851 [inline]
      SyS_setsockopt+0x189/0x360 net/socket.c:1830
      entry_SYSCALL_64_fastpath+0x1f/0x96

Reported-by: syzbot <syzkaller@googlegroups.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/hmac.c,"{""sha"": ""e74730224f0a5f6346bb8ae7b80f3ed5e6cb6281"", ""filename"": ""crypto/hmac.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/crypto/hmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/crypto/hmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/hmac.c?ref=af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1"", ""patch"": ""@@ -195,11 +195,15 @@ static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n \tsalg = shash_attr_alg(tb[1], 0, 0);\n \tif (IS_ERR(salg))\n \t\treturn PTR_ERR(salg);\n+\talg = &salg->base;\n \n+\t/* The underlying hash algorithm must be unkeyed */\n \terr = -EINVAL;\n+\tif (crypto_shash_alg_has_setkey(salg))\n+\t\tgoto out_put_alg;\n+\n \tds = salg->digestsize;\n \tss = salg->statesize;\n-\talg = &salg->base;\n \tif (ds > alg->cra_blocksize ||\n \t    ss < alg->cra_blocksize)\n \t\tgoto out_put_alg;""}<_**next**_>{""sha"": ""e849d3ee2e2728d346df1f21f6a8d4db57fc42c5"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1"", ""patch"": ""@@ -25,11 +25,12 @@\n \n static const struct crypto_type crypto_shash_type;\n \n-static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n-\t\t\t   unsigned int keylen)\n+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n+\t\t    unsigned int keylen)\n {\n \treturn -ENOSYS;\n }\n+EXPORT_SYMBOL_GPL(shash_no_setkey);\n \n static int shash_setkey_unaligned(struct crypto_shash *tfm, const u8 *key,\n \t\t\t\t  unsigned int keylen)""}<_**next**_>{""sha"": ""c2bae8da642cbaef97f3de444a446a27df15dc18"", ""filename"": ""include/crypto/internal/hash.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/include/crypto/internal/hash.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1/include/crypto/internal/hash.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/hash.h?ref=af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1"", ""patch"": ""@@ -82,6 +82,14 @@ int ahash_register_instance(struct crypto_template *tmpl,\n \t\t\t    struct ahash_instance *inst);\n void ahash_free_instance(struct crypto_instance *inst);\n \n+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n+\t\t    unsigned int keylen);\n+\n+static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)\n+{\n+\treturn alg->setkey != shash_no_setkey;\n+}\n+\n int crypto_init_ahash_spawn(struct crypto_ahash_spawn *spawn,\n \t\t\t    struct hash_alg_common *alg,\n \t\t\t    struct crypto_instance *inst);""}","static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct shash_instance *inst;
	struct crypto_alg *alg;
	struct shash_alg *salg;
	int err;
	int ds;
	int ss;

	err = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);
	if (err)
		return err;

 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
	alg = &salg->base;
 
	/* The underlying hash algorithm must be unkeyed */
 	err = -EINVAL;
	if (crypto_shash_alg_has_setkey(salg))
		goto out_put_alg;

 	ds = salg->digestsize;
 	ss = salg->statesize;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;

	inst = shash_alloc_instance(""hmac"", alg);
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	err = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,
				      shash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	inst->alg.base.cra_priority = alg->cra_priority;
	inst->alg.base.cra_blocksize = alg->cra_blocksize;
	inst->alg.base.cra_alignmask = alg->cra_alignmask;

	ss = ALIGN(ss, alg->cra_alignmask + 1);
	inst->alg.digestsize = ds;
	inst->alg.statesize = ss;

	inst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +
				     ALIGN(ss * 2, crypto_tfm_ctx_alignment());

	inst->alg.base.cra_init = hmac_init_tfm;
	inst->alg.base.cra_exit = hmac_exit_tfm;

	inst->alg.init = hmac_init;
	inst->alg.update = hmac_update;
	inst->alg.final = hmac_final;
	inst->alg.finup = hmac_finup;
	inst->alg.export = hmac_export;
	inst->alg.import = hmac_import;
	inst->alg.setkey = hmac_setkey;

	err = shash_register_instance(tmpl, inst);
	if (err) {
out_free_inst:
		shash_free_instance(shash_crypto_instance(inst));
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
","static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct shash_instance *inst;
	struct crypto_alg *alg;
	struct shash_alg *salg;
	int err;
	int ds;
	int ss;

	err = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);
	if (err)
		return err;

 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
 
 	err = -EINVAL;
 	ds = salg->digestsize;
 	ss = salg->statesize;
	alg = &salg->base;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;

	inst = shash_alloc_instance(""hmac"", alg);
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	err = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,
				      shash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	inst->alg.base.cra_priority = alg->cra_priority;
	inst->alg.base.cra_blocksize = alg->cra_blocksize;
	inst->alg.base.cra_alignmask = alg->cra_alignmask;

	ss = ALIGN(ss, alg->cra_alignmask + 1);
	inst->alg.digestsize = ds;
	inst->alg.statesize = ss;

	inst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +
				     ALIGN(ss * 2, crypto_tfm_ctx_alignment());

	inst->alg.base.cra_init = hmac_init_tfm;
	inst->alg.base.cra_exit = hmac_exit_tfm;

	inst->alg.init = hmac_init;
	inst->alg.update = hmac_update;
	inst->alg.final = hmac_final;
	inst->alg.finup = hmac_finup;
	inst->alg.export = hmac_export;
	inst->alg.import = hmac_import;
	inst->alg.setkey = hmac_setkey;

	err = shash_register_instance(tmpl, inst);
	if (err) {
out_free_inst:
		shash_free_instance(shash_crypto_instance(inst));
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
",C,"	alg = &salg->base;
	/* The underlying hash algorithm must be unkeyed */
	if (crypto_shash_alg_has_setkey(salg))
		goto out_put_alg;

","	alg = &salg->base;
",,"@@ -195,11 +195,15 @@ static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
+	alg = &salg->base;
 
+	/* The underlying hash algorithm must be unkeyed */
 	err = -EINVAL;
+	if (crypto_shash_alg_has_setkey(salg))
+		goto out_put_alg;
+
 	ds = salg->digestsize;
 	ss = salg->statesize;
-	alg = &salg->base;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;",linux,af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,887207ed9e5812ed9239b6d07185a2d35dda91db,1,"static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct shash_instance *inst;
	struct crypto_alg *alg;
	struct shash_alg *salg;
	int err;
	int ds;
	int ss;

	err = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);
	if (err)
		return err;

 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
//fix_flaw_line_below:
//	alg = &salg->base;
 
//fix_flaw_line_below:
//	/* The underlying hash algorithm must be unkeyed */
 	err = -EINVAL;
//fix_flaw_line_below:
//	if (crypto_shash_alg_has_setkey(salg))
//fix_flaw_line_below:
//		goto out_put_alg;
//fix_flaw_line_below:
//
 	ds = salg->digestsize;
 	ss = salg->statesize;
//flaw_line_below:
	alg = &salg->base;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;

	inst = shash_alloc_instance(""hmac"", alg);
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	err = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,
				      shash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	inst->alg.base.cra_priority = alg->cra_priority;
	inst->alg.base.cra_blocksize = alg->cra_blocksize;
	inst->alg.base.cra_alignmask = alg->cra_alignmask;

	ss = ALIGN(ss, alg->cra_alignmask + 1);
	inst->alg.digestsize = ds;
	inst->alg.statesize = ss;

	inst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +
				     ALIGN(ss * 2, crypto_tfm_ctx_alignment());

	inst->alg.base.cra_init = hmac_init_tfm;
	inst->alg.base.cra_exit = hmac_exit_tfm;

	inst->alg.init = hmac_init;
	inst->alg.update = hmac_update;
	inst->alg.final = hmac_final;
	inst->alg.finup = hmac_finup;
	inst->alg.export = hmac_export;
	inst->alg.import = hmac_import;
	inst->alg.setkey = hmac_setkey;

	err = shash_register_instance(tmpl, inst);
	if (err) {
out_free_inst:
		shash_free_instance(shash_crypto_instance(inst));
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
",180821,"static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct shash_instance *inst;
	struct crypto_alg *alg;
	struct shash_alg *salg;
	int err;
	int ds;
	int ss;

	err = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);
	if (err)
		return err;

 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
 
 	err = -EINVAL;
 	ds = salg->digestsize;
 	ss = salg->statesize;
	alg = &salg->base;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;

	inst = shash_alloc_instance(""hmac"", alg);
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	err = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,
				      shash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	inst->alg.base.cra_priority = alg->cra_priority;
	inst->alg.base.cra_blocksize = alg->cra_blocksize;
	inst->alg.base.cra_alignmask = alg->cra_alignmask;

	ss = ALIGN(ss, alg->cra_alignmask + 1);
	inst->alg.digestsize = ds;
	inst->alg.statesize = ss;

	inst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +
				     ALIGN(ss * 2, crypto_tfm_ctx_alignment());

	inst->alg.base.cra_init = hmac_init_tfm;
	inst->alg.base.cra_exit = hmac_exit_tfm;

	inst->alg.init = hmac_init;
	inst->alg.update = hmac_update;
	inst->alg.final = hmac_final;
	inst->alg.finup = hmac_finup;
	inst->alg.export = hmac_export;
	inst->alg.import = hmac_import;
	inst->alg.setkey = hmac_setkey;

	err = shash_register_instance(tmpl, inst);
	if (err) {
out_free_inst:
		shash_free_instance(shash_crypto_instance(inst));
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
","static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct shash_instance *inst;
	struct crypto_alg *alg;
	struct shash_alg *salg;
	int err;
	int ds;
	int ss;

	err = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);
	if (err)
		return err;

 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
	alg = &salg->base;
 
	/* The underlying hash algorithm must be unkeyed */
 	err = -EINVAL;
	if (crypto_shash_alg_has_setkey(salg))
		goto out_put_alg;

 	ds = salg->digestsize;
 	ss = salg->statesize;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;

	inst = shash_alloc_instance(""hmac"", alg);
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	err = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,
				      shash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	inst->alg.base.cra_priority = alg->cra_priority;
	inst->alg.base.cra_blocksize = alg->cra_blocksize;
	inst->alg.base.cra_alignmask = alg->cra_alignmask;

	ss = ALIGN(ss, alg->cra_alignmask + 1);
	inst->alg.digestsize = ds;
	inst->alg.statesize = ss;

	inst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +
				     ALIGN(ss * 2, crypto_tfm_ctx_alignment());

	inst->alg.base.cra_init = hmac_init_tfm;
	inst->alg.base.cra_exit = hmac_exit_tfm;

	inst->alg.init = hmac_init;
	inst->alg.update = hmac_update;
	inst->alg.final = hmac_final;
	inst->alg.finup = hmac_finup;
	inst->alg.export = hmac_export;
	inst->alg.import = hmac_import;
	inst->alg.setkey = hmac_setkey;

	err = shash_register_instance(tmpl, inst);
	if (err) {
out_free_inst:
		shash_free_instance(shash_crypto_instance(inst));
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
","The vulnerability in the original code stemmed from the lack of validation to ensure that the underlying hash algorithm was unkeyed before proceeding with HMAC creation. Specifically, the absence of a check for `crypto_shash_alg_has_setkey(salg)` allowed the use of keyed hash algorithms, which could lead to security issues. The fixed code addresses this vulnerability by introducing a validation step that checks if the algorithm supports a key using `crypto_shash_alg_has_setkey(salg)`. If it does, the function exits early, preventing the creation of an HMAC instance with an inappropriate algorithm.","The vulnerability in the original code arose from the lack of a check to ensure that the underlying hash algorithm was unkeyed, which could allow the use of inappropriate algorithms for HMAC creation. This oversight posed a security risk, as it could lead to the use of keyed hash algorithms that are not suitable for HMAC operations. The revised code rectifies this issue by implementing a validation step that verifies whether the algorithm supports a key. If it does, the function exits early, thereby preventing the creation of an HMAC instance with an unsuitable algorithm.",2,5,4,4
16,16,180951,180951,,Remote,Not required,Partial,CVE-2017-14041,https://www.cvedetails.com/cve/CVE-2017-14041/,CWE-787,Medium,Partial,Partial,,2017-08-30,6.8,"A stack-based buffer overflow was discovered in the pgxtoimage function in bin/jp2/convert.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.",2017-11-05,DoS Exec Code Overflow ,1,https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,pgxtoimage(): fix write stack buffer overflow (#997),1,src/bin/jp2/convert.c,"{""sha"": ""e606c9be70fb55d4a231a7675c55e00c2b9daac6"", ""filename"": ""src/bin/jp2/convert.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/uclouvain/openjpeg/blob/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9/src/bin/jp2/convert.c"", ""raw_url"": ""https://github.com/uclouvain/openjpeg/raw/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9/src/bin/jp2/convert.c"", ""contents_url"": ""https://api.github.com/repos/uclouvain/openjpeg/contents/src/bin/jp2/convert.c?ref=e5285319229a5d77bf316bb0d3a6cbd3cb8666d9"", ""patch"": ""@@ -1185,7 +1185,7 @@ opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n     }\n \n     fseek(f, 0, SEEK_SET);\n-    if (fscanf(f, \""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\"", temp, &endian1,\n+    if (fscanf(f, \""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\"", temp, &endian1,\n                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {\n         fclose(f);\n         fprintf(stderr,""}","opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
     }
 
     fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}
","opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
     }
 
     fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}
",C,"    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
","    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
",,"@@ -1185,7 +1185,7 @@ opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
     }
 
     fseek(f, 0, SEEK_SET);
-    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
+    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,",openjpeg,e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,5597522cac96b1bc6d48a447751b1c6049248eef,1,"opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
     }
 
     fseek(f, 0, SEEK_SET);
//flaw_line_below:
    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
//fix_flaw_line_below:
//    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}
",180951,"opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
     }
 
     fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}
","opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, prec;
    int i, numcomps, max;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int bigendian;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    max = 0;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !\n"", filename);
        return NULL;
     }
 
     fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,
                ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        bigendian = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        bigendian = 0;
    } else {
        fclose(f);
        fprintf(stderr, ""Bad pgx header, please check input file\n"");
        return NULL;
    }

    /* initialize image component */

    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (prec < 8) {
        force8 = 1;
        ushift = 8 - prec;
        dshift = prec - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (prec - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        prec = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)prec;
    cmptparm.bpp = (OPJ_UINT32)prec;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }
    /* set image offset and reference grid */
    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;

    /* set image data */

    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int v;
        if (force8) {
            v = readuchar(f) + adjustS;
            v = (v << ushift) + (v >> dshift);
            comp->data[i] = (unsigned char)v;

            if (v > max) {
                max = v;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                v = readuchar(f);
            } else {
                v = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                v = readushort(f, bigendian);
            } else {
                v = (short) readushort(f, bigendian);
            }
        } else {
            if (!comp->sgnd) {
                v = (int)readuint(f, bigendian);
            } else {
                v = (int) readuint(f, bigendian);
            }
        }
        if (v > max) {
            max = v;
        }
        comp->data[i] = v;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;

    return image;
}
","The vulnerability in the original code arises from the use of `fscanf` with the format string `""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d""` without proper size limits on the input buffers, particularly `temp` and `signtmp`. This can lead to buffer overflows if the input exceeds the allocated size of these arrays. The fixed code addresses this vulnerability by modifying the format string to include size specifiers, such as `%31[ \t]`, which limits the number of characters read into `temp` and `signtmp`, thus preventing potential buffer overflow attacks.","The vulnerability in the original code stems from the lack of size limits in the input reading function, which can lead to buffer overflows if the input exceeds the allocated memory for certain buffers. This can allow an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution or crashes. The fixed code mitigates this risk by incorporating size specifiers in the input format string, ensuring that the number of characters read into the buffers does not exceed their allocated sizes. This change effectively prevents buffer overflow vulnerabilities and enhances the overall security of the code.",4,5,5,4
17,17,180954,180954,,Remote,Not required,Partial,CVE-2017-14040,https://www.cvedetails.com/cve/CVE-2017-14040/,CWE-787,Medium,Partial,Partial,,2017-08-30,6.8,"An invalid write access was discovered in bin/jp2/convert.c in OpenJPEG 2.2.0, triggering a crash in the tgatoimage function. The vulnerability may lead to remote denial of service or possibly unspecified other impact.",2017-11-05,DoS ,18,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2cd30c2b06ce332dede81cccad8b334cde997281,"tgatoimage(): avoid excessive memory allocation attempt, and fixes unaligned load (#995)",0,src/bin/jp2/convert.c,"{""sha"": ""73dfc8d5fd79adc6238ca0923b179c0cad15263c"", ""filename"": ""src/bin/jp2/convert.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 12, ""changes"": 39, ""blob_url"": ""https://github.com/uclouvain/openjpeg/blob/2cd30c2b06ce332dede81cccad8b334cde997281/src/bin/jp2/convert.c"", ""raw_url"": ""https://github.com/uclouvain/openjpeg/raw/2cd30c2b06ce332dede81cccad8b334cde997281/src/bin/jp2/convert.c"", ""contents_url"": ""https://api.github.com/repos/uclouvain/openjpeg/contents/src/bin/jp2/convert.c?ref=2cd30c2b06ce332dede81cccad8b334cde997281"", ""patch"": ""@@ -580,13 +580,10 @@ struct tga_header {\n };\n #endif /* INFORMATION_ONLY */\n \n-static unsigned short get_ushort(const unsigned char *data)\n+/* Returns a ushort from a little-endian serialized value */\n+static unsigned short get_tga_ushort(const unsigned char *data)\n {\n-    unsigned short val = *(const unsigned short *)data;\n-#ifdef OPJ_BIG_ENDIAN\n-    val = ((val & 0xffU) << 8) | (val >> 8);\n-#endif\n-    return val;\n+    return data[0] | (data[1] << 8);\n }\n \n #define TGA_HEADER_SIZE 18\n@@ -613,17 +610,17 @@ static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n     id_len = tga[0];\n     /*cmap_type = tga[1];*/\n     image_type = tga[2];\n-    /*cmap_index = get_ushort(&tga[3]);*/\n-    cmap_len = get_ushort(&tga[5]);\n+    /*cmap_index = get_tga_ushort(&tga[3]);*/\n+    cmap_len = get_tga_ushort(&tga[5]);\n     cmap_entry_size = tga[7];\n \n \n #if 0\n-    x_origin = get_ushort(&tga[8]);\n-    y_origin = get_ushort(&tga[10]);\n+    x_origin = get_tga_ushort(&tga[8]);\n+    y_origin = get_tga_ushort(&tga[10]);\n #endif\n-    image_w = get_ushort(&tga[12]);\n-    image_h = get_ushort(&tga[14]);\n+    image_w = get_tga_ushort(&tga[12]);\n+    image_h = get_tga_ushort(&tga[14]);\n     pixel_depth = tga[16];\n     image_desc  = tga[17];\n \n@@ -817,6 +814,24 @@ opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)\n         color_space = OPJ_CLRSPC_SRGB;\n     }\n \n+    /* If the declared file size is > 10 MB, check that the file is big */\n+    /* enough to avoid excessive memory allocations */\n+    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {\n+        char ch;\n+        OPJ_UINT64 expected_file_size =\n+            (OPJ_UINT64)image_width * image_height * numcomps;\n+        long curpos = ftell(f);\n+        if (expected_file_size > (OPJ_UINT64)INT_MAX) {\n+            expected_file_size = (OPJ_UINT64)INT_MAX;\n+        }\n+        fseek(f, (long)expected_file_size - 1, SEEK_SET);\n+        if (fread(&ch, 1, 1, f) != 1) {\n+            fclose(f);\n+            return NULL;\n+        }\n+        fseek(f, curpos, SEEK_SET);\n+    }\n+\n     subsampling_dx = parameters->subsampling_dx;\n     subsampling_dy = parameters->subsampling_dy;\n ""}","opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int flip_image = 0;
    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int subsampling_dx, subsampling_dy;
    int i;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !!\n"", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &flip_image)) {
        fclose(f);
        return NULL;
    }

    /* We currently only support 24 & 32 bit tga's ... */
    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }

    /* initialize image components */
    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);  /* Mono with & without alpha. */
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
         color_space = OPJ_CLRSPC_SRGB;
     }
 
    /* If the declared file size is > 10 MB, check that the file is big */
    /* enough to avoid excessive memory allocations */
    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
        char ch;
        OPJ_UINT64 expected_file_size =
            (OPJ_UINT64)image_width * image_height * numcomps;
        long curpos = ftell(f);
        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
            expected_file_size = (OPJ_UINT64)INT_MAX;
        }
        fseek(f, (long)expected_file_size - 1, SEEK_SET);
        if (fread(&ch, 1, 1, f) != 1) {
            fclose(f);
            return NULL;
        }
        fseek(f, curpos, SEEK_SET);
    }

     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;
        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }


    /* set image offset and reference grid */
    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1;

    /* set image data */
    for (y = 0; y < image_height; y++) {
        int index;

        if (flip_image) {
            index = (int)((image_height - y - 1) * image_width);
        } else {
            index = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                index++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, a;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&a, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                image->comps[3].data[index] = a;
                index++;
            }
        } else {
            fprintf(stderr, ""Currently unsupported bit depth : %s\n"", filename);
        }
    }
    fclose(f);
    return image;
}
","opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int flip_image = 0;
    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int subsampling_dx, subsampling_dy;
    int i;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !!\n"", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &flip_image)) {
        fclose(f);
        return NULL;
    }

    /* We currently only support 24 & 32 bit tga's ... */
    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }

    /* initialize image components */
    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);  /* Mono with & without alpha. */
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
         color_space = OPJ_CLRSPC_SRGB;
     }
 
     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;
        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }


    /* set image offset and reference grid */
    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1;

    /* set image data */
    for (y = 0; y < image_height; y++) {
        int index;

        if (flip_image) {
            index = (int)((image_height - y - 1) * image_width);
        } else {
            index = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                index++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, a;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&a, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                image->comps[3].data[index] = a;
                index++;
            }
        } else {
            fprintf(stderr, ""Currently unsupported bit depth : %s\n"", filename);
        }
    }
    fclose(f);
    return image;
}
",C,"    /* If the declared file size is > 10 MB, check that the file is big */
    /* enough to avoid excessive memory allocations */
    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
        char ch;
        OPJ_UINT64 expected_file_size =
            (OPJ_UINT64)image_width * image_height * numcomps;
        long curpos = ftell(f);
        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
            expected_file_size = (OPJ_UINT64)INT_MAX;
        }
        fseek(f, (long)expected_file_size - 1, SEEK_SET);
        if (fread(&ch, 1, 1, f) != 1) {
            fclose(f);
            return NULL;
        }
        fseek(f, curpos, SEEK_SET);
    }

",,,"@@ -580,13 +580,10 @@ struct tga_header {
 };
 #endif /* INFORMATION_ONLY */
 
-static unsigned short get_ushort(const unsigned char *data)
+/* Returns a ushort from a little-endian serialized value */
+static unsigned short get_tga_ushort(const unsigned char *data)
 {
-    unsigned short val = *(const unsigned short *)data;
-#ifdef OPJ_BIG_ENDIAN
-    val = ((val & 0xffU) << 8) | (val >> 8);
-#endif
-    return val;
+    return data[0] | (data[1] << 8);
 }
 
 #define TGA_HEADER_SIZE 18
@@ -613,17 +610,17 @@ static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,
     id_len = tga[0];
     /*cmap_type = tga[1];*/
     image_type = tga[2];
-    /*cmap_index = get_ushort(&tga[3]);*/
-    cmap_len = get_ushort(&tga[5]);
+    /*cmap_index = get_tga_ushort(&tga[3]);*/
+    cmap_len = get_tga_ushort(&tga[5]);
     cmap_entry_size = tga[7];
 
 
 #if 0
-    x_origin = get_ushort(&tga[8]);
-    y_origin = get_ushort(&tga[10]);
+    x_origin = get_tga_ushort(&tga[8]);
+    y_origin = get_tga_ushort(&tga[10]);
 #endif
-    image_w = get_ushort(&tga[12]);
-    image_h = get_ushort(&tga[14]);
+    image_w = get_tga_ushort(&tga[12]);
+    image_h = get_tga_ushort(&tga[14]);
     pixel_depth = tga[16];
     image_desc  = tga[17];
 
@@ -817,6 +814,24 @@ opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
         color_space = OPJ_CLRSPC_SRGB;
     }
 
+    /* If the declared file size is > 10 MB, check that the file is big */
+    /* enough to avoid excessive memory allocations */
+    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
+        char ch;
+        OPJ_UINT64 expected_file_size =
+            (OPJ_UINT64)image_width * image_height * numcomps;
+        long curpos = ftell(f);
+        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
+            expected_file_size = (OPJ_UINT64)INT_MAX;
+        }
+        fseek(f, (long)expected_file_size - 1, SEEK_SET);
+        if (fread(&ch, 1, 1, f) != 1) {
+            fclose(f);
+            return NULL;
+        }
+        fseek(f, curpos, SEEK_SET);
+    }
+
     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 ",openjpeg,2cd30c2b06ce332dede81cccad8b334cde997281,09e83407fa2b53c606d3179031b8d8b31272e20c,1,"opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int flip_image = 0;
    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int subsampling_dx, subsampling_dy;
    int i;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !!\n"", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &flip_image)) {
        fclose(f);
        return NULL;
    }

    /* We currently only support 24 & 32 bit tga's ... */
    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }

    /* initialize image components */
    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);  /* Mono with & without alpha. */
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
         color_space = OPJ_CLRSPC_SRGB;
     }
 
//fix_flaw_line_below:
//    /* If the declared file size is > 10 MB, check that the file is big */
//fix_flaw_line_below:
//    /* enough to avoid excessive memory allocations */
//fix_flaw_line_below:
//    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
//fix_flaw_line_below:
//        char ch;
//fix_flaw_line_below:
//        OPJ_UINT64 expected_file_size =
//fix_flaw_line_below:
//            (OPJ_UINT64)image_width * image_height * numcomps;
//fix_flaw_line_below:
//        long curpos = ftell(f);
//fix_flaw_line_below:
//        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
//fix_flaw_line_below:
//            expected_file_size = (OPJ_UINT64)INT_MAX;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//        fseek(f, (long)expected_file_size - 1, SEEK_SET);
//fix_flaw_line_below:
//        if (fread(&ch, 1, 1, f) != 1) {
//fix_flaw_line_below:
//            fclose(f);
//fix_flaw_line_below:
//            return NULL;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//        fseek(f, curpos, SEEK_SET);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;
        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }


    /* set image offset and reference grid */
    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1;

    /* set image data */
    for (y = 0; y < image_height; y++) {
        int index;

        if (flip_image) {
            index = (int)((image_height - y - 1) * image_width);
        } else {
            index = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                index++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, a;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&a, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                image->comps[3].data[index] = a;
                index++;
            }
        } else {
            fprintf(stderr, ""Currently unsupported bit depth : %s\n"", filename);
        }
    }
    fclose(f);
    return image;
}
",180954,"opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int flip_image = 0;
    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int subsampling_dx, subsampling_dy;
    int i;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !!\n"", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &flip_image)) {
        fclose(f);
        return NULL;
    }

    /* We currently only support 24 & 32 bit tga's ... */
    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }

    /* initialize image components */
    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);  /* Mono with & without alpha. */
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
         color_space = OPJ_CLRSPC_SRGB;
     }
 
     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;
        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }


    /* set image offset and reference grid */
    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1;

    /* set image data */
    for (y = 0; y < image_height; y++) {
        int index;

        if (flip_image) {
            index = (int)((image_height - y - 1) * image_width);
        } else {
            index = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                index++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, a;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&a, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                image->comps[3].data[index] = a;
                index++;
            }
        } else {
            fprintf(stderr, ""Currently unsupported bit depth : %s\n"", filename);
        }
    }
    fclose(f);
    return image;
}
","opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int flip_image = 0;
    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int subsampling_dx, subsampling_dy;
    int i;

    f = fopen(filename, ""rb"");
    if (!f) {
        fprintf(stderr, ""Failed to open %s for reading !!\n"", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &flip_image)) {
        fclose(f);
        return NULL;
    }

    /* We currently only support 24 & 32 bit tga's ... */
    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }

    /* initialize image components */
    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);  /* Mono with & without alpha. */
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
         color_space = OPJ_CLRSPC_SRGB;
     }
 
    /* If the declared file size is > 10 MB, check that the file is big */
    /* enough to avoid excessive memory allocations */
    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
        char ch;
        OPJ_UINT64 expected_file_size =
            (OPJ_UINT64)image_width * image_height * numcomps;
        long curpos = ftell(f);
        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
            expected_file_size = (OPJ_UINT64)INT_MAX;
        }
        fseek(f, (long)expected_file_size - 1, SEEK_SET);
        if (fread(&ch, 1, 1, f) != 1) {
            fclose(f);
            return NULL;
        }
        fseek(f, curpos, SEEK_SET);
    }

     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;
        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }

    /* create the image */
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }


    /* set image offset and reference grid */
    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *
                (OPJ_UINT32)subsampling_dx + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)subsampling_dy + 1;

    /* set image data */
    for (y = 0; y < image_height; y++) {
        int index;

        if (flip_image) {
            index = (int)((image_height - y - 1) * image_width);
        } else {
            index = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                index++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, a;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&a, 1, 1, f)) {
                    fprintf(stderr,
                            ""\nError: fread return a number of element different from the expected.\n"");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[index] = r;
                image->comps[1].data[index] = g;
                image->comps[2].data[index] = b;
                image->comps[3].data[index] = a;
                index++;
            }
        } else {
            fprintf(stderr, ""Currently unsupported bit depth : %s\n"", filename);
        }
    }
    fclose(f);
    return image;
}
","The vulnerability in the original code arises from a lack of validation for the image dimensions, specifically in the handling of large images. If `image_width` and `image_height` are large, the calculation of `expected_file_size` could lead to excessive memory allocation or even integer overflow, potentially causing a denial of service or memory corruption. The fixed code introduces a check to ensure that if the declared file size exceeds 10 MB, it verifies that the file is sufficiently large before proceeding with memory allocation. This is done by calculating `expected_file_size` and checking it against `INT_MAX`, thus preventing potential vulnerabilities related to large image processing.","The vulnerability in the original code stems from inadequate validation of image dimensions, which could lead to excessive memory allocation or integer overflow when processing large images. This oversight poses risks such as denial of service or memory corruption, as the program may attempt to allocate more memory than is available. The revised code addresses this issue by implementing a check for the declared file size, ensuring that it verifies the file's size before proceeding with memory allocation. This additional validation step effectively mitigates the risks associated with handling large image files.",4,5,5,3
18,18,181281,181281,,Remote,Not required,Partial,CVE-2017-9225,https://www.cvedetails.com/cve/CVE-2017-9225/,CWE-787,Low,Partial,Partial,,2017-05-24,7.5,"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds write in onigenc_unicode_get_case_fold_codes_by_str() occurs during regular expression compilation. Code point 0xFFFFFFFF is not properly handled in unicode_unfold_key(). A malformed regular expression could result in 4 bytes being written off the end of a stack buffer of expand_case_fold_string() during the call to onigenc_unicode_get_case_fold_codes_by_str(), a typical stack buffer overflow.",2017-06-02,Overflow ,1,https://github.com/kkos/oniguruma/commit/166a6c3999bf06b4de0ab4ce6b088a468cc4029f,166a6c3999bf06b4de0ab4ce6b088a468cc4029f,fix #56 : return invalid result for codepoint 0xFFFFFFFF,1,src/unicode_unfold_key.c,"{""sha"": ""34f9c2fd4110efb212786b9d0ed1d76800ecc539"", ""filename"": ""src/gperf_unfold_key_conv.py"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/166a6c3999bf06b4de0ab4ce6b088a468cc4029f/src/gperf_unfold_key_conv.py"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/166a6c3999bf06b4de0ab4ce6b088a468cc4029f/src/gperf_unfold_key_conv.py"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/gperf_unfold_key_conv.py?ref=166a6c3999bf06b4de0ab4ce6b088a468cc4029f"", ""patch"": ""@@ -36,7 +36,7 @@ def parse_line(s):\n     if r != s: return r\n     r = re.sub(REG_GET_CODE, 'OnigCodePoint gcode = wordlist[key].code;', s)\n     if r != s: return r\n-    r = re.sub(REG_CODE_CHECK, 'if (code == gcode)', s)\n+    r = re.sub(REG_CODE_CHECK, 'if (code == gcode && wordlist[key].index >= 0)', s)\n     if r != s: return r\n \n     return s""}<_**next**_>{""sha"": ""15302caada8e0c4ddec158b290cebecfc899b4a7"", ""filename"": ""src/unicode_unfold_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/166a6c3999bf06b4de0ab4ce6b088a468cc4029f/src/unicode_unfold_key.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/166a6c3999bf06b4de0ab4ce6b088a468cc4029f/src/unicode_unfold_key.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/unicode_unfold_key.c?ref=166a6c3999bf06b4de0ab4ce6b088a468cc4029f"", ""patch"": ""@@ -2850,7 +2850,7 @@ unicode_unfold_key(OnigCodePoint code)\n         {\n           OnigCodePoint gcode = wordlist[key].code;\n \n-          if (code == gcode)\n+          if (code == gcode && wordlist[key].index >= 0)\n             return &wordlist[key];\n         }\n     }""}","unicode_unfold_key(OnigCodePoint code)
{
  static const struct ByUnfoldKey wordlist[] =
    {
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0x1040a, 3267, 1},

      {0x1e0a, 1727, 1},

      {0x040a, 1016, 1},

      {0x010a, 186, 1},

      {0x1f0a, 2088, 1},

      {0x2c0a, 2451, 1},

      {0x0189, 619, 1},

      {0x1f89, 134, 2},

      {0x1f85, 154, 2},

      {0x0389, 733, 1},

      {0x03ff, 724, 1},

      {0xab89, 1523, 1},

      {0xab85, 1511, 1},

      {0x10c89, 3384, 1},

      {0x10c85, 3372, 1},

      {0x1e84, 1911, 1},

      {0x03f5, 752, 1},

      {0x0184, 360, 1},

      {0x1f84, 149, 2},

      {0x2c84, 2592, 1},

      {0x017d, 351, 1},

      {0x1ff3, 96, 2},

      {0xab84, 1508, 1},

      {0xa784, 3105, 1},

      {0x10c84, 3369, 1},

      {0xab7d, 1487, 1},

      {0xa77d, 1706, 1},

      {0x1e98, 38, 2},

      {0x0498, 1106, 1},

      {0x0198, 375, 1},

      {0x1f98, 169, 2},

      {0x2c98, 2622, 1},

      {0x0398, 762, 1},

      {0xa684, 2940, 1},

      {0xab98, 1568, 1},

      {0xa798, 3123, 1},

      {0x10c98, 3429, 1},

      {0x050a, 1277, 1},

      {0x1ffb, 2265, 1},

      {0x1e96, 16, 2},

      {0x0496, 1103, 1},

      {0x0196, 652, 1},

      {0x1f96, 199, 2},

      {0x2c96, 2619, 1},

      {0x0396, 756, 1},

      {0xa698, 2970, 1},

      {0xab96, 1562, 1},

      {0xa796, 3120, 1},

      {0x10c96, 3423, 1},

      {0x1feb, 2259, 1},

      {0x2ceb, 2736, 1},

      {0x1e90, 1929, 1},

      {0x0490, 1094, 1},

      {0x0190, 628, 1},

      {0x1f90, 169, 2},

      {0x2c90, 2610, 1},

      {0x0390, 25, 3},

      {0xa696, 2967, 1},

      {0xab90, 1544, 1},

      {0xa790, 3114, 1},

      {0x10c90, 3405, 1},

      {0x01d7, 444, 1},

      {0x1fd7, 31, 3},

      {0x1ea6, 1947, 1},

      {0x04a6, 1127, 1},

      {0x01a6, 676, 1},

      {0x1fa6, 239, 2},

      {0x2ca6, 2643, 1},

      {0x03a6, 810, 1},

      {0xa690, 2958, 1},

      {0xaba6, 1610, 1},

      {0xa7a6, 3144, 1},

      {0x10ca6, 3471, 1},

      {0x1ea4, 1944, 1},

      {0x04a4, 1124, 1},

      {0x01a4, 390, 1},

      {0x1fa4, 229, 2},

      {0x2ca4, 2640, 1},

      {0x03a4, 804, 1},

      {0x10a6, 2763, 1},

      {0xaba4, 1604, 1},

      {0xa7a4, 3141, 1},

      {0x10ca4, 3465, 1},

      {0x1ea0, 1938, 1},

      {0x04a0, 1118, 1},

      {0x01a0, 384, 1},

      {0x1fa0, 209, 2},

      {0x2ca0, 2634, 1},

      {0x03a0, 792, 1},

      {0x10a4, 2757, 1},

      {0xaba0, 1592, 1},

      {0xa7a0, 3135, 1},

      {0x10ca0, 3453, 1},

      {0x1eb2, 1965, 1},

      {0x04b2, 1145, 1},

      {0x01b2, 694, 1},

      {0x1fb2, 249, 2},

      {0x2cb2, 2661, 1},

      {0x03fd, 718, 1},

      {0x10a0, 2745, 1},

      {0xabb2, 1646, 1},

      {0xa7b2, 703, 1},

      {0x10cb2, 3507, 1},

      {0x1eac, 1956, 1},

      {0x04ac, 1136, 1},

      {0x01ac, 396, 1},

      {0x1fac, 229, 2},

      {0x2cac, 2652, 1},

      {0x0537, 1352, 1},

      {0x10b2, 2799, 1},

      {0xabac, 1628, 1},

      {0xa7ac, 637, 1},

      {0x10cac, 3489, 1},

      {0x1eaa, 1953, 1},

      {0x04aa, 1133, 1},

      {0x00dd, 162, 1},

      {0x1faa, 219, 2},

      {0x2caa, 2649, 1},

      {0x03aa, 824, 1},

      {0x10ac, 2781, 1},

      {0xabaa, 1622, 1},

      {0xa7aa, 646, 1},

      {0x10caa, 3483, 1},

      {0x1ea8, 1950, 1},

      {0x04a8, 1130, 1},

      {0x020a, 517, 1},

      {0x1fa8, 209, 2},

      {0x2ca8, 2646, 1},

      {0x03a8, 817, 1},

      {0x10aa, 2775, 1},

      {0xaba8, 1616, 1},

      {0xa7a8, 3147, 1},

      {0x10ca8, 3477, 1},

      {0x1ea2, 1941, 1},

      {0x04a2, 1121, 1},

      {0x01a2, 387, 1},

      {0x1fa2, 219, 2},

      {0x2ca2, 2637, 1},

      {0x118a6, 3528, 1},

      {0x10a8, 2769, 1},

      {0xaba2, 1598, 1},

      {0xa7a2, 3138, 1},

      {0x10ca2, 3459, 1},

      {0x2ced, 2739, 1},

      {0x1fe9, 2283, 1},

      {0x1fe7, 47, 3},

      {0x1eb0, 1962, 1},

      {0x04b0, 1142, 1},

      {0x118a4, 3522, 1},

      {0x10a2, 2751, 1},

      {0x2cb0, 2658, 1},

      {0x03b0, 41, 3},

      {0x1fe3, 41, 3},

      {0xabb0, 1640, 1},

      {0xa7b0, 706, 1},

      {0x10cb0, 3501, 1},

      {0x01d9, 447, 1},

      {0x1fd9, 2277, 1},

      {0x118a0, 3510, 1},

      {0x00df, 24, 2},

      {0x00d9, 150, 1},

      {0xab77, 1469, 1},

      {0x10b0, 2793, 1},

      {0x1eae, 1959, 1},

      {0x04ae, 1139, 1},

      {0x01ae, 685, 1},

      {0x1fae, 239, 2},

      {0x2cae, 2655, 1},

      {0x118b2, 3564, 1},

      {0xab73, 1457, 1},

      {0xabae, 1634, 1},

      {0xab71, 1451, 1},

      {0x10cae, 3495, 1},

      {0x1e2a, 1775, 1},

      {0x042a, 968, 1},

      {0x012a, 234, 1},

      {0x1f2a, 2130, 1},

      {0x2c2a, 2547, 1},

      {0x118ac, 3546, 1},

      {0x10ae, 2787, 1},

      {0x0535, 1346, 1},

      {0xa72a, 2988, 1},

      {0x1e9a, 0, 2},

      {0x049a, 1109, 1},

      {0xff37, 3225, 1},

      {0x1f9a, 179, 2},

      {0x2c9a, 2625, 1},

      {0x039a, 772, 1},

      {0x118aa, 3540, 1},

      {0xab9a, 1574, 1},

      {0xa79a, 3126, 1},

      {0x10c9a, 3435, 1},

      {0x1e94, 1935, 1},

      {0x0494, 1100, 1},

      {0x0194, 640, 1},

      {0x1f94, 189, 2},

      {0x2c94, 2616, 1},

      {0x0394, 749, 1},

      {0x118a8, 3534, 1},

      {0xab94, 1556, 1},

      {0xa69a, 2973, 1},

      {0x10c94, 3417, 1},

      {0x10402, 3243, 1},

      {0x1e02, 1715, 1},

      {0x0402, 992, 1},

      {0x0102, 174, 1},

      {0x0533, 1340, 1},

      {0x2c02, 2427, 1},

      {0x118a2, 3516, 1},

      {0x052a, 1325, 1},

      {0xa694, 2964, 1},

      {0x1e92, 1932, 1},

      {0x0492, 1097, 1},

      {0x2165, 2307, 1},

      {0x1f92, 179, 2},

      {0x2c92, 2613, 1},

      {0x0392, 742, 1},

      {0x2161, 2295, 1},

      {0xab92, 1550, 1},

      {0xa792, 3117, 1},

      {0x10c92, 3411, 1},

      {0x118b0, 3558, 1},

      {0x1f5f, 2199, 1},

      {0x1e8e, 1926, 1},

      {0x048e, 1091, 1},

      {0x018e, 453, 1},

      {0x1f8e, 159, 2},

      {0x2c8e, 2607, 1},

      {0x038e, 833, 1},

      {0xa692, 2961, 1},

      {0xab8e, 1538, 1},

      {0x0055, 59, 1},

      {0x10c8e, 3399, 1},

      {0x1f5d, 2196, 1},

      {0x212a, 27, 1},

      {0x04cb, 1181, 1},

      {0x01cb, 425, 1},

      {0x1fcb, 2241, 1},

      {0x118ae, 3552, 1},

      {0x0502, 1265, 1},

      {0x00cb, 111, 1},

      {0xa68e, 2955, 1},

      {0x1e8a, 1920, 1},

      {0x048a, 1085, 1},

      {0x018a, 622, 1},

      {0x1f8a, 139, 2},

      {0x2c8a, 2601, 1},

      {0x038a, 736, 1},

      {0x2c67, 2571, 1},

      {0xab8a, 1526, 1},

      {0x1e86, 1914, 1},

      {0x10c8a, 3387, 1},

      {0x0186, 616, 1},

      {0x1f86, 159, 2},

      {0x2c86, 2595, 1},

      {0x0386, 727, 1},

      {0xff35, 3219, 1},

      {0xab86, 1514, 1},

      {0xa786, 3108, 1},

      {0x10c86, 3375, 1},

      {0xa68a, 2949, 1},

      {0x0555, 1442, 1},

      {0x1ebc, 1980, 1},

      {0x04bc, 1160, 1},

      {0x01bc, 411, 1},

      {0x1fbc, 62, 2},

      {0x2cbc, 2676, 1},

      {0x1f5b, 2193, 1},

      {0xa686, 2943, 1},

      {0xabbc, 1676, 1},

      {0x1eb8, 1974, 1},

      {0x04b8, 1154, 1},

      {0x01b8, 408, 1},

      {0x1fb8, 2268, 1},

      {0x2cb8, 2670, 1},

      {0x01db, 450, 1},

      {0x1fdb, 2247, 1},

      {0xabb8, 1664, 1},

      {0x10bc, 2829, 1},

      {0x00db, 156, 1},

      {0x1eb6, 1971, 1},

      {0x04b6, 1151, 1},

      {0xff33, 3213, 1},

      {0x1fb6, 58, 2},

      {0x2cb6, 2667, 1},

      {0xff2a, 3186, 1},

      {0x10b8, 2817, 1},

      {0xabb6, 1658, 1},

      {0xa7b6, 3153, 1},

      {0x10426, 3351, 1},

      {0x1e26, 1769, 1},

      {0x0426, 956, 1},

      {0x0126, 228, 1},

      {0x0053, 52, 1},

      {0x2c26, 2535, 1},

      {0x0057, 65, 1},

      {0x10b6, 2811, 1},

      {0x022a, 562, 1},

      {0xa726, 2982, 1},

      {0x1e2e, 1781, 1},

      {0x042e, 980, 1},

      {0x012e, 240, 1},

      {0x1f2e, 2142, 1},

      {0x2c2e, 2559, 1},
      {0xffffffff, -1, 0},

      {0x2167, 2313, 1},
      {0xffffffff, -1, 0},

      {0xa72e, 2994, 1},

      {0x1e2c, 1778, 1},

      {0x042c, 974, 1},

      {0x012c, 237, 1},

      {0x1f2c, 2136, 1},

      {0x2c2c, 2553, 1},

      {0x1f6f, 2223, 1},

      {0x2c6f, 604, 1},

      {0xabbf, 1685, 1},

      {0xa72c, 2991, 1},

      {0x1e28, 1772, 1},

      {0x0428, 962, 1},

      {0x0128, 231, 1},

      {0x1f28, 2124, 1},

      {0x2c28, 2541, 1},
      {0xffffffff, -1, 0},

      {0x0553, 1436, 1},

      {0x10bf, 2838, 1},

      {0xa728, 2985, 1},

      {0x0526, 1319, 1},

      {0x0202, 505, 1},

      {0x1e40, 1808, 1},

      {0x10424, 3345, 1},

      {0x1e24, 1766, 1},

      {0x0424, 950, 1},

      {0x0124, 225, 1},
      {0xffffffff, -1, 0},

      {0x2c24, 2529, 1},

      {0x052e, 1331, 1},

      {0xa740, 3018, 1},

      {0x118bc, 3594, 1},

      {0xa724, 2979, 1},

      {0x1ef2, 2061, 1},

      {0x04f2, 1241, 1},

      {0x01f2, 483, 1},

      {0x1ff2, 257, 2},

      {0x2cf2, 2742, 1},

      {0x052c, 1328, 1},

      {0x118b8, 3582, 1},

      {0xa640, 2865, 1},

      {0x10422, 3339, 1},

      {0x1e22, 1763, 1},

      {0x0422, 944, 1},

      {0x0122, 222, 1},

      {0x2126, 820, 1},

      {0x2c22, 2523, 1},

      {0x0528, 1322, 1},

      {0x01f1, 483, 1},

      {0x118b6, 3576, 1},

      {0xa722, 2976, 1},

      {0x03f1, 796, 1},

      {0x1ebe, 1983, 1},

      {0x04be, 1163, 1},

      {0xfb02, 12, 2},

      {0x1fbe, 767, 1},

      {0x2cbe, 2679, 1},

      {0x01b5, 405, 1},

      {0x0540, 1379, 1},

      {0xabbe, 1682, 1},

      {0x0524, 1316, 1},

      {0x00b5, 779, 1},

      {0xabb5, 1655, 1},

      {0x1eba, 1977, 1},

      {0x04ba, 1157, 1},

      {0x216f, 2337, 1},

      {0x1fba, 2226, 1},

      {0x2cba, 2673, 1},

      {0x10be, 2835, 1},

      {0x0051, 46, 1},

      {0xabba, 1670, 1},

      {0x10b5, 2808, 1},

      {0x1e6e, 1878, 1},

      {0x046e, 1055, 1},

      {0x016e, 330, 1},

      {0x1f6e, 2220, 1},

      {0x2c6e, 664, 1},

      {0x118bf, 3603, 1},

      {0x0522, 1313, 1},

      {0x10ba, 2823, 1},

      {0xa76e, 3087, 1},

      {0x1eb4, 1968, 1},

      {0x04b4, 1148, 1},

      {0x2c75, 2583, 1},

      {0x1fb4, 50, 2},

      {0x2cb4, 2664, 1},

      {0xab75, 1463, 1},

      {0x1ec2, 1989, 1},

      {0xabb4, 1652, 1},

      {0xa7b4, 3150, 1},

      {0x1fc2, 253, 2},

      {0x2cc2, 2685, 1},

      {0x03c2, 800, 1},

      {0x00c2, 83, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff26, 3174, 1},

      {0x10b4, 2805, 1},

      {0x1eca, 2001, 1},

      {0x0551, 1430, 1},

      {0x01ca, 425, 1},

      {0x1fca, 2238, 1},

      {0x2cca, 2697, 1},

      {0x10c2, 2847, 1},

      {0x00ca, 108, 1},

      {0xff2e, 3198, 1},

      {0x1e8c, 1923, 1},

      {0x048c, 1088, 1},

      {0x0226, 556, 1},

      {0x1f8c, 149, 2},

      {0x2c8c, 2604, 1},

      {0x038c, 830, 1},
      {0xffffffff, -1, 0},

      {0xab8c, 1532, 1},

      {0xff2c, 3192, 1},

      {0x10c8c, 3393, 1},

      {0x1ec4, 1992, 1},

      {0x022e, 568, 1},

      {0x01c4, 417, 1},

      {0x1fc4, 54, 2},

      {0x2cc4, 2688, 1},
      {0xffffffff, -1, 0},

      {0x00c4, 89, 1},

      {0xff28, 3180, 1},

      {0xa68c, 2952, 1},

      {0x01cf, 432, 1},

      {0x022c, 565, 1},

      {0x118be, 3600, 1},

      {0x03cf, 839, 1},

      {0x00cf, 123, 1},

      {0x118b5, 3573, 1},
      {0xffffffff, -1, 0},

      {0x10c4, 2853, 1},

      {0x216e, 2334, 1},

      {0x24cb, 2406, 1},

      {0x0228, 559, 1},

      {0xff24, 3168, 1},
      {0xffffffff, -1, 0},

      {0x118ba, 3588, 1},

      {0x1efe, 2079, 1},

      {0x04fe, 1259, 1},

      {0x01fe, 499, 1},

      {0x1e9e, 24, 2},

      {0x049e, 1115, 1},

      {0x03fe, 721, 1},

      {0x1f9e, 199, 2},

      {0x2c9e, 2631, 1},

      {0x039e, 786, 1},

      {0x0224, 553, 1},

      {0xab9e, 1586, 1},

      {0xa79e, 3132, 1},

      {0x10c9e, 3447, 1},

      {0x01f7, 414, 1},

      {0x1ff7, 67, 3},

      {0xff22, 3162, 1},

      {0x03f7, 884, 1},

      {0x118b4, 3570, 1},

      {0x049c, 1112, 1},

      {0x019c, 661, 1},

      {0x1f9c, 189, 2},

      {0x2c9c, 2628, 1},

      {0x039c, 779, 1},

      {0x24bc, 2361, 1},

      {0xab9c, 1580, 1},

      {0xa79c, 3129, 1},

      {0x10c9c, 3441, 1},

      {0x0222, 550, 1},

      {0x1e7c, 1899, 1},

      {0x047c, 1076, 1},

      {0x1e82, 1908, 1},

      {0x24b8, 2349, 1},

      {0x0182, 357, 1},

      {0x1f82, 139, 2},

      {0x2c82, 2589, 1},

      {0xab7c, 1484, 1},
      {0xffffffff, -1, 0},

      {0xab82, 1502, 1},

      {0xa782, 3102, 1},

      {0x10c82, 3363, 1},

      {0x2c63, 1709, 1},

      {0x24b6, 2343, 1},

      {0x1e80, 1905, 1},

      {0x0480, 1082, 1},

      {0x1f59, 2190, 1},

      {0x1f80, 129, 2},

      {0x2c80, 2586, 1},

      {0x0059, 71, 1},

      {0xa682, 2937, 1},

      {0xab80, 1496, 1},

      {0xa780, 3099, 1},

      {0x10c80, 3357, 1},
      {0xffffffff, -1, 0},

      {0x1e4c, 1826, 1},

      {0x0145, 270, 1},

      {0x014c, 279, 1},

      {0x1f4c, 2184, 1},

      {0x0345, 767, 1},

      {0x0045, 12, 1},

      {0x004c, 31, 1},

      {0xa680, 2934, 1},

      {0xa74c, 3036, 1},

      {0x1e4a, 1823, 1},

      {0x01d5, 441, 1},

      {0x014a, 276, 1},

      {0x1f4a, 2178, 1},

      {0x03d5, 810, 1},

      {0x00d5, 141, 1},

      {0x004a, 24, 1},

      {0x24bf, 2370, 1},

      {0xa74a, 3033, 1},

      {0xa64c, 2883, 1},

      {0x1041c, 3321, 1},

      {0x1e1c, 1754, 1},

      {0x041c, 926, 1},

      {0x011c, 213, 1},

      {0x1f1c, 2118, 1},

      {0x2c1c, 2505, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xa64a, 2880, 1},

      {0x1041a, 3315, 1},

      {0x1e1a, 1751, 1},

      {0x041a, 920, 1},

      {0x011a, 210, 1},

      {0x1f1a, 2112, 1},

      {0x2c1a, 2499, 1},

      {0xabbd, 1679, 1},

      {0x0545, 1394, 1},

      {0x054c, 1415, 1},

      {0x10418, 3309, 1},

      {0x1e18, 1748, 1},

      {0x0418, 914, 1},

      {0x0118, 207, 1},

      {0x1f18, 2106, 1},

      {0x2c18, 2493, 1},

      {0x10bd, 2832, 1},

      {0x2163, 2301, 1},

      {0x054a, 1409, 1},

      {0x1040e, 3279, 1},

      {0x1e0e, 1733, 1},

      {0x040e, 1028, 1},

      {0x010e, 192, 1},

      {0x1f0e, 2100, 1},

      {0x2c0e, 2463, 1},

      {0x1efc, 2076, 1},

      {0x04fc, 1256, 1},

      {0x01fc, 496, 1},

      {0x1ffc, 96, 2},

      {0x051c, 1304, 1},

      {0x1040c, 3273, 1},

      {0x1e0c, 1730, 1},

      {0x040c, 1022, 1},

      {0x010c, 189, 1},

      {0x1f0c, 2094, 1},

      {0x2c0c, 2457, 1},

      {0x1f6d, 2217, 1},

      {0x2c6d, 607, 1},

      {0x051a, 1301, 1},

      {0x24be, 2367, 1},

      {0x10408, 3261, 1},

      {0x1e08, 1724, 1},

      {0x0408, 1010, 1},

      {0x0108, 183, 1},

      {0x1f08, 2082, 1},

      {0x2c08, 2445, 1},

      {0x04c9, 1178, 1},

      {0x0518, 1298, 1},

      {0x1fc9, 2235, 1},
      {0xffffffff, -1, 0},

      {0x24ba, 2355, 1},

      {0x00c9, 105, 1},

      {0x10416, 3303, 1},

      {0x1e16, 1745, 1},

      {0x0416, 908, 1},

      {0x0116, 204, 1},

      {0x050e, 1283, 1},

      {0x2c16, 2487, 1},

      {0x10414, 3297, 1},

      {0x1e14, 1742, 1},

      {0x0414, 902, 1},

      {0x0114, 201, 1},

      {0x042b, 971, 1},

      {0x2c14, 2481, 1},

      {0x1f2b, 2133, 1},

      {0x2c2b, 2550, 1},
      {0xffffffff, -1, 0},

      {0x050c, 1280, 1},

      {0x10406, 3255, 1},

      {0x1e06, 1721, 1},

      {0x0406, 1004, 1},

      {0x0106, 180, 1},

      {0x13fb, 1697, 1},

      {0x2c06, 2439, 1},

      {0x24c2, 2379, 1},

      {0x118bd, 3597, 1},
      {0xffffffff, -1, 0},

      {0x0508, 1274, 1},

      {0x10404, 3249, 1},

      {0x1e04, 1718, 1},

      {0x0404, 998, 1},

      {0x0104, 177, 1},

      {0x1f95, 194, 2},

      {0x2c04, 2433, 1},

      {0x0395, 752, 1},

      {0x24ca, 2403, 1},

      {0xab95, 1559, 1},

      {0x0531, 1334, 1},

      {0x10c95, 3420, 1},

      {0x0516, 1295, 1},

      {0x1e6c, 1875, 1},

      {0x046c, 1052, 1},

      {0x016c, 327, 1},

      {0x1f6c, 2214, 1},

      {0x216d, 2331, 1},

      {0x0514, 1292, 1},

      {0x0245, 697, 1},

      {0x024c, 598, 1},

      {0xa76c, 3084, 1},

      {0x10400, 3237, 1},

      {0x1e00, 1712, 1},

      {0x0400, 986, 1},

      {0x0100, 171, 1},

      {0x24c4, 2385, 1},

      {0x2c00, 2421, 1},

      {0x0506, 1271, 1},

      {0x024a, 595, 1},

      {0x1fab, 224, 2},

      {0xa66c, 2931, 1},

      {0x03ab, 827, 1},

      {0x24cf, 2418, 1},

      {0xabab, 1625, 1},

      {0xa7ab, 631, 1},

      {0x10cab, 3486, 1},
      {0xffffffff, -1, 0},

      {0x0504, 1268, 1},
      {0xffffffff, -1, 0},

      {0x021c, 544, 1},

      {0x01a9, 679, 1},

      {0x1fa9, 214, 2},

      {0x10ab, 2778, 1},

      {0x03a9, 820, 1},

      {0x212b, 92, 1},

      {0xaba9, 1619, 1},

      {0x1e88, 1917, 1},

      {0x10ca9, 3480, 1},

      {0x021a, 541, 1},

      {0x1f88, 129, 2},

      {0x2c88, 2598, 1},

      {0x0388, 730, 1},

      {0x13fd, 1703, 1},

      {0xab88, 1520, 1},

      {0x10a9, 2772, 1},

      {0x10c88, 3381, 1},
      {0xffffffff, -1, 0},

      {0x0218, 538, 1},

      {0x0500, 1262, 1},

      {0x1f4d, 2187, 1},

      {0x01a7, 393, 1},

      {0x1fa7, 244, 2},

      {0x004d, 34, 1},

      {0x03a7, 814, 1},

      {0xa688, 2946, 1},

      {0xaba7, 1613, 1},

      {0x020e, 523, 1},

      {0x10ca7, 3474, 1},

      {0x1e6a, 1872, 1},

      {0x046a, 1049, 1},

      {0x016a, 324, 1},

      {0x1f6a, 2208, 1},
      {0xffffffff, -1, 0},

      {0x216c, 2328, 1},

      {0x10a7, 2766, 1},

      {0x01d1, 435, 1},

      {0xa76a, 3081, 1},

      {0x020c, 520, 1},

      {0x03d1, 762, 1},

      {0x00d1, 129, 1},

      {0x1e68, 1869, 1},

      {0x0468, 1046, 1},

      {0x0168, 321, 1},

      {0x1f68, 2202, 1},
      {0xffffffff, -1, 0},

      {0xff31, 3207, 1},

      {0xa66a, 2928, 1},

      {0x0208, 514, 1},

      {0xa768, 3078, 1},

      {0x1e64, 1863, 1},

      {0x0464, 1040, 1},

      {0x0164, 315, 1},

      {0x054d, 1418, 1},

      {0x2c64, 673, 1},
      {0xffffffff, -1, 0},

      {0xff2b, 3189, 1},
      {0xffffffff, -1, 0},

      {0xa764, 3072, 1},

      {0xa668, 2925, 1},

      {0x0216, 535, 1},
      {0xffffffff, -1, 0},

      {0x118ab, 3543, 1},

      {0x1e62, 1860, 1},

      {0x0462, 1037, 1},

      {0x0162, 312, 1},

      {0x0214, 532, 1},

      {0x2c62, 655, 1},

      {0xa664, 2919, 1},

      {0x1ed2, 2013, 1},

      {0x04d2, 1193, 1},

      {0xa762, 3069, 1},

      {0x1fd2, 20, 3},

      {0x2cd2, 2709, 1},

      {0x118a9, 3537, 1},

      {0x00d2, 132, 1},

      {0x0206, 511, 1},

      {0x10420, 3333, 1},

      {0x1e20, 1760, 1},

      {0x0420, 938, 1},

      {0x0120, 219, 1},

      {0xa662, 2916, 1},

      {0x2c20, 2517, 1},

      {0x1e60, 1856, 1},

      {0x0460, 1034, 1},

      {0x0160, 309, 1},

      {0x0204, 508, 1},

      {0x2c60, 2562, 1},
      {0xffffffff, -1, 0},

      {0x24bd, 2364, 1},

      {0x216a, 2322, 1},

      {0xa760, 3066, 1},
      {0xffffffff, -1, 0},

      {0xfb16, 125, 2},

      {0x118a7, 3531, 1},

      {0x1efa, 2073, 1},

      {0x04fa, 1253, 1},

      {0x01fa, 493, 1},

      {0x1ffa, 2262, 1},

      {0xfb14, 109, 2},

      {0x03fa, 887, 1},

      {0xa660, 2913, 1},

      {0x2168, 2316, 1},

      {0x01b7, 700, 1},

      {0x1fb7, 10, 3},

      {0x1f6b, 2211, 1},

      {0x2c6b, 2577, 1},

      {0x0200, 502, 1},

      {0xabb7, 1661, 1},

      {0xfb06, 29, 2},

      {0x1e56, 1841, 1},

      {0x2164, 2304, 1},

      {0x0156, 294, 1},

      {0x1f56, 62, 3},

      {0x0520, 1310, 1},

      {0x004f, 40, 1},

      {0x0056, 62, 1},

      {0x10b7, 2814, 1},

      {0xa756, 3051, 1},

      {0xfb04, 5, 3},

      {0x1e78, 1893, 1},

      {0x0478, 1070, 1},

      {0x0178, 168, 1},

      {0x1e54, 1838, 1},

      {0x2162, 2298, 1},

      {0x0154, 291, 1},

      {0x1f54, 57, 3},

      {0xab78, 1472, 1},

      {0xa656, 2898, 1},

      {0x0054, 56, 1},

      {0x1e52, 1835, 1},

      {0xa754, 3048, 1},

      {0x0152, 288, 1},

      {0x1f52, 52, 3},

      {0x24c9, 2400, 1},

      {0x1e32, 1787, 1},

      {0x0052, 49, 1},

      {0x0132, 243, 1},

      {0xa752, 3045, 1},
      {0xffffffff, -1, 0},

      {0xfb00, 4, 2},

      {0xa654, 2895, 1},
      {0xffffffff, -1, 0},

      {0xa732, 2997, 1},

      {0x2160, 2292, 1},

      {0x054f, 1424, 1},

      {0x0556, 1445, 1},

      {0x1e50, 1832, 1},

      {0xa652, 2892, 1},

      {0x0150, 285, 1},

      {0x1f50, 84, 2},

      {0x017b, 348, 1},

      {0x1e4e, 1829, 1},

      {0x0050, 43, 1},

      {0x014e, 282, 1},

      {0xa750, 3042, 1},

      {0xab7b, 1481, 1},

      {0xa77b, 3093, 1},

      {0x004e, 37, 1},

      {0x0554, 1439, 1},

      {0xa74e, 3039, 1},

      {0x1e48, 1820, 1},
      {0xffffffff, -1, 0},

      {0x216b, 2325, 1},

      {0x1f48, 2172, 1},

      {0xa650, 2889, 1},

      {0x0552, 1433, 1},

      {0x0048, 21, 1},
      {0xffffffff, -1, 0},

      {0xa748, 3030, 1},

      {0xa64e, 2886, 1},

      {0x0532, 1337, 1},

      {0x1041e, 3327, 1},

      {0x1e1e, 1757, 1},

      {0x041e, 932, 1},

      {0x011e, 216, 1},

      {0x118b7, 3579, 1},

      {0x2c1e, 2511, 1},
      {0xffffffff, -1, 0},

      {0xa648, 2877, 1},

      {0x1ff9, 2253, 1},
      {0xffffffff, -1, 0},

      {0x03f9, 878, 1},

      {0x0550, 1427, 1},

      {0x10412, 3291, 1},

      {0x1e12, 1739, 1},

      {0x0412, 896, 1},

      {0x0112, 198, 1},

      {0x054e, 1421, 1},

      {0x2c12, 2475, 1},

      {0x10410, 3285, 1},

      {0x1e10, 1736, 1},

      {0x0410, 890, 1},

      {0x0110, 195, 1},
      {0xffffffff, -1, 0},

      {0x2c10, 2469, 1},

      {0x2132, 2289, 1},

      {0x0548, 1403, 1},

      {0x1ef8, 2070, 1},

      {0x04f8, 1250, 1},

      {0x01f8, 490, 1},

      {0x1ff8, 2250, 1},

      {0x0220, 381, 1},

      {0x1ee2, 2037, 1},

      {0x04e2, 1217, 1},

      {0x01e2, 462, 1},

      {0x1fe2, 36, 3},

      {0x2ce2, 2733, 1},

      {0x03e2, 857, 1},

      {0x051e, 1307, 1},

      {0x1ede, 2031, 1},

      {0x04de, 1211, 1},

      {0x01de, 456, 1},
      {0xffffffff, -1, 0},

      {0x2cde, 2727, 1},

      {0x03de, 851, 1},

      {0x00de, 165, 1},

      {0x1f69, 2205, 1},

      {0x2c69, 2574, 1},

      {0x1eda, 2025, 1},

      {0x04da, 1205, 1},

      {0x0512, 1289, 1},

      {0x1fda, 2244, 1},

      {0x2cda, 2721, 1},

      {0x03da, 845, 1},

      {0x00da, 153, 1},
      {0xffffffff, -1, 0},

      {0x0510, 1286, 1},

      {0x1ed8, 2022, 1},

      {0x04d8, 1202, 1},
      {0xffffffff, -1, 0},

      {0x1fd8, 2274, 1},

      {0x2cd8, 2718, 1},

      {0x03d8, 842, 1},

      {0x00d8, 147, 1},

      {0x1ed6, 2019, 1},

      {0x04d6, 1199, 1},
      {0xffffffff, -1, 0},

      {0x1fd6, 76, 2},

      {0x2cd6, 2715, 1},

      {0x03d6, 792, 1},

      {0x00d6, 144, 1},

      {0x1ec8, 1998, 1},
      {0xffffffff, -1, 0},

      {0x01c8, 421, 1},

      {0x1fc8, 2232, 1},

      {0x2cc8, 2694, 1},

      {0xff32, 3210, 1},

      {0x00c8, 102, 1},

      {0x04c7, 1175, 1},

      {0x01c7, 421, 1},

      {0x1fc7, 15, 3},

      {0x1ec0, 1986, 1},

      {0x04c0, 1187, 1},

      {0x00c7, 99, 1},
      {0xffffffff, -1, 0},

      {0x2cc0, 2682, 1},

      {0x0179, 345, 1},

      {0x00c0, 77, 1},

      {0x0232, 574, 1},

      {0x01b3, 402, 1},

      {0x1fb3, 62, 2},

      {0xab79, 1475, 1},

      {0xa779, 3090, 1},

      {0x10c7, 2859, 1},

      {0xabb3, 1649, 1},

      {0xa7b3, 3156, 1},

      {0x1fa5, 234, 2},

      {0x10c0, 2841, 1},

      {0x03a5, 807, 1},
      {0xffffffff, -1, 0},

      {0xaba5, 1607, 1},

      {0x01b1, 691, 1},

      {0x10ca5, 3468, 1},

      {0x10b3, 2802, 1},

      {0x2169, 2319, 1},

      {0x024e, 601, 1},

      {0xabb1, 1643, 1},

      {0xa7b1, 682, 1},

      {0x10cb1, 3504, 1},

      {0x10a5, 2760, 1},
      {0xffffffff, -1, 0},

      {0x01af, 399, 1},

      {0x1faf, 244, 2},
      {0xffffffff, -1, 0},

      {0x0248, 592, 1},

      {0x10b1, 2796, 1},

      {0xabaf, 1637, 1},

      {0x1fad, 234, 2},

      {0x10caf, 3498, 1},

      {0x04cd, 1184, 1},

      {0x01cd, 429, 1},

      {0xabad, 1631, 1},

      {0xa7ad, 658, 1},

      {0x10cad, 3492, 1},

      {0x00cd, 117, 1},

      {0x10af, 2790, 1},

      {0x021e, 547, 1},

      {0x1fa3, 224, 2},
      {0xffffffff, -1, 0},

      {0x03a3, 800, 1},

      {0x10ad, 2784, 1},

      {0xaba3, 1601, 1},
      {0xffffffff, -1, 0},

      {0x10ca3, 3462, 1},

      {0x10cd, 2862, 1},

      {0x1fa1, 214, 2},

      {0x24b7, 2346, 1},

      {0x03a1, 796, 1},

      {0x0212, 529, 1},

      {0xaba1, 1595, 1},

      {0x10a3, 2754, 1},

      {0x10ca1, 3456, 1},

      {0x01d3, 438, 1},

      {0x1fd3, 25, 3},

      {0x0210, 526, 1},
      {0xffffffff, -1, 0},

      {0x00d3, 135, 1},

      {0x1e97, 34, 2},

      {0x10a1, 2748, 1},

      {0x0197, 649, 1},

      {0x1f97, 204, 2},
      {0xffffffff, -1, 0},

      {0x0397, 759, 1},

      {0x1041d, 3324, 1},

      {0xab97, 1565, 1},

      {0x041d, 929, 1},

      {0x10c97, 3426, 1},

      {0x1f1d, 2121, 1},

      {0x2c1d, 2508, 1},

      {0x1e72, 1884, 1},

      {0x0472, 1061, 1},

      {0x0172, 336, 1},

      {0x118b3, 3567, 1},

      {0x2c72, 2580, 1},

      {0x0372, 712, 1},

      {0x1041b, 3318, 1},

      {0xab72, 1454, 1},

      {0x041b, 923, 1},

      {0x118a5, 3525, 1},

      {0x1f1b, 2115, 1},

      {0x2c1b, 2502, 1},

      {0x1e70, 1881, 1},

      {0x0470, 1058, 1},

      {0x0170, 333, 1},

      {0x118b1, 3561, 1},

      {0x2c70, 610, 1},

      {0x0370, 709, 1},

      {0x1e46, 1817, 1},

      {0xab70, 1448, 1},

      {0x1e66, 1866, 1},

      {0x0466, 1043, 1},

      {0x0166, 318, 1},

      {0x1e44, 1814, 1},

      {0x0046, 15, 1},

      {0x118af, 3555, 1},

      {0xa746, 3027, 1},
      {0xffffffff, -1, 0},

      {0xa766, 3075, 1},

      {0x0044, 9, 1},

      {0x118ad, 3549, 1},

      {0xa744, 3024, 1},

      {0x1e7a, 1896, 1},

      {0x047a, 1073, 1},

      {0x1e3a, 1799, 1},
      {0xffffffff, -1, 0},

      {0xa646, 2874, 1},

      {0x1f3a, 2154, 1},

      {0xa666, 2922, 1},

      {0xab7a, 1478, 1},

      {0x118a3, 3519, 1},

      {0xa644, 2871, 1},

      {0xa73a, 3009, 1},
      {0xffffffff, -1, 0},

      {0x1ef4, 2064, 1},

      {0x04f4, 1244, 1},

      {0x01f4, 487, 1},

      {0x1ff4, 101, 2},

      {0x118a1, 3513, 1},

      {0x03f4, 762, 1},

      {0x1eec, 2052, 1},

      {0x04ec, 1232, 1},

      {0x01ec, 477, 1},

      {0x1fec, 2286, 1},

      {0x0546, 1397, 1},

      {0x03ec, 872, 1},
      {0xffffffff, -1, 0},

      {0x013f, 261, 1},

      {0x1f3f, 2169, 1},

      {0x0544, 1391, 1},

      {0x1eea, 2049, 1},

      {0x04ea, 1229, 1},

      {0x01ea, 474, 1},

      {0x1fea, 2256, 1},
      {0xffffffff, -1, 0},

      {0x03ea, 869, 1},

      {0x1ee8, 2046, 1},

      {0x04e8, 1226, 1},

      {0x01e8, 471, 1},

      {0x1fe8, 2280, 1},

      {0x053a, 1361, 1},

      {0x03e8, 866, 1},

      {0x1ee6, 2043, 1},

      {0x04e6, 1223, 1},

      {0x01e6, 468, 1},

      {0x1fe6, 88, 2},

      {0x1f4b, 2181, 1},

      {0x03e6, 863, 1},

      {0x1e5e, 1853, 1},

      {0x004b, 27, 1},

      {0x015e, 306, 1},

      {0x2166, 2310, 1},

      {0x1ee4, 2040, 1},

      {0x04e4, 1220, 1},

      {0x01e4, 465, 1},

      {0x1fe4, 80, 2},

      {0xa75e, 3063, 1},

      {0x03e4, 860, 1},

      {0x1ee0, 2034, 1},

      {0x04e0, 1214, 1},

      {0x01e0, 459, 1},

      {0x053f, 1376, 1},

      {0x2ce0, 2730, 1},

      {0x03e0, 854, 1},

      {0x1edc, 2028, 1},

      {0x04dc, 1208, 1},

      {0xa65e, 2910, 1},
      {0xffffffff, -1, 0},

      {0x2cdc, 2724, 1},

      {0x03dc, 848, 1},

      {0x00dc, 159, 1},

      {0x1ed0, 2010, 1},

      {0x04d0, 1190, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x2cd0, 2706, 1},

      {0x03d0, 742, 1},

      {0x00d0, 126, 1},

      {0x1ecc, 2004, 1},

      {0x054b, 1412, 1},
      {0xffffffff, -1, 0},

      {0x1fcc, 71, 2},

      {0x2ccc, 2700, 1},

      {0x1ec6, 1995, 1},

      {0x00cc, 114, 1},
      {0xffffffff, -1, 0},

      {0x1fc6, 67, 2},

      {0x2cc6, 2691, 1},

      {0x24c8, 2397, 1},

      {0x00c6, 96, 1},

      {0x04c5, 1172, 1},

      {0x01c5, 417, 1},
      {0xffffffff, -1, 0},

      {0x1fbb, 2229, 1},

      {0x24c7, 2394, 1},

      {0x00c5, 92, 1},

      {0x1fb9, 2271, 1},

      {0xabbb, 1673, 1},

      {0x24c0, 2373, 1},

      {0x04c3, 1169, 1},

      {0xabb9, 1667, 1},

      {0x1fc3, 71, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x00c3, 86, 1},

      {0x10c5, 2856, 1},

      {0x10bb, 2826, 1},

      {0x1ed4, 2016, 1},

      {0x04d4, 1196, 1},

      {0x10b9, 2820, 1},

      {0x13fc, 1700, 1},

      {0x2cd4, 2712, 1},

      {0x0246, 589, 1},

      {0x00d4, 138, 1},

      {0x10c3, 2850, 1},
      {0xffffffff, -1, 0},

      {0xff3a, 3234, 1},

      {0x0244, 688, 1},

      {0x019f, 670, 1},

      {0x1f9f, 204, 2},
      {0xffffffff, -1, 0},

      {0x039f, 789, 1},
      {0xffffffff, -1, 0},

      {0xab9f, 1589, 1},
      {0xffffffff, -1, 0},

      {0x10c9f, 3450, 1},

      {0x019d, 667, 1},

      {0x1f9d, 194, 2},

      {0x023a, 2565, 1},

      {0x039d, 783, 1},

      {0x1e5a, 1847, 1},

      {0xab9d, 1583, 1},

      {0x015a, 300, 1},

      {0x10c9d, 3444, 1},

      {0x1e9b, 1856, 1},

      {0x24cd, 2412, 1},

      {0x005a, 74, 1},

      {0x1f9b, 184, 2},

      {0xa75a, 3057, 1},

      {0x039b, 776, 1},

      {0x1ece, 2007, 1},

      {0xab9b, 1577, 1},

      {0x1e99, 42, 2},

      {0x10c9b, 3438, 1},

      {0x2cce, 2703, 1},

      {0x1f99, 174, 2},

      {0x00ce, 120, 1},

      {0x0399, 767, 1},

      {0xa65a, 2904, 1},

      {0xab99, 1571, 1},
      {0xffffffff, -1, 0},

      {0x10c99, 3432, 1},

      {0x0193, 634, 1},

      {0x1f93, 184, 2},

      {0x1e58, 1844, 1},

      {0x0393, 746, 1},

      {0x0158, 297, 1},

      {0xab93, 1553, 1},
      {0xffffffff, -1, 0},

      {0x10c93, 3414, 1},

      {0x0058, 68, 1},

      {0x042d, 977, 1},

      {0xa758, 3054, 1},

      {0x1f2d, 2139, 1},

      {0x2c2d, 2556, 1},

      {0x118bb, 3591, 1},

      {0x0191, 369, 1},

      {0x1f91, 174, 2},

      {0x118b9, 3585, 1},

      {0x0391, 739, 1},
      {0xffffffff, -1, 0},

      {0xab91, 1547, 1},

      {0xa658, 2901, 1},

      {0x10c91, 3408, 1},

      {0x018f, 625, 1},

      {0x1f8f, 164, 2},
      {0xffffffff, -1, 0},

      {0x038f, 836, 1},
      {0xffffffff, -1, 0},

      {0xab8f, 1541, 1},
      {0xffffffff, -1, 0},

      {0x10c8f, 3402, 1},

      {0x018b, 366, 1},

      {0x1f8b, 144, 2},
      {0xffffffff, -1, 0},

      {0x0187, 363, 1},

      {0x1f87, 164, 2},

      {0xab8b, 1529, 1},

      {0xa78b, 3111, 1},

      {0x10c8b, 3390, 1},

      {0xab87, 1517, 1},

      {0x04c1, 1166, 1},

      {0x10c87, 3378, 1},

      {0x1e7e, 1902, 1},

      {0x047e, 1079, 1},
      {0xffffffff, -1, 0},

      {0x00c1, 80, 1},

      {0x2c7e, 580, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab7e, 1490, 1},

      {0xa77e, 3096, 1},

      {0x1e76, 1890, 1},

      {0x0476, 1067, 1},

      {0x0176, 342, 1},

      {0x1e42, 1811, 1},

      {0x10c1, 2844, 1},

      {0x0376, 715, 1},

      {0x1e36, 1793, 1},

      {0xab76, 1466, 1},

      {0x0136, 249, 1},

      {0x0042, 3, 1},

      {0x1e3e, 1805, 1},

      {0xa742, 3021, 1},

      {0x1e38, 1796, 1},

      {0x1f3e, 2166, 1},

      {0xa736, 3003, 1},

      {0x1f38, 2148, 1},
      {0xffffffff, -1, 0},

      {0x0587, 105, 2},

      {0xa73e, 3015, 1},
      {0xffffffff, -1, 0},

      {0xa738, 3006, 1},

      {0xa642, 2868, 1},

      {0x1e5c, 1850, 1},

      {0x1e34, 1790, 1},

      {0x015c, 303, 1},

      {0x0134, 246, 1},

      {0x1ef6, 2067, 1},

      {0x04f6, 1247, 1},

      {0x01f6, 372, 1},

      {0x1ff6, 92, 2},

      {0xa75c, 3060, 1},

      {0xa734, 3000, 1},

      {0x1ef0, 2058, 1},

      {0x04f0, 1238, 1},

      {0x01f0, 20, 2},
      {0xffffffff, -1, 0},

      {0x1e30, 1784, 1},

      {0x03f0, 772, 1},

      {0x0130, 261, 2},

      {0x0542, 1385, 1},

      {0xa65c, 2907, 1},

      {0x1f83, 144, 2},

      {0x0536, 1349, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab83, 1505, 1},

      {0x053e, 1373, 1},

      {0x10c83, 3366, 1},

      {0x0538, 1355, 1},

      {0x1eee, 2055, 1},

      {0x04ee, 1235, 1},

      {0x01ee, 480, 1},

      {0x1f8d, 154, 2},
      {0xffffffff, -1, 0},

      {0x03ee, 875, 1},
      {0xffffffff, -1, 0},

      {0xab8d, 1535, 1},

      {0xa78d, 643, 1},

      {0x10c8d, 3396, 1},

      {0x0534, 1343, 1},

      {0x0181, 613, 1},

      {0x1f81, 134, 2},

      {0x013d, 258, 1},

      {0x1f3d, 2163, 1},
      {0xffffffff, -1, 0},

      {0xab81, 1499, 1},

      {0x017f, 52, 1},

      {0x10c81, 3360, 1},

      {0x2c7f, 583, 1},

      {0x037f, 881, 1},

      {0xff2d, 3195, 1},

      {0xab7f, 1493, 1},

      {0x1e74, 1887, 1},

      {0x0474, 1064, 1},

      {0x0174, 339, 1},

      {0x1e3c, 1802, 1},

      {0x0149, 46, 2},

      {0x1f49, 2175, 1},

      {0x1f3c, 2160, 1},

      {0xab74, 1460, 1},

      {0x0049, 3606, 1},

      {0x0143, 267, 1},

      {0x24cc, 2409, 1},

      {0xa73c, 3012, 1},
      {0xffffffff, -1, 0},

      {0x0043, 6, 1},

      {0x0141, 264, 1},

      {0x24c6, 2391, 1},

      {0x013b, 255, 1},

      {0x1f3b, 2157, 1},

      {0x0041, 0, 1},

      {0x0139, 252, 1},

      {0x1f39, 2151, 1},

      {0x24c5, 2388, 1},

      {0x24bb, 2358, 1},

      {0x13fa, 1694, 1},

      {0x053d, 1370, 1},

      {0x24b9, 2352, 1},

      {0x0429, 965, 1},

      {0x2183, 2340, 1},

      {0x1f29, 2127, 1},

      {0x2c29, 2544, 1},

      {0x24c3, 2382, 1},

      {0x10427, 3354, 1},

      {0x10425, 3348, 1},

      {0x0427, 959, 1},

      {0x0425, 953, 1},
      {0xffffffff, -1, 0},

      {0x2c27, 2538, 1},

      {0x2c25, 2532, 1},

      {0x0549, 1406, 1},

      {0x053c, 1367, 1},

      {0x10423, 3342, 1},
      {0xffffffff, -1, 0},

      {0x0423, 947, 1},

      {0x0543, 1388, 1},
      {0xffffffff, -1, 0},

      {0x2c23, 2526, 1},

      {0xff36, 3222, 1},
      {0xffffffff, -1, 0},

      {0x0541, 1382, 1},

      {0x10421, 3336, 1},

      {0x053b, 1364, 1},

      {0x0421, 941, 1},

      {0xff38, 3228, 1},

      {0x0539, 1358, 1},

      {0x2c21, 2520, 1},

      {0x10419, 3312, 1},

      {0x10417, 3306, 1},

      {0x0419, 917, 1},

      {0x0417, 911, 1},

      {0x1f19, 2109, 1},

      {0x2c19, 2496, 1},

      {0x2c17, 2490, 1},

      {0x023e, 2568, 1},

      {0xff34, 3216, 1},

      {0x10415, 3300, 1},

      {0x10413, 3294, 1},

      {0x0415, 905, 1},

      {0x0413, 899, 1},
      {0xffffffff, -1, 0},

      {0x2c15, 2484, 1},

      {0x2c13, 2478, 1},
      {0xffffffff, -1, 0},

      {0x24ce, 2415, 1},

      {0x1040f, 3282, 1},
      {0xffffffff, -1, 0},

      {0x040f, 1031, 1},

      {0xff30, 3204, 1},

      {0x1f0f, 2103, 1},

      {0x2c0f, 2466, 1},

      {0x1040d, 3276, 1},
      {0xffffffff, -1, 0},

      {0x040d, 1025, 1},

      {0x0147, 273, 1},

      {0x1f0d, 2097, 1},

      {0x2c0d, 2460, 1},

      {0x1040b, 3270, 1},

      {0x0047, 18, 1},

      {0x040b, 1019, 1},

      {0x0230, 571, 1},

      {0x1f0b, 2091, 1},

      {0x2c0b, 2454, 1},

      {0x10409, 3264, 1},

      {0x10405, 3252, 1},

      {0x0409, 1013, 1},

      {0x0405, 1001, 1},

      {0x1f09, 2085, 1},

      {0x2c09, 2448, 1},

      {0x2c05, 2436, 1},

      {0x10403, 3246, 1},

      {0x10401, 3240, 1},

      {0x0403, 995, 1},

      {0x0401, 989, 1},
      {0xffffffff, -1, 0},

      {0x2c03, 2430, 1},

      {0x2c01, 2424, 1},

      {0x13f9, 1691, 1},

      {0x042f, 983, 1},
      {0xffffffff, -1, 0},

      {0x1f2f, 2145, 1},

      {0x1041f, 3330, 1},
      {0xffffffff, -1, 0},

      {0x041f, 935, 1},

      {0x023d, 378, 1},

      {0x10411, 3288, 1},

      {0x2c1f, 2514, 1},

      {0x0411, 893, 1},

      {0x0547, 1400, 1},
      {0xffffffff, -1, 0},

      {0x2c11, 2472, 1},

      {0x10407, 3258, 1},
      {0xffffffff, -1, 0},

      {0x0407, 1007, 1},

      {0x24c1, 2376, 1},
      {0xffffffff, -1, 0},

      {0x2c07, 2442, 1},
      {0xffffffff, -1, 0},

      {0x13f8, 1688, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff39, 3231, 1},
      {0xffffffff, -1, 0},

      {0x0243, 354, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x0241, 586, 1},

      {0xff29, 3183, 1},

      {0x023b, 577, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff27, 3177, 1},

      {0xff25, 3171, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff23, 3165, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff21, 3159, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb17, 117, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff2f, 3201, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb15, 113, 2},

      {0xfb13, 121, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb05, 29, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb03, 0, 3},

      {0xfb01, 8, 2}
    };

  if (0 == 0)
    {
      int key = hash(&code);

      if (key <= MAX_HASH_VALUE && key >= 0)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
          if (code == gcode && wordlist[key].index >= 0)
             return &wordlist[key];
         }
     }
  return 0;
}
","unicode_unfold_key(OnigCodePoint code)
{
  static const struct ByUnfoldKey wordlist[] =
    {
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0x1040a, 3267, 1},

      {0x1e0a, 1727, 1},

      {0x040a, 1016, 1},

      {0x010a, 186, 1},

      {0x1f0a, 2088, 1},

      {0x2c0a, 2451, 1},

      {0x0189, 619, 1},

      {0x1f89, 134, 2},

      {0x1f85, 154, 2},

      {0x0389, 733, 1},

      {0x03ff, 724, 1},

      {0xab89, 1523, 1},

      {0xab85, 1511, 1},

      {0x10c89, 3384, 1},

      {0x10c85, 3372, 1},

      {0x1e84, 1911, 1},

      {0x03f5, 752, 1},

      {0x0184, 360, 1},

      {0x1f84, 149, 2},

      {0x2c84, 2592, 1},

      {0x017d, 351, 1},

      {0x1ff3, 96, 2},

      {0xab84, 1508, 1},

      {0xa784, 3105, 1},

      {0x10c84, 3369, 1},

      {0xab7d, 1487, 1},

      {0xa77d, 1706, 1},

      {0x1e98, 38, 2},

      {0x0498, 1106, 1},

      {0x0198, 375, 1},

      {0x1f98, 169, 2},

      {0x2c98, 2622, 1},

      {0x0398, 762, 1},

      {0xa684, 2940, 1},

      {0xab98, 1568, 1},

      {0xa798, 3123, 1},

      {0x10c98, 3429, 1},

      {0x050a, 1277, 1},

      {0x1ffb, 2265, 1},

      {0x1e96, 16, 2},

      {0x0496, 1103, 1},

      {0x0196, 652, 1},

      {0x1f96, 199, 2},

      {0x2c96, 2619, 1},

      {0x0396, 756, 1},

      {0xa698, 2970, 1},

      {0xab96, 1562, 1},

      {0xa796, 3120, 1},

      {0x10c96, 3423, 1},

      {0x1feb, 2259, 1},

      {0x2ceb, 2736, 1},

      {0x1e90, 1929, 1},

      {0x0490, 1094, 1},

      {0x0190, 628, 1},

      {0x1f90, 169, 2},

      {0x2c90, 2610, 1},

      {0x0390, 25, 3},

      {0xa696, 2967, 1},

      {0xab90, 1544, 1},

      {0xa790, 3114, 1},

      {0x10c90, 3405, 1},

      {0x01d7, 444, 1},

      {0x1fd7, 31, 3},

      {0x1ea6, 1947, 1},

      {0x04a6, 1127, 1},

      {0x01a6, 676, 1},

      {0x1fa6, 239, 2},

      {0x2ca6, 2643, 1},

      {0x03a6, 810, 1},

      {0xa690, 2958, 1},

      {0xaba6, 1610, 1},

      {0xa7a6, 3144, 1},

      {0x10ca6, 3471, 1},

      {0x1ea4, 1944, 1},

      {0x04a4, 1124, 1},

      {0x01a4, 390, 1},

      {0x1fa4, 229, 2},

      {0x2ca4, 2640, 1},

      {0x03a4, 804, 1},

      {0x10a6, 2763, 1},

      {0xaba4, 1604, 1},

      {0xa7a4, 3141, 1},

      {0x10ca4, 3465, 1},

      {0x1ea0, 1938, 1},

      {0x04a0, 1118, 1},

      {0x01a0, 384, 1},

      {0x1fa0, 209, 2},

      {0x2ca0, 2634, 1},

      {0x03a0, 792, 1},

      {0x10a4, 2757, 1},

      {0xaba0, 1592, 1},

      {0xa7a0, 3135, 1},

      {0x10ca0, 3453, 1},

      {0x1eb2, 1965, 1},

      {0x04b2, 1145, 1},

      {0x01b2, 694, 1},

      {0x1fb2, 249, 2},

      {0x2cb2, 2661, 1},

      {0x03fd, 718, 1},

      {0x10a0, 2745, 1},

      {0xabb2, 1646, 1},

      {0xa7b2, 703, 1},

      {0x10cb2, 3507, 1},

      {0x1eac, 1956, 1},

      {0x04ac, 1136, 1},

      {0x01ac, 396, 1},

      {0x1fac, 229, 2},

      {0x2cac, 2652, 1},

      {0x0537, 1352, 1},

      {0x10b2, 2799, 1},

      {0xabac, 1628, 1},

      {0xa7ac, 637, 1},

      {0x10cac, 3489, 1},

      {0x1eaa, 1953, 1},

      {0x04aa, 1133, 1},

      {0x00dd, 162, 1},

      {0x1faa, 219, 2},

      {0x2caa, 2649, 1},

      {0x03aa, 824, 1},

      {0x10ac, 2781, 1},

      {0xabaa, 1622, 1},

      {0xa7aa, 646, 1},

      {0x10caa, 3483, 1},

      {0x1ea8, 1950, 1},

      {0x04a8, 1130, 1},

      {0x020a, 517, 1},

      {0x1fa8, 209, 2},

      {0x2ca8, 2646, 1},

      {0x03a8, 817, 1},

      {0x10aa, 2775, 1},

      {0xaba8, 1616, 1},

      {0xa7a8, 3147, 1},

      {0x10ca8, 3477, 1},

      {0x1ea2, 1941, 1},

      {0x04a2, 1121, 1},

      {0x01a2, 387, 1},

      {0x1fa2, 219, 2},

      {0x2ca2, 2637, 1},

      {0x118a6, 3528, 1},

      {0x10a8, 2769, 1},

      {0xaba2, 1598, 1},

      {0xa7a2, 3138, 1},

      {0x10ca2, 3459, 1},

      {0x2ced, 2739, 1},

      {0x1fe9, 2283, 1},

      {0x1fe7, 47, 3},

      {0x1eb0, 1962, 1},

      {0x04b0, 1142, 1},

      {0x118a4, 3522, 1},

      {0x10a2, 2751, 1},

      {0x2cb0, 2658, 1},

      {0x03b0, 41, 3},

      {0x1fe3, 41, 3},

      {0xabb0, 1640, 1},

      {0xa7b0, 706, 1},

      {0x10cb0, 3501, 1},

      {0x01d9, 447, 1},

      {0x1fd9, 2277, 1},

      {0x118a0, 3510, 1},

      {0x00df, 24, 2},

      {0x00d9, 150, 1},

      {0xab77, 1469, 1},

      {0x10b0, 2793, 1},

      {0x1eae, 1959, 1},

      {0x04ae, 1139, 1},

      {0x01ae, 685, 1},

      {0x1fae, 239, 2},

      {0x2cae, 2655, 1},

      {0x118b2, 3564, 1},

      {0xab73, 1457, 1},

      {0xabae, 1634, 1},

      {0xab71, 1451, 1},

      {0x10cae, 3495, 1},

      {0x1e2a, 1775, 1},

      {0x042a, 968, 1},

      {0x012a, 234, 1},

      {0x1f2a, 2130, 1},

      {0x2c2a, 2547, 1},

      {0x118ac, 3546, 1},

      {0x10ae, 2787, 1},

      {0x0535, 1346, 1},

      {0xa72a, 2988, 1},

      {0x1e9a, 0, 2},

      {0x049a, 1109, 1},

      {0xff37, 3225, 1},

      {0x1f9a, 179, 2},

      {0x2c9a, 2625, 1},

      {0x039a, 772, 1},

      {0x118aa, 3540, 1},

      {0xab9a, 1574, 1},

      {0xa79a, 3126, 1},

      {0x10c9a, 3435, 1},

      {0x1e94, 1935, 1},

      {0x0494, 1100, 1},

      {0x0194, 640, 1},

      {0x1f94, 189, 2},

      {0x2c94, 2616, 1},

      {0x0394, 749, 1},

      {0x118a8, 3534, 1},

      {0xab94, 1556, 1},

      {0xa69a, 2973, 1},

      {0x10c94, 3417, 1},

      {0x10402, 3243, 1},

      {0x1e02, 1715, 1},

      {0x0402, 992, 1},

      {0x0102, 174, 1},

      {0x0533, 1340, 1},

      {0x2c02, 2427, 1},

      {0x118a2, 3516, 1},

      {0x052a, 1325, 1},

      {0xa694, 2964, 1},

      {0x1e92, 1932, 1},

      {0x0492, 1097, 1},

      {0x2165, 2307, 1},

      {0x1f92, 179, 2},

      {0x2c92, 2613, 1},

      {0x0392, 742, 1},

      {0x2161, 2295, 1},

      {0xab92, 1550, 1},

      {0xa792, 3117, 1},

      {0x10c92, 3411, 1},

      {0x118b0, 3558, 1},

      {0x1f5f, 2199, 1},

      {0x1e8e, 1926, 1},

      {0x048e, 1091, 1},

      {0x018e, 453, 1},

      {0x1f8e, 159, 2},

      {0x2c8e, 2607, 1},

      {0x038e, 833, 1},

      {0xa692, 2961, 1},

      {0xab8e, 1538, 1},

      {0x0055, 59, 1},

      {0x10c8e, 3399, 1},

      {0x1f5d, 2196, 1},

      {0x212a, 27, 1},

      {0x04cb, 1181, 1},

      {0x01cb, 425, 1},

      {0x1fcb, 2241, 1},

      {0x118ae, 3552, 1},

      {0x0502, 1265, 1},

      {0x00cb, 111, 1},

      {0xa68e, 2955, 1},

      {0x1e8a, 1920, 1},

      {0x048a, 1085, 1},

      {0x018a, 622, 1},

      {0x1f8a, 139, 2},

      {0x2c8a, 2601, 1},

      {0x038a, 736, 1},

      {0x2c67, 2571, 1},

      {0xab8a, 1526, 1},

      {0x1e86, 1914, 1},

      {0x10c8a, 3387, 1},

      {0x0186, 616, 1},

      {0x1f86, 159, 2},

      {0x2c86, 2595, 1},

      {0x0386, 727, 1},

      {0xff35, 3219, 1},

      {0xab86, 1514, 1},

      {0xa786, 3108, 1},

      {0x10c86, 3375, 1},

      {0xa68a, 2949, 1},

      {0x0555, 1442, 1},

      {0x1ebc, 1980, 1},

      {0x04bc, 1160, 1},

      {0x01bc, 411, 1},

      {0x1fbc, 62, 2},

      {0x2cbc, 2676, 1},

      {0x1f5b, 2193, 1},

      {0xa686, 2943, 1},

      {0xabbc, 1676, 1},

      {0x1eb8, 1974, 1},

      {0x04b8, 1154, 1},

      {0x01b8, 408, 1},

      {0x1fb8, 2268, 1},

      {0x2cb8, 2670, 1},

      {0x01db, 450, 1},

      {0x1fdb, 2247, 1},

      {0xabb8, 1664, 1},

      {0x10bc, 2829, 1},

      {0x00db, 156, 1},

      {0x1eb6, 1971, 1},

      {0x04b6, 1151, 1},

      {0xff33, 3213, 1},

      {0x1fb6, 58, 2},

      {0x2cb6, 2667, 1},

      {0xff2a, 3186, 1},

      {0x10b8, 2817, 1},

      {0xabb6, 1658, 1},

      {0xa7b6, 3153, 1},

      {0x10426, 3351, 1},

      {0x1e26, 1769, 1},

      {0x0426, 956, 1},

      {0x0126, 228, 1},

      {0x0053, 52, 1},

      {0x2c26, 2535, 1},

      {0x0057, 65, 1},

      {0x10b6, 2811, 1},

      {0x022a, 562, 1},

      {0xa726, 2982, 1},

      {0x1e2e, 1781, 1},

      {0x042e, 980, 1},

      {0x012e, 240, 1},

      {0x1f2e, 2142, 1},

      {0x2c2e, 2559, 1},
      {0xffffffff, -1, 0},

      {0x2167, 2313, 1},
      {0xffffffff, -1, 0},

      {0xa72e, 2994, 1},

      {0x1e2c, 1778, 1},

      {0x042c, 974, 1},

      {0x012c, 237, 1},

      {0x1f2c, 2136, 1},

      {0x2c2c, 2553, 1},

      {0x1f6f, 2223, 1},

      {0x2c6f, 604, 1},

      {0xabbf, 1685, 1},

      {0xa72c, 2991, 1},

      {0x1e28, 1772, 1},

      {0x0428, 962, 1},

      {0x0128, 231, 1},

      {0x1f28, 2124, 1},

      {0x2c28, 2541, 1},
      {0xffffffff, -1, 0},

      {0x0553, 1436, 1},

      {0x10bf, 2838, 1},

      {0xa728, 2985, 1},

      {0x0526, 1319, 1},

      {0x0202, 505, 1},

      {0x1e40, 1808, 1},

      {0x10424, 3345, 1},

      {0x1e24, 1766, 1},

      {0x0424, 950, 1},

      {0x0124, 225, 1},
      {0xffffffff, -1, 0},

      {0x2c24, 2529, 1},

      {0x052e, 1331, 1},

      {0xa740, 3018, 1},

      {0x118bc, 3594, 1},

      {0xa724, 2979, 1},

      {0x1ef2, 2061, 1},

      {0x04f2, 1241, 1},

      {0x01f2, 483, 1},

      {0x1ff2, 257, 2},

      {0x2cf2, 2742, 1},

      {0x052c, 1328, 1},

      {0x118b8, 3582, 1},

      {0xa640, 2865, 1},

      {0x10422, 3339, 1},

      {0x1e22, 1763, 1},

      {0x0422, 944, 1},

      {0x0122, 222, 1},

      {0x2126, 820, 1},

      {0x2c22, 2523, 1},

      {0x0528, 1322, 1},

      {0x01f1, 483, 1},

      {0x118b6, 3576, 1},

      {0xa722, 2976, 1},

      {0x03f1, 796, 1},

      {0x1ebe, 1983, 1},

      {0x04be, 1163, 1},

      {0xfb02, 12, 2},

      {0x1fbe, 767, 1},

      {0x2cbe, 2679, 1},

      {0x01b5, 405, 1},

      {0x0540, 1379, 1},

      {0xabbe, 1682, 1},

      {0x0524, 1316, 1},

      {0x00b5, 779, 1},

      {0xabb5, 1655, 1},

      {0x1eba, 1977, 1},

      {0x04ba, 1157, 1},

      {0x216f, 2337, 1},

      {0x1fba, 2226, 1},

      {0x2cba, 2673, 1},

      {0x10be, 2835, 1},

      {0x0051, 46, 1},

      {0xabba, 1670, 1},

      {0x10b5, 2808, 1},

      {0x1e6e, 1878, 1},

      {0x046e, 1055, 1},

      {0x016e, 330, 1},

      {0x1f6e, 2220, 1},

      {0x2c6e, 664, 1},

      {0x118bf, 3603, 1},

      {0x0522, 1313, 1},

      {0x10ba, 2823, 1},

      {0xa76e, 3087, 1},

      {0x1eb4, 1968, 1},

      {0x04b4, 1148, 1},

      {0x2c75, 2583, 1},

      {0x1fb4, 50, 2},

      {0x2cb4, 2664, 1},

      {0xab75, 1463, 1},

      {0x1ec2, 1989, 1},

      {0xabb4, 1652, 1},

      {0xa7b4, 3150, 1},

      {0x1fc2, 253, 2},

      {0x2cc2, 2685, 1},

      {0x03c2, 800, 1},

      {0x00c2, 83, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff26, 3174, 1},

      {0x10b4, 2805, 1},

      {0x1eca, 2001, 1},

      {0x0551, 1430, 1},

      {0x01ca, 425, 1},

      {0x1fca, 2238, 1},

      {0x2cca, 2697, 1},

      {0x10c2, 2847, 1},

      {0x00ca, 108, 1},

      {0xff2e, 3198, 1},

      {0x1e8c, 1923, 1},

      {0x048c, 1088, 1},

      {0x0226, 556, 1},

      {0x1f8c, 149, 2},

      {0x2c8c, 2604, 1},

      {0x038c, 830, 1},
      {0xffffffff, -1, 0},

      {0xab8c, 1532, 1},

      {0xff2c, 3192, 1},

      {0x10c8c, 3393, 1},

      {0x1ec4, 1992, 1},

      {0x022e, 568, 1},

      {0x01c4, 417, 1},

      {0x1fc4, 54, 2},

      {0x2cc4, 2688, 1},
      {0xffffffff, -1, 0},

      {0x00c4, 89, 1},

      {0xff28, 3180, 1},

      {0xa68c, 2952, 1},

      {0x01cf, 432, 1},

      {0x022c, 565, 1},

      {0x118be, 3600, 1},

      {0x03cf, 839, 1},

      {0x00cf, 123, 1},

      {0x118b5, 3573, 1},
      {0xffffffff, -1, 0},

      {0x10c4, 2853, 1},

      {0x216e, 2334, 1},

      {0x24cb, 2406, 1},

      {0x0228, 559, 1},

      {0xff24, 3168, 1},
      {0xffffffff, -1, 0},

      {0x118ba, 3588, 1},

      {0x1efe, 2079, 1},

      {0x04fe, 1259, 1},

      {0x01fe, 499, 1},

      {0x1e9e, 24, 2},

      {0x049e, 1115, 1},

      {0x03fe, 721, 1},

      {0x1f9e, 199, 2},

      {0x2c9e, 2631, 1},

      {0x039e, 786, 1},

      {0x0224, 553, 1},

      {0xab9e, 1586, 1},

      {0xa79e, 3132, 1},

      {0x10c9e, 3447, 1},

      {0x01f7, 414, 1},

      {0x1ff7, 67, 3},

      {0xff22, 3162, 1},

      {0x03f7, 884, 1},

      {0x118b4, 3570, 1},

      {0x049c, 1112, 1},

      {0x019c, 661, 1},

      {0x1f9c, 189, 2},

      {0x2c9c, 2628, 1},

      {0x039c, 779, 1},

      {0x24bc, 2361, 1},

      {0xab9c, 1580, 1},

      {0xa79c, 3129, 1},

      {0x10c9c, 3441, 1},

      {0x0222, 550, 1},

      {0x1e7c, 1899, 1},

      {0x047c, 1076, 1},

      {0x1e82, 1908, 1},

      {0x24b8, 2349, 1},

      {0x0182, 357, 1},

      {0x1f82, 139, 2},

      {0x2c82, 2589, 1},

      {0xab7c, 1484, 1},
      {0xffffffff, -1, 0},

      {0xab82, 1502, 1},

      {0xa782, 3102, 1},

      {0x10c82, 3363, 1},

      {0x2c63, 1709, 1},

      {0x24b6, 2343, 1},

      {0x1e80, 1905, 1},

      {0x0480, 1082, 1},

      {0x1f59, 2190, 1},

      {0x1f80, 129, 2},

      {0x2c80, 2586, 1},

      {0x0059, 71, 1},

      {0xa682, 2937, 1},

      {0xab80, 1496, 1},

      {0xa780, 3099, 1},

      {0x10c80, 3357, 1},
      {0xffffffff, -1, 0},

      {0x1e4c, 1826, 1},

      {0x0145, 270, 1},

      {0x014c, 279, 1},

      {0x1f4c, 2184, 1},

      {0x0345, 767, 1},

      {0x0045, 12, 1},

      {0x004c, 31, 1},

      {0xa680, 2934, 1},

      {0xa74c, 3036, 1},

      {0x1e4a, 1823, 1},

      {0x01d5, 441, 1},

      {0x014a, 276, 1},

      {0x1f4a, 2178, 1},

      {0x03d5, 810, 1},

      {0x00d5, 141, 1},

      {0x004a, 24, 1},

      {0x24bf, 2370, 1},

      {0xa74a, 3033, 1},

      {0xa64c, 2883, 1},

      {0x1041c, 3321, 1},

      {0x1e1c, 1754, 1},

      {0x041c, 926, 1},

      {0x011c, 213, 1},

      {0x1f1c, 2118, 1},

      {0x2c1c, 2505, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xa64a, 2880, 1},

      {0x1041a, 3315, 1},

      {0x1e1a, 1751, 1},

      {0x041a, 920, 1},

      {0x011a, 210, 1},

      {0x1f1a, 2112, 1},

      {0x2c1a, 2499, 1},

      {0xabbd, 1679, 1},

      {0x0545, 1394, 1},

      {0x054c, 1415, 1},

      {0x10418, 3309, 1},

      {0x1e18, 1748, 1},

      {0x0418, 914, 1},

      {0x0118, 207, 1},

      {0x1f18, 2106, 1},

      {0x2c18, 2493, 1},

      {0x10bd, 2832, 1},

      {0x2163, 2301, 1},

      {0x054a, 1409, 1},

      {0x1040e, 3279, 1},

      {0x1e0e, 1733, 1},

      {0x040e, 1028, 1},

      {0x010e, 192, 1},

      {0x1f0e, 2100, 1},

      {0x2c0e, 2463, 1},

      {0x1efc, 2076, 1},

      {0x04fc, 1256, 1},

      {0x01fc, 496, 1},

      {0x1ffc, 96, 2},

      {0x051c, 1304, 1},

      {0x1040c, 3273, 1},

      {0x1e0c, 1730, 1},

      {0x040c, 1022, 1},

      {0x010c, 189, 1},

      {0x1f0c, 2094, 1},

      {0x2c0c, 2457, 1},

      {0x1f6d, 2217, 1},

      {0x2c6d, 607, 1},

      {0x051a, 1301, 1},

      {0x24be, 2367, 1},

      {0x10408, 3261, 1},

      {0x1e08, 1724, 1},

      {0x0408, 1010, 1},

      {0x0108, 183, 1},

      {0x1f08, 2082, 1},

      {0x2c08, 2445, 1},

      {0x04c9, 1178, 1},

      {0x0518, 1298, 1},

      {0x1fc9, 2235, 1},
      {0xffffffff, -1, 0},

      {0x24ba, 2355, 1},

      {0x00c9, 105, 1},

      {0x10416, 3303, 1},

      {0x1e16, 1745, 1},

      {0x0416, 908, 1},

      {0x0116, 204, 1},

      {0x050e, 1283, 1},

      {0x2c16, 2487, 1},

      {0x10414, 3297, 1},

      {0x1e14, 1742, 1},

      {0x0414, 902, 1},

      {0x0114, 201, 1},

      {0x042b, 971, 1},

      {0x2c14, 2481, 1},

      {0x1f2b, 2133, 1},

      {0x2c2b, 2550, 1},
      {0xffffffff, -1, 0},

      {0x050c, 1280, 1},

      {0x10406, 3255, 1},

      {0x1e06, 1721, 1},

      {0x0406, 1004, 1},

      {0x0106, 180, 1},

      {0x13fb, 1697, 1},

      {0x2c06, 2439, 1},

      {0x24c2, 2379, 1},

      {0x118bd, 3597, 1},
      {0xffffffff, -1, 0},

      {0x0508, 1274, 1},

      {0x10404, 3249, 1},

      {0x1e04, 1718, 1},

      {0x0404, 998, 1},

      {0x0104, 177, 1},

      {0x1f95, 194, 2},

      {0x2c04, 2433, 1},

      {0x0395, 752, 1},

      {0x24ca, 2403, 1},

      {0xab95, 1559, 1},

      {0x0531, 1334, 1},

      {0x10c95, 3420, 1},

      {0x0516, 1295, 1},

      {0x1e6c, 1875, 1},

      {0x046c, 1052, 1},

      {0x016c, 327, 1},

      {0x1f6c, 2214, 1},

      {0x216d, 2331, 1},

      {0x0514, 1292, 1},

      {0x0245, 697, 1},

      {0x024c, 598, 1},

      {0xa76c, 3084, 1},

      {0x10400, 3237, 1},

      {0x1e00, 1712, 1},

      {0x0400, 986, 1},

      {0x0100, 171, 1},

      {0x24c4, 2385, 1},

      {0x2c00, 2421, 1},

      {0x0506, 1271, 1},

      {0x024a, 595, 1},

      {0x1fab, 224, 2},

      {0xa66c, 2931, 1},

      {0x03ab, 827, 1},

      {0x24cf, 2418, 1},

      {0xabab, 1625, 1},

      {0xa7ab, 631, 1},

      {0x10cab, 3486, 1},
      {0xffffffff, -1, 0},

      {0x0504, 1268, 1},
      {0xffffffff, -1, 0},

      {0x021c, 544, 1},

      {0x01a9, 679, 1},

      {0x1fa9, 214, 2},

      {0x10ab, 2778, 1},

      {0x03a9, 820, 1},

      {0x212b, 92, 1},

      {0xaba9, 1619, 1},

      {0x1e88, 1917, 1},

      {0x10ca9, 3480, 1},

      {0x021a, 541, 1},

      {0x1f88, 129, 2},

      {0x2c88, 2598, 1},

      {0x0388, 730, 1},

      {0x13fd, 1703, 1},

      {0xab88, 1520, 1},

      {0x10a9, 2772, 1},

      {0x10c88, 3381, 1},
      {0xffffffff, -1, 0},

      {0x0218, 538, 1},

      {0x0500, 1262, 1},

      {0x1f4d, 2187, 1},

      {0x01a7, 393, 1},

      {0x1fa7, 244, 2},

      {0x004d, 34, 1},

      {0x03a7, 814, 1},

      {0xa688, 2946, 1},

      {0xaba7, 1613, 1},

      {0x020e, 523, 1},

      {0x10ca7, 3474, 1},

      {0x1e6a, 1872, 1},

      {0x046a, 1049, 1},

      {0x016a, 324, 1},

      {0x1f6a, 2208, 1},
      {0xffffffff, -1, 0},

      {0x216c, 2328, 1},

      {0x10a7, 2766, 1},

      {0x01d1, 435, 1},

      {0xa76a, 3081, 1},

      {0x020c, 520, 1},

      {0x03d1, 762, 1},

      {0x00d1, 129, 1},

      {0x1e68, 1869, 1},

      {0x0468, 1046, 1},

      {0x0168, 321, 1},

      {0x1f68, 2202, 1},
      {0xffffffff, -1, 0},

      {0xff31, 3207, 1},

      {0xa66a, 2928, 1},

      {0x0208, 514, 1},

      {0xa768, 3078, 1},

      {0x1e64, 1863, 1},

      {0x0464, 1040, 1},

      {0x0164, 315, 1},

      {0x054d, 1418, 1},

      {0x2c64, 673, 1},
      {0xffffffff, -1, 0},

      {0xff2b, 3189, 1},
      {0xffffffff, -1, 0},

      {0xa764, 3072, 1},

      {0xa668, 2925, 1},

      {0x0216, 535, 1},
      {0xffffffff, -1, 0},

      {0x118ab, 3543, 1},

      {0x1e62, 1860, 1},

      {0x0462, 1037, 1},

      {0x0162, 312, 1},

      {0x0214, 532, 1},

      {0x2c62, 655, 1},

      {0xa664, 2919, 1},

      {0x1ed2, 2013, 1},

      {0x04d2, 1193, 1},

      {0xa762, 3069, 1},

      {0x1fd2, 20, 3},

      {0x2cd2, 2709, 1},

      {0x118a9, 3537, 1},

      {0x00d2, 132, 1},

      {0x0206, 511, 1},

      {0x10420, 3333, 1},

      {0x1e20, 1760, 1},

      {0x0420, 938, 1},

      {0x0120, 219, 1},

      {0xa662, 2916, 1},

      {0x2c20, 2517, 1},

      {0x1e60, 1856, 1},

      {0x0460, 1034, 1},

      {0x0160, 309, 1},

      {0x0204, 508, 1},

      {0x2c60, 2562, 1},
      {0xffffffff, -1, 0},

      {0x24bd, 2364, 1},

      {0x216a, 2322, 1},

      {0xa760, 3066, 1},
      {0xffffffff, -1, 0},

      {0xfb16, 125, 2},

      {0x118a7, 3531, 1},

      {0x1efa, 2073, 1},

      {0x04fa, 1253, 1},

      {0x01fa, 493, 1},

      {0x1ffa, 2262, 1},

      {0xfb14, 109, 2},

      {0x03fa, 887, 1},

      {0xa660, 2913, 1},

      {0x2168, 2316, 1},

      {0x01b7, 700, 1},

      {0x1fb7, 10, 3},

      {0x1f6b, 2211, 1},

      {0x2c6b, 2577, 1},

      {0x0200, 502, 1},

      {0xabb7, 1661, 1},

      {0xfb06, 29, 2},

      {0x1e56, 1841, 1},

      {0x2164, 2304, 1},

      {0x0156, 294, 1},

      {0x1f56, 62, 3},

      {0x0520, 1310, 1},

      {0x004f, 40, 1},

      {0x0056, 62, 1},

      {0x10b7, 2814, 1},

      {0xa756, 3051, 1},

      {0xfb04, 5, 3},

      {0x1e78, 1893, 1},

      {0x0478, 1070, 1},

      {0x0178, 168, 1},

      {0x1e54, 1838, 1},

      {0x2162, 2298, 1},

      {0x0154, 291, 1},

      {0x1f54, 57, 3},

      {0xab78, 1472, 1},

      {0xa656, 2898, 1},

      {0x0054, 56, 1},

      {0x1e52, 1835, 1},

      {0xa754, 3048, 1},

      {0x0152, 288, 1},

      {0x1f52, 52, 3},

      {0x24c9, 2400, 1},

      {0x1e32, 1787, 1},

      {0x0052, 49, 1},

      {0x0132, 243, 1},

      {0xa752, 3045, 1},
      {0xffffffff, -1, 0},

      {0xfb00, 4, 2},

      {0xa654, 2895, 1},
      {0xffffffff, -1, 0},

      {0xa732, 2997, 1},

      {0x2160, 2292, 1},

      {0x054f, 1424, 1},

      {0x0556, 1445, 1},

      {0x1e50, 1832, 1},

      {0xa652, 2892, 1},

      {0x0150, 285, 1},

      {0x1f50, 84, 2},

      {0x017b, 348, 1},

      {0x1e4e, 1829, 1},

      {0x0050, 43, 1},

      {0x014e, 282, 1},

      {0xa750, 3042, 1},

      {0xab7b, 1481, 1},

      {0xa77b, 3093, 1},

      {0x004e, 37, 1},

      {0x0554, 1439, 1},

      {0xa74e, 3039, 1},

      {0x1e48, 1820, 1},
      {0xffffffff, -1, 0},

      {0x216b, 2325, 1},

      {0x1f48, 2172, 1},

      {0xa650, 2889, 1},

      {0x0552, 1433, 1},

      {0x0048, 21, 1},
      {0xffffffff, -1, 0},

      {0xa748, 3030, 1},

      {0xa64e, 2886, 1},

      {0x0532, 1337, 1},

      {0x1041e, 3327, 1},

      {0x1e1e, 1757, 1},

      {0x041e, 932, 1},

      {0x011e, 216, 1},

      {0x118b7, 3579, 1},

      {0x2c1e, 2511, 1},
      {0xffffffff, -1, 0},

      {0xa648, 2877, 1},

      {0x1ff9, 2253, 1},
      {0xffffffff, -1, 0},

      {0x03f9, 878, 1},

      {0x0550, 1427, 1},

      {0x10412, 3291, 1},

      {0x1e12, 1739, 1},

      {0x0412, 896, 1},

      {0x0112, 198, 1},

      {0x054e, 1421, 1},

      {0x2c12, 2475, 1},

      {0x10410, 3285, 1},

      {0x1e10, 1736, 1},

      {0x0410, 890, 1},

      {0x0110, 195, 1},
      {0xffffffff, -1, 0},

      {0x2c10, 2469, 1},

      {0x2132, 2289, 1},

      {0x0548, 1403, 1},

      {0x1ef8, 2070, 1},

      {0x04f8, 1250, 1},

      {0x01f8, 490, 1},

      {0x1ff8, 2250, 1},

      {0x0220, 381, 1},

      {0x1ee2, 2037, 1},

      {0x04e2, 1217, 1},

      {0x01e2, 462, 1},

      {0x1fe2, 36, 3},

      {0x2ce2, 2733, 1},

      {0x03e2, 857, 1},

      {0x051e, 1307, 1},

      {0x1ede, 2031, 1},

      {0x04de, 1211, 1},

      {0x01de, 456, 1},
      {0xffffffff, -1, 0},

      {0x2cde, 2727, 1},

      {0x03de, 851, 1},

      {0x00de, 165, 1},

      {0x1f69, 2205, 1},

      {0x2c69, 2574, 1},

      {0x1eda, 2025, 1},

      {0x04da, 1205, 1},

      {0x0512, 1289, 1},

      {0x1fda, 2244, 1},

      {0x2cda, 2721, 1},

      {0x03da, 845, 1},

      {0x00da, 153, 1},
      {0xffffffff, -1, 0},

      {0x0510, 1286, 1},

      {0x1ed8, 2022, 1},

      {0x04d8, 1202, 1},
      {0xffffffff, -1, 0},

      {0x1fd8, 2274, 1},

      {0x2cd8, 2718, 1},

      {0x03d8, 842, 1},

      {0x00d8, 147, 1},

      {0x1ed6, 2019, 1},

      {0x04d6, 1199, 1},
      {0xffffffff, -1, 0},

      {0x1fd6, 76, 2},

      {0x2cd6, 2715, 1},

      {0x03d6, 792, 1},

      {0x00d6, 144, 1},

      {0x1ec8, 1998, 1},
      {0xffffffff, -1, 0},

      {0x01c8, 421, 1},

      {0x1fc8, 2232, 1},

      {0x2cc8, 2694, 1},

      {0xff32, 3210, 1},

      {0x00c8, 102, 1},

      {0x04c7, 1175, 1},

      {0x01c7, 421, 1},

      {0x1fc7, 15, 3},

      {0x1ec0, 1986, 1},

      {0x04c0, 1187, 1},

      {0x00c7, 99, 1},
      {0xffffffff, -1, 0},

      {0x2cc0, 2682, 1},

      {0x0179, 345, 1},

      {0x00c0, 77, 1},

      {0x0232, 574, 1},

      {0x01b3, 402, 1},

      {0x1fb3, 62, 2},

      {0xab79, 1475, 1},

      {0xa779, 3090, 1},

      {0x10c7, 2859, 1},

      {0xabb3, 1649, 1},

      {0xa7b3, 3156, 1},

      {0x1fa5, 234, 2},

      {0x10c0, 2841, 1},

      {0x03a5, 807, 1},
      {0xffffffff, -1, 0},

      {0xaba5, 1607, 1},

      {0x01b1, 691, 1},

      {0x10ca5, 3468, 1},

      {0x10b3, 2802, 1},

      {0x2169, 2319, 1},

      {0x024e, 601, 1},

      {0xabb1, 1643, 1},

      {0xa7b1, 682, 1},

      {0x10cb1, 3504, 1},

      {0x10a5, 2760, 1},
      {0xffffffff, -1, 0},

      {0x01af, 399, 1},

      {0x1faf, 244, 2},
      {0xffffffff, -1, 0},

      {0x0248, 592, 1},

      {0x10b1, 2796, 1},

      {0xabaf, 1637, 1},

      {0x1fad, 234, 2},

      {0x10caf, 3498, 1},

      {0x04cd, 1184, 1},

      {0x01cd, 429, 1},

      {0xabad, 1631, 1},

      {0xa7ad, 658, 1},

      {0x10cad, 3492, 1},

      {0x00cd, 117, 1},

      {0x10af, 2790, 1},

      {0x021e, 547, 1},

      {0x1fa3, 224, 2},
      {0xffffffff, -1, 0},

      {0x03a3, 800, 1},

      {0x10ad, 2784, 1},

      {0xaba3, 1601, 1},
      {0xffffffff, -1, 0},

      {0x10ca3, 3462, 1},

      {0x10cd, 2862, 1},

      {0x1fa1, 214, 2},

      {0x24b7, 2346, 1},

      {0x03a1, 796, 1},

      {0x0212, 529, 1},

      {0xaba1, 1595, 1},

      {0x10a3, 2754, 1},

      {0x10ca1, 3456, 1},

      {0x01d3, 438, 1},

      {0x1fd3, 25, 3},

      {0x0210, 526, 1},
      {0xffffffff, -1, 0},

      {0x00d3, 135, 1},

      {0x1e97, 34, 2},

      {0x10a1, 2748, 1},

      {0x0197, 649, 1},

      {0x1f97, 204, 2},
      {0xffffffff, -1, 0},

      {0x0397, 759, 1},

      {0x1041d, 3324, 1},

      {0xab97, 1565, 1},

      {0x041d, 929, 1},

      {0x10c97, 3426, 1},

      {0x1f1d, 2121, 1},

      {0x2c1d, 2508, 1},

      {0x1e72, 1884, 1},

      {0x0472, 1061, 1},

      {0x0172, 336, 1},

      {0x118b3, 3567, 1},

      {0x2c72, 2580, 1},

      {0x0372, 712, 1},

      {0x1041b, 3318, 1},

      {0xab72, 1454, 1},

      {0x041b, 923, 1},

      {0x118a5, 3525, 1},

      {0x1f1b, 2115, 1},

      {0x2c1b, 2502, 1},

      {0x1e70, 1881, 1},

      {0x0470, 1058, 1},

      {0x0170, 333, 1},

      {0x118b1, 3561, 1},

      {0x2c70, 610, 1},

      {0x0370, 709, 1},

      {0x1e46, 1817, 1},

      {0xab70, 1448, 1},

      {0x1e66, 1866, 1},

      {0x0466, 1043, 1},

      {0x0166, 318, 1},

      {0x1e44, 1814, 1},

      {0x0046, 15, 1},

      {0x118af, 3555, 1},

      {0xa746, 3027, 1},
      {0xffffffff, -1, 0},

      {0xa766, 3075, 1},

      {0x0044, 9, 1},

      {0x118ad, 3549, 1},

      {0xa744, 3024, 1},

      {0x1e7a, 1896, 1},

      {0x047a, 1073, 1},

      {0x1e3a, 1799, 1},
      {0xffffffff, -1, 0},

      {0xa646, 2874, 1},

      {0x1f3a, 2154, 1},

      {0xa666, 2922, 1},

      {0xab7a, 1478, 1},

      {0x118a3, 3519, 1},

      {0xa644, 2871, 1},

      {0xa73a, 3009, 1},
      {0xffffffff, -1, 0},

      {0x1ef4, 2064, 1},

      {0x04f4, 1244, 1},

      {0x01f4, 487, 1},

      {0x1ff4, 101, 2},

      {0x118a1, 3513, 1},

      {0x03f4, 762, 1},

      {0x1eec, 2052, 1},

      {0x04ec, 1232, 1},

      {0x01ec, 477, 1},

      {0x1fec, 2286, 1},

      {0x0546, 1397, 1},

      {0x03ec, 872, 1},
      {0xffffffff, -1, 0},

      {0x013f, 261, 1},

      {0x1f3f, 2169, 1},

      {0x0544, 1391, 1},

      {0x1eea, 2049, 1},

      {0x04ea, 1229, 1},

      {0x01ea, 474, 1},

      {0x1fea, 2256, 1},
      {0xffffffff, -1, 0},

      {0x03ea, 869, 1},

      {0x1ee8, 2046, 1},

      {0x04e8, 1226, 1},

      {0x01e8, 471, 1},

      {0x1fe8, 2280, 1},

      {0x053a, 1361, 1},

      {0x03e8, 866, 1},

      {0x1ee6, 2043, 1},

      {0x04e6, 1223, 1},

      {0x01e6, 468, 1},

      {0x1fe6, 88, 2},

      {0x1f4b, 2181, 1},

      {0x03e6, 863, 1},

      {0x1e5e, 1853, 1},

      {0x004b, 27, 1},

      {0x015e, 306, 1},

      {0x2166, 2310, 1},

      {0x1ee4, 2040, 1},

      {0x04e4, 1220, 1},

      {0x01e4, 465, 1},

      {0x1fe4, 80, 2},

      {0xa75e, 3063, 1},

      {0x03e4, 860, 1},

      {0x1ee0, 2034, 1},

      {0x04e0, 1214, 1},

      {0x01e0, 459, 1},

      {0x053f, 1376, 1},

      {0x2ce0, 2730, 1},

      {0x03e0, 854, 1},

      {0x1edc, 2028, 1},

      {0x04dc, 1208, 1},

      {0xa65e, 2910, 1},
      {0xffffffff, -1, 0},

      {0x2cdc, 2724, 1},

      {0x03dc, 848, 1},

      {0x00dc, 159, 1},

      {0x1ed0, 2010, 1},

      {0x04d0, 1190, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x2cd0, 2706, 1},

      {0x03d0, 742, 1},

      {0x00d0, 126, 1},

      {0x1ecc, 2004, 1},

      {0x054b, 1412, 1},
      {0xffffffff, -1, 0},

      {0x1fcc, 71, 2},

      {0x2ccc, 2700, 1},

      {0x1ec6, 1995, 1},

      {0x00cc, 114, 1},
      {0xffffffff, -1, 0},

      {0x1fc6, 67, 2},

      {0x2cc6, 2691, 1},

      {0x24c8, 2397, 1},

      {0x00c6, 96, 1},

      {0x04c5, 1172, 1},

      {0x01c5, 417, 1},
      {0xffffffff, -1, 0},

      {0x1fbb, 2229, 1},

      {0x24c7, 2394, 1},

      {0x00c5, 92, 1},

      {0x1fb9, 2271, 1},

      {0xabbb, 1673, 1},

      {0x24c0, 2373, 1},

      {0x04c3, 1169, 1},

      {0xabb9, 1667, 1},

      {0x1fc3, 71, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x00c3, 86, 1},

      {0x10c5, 2856, 1},

      {0x10bb, 2826, 1},

      {0x1ed4, 2016, 1},

      {0x04d4, 1196, 1},

      {0x10b9, 2820, 1},

      {0x13fc, 1700, 1},

      {0x2cd4, 2712, 1},

      {0x0246, 589, 1},

      {0x00d4, 138, 1},

      {0x10c3, 2850, 1},
      {0xffffffff, -1, 0},

      {0xff3a, 3234, 1},

      {0x0244, 688, 1},

      {0x019f, 670, 1},

      {0x1f9f, 204, 2},
      {0xffffffff, -1, 0},

      {0x039f, 789, 1},
      {0xffffffff, -1, 0},

      {0xab9f, 1589, 1},
      {0xffffffff, -1, 0},

      {0x10c9f, 3450, 1},

      {0x019d, 667, 1},

      {0x1f9d, 194, 2},

      {0x023a, 2565, 1},

      {0x039d, 783, 1},

      {0x1e5a, 1847, 1},

      {0xab9d, 1583, 1},

      {0x015a, 300, 1},

      {0x10c9d, 3444, 1},

      {0x1e9b, 1856, 1},

      {0x24cd, 2412, 1},

      {0x005a, 74, 1},

      {0x1f9b, 184, 2},

      {0xa75a, 3057, 1},

      {0x039b, 776, 1},

      {0x1ece, 2007, 1},

      {0xab9b, 1577, 1},

      {0x1e99, 42, 2},

      {0x10c9b, 3438, 1},

      {0x2cce, 2703, 1},

      {0x1f99, 174, 2},

      {0x00ce, 120, 1},

      {0x0399, 767, 1},

      {0xa65a, 2904, 1},

      {0xab99, 1571, 1},
      {0xffffffff, -1, 0},

      {0x10c99, 3432, 1},

      {0x0193, 634, 1},

      {0x1f93, 184, 2},

      {0x1e58, 1844, 1},

      {0x0393, 746, 1},

      {0x0158, 297, 1},

      {0xab93, 1553, 1},
      {0xffffffff, -1, 0},

      {0x10c93, 3414, 1},

      {0x0058, 68, 1},

      {0x042d, 977, 1},

      {0xa758, 3054, 1},

      {0x1f2d, 2139, 1},

      {0x2c2d, 2556, 1},

      {0x118bb, 3591, 1},

      {0x0191, 369, 1},

      {0x1f91, 174, 2},

      {0x118b9, 3585, 1},

      {0x0391, 739, 1},
      {0xffffffff, -1, 0},

      {0xab91, 1547, 1},

      {0xa658, 2901, 1},

      {0x10c91, 3408, 1},

      {0x018f, 625, 1},

      {0x1f8f, 164, 2},
      {0xffffffff, -1, 0},

      {0x038f, 836, 1},
      {0xffffffff, -1, 0},

      {0xab8f, 1541, 1},
      {0xffffffff, -1, 0},

      {0x10c8f, 3402, 1},

      {0x018b, 366, 1},

      {0x1f8b, 144, 2},
      {0xffffffff, -1, 0},

      {0x0187, 363, 1},

      {0x1f87, 164, 2},

      {0xab8b, 1529, 1},

      {0xa78b, 3111, 1},

      {0x10c8b, 3390, 1},

      {0xab87, 1517, 1},

      {0x04c1, 1166, 1},

      {0x10c87, 3378, 1},

      {0x1e7e, 1902, 1},

      {0x047e, 1079, 1},
      {0xffffffff, -1, 0},

      {0x00c1, 80, 1},

      {0x2c7e, 580, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab7e, 1490, 1},

      {0xa77e, 3096, 1},

      {0x1e76, 1890, 1},

      {0x0476, 1067, 1},

      {0x0176, 342, 1},

      {0x1e42, 1811, 1},

      {0x10c1, 2844, 1},

      {0x0376, 715, 1},

      {0x1e36, 1793, 1},

      {0xab76, 1466, 1},

      {0x0136, 249, 1},

      {0x0042, 3, 1},

      {0x1e3e, 1805, 1},

      {0xa742, 3021, 1},

      {0x1e38, 1796, 1},

      {0x1f3e, 2166, 1},

      {0xa736, 3003, 1},

      {0x1f38, 2148, 1},
      {0xffffffff, -1, 0},

      {0x0587, 105, 2},

      {0xa73e, 3015, 1},
      {0xffffffff, -1, 0},

      {0xa738, 3006, 1},

      {0xa642, 2868, 1},

      {0x1e5c, 1850, 1},

      {0x1e34, 1790, 1},

      {0x015c, 303, 1},

      {0x0134, 246, 1},

      {0x1ef6, 2067, 1},

      {0x04f6, 1247, 1},

      {0x01f6, 372, 1},

      {0x1ff6, 92, 2},

      {0xa75c, 3060, 1},

      {0xa734, 3000, 1},

      {0x1ef0, 2058, 1},

      {0x04f0, 1238, 1},

      {0x01f0, 20, 2},
      {0xffffffff, -1, 0},

      {0x1e30, 1784, 1},

      {0x03f0, 772, 1},

      {0x0130, 261, 2},

      {0x0542, 1385, 1},

      {0xa65c, 2907, 1},

      {0x1f83, 144, 2},

      {0x0536, 1349, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab83, 1505, 1},

      {0x053e, 1373, 1},

      {0x10c83, 3366, 1},

      {0x0538, 1355, 1},

      {0x1eee, 2055, 1},

      {0x04ee, 1235, 1},

      {0x01ee, 480, 1},

      {0x1f8d, 154, 2},
      {0xffffffff, -1, 0},

      {0x03ee, 875, 1},
      {0xffffffff, -1, 0},

      {0xab8d, 1535, 1},

      {0xa78d, 643, 1},

      {0x10c8d, 3396, 1},

      {0x0534, 1343, 1},

      {0x0181, 613, 1},

      {0x1f81, 134, 2},

      {0x013d, 258, 1},

      {0x1f3d, 2163, 1},
      {0xffffffff, -1, 0},

      {0xab81, 1499, 1},

      {0x017f, 52, 1},

      {0x10c81, 3360, 1},

      {0x2c7f, 583, 1},

      {0x037f, 881, 1},

      {0xff2d, 3195, 1},

      {0xab7f, 1493, 1},

      {0x1e74, 1887, 1},

      {0x0474, 1064, 1},

      {0x0174, 339, 1},

      {0x1e3c, 1802, 1},

      {0x0149, 46, 2},

      {0x1f49, 2175, 1},

      {0x1f3c, 2160, 1},

      {0xab74, 1460, 1},

      {0x0049, 3606, 1},

      {0x0143, 267, 1},

      {0x24cc, 2409, 1},

      {0xa73c, 3012, 1},
      {0xffffffff, -1, 0},

      {0x0043, 6, 1},

      {0x0141, 264, 1},

      {0x24c6, 2391, 1},

      {0x013b, 255, 1},

      {0x1f3b, 2157, 1},

      {0x0041, 0, 1},

      {0x0139, 252, 1},

      {0x1f39, 2151, 1},

      {0x24c5, 2388, 1},

      {0x24bb, 2358, 1},

      {0x13fa, 1694, 1},

      {0x053d, 1370, 1},

      {0x24b9, 2352, 1},

      {0x0429, 965, 1},

      {0x2183, 2340, 1},

      {0x1f29, 2127, 1},

      {0x2c29, 2544, 1},

      {0x24c3, 2382, 1},

      {0x10427, 3354, 1},

      {0x10425, 3348, 1},

      {0x0427, 959, 1},

      {0x0425, 953, 1},
      {0xffffffff, -1, 0},

      {0x2c27, 2538, 1},

      {0x2c25, 2532, 1},

      {0x0549, 1406, 1},

      {0x053c, 1367, 1},

      {0x10423, 3342, 1},
      {0xffffffff, -1, 0},

      {0x0423, 947, 1},

      {0x0543, 1388, 1},
      {0xffffffff, -1, 0},

      {0x2c23, 2526, 1},

      {0xff36, 3222, 1},
      {0xffffffff, -1, 0},

      {0x0541, 1382, 1},

      {0x10421, 3336, 1},

      {0x053b, 1364, 1},

      {0x0421, 941, 1},

      {0xff38, 3228, 1},

      {0x0539, 1358, 1},

      {0x2c21, 2520, 1},

      {0x10419, 3312, 1},

      {0x10417, 3306, 1},

      {0x0419, 917, 1},

      {0x0417, 911, 1},

      {0x1f19, 2109, 1},

      {0x2c19, 2496, 1},

      {0x2c17, 2490, 1},

      {0x023e, 2568, 1},

      {0xff34, 3216, 1},

      {0x10415, 3300, 1},

      {0x10413, 3294, 1},

      {0x0415, 905, 1},

      {0x0413, 899, 1},
      {0xffffffff, -1, 0},

      {0x2c15, 2484, 1},

      {0x2c13, 2478, 1},
      {0xffffffff, -1, 0},

      {0x24ce, 2415, 1},

      {0x1040f, 3282, 1},
      {0xffffffff, -1, 0},

      {0x040f, 1031, 1},

      {0xff30, 3204, 1},

      {0x1f0f, 2103, 1},

      {0x2c0f, 2466, 1},

      {0x1040d, 3276, 1},
      {0xffffffff, -1, 0},

      {0x040d, 1025, 1},

      {0x0147, 273, 1},

      {0x1f0d, 2097, 1},

      {0x2c0d, 2460, 1},

      {0x1040b, 3270, 1},

      {0x0047, 18, 1},

      {0x040b, 1019, 1},

      {0x0230, 571, 1},

      {0x1f0b, 2091, 1},

      {0x2c0b, 2454, 1},

      {0x10409, 3264, 1},

      {0x10405, 3252, 1},

      {0x0409, 1013, 1},

      {0x0405, 1001, 1},

      {0x1f09, 2085, 1},

      {0x2c09, 2448, 1},

      {0x2c05, 2436, 1},

      {0x10403, 3246, 1},

      {0x10401, 3240, 1},

      {0x0403, 995, 1},

      {0x0401, 989, 1},
      {0xffffffff, -1, 0},

      {0x2c03, 2430, 1},

      {0x2c01, 2424, 1},

      {0x13f9, 1691, 1},

      {0x042f, 983, 1},
      {0xffffffff, -1, 0},

      {0x1f2f, 2145, 1},

      {0x1041f, 3330, 1},
      {0xffffffff, -1, 0},

      {0x041f, 935, 1},

      {0x023d, 378, 1},

      {0x10411, 3288, 1},

      {0x2c1f, 2514, 1},

      {0x0411, 893, 1},

      {0x0547, 1400, 1},
      {0xffffffff, -1, 0},

      {0x2c11, 2472, 1},

      {0x10407, 3258, 1},
      {0xffffffff, -1, 0},

      {0x0407, 1007, 1},

      {0x24c1, 2376, 1},
      {0xffffffff, -1, 0},

      {0x2c07, 2442, 1},
      {0xffffffff, -1, 0},

      {0x13f8, 1688, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff39, 3231, 1},
      {0xffffffff, -1, 0},

      {0x0243, 354, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x0241, 586, 1},

      {0xff29, 3183, 1},

      {0x023b, 577, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff27, 3177, 1},

      {0xff25, 3171, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff23, 3165, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff21, 3159, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb17, 117, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff2f, 3201, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb15, 113, 2},

      {0xfb13, 121, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb05, 29, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb03, 0, 3},

      {0xfb01, 8, 2}
    };

  if (0 == 0)
    {
      int key = hash(&code);

      if (key <= MAX_HASH_VALUE && key >= 0)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
          if (code == gcode)
             return &wordlist[key];
         }
     }
  return 0;
}
",C,"          if (code == gcode && wordlist[key].index >= 0)
","          if (code == gcode)
",,"@@ -2850,7 +2850,7 @@ unicode_unfold_key(OnigCodePoint code)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
-          if (code == gcode)
+          if (code == gcode && wordlist[key].index >= 0)
             return &wordlist[key];
         }
     }",oniguruma,166a6c3999bf06b4de0ab4ce6b088a468cc4029f,42c9a8aa87922f2a0fbb85237dfd2b3dadbdafb7,1,"unicode_unfold_key(OnigCodePoint code)
{
  static const struct ByUnfoldKey wordlist[] =
    {
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0x1040a, 3267, 1},

      {0x1e0a, 1727, 1},

      {0x040a, 1016, 1},

      {0x010a, 186, 1},

      {0x1f0a, 2088, 1},

      {0x2c0a, 2451, 1},

      {0x0189, 619, 1},

      {0x1f89, 134, 2},

      {0x1f85, 154, 2},

      {0x0389, 733, 1},

      {0x03ff, 724, 1},

      {0xab89, 1523, 1},

      {0xab85, 1511, 1},

      {0x10c89, 3384, 1},

      {0x10c85, 3372, 1},

      {0x1e84, 1911, 1},

      {0x03f5, 752, 1},

      {0x0184, 360, 1},

      {0x1f84, 149, 2},

      {0x2c84, 2592, 1},

      {0x017d, 351, 1},

      {0x1ff3, 96, 2},

      {0xab84, 1508, 1},

      {0xa784, 3105, 1},

      {0x10c84, 3369, 1},

      {0xab7d, 1487, 1},

      {0xa77d, 1706, 1},

      {0x1e98, 38, 2},

      {0x0498, 1106, 1},

      {0x0198, 375, 1},

      {0x1f98, 169, 2},

      {0x2c98, 2622, 1},

      {0x0398, 762, 1},

      {0xa684, 2940, 1},

      {0xab98, 1568, 1},

      {0xa798, 3123, 1},

      {0x10c98, 3429, 1},

      {0x050a, 1277, 1},

      {0x1ffb, 2265, 1},

      {0x1e96, 16, 2},

      {0x0496, 1103, 1},

      {0x0196, 652, 1},

      {0x1f96, 199, 2},

      {0x2c96, 2619, 1},

      {0x0396, 756, 1},

      {0xa698, 2970, 1},

      {0xab96, 1562, 1},

      {0xa796, 3120, 1},

      {0x10c96, 3423, 1},

      {0x1feb, 2259, 1},

      {0x2ceb, 2736, 1},

      {0x1e90, 1929, 1},

      {0x0490, 1094, 1},

      {0x0190, 628, 1},

      {0x1f90, 169, 2},

      {0x2c90, 2610, 1},

      {0x0390, 25, 3},

      {0xa696, 2967, 1},

      {0xab90, 1544, 1},

      {0xa790, 3114, 1},

      {0x10c90, 3405, 1},

      {0x01d7, 444, 1},

      {0x1fd7, 31, 3},

      {0x1ea6, 1947, 1},

      {0x04a6, 1127, 1},

      {0x01a6, 676, 1},

      {0x1fa6, 239, 2},

      {0x2ca6, 2643, 1},

      {0x03a6, 810, 1},

      {0xa690, 2958, 1},

      {0xaba6, 1610, 1},

      {0xa7a6, 3144, 1},

      {0x10ca6, 3471, 1},

      {0x1ea4, 1944, 1},

      {0x04a4, 1124, 1},

      {0x01a4, 390, 1},

      {0x1fa4, 229, 2},

      {0x2ca4, 2640, 1},

      {0x03a4, 804, 1},

      {0x10a6, 2763, 1},

      {0xaba4, 1604, 1},

      {0xa7a4, 3141, 1},

      {0x10ca4, 3465, 1},

      {0x1ea0, 1938, 1},

      {0x04a0, 1118, 1},

      {0x01a0, 384, 1},

      {0x1fa0, 209, 2},

      {0x2ca0, 2634, 1},

      {0x03a0, 792, 1},

      {0x10a4, 2757, 1},

      {0xaba0, 1592, 1},

      {0xa7a0, 3135, 1},

      {0x10ca0, 3453, 1},

      {0x1eb2, 1965, 1},

      {0x04b2, 1145, 1},

      {0x01b2, 694, 1},

      {0x1fb2, 249, 2},

      {0x2cb2, 2661, 1},

      {0x03fd, 718, 1},

      {0x10a0, 2745, 1},

      {0xabb2, 1646, 1},

      {0xa7b2, 703, 1},

      {0x10cb2, 3507, 1},

      {0x1eac, 1956, 1},

      {0x04ac, 1136, 1},

      {0x01ac, 396, 1},

      {0x1fac, 229, 2},

      {0x2cac, 2652, 1},

      {0x0537, 1352, 1},

      {0x10b2, 2799, 1},

      {0xabac, 1628, 1},

      {0xa7ac, 637, 1},

      {0x10cac, 3489, 1},

      {0x1eaa, 1953, 1},

      {0x04aa, 1133, 1},

      {0x00dd, 162, 1},

      {0x1faa, 219, 2},

      {0x2caa, 2649, 1},

      {0x03aa, 824, 1},

      {0x10ac, 2781, 1},

      {0xabaa, 1622, 1},

      {0xa7aa, 646, 1},

      {0x10caa, 3483, 1},

      {0x1ea8, 1950, 1},

      {0x04a8, 1130, 1},

      {0x020a, 517, 1},

      {0x1fa8, 209, 2},

      {0x2ca8, 2646, 1},

      {0x03a8, 817, 1},

      {0x10aa, 2775, 1},

      {0xaba8, 1616, 1},

      {0xa7a8, 3147, 1},

      {0x10ca8, 3477, 1},

      {0x1ea2, 1941, 1},

      {0x04a2, 1121, 1},

      {0x01a2, 387, 1},

      {0x1fa2, 219, 2},

      {0x2ca2, 2637, 1},

      {0x118a6, 3528, 1},

      {0x10a8, 2769, 1},

      {0xaba2, 1598, 1},

      {0xa7a2, 3138, 1},

      {0x10ca2, 3459, 1},

      {0x2ced, 2739, 1},

      {0x1fe9, 2283, 1},

      {0x1fe7, 47, 3},

      {0x1eb0, 1962, 1},

      {0x04b0, 1142, 1},

      {0x118a4, 3522, 1},

      {0x10a2, 2751, 1},

      {0x2cb0, 2658, 1},

      {0x03b0, 41, 3},

      {0x1fe3, 41, 3},

      {0xabb0, 1640, 1},

      {0xa7b0, 706, 1},

      {0x10cb0, 3501, 1},

      {0x01d9, 447, 1},

      {0x1fd9, 2277, 1},

      {0x118a0, 3510, 1},

      {0x00df, 24, 2},

      {0x00d9, 150, 1},

      {0xab77, 1469, 1},

      {0x10b0, 2793, 1},

      {0x1eae, 1959, 1},

      {0x04ae, 1139, 1},

      {0x01ae, 685, 1},

      {0x1fae, 239, 2},

      {0x2cae, 2655, 1},

      {0x118b2, 3564, 1},

      {0xab73, 1457, 1},

      {0xabae, 1634, 1},

      {0xab71, 1451, 1},

      {0x10cae, 3495, 1},

      {0x1e2a, 1775, 1},

      {0x042a, 968, 1},

      {0x012a, 234, 1},

      {0x1f2a, 2130, 1},

      {0x2c2a, 2547, 1},

      {0x118ac, 3546, 1},

      {0x10ae, 2787, 1},

      {0x0535, 1346, 1},

      {0xa72a, 2988, 1},

      {0x1e9a, 0, 2},

      {0x049a, 1109, 1},

      {0xff37, 3225, 1},

      {0x1f9a, 179, 2},

      {0x2c9a, 2625, 1},

      {0x039a, 772, 1},

      {0x118aa, 3540, 1},

      {0xab9a, 1574, 1},

      {0xa79a, 3126, 1},

      {0x10c9a, 3435, 1},

      {0x1e94, 1935, 1},

      {0x0494, 1100, 1},

      {0x0194, 640, 1},

      {0x1f94, 189, 2},

      {0x2c94, 2616, 1},

      {0x0394, 749, 1},

      {0x118a8, 3534, 1},

      {0xab94, 1556, 1},

      {0xa69a, 2973, 1},

      {0x10c94, 3417, 1},

      {0x10402, 3243, 1},

      {0x1e02, 1715, 1},

      {0x0402, 992, 1},

      {0x0102, 174, 1},

      {0x0533, 1340, 1},

      {0x2c02, 2427, 1},

      {0x118a2, 3516, 1},

      {0x052a, 1325, 1},

      {0xa694, 2964, 1},

      {0x1e92, 1932, 1},

      {0x0492, 1097, 1},

      {0x2165, 2307, 1},

      {0x1f92, 179, 2},

      {0x2c92, 2613, 1},

      {0x0392, 742, 1},

      {0x2161, 2295, 1},

      {0xab92, 1550, 1},

      {0xa792, 3117, 1},

      {0x10c92, 3411, 1},

      {0x118b0, 3558, 1},

      {0x1f5f, 2199, 1},

      {0x1e8e, 1926, 1},

      {0x048e, 1091, 1},

      {0x018e, 453, 1},

      {0x1f8e, 159, 2},

      {0x2c8e, 2607, 1},

      {0x038e, 833, 1},

      {0xa692, 2961, 1},

      {0xab8e, 1538, 1},

      {0x0055, 59, 1},

      {0x10c8e, 3399, 1},

      {0x1f5d, 2196, 1},

      {0x212a, 27, 1},

      {0x04cb, 1181, 1},

      {0x01cb, 425, 1},

      {0x1fcb, 2241, 1},

      {0x118ae, 3552, 1},

      {0x0502, 1265, 1},

      {0x00cb, 111, 1},

      {0xa68e, 2955, 1},

      {0x1e8a, 1920, 1},

      {0x048a, 1085, 1},

      {0x018a, 622, 1},

      {0x1f8a, 139, 2},

      {0x2c8a, 2601, 1},

      {0x038a, 736, 1},

      {0x2c67, 2571, 1},

      {0xab8a, 1526, 1},

      {0x1e86, 1914, 1},

      {0x10c8a, 3387, 1},

      {0x0186, 616, 1},

      {0x1f86, 159, 2},

      {0x2c86, 2595, 1},

      {0x0386, 727, 1},

      {0xff35, 3219, 1},

      {0xab86, 1514, 1},

      {0xa786, 3108, 1},

      {0x10c86, 3375, 1},

      {0xa68a, 2949, 1},

      {0x0555, 1442, 1},

      {0x1ebc, 1980, 1},

      {0x04bc, 1160, 1},

      {0x01bc, 411, 1},

      {0x1fbc, 62, 2},

      {0x2cbc, 2676, 1},

      {0x1f5b, 2193, 1},

      {0xa686, 2943, 1},

      {0xabbc, 1676, 1},

      {0x1eb8, 1974, 1},

      {0x04b8, 1154, 1},

      {0x01b8, 408, 1},

      {0x1fb8, 2268, 1},

      {0x2cb8, 2670, 1},

      {0x01db, 450, 1},

      {0x1fdb, 2247, 1},

      {0xabb8, 1664, 1},

      {0x10bc, 2829, 1},

      {0x00db, 156, 1},

      {0x1eb6, 1971, 1},

      {0x04b6, 1151, 1},

      {0xff33, 3213, 1},

      {0x1fb6, 58, 2},

      {0x2cb6, 2667, 1},

      {0xff2a, 3186, 1},

      {0x10b8, 2817, 1},

      {0xabb6, 1658, 1},

      {0xa7b6, 3153, 1},

      {0x10426, 3351, 1},

      {0x1e26, 1769, 1},

      {0x0426, 956, 1},

      {0x0126, 228, 1},

      {0x0053, 52, 1},

      {0x2c26, 2535, 1},

      {0x0057, 65, 1},

      {0x10b6, 2811, 1},

      {0x022a, 562, 1},

      {0xa726, 2982, 1},

      {0x1e2e, 1781, 1},

      {0x042e, 980, 1},

      {0x012e, 240, 1},

      {0x1f2e, 2142, 1},

      {0x2c2e, 2559, 1},
      {0xffffffff, -1, 0},

      {0x2167, 2313, 1},
      {0xffffffff, -1, 0},

      {0xa72e, 2994, 1},

      {0x1e2c, 1778, 1},

      {0x042c, 974, 1},

      {0x012c, 237, 1},

      {0x1f2c, 2136, 1},

      {0x2c2c, 2553, 1},

      {0x1f6f, 2223, 1},

      {0x2c6f, 604, 1},

      {0xabbf, 1685, 1},

      {0xa72c, 2991, 1},

      {0x1e28, 1772, 1},

      {0x0428, 962, 1},

      {0x0128, 231, 1},

      {0x1f28, 2124, 1},

      {0x2c28, 2541, 1},
      {0xffffffff, -1, 0},

      {0x0553, 1436, 1},

      {0x10bf, 2838, 1},

      {0xa728, 2985, 1},

      {0x0526, 1319, 1},

      {0x0202, 505, 1},

      {0x1e40, 1808, 1},

      {0x10424, 3345, 1},

      {0x1e24, 1766, 1},

      {0x0424, 950, 1},

      {0x0124, 225, 1},
      {0xffffffff, -1, 0},

      {0x2c24, 2529, 1},

      {0x052e, 1331, 1},

      {0xa740, 3018, 1},

      {0x118bc, 3594, 1},

      {0xa724, 2979, 1},

      {0x1ef2, 2061, 1},

      {0x04f2, 1241, 1},

      {0x01f2, 483, 1},

      {0x1ff2, 257, 2},

      {0x2cf2, 2742, 1},

      {0x052c, 1328, 1},

      {0x118b8, 3582, 1},

      {0xa640, 2865, 1},

      {0x10422, 3339, 1},

      {0x1e22, 1763, 1},

      {0x0422, 944, 1},

      {0x0122, 222, 1},

      {0x2126, 820, 1},

      {0x2c22, 2523, 1},

      {0x0528, 1322, 1},

      {0x01f1, 483, 1},

      {0x118b6, 3576, 1},

      {0xa722, 2976, 1},

      {0x03f1, 796, 1},

      {0x1ebe, 1983, 1},

      {0x04be, 1163, 1},

      {0xfb02, 12, 2},

      {0x1fbe, 767, 1},

      {0x2cbe, 2679, 1},

      {0x01b5, 405, 1},

      {0x0540, 1379, 1},

      {0xabbe, 1682, 1},

      {0x0524, 1316, 1},

      {0x00b5, 779, 1},

      {0xabb5, 1655, 1},

      {0x1eba, 1977, 1},

      {0x04ba, 1157, 1},

      {0x216f, 2337, 1},

      {0x1fba, 2226, 1},

      {0x2cba, 2673, 1},

      {0x10be, 2835, 1},

      {0x0051, 46, 1},

      {0xabba, 1670, 1},

      {0x10b5, 2808, 1},

      {0x1e6e, 1878, 1},

      {0x046e, 1055, 1},

      {0x016e, 330, 1},

      {0x1f6e, 2220, 1},

      {0x2c6e, 664, 1},

      {0x118bf, 3603, 1},

      {0x0522, 1313, 1},

      {0x10ba, 2823, 1},

      {0xa76e, 3087, 1},

      {0x1eb4, 1968, 1},

      {0x04b4, 1148, 1},

      {0x2c75, 2583, 1},

      {0x1fb4, 50, 2},

      {0x2cb4, 2664, 1},

      {0xab75, 1463, 1},

      {0x1ec2, 1989, 1},

      {0xabb4, 1652, 1},

      {0xa7b4, 3150, 1},

      {0x1fc2, 253, 2},

      {0x2cc2, 2685, 1},

      {0x03c2, 800, 1},

      {0x00c2, 83, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff26, 3174, 1},

      {0x10b4, 2805, 1},

      {0x1eca, 2001, 1},

      {0x0551, 1430, 1},

      {0x01ca, 425, 1},

      {0x1fca, 2238, 1},

      {0x2cca, 2697, 1},

      {0x10c2, 2847, 1},

      {0x00ca, 108, 1},

      {0xff2e, 3198, 1},

      {0x1e8c, 1923, 1},

      {0x048c, 1088, 1},

      {0x0226, 556, 1},

      {0x1f8c, 149, 2},

      {0x2c8c, 2604, 1},

      {0x038c, 830, 1},
      {0xffffffff, -1, 0},

      {0xab8c, 1532, 1},

      {0xff2c, 3192, 1},

      {0x10c8c, 3393, 1},

      {0x1ec4, 1992, 1},

      {0x022e, 568, 1},

      {0x01c4, 417, 1},

      {0x1fc4, 54, 2},

      {0x2cc4, 2688, 1},
      {0xffffffff, -1, 0},

      {0x00c4, 89, 1},

      {0xff28, 3180, 1},

      {0xa68c, 2952, 1},

      {0x01cf, 432, 1},

      {0x022c, 565, 1},

      {0x118be, 3600, 1},

      {0x03cf, 839, 1},

      {0x00cf, 123, 1},

      {0x118b5, 3573, 1},
      {0xffffffff, -1, 0},

      {0x10c4, 2853, 1},

      {0x216e, 2334, 1},

      {0x24cb, 2406, 1},

      {0x0228, 559, 1},

      {0xff24, 3168, 1},
      {0xffffffff, -1, 0},

      {0x118ba, 3588, 1},

      {0x1efe, 2079, 1},

      {0x04fe, 1259, 1},

      {0x01fe, 499, 1},

      {0x1e9e, 24, 2},

      {0x049e, 1115, 1},

      {0x03fe, 721, 1},

      {0x1f9e, 199, 2},

      {0x2c9e, 2631, 1},

      {0x039e, 786, 1},

      {0x0224, 553, 1},

      {0xab9e, 1586, 1},

      {0xa79e, 3132, 1},

      {0x10c9e, 3447, 1},

      {0x01f7, 414, 1},

      {0x1ff7, 67, 3},

      {0xff22, 3162, 1},

      {0x03f7, 884, 1},

      {0x118b4, 3570, 1},

      {0x049c, 1112, 1},

      {0x019c, 661, 1},

      {0x1f9c, 189, 2},

      {0x2c9c, 2628, 1},

      {0x039c, 779, 1},

      {0x24bc, 2361, 1},

      {0xab9c, 1580, 1},

      {0xa79c, 3129, 1},

      {0x10c9c, 3441, 1},

      {0x0222, 550, 1},

      {0x1e7c, 1899, 1},

      {0x047c, 1076, 1},

      {0x1e82, 1908, 1},

      {0x24b8, 2349, 1},

      {0x0182, 357, 1},

      {0x1f82, 139, 2},

      {0x2c82, 2589, 1},

      {0xab7c, 1484, 1},
      {0xffffffff, -1, 0},

      {0xab82, 1502, 1},

      {0xa782, 3102, 1},

      {0x10c82, 3363, 1},

      {0x2c63, 1709, 1},

      {0x24b6, 2343, 1},

      {0x1e80, 1905, 1},

      {0x0480, 1082, 1},

      {0x1f59, 2190, 1},

      {0x1f80, 129, 2},

      {0x2c80, 2586, 1},

      {0x0059, 71, 1},

      {0xa682, 2937, 1},

      {0xab80, 1496, 1},

      {0xa780, 3099, 1},

      {0x10c80, 3357, 1},
      {0xffffffff, -1, 0},

      {0x1e4c, 1826, 1},

      {0x0145, 270, 1},

      {0x014c, 279, 1},

      {0x1f4c, 2184, 1},

      {0x0345, 767, 1},

      {0x0045, 12, 1},

      {0x004c, 31, 1},

      {0xa680, 2934, 1},

      {0xa74c, 3036, 1},

      {0x1e4a, 1823, 1},

      {0x01d5, 441, 1},

      {0x014a, 276, 1},

      {0x1f4a, 2178, 1},

      {0x03d5, 810, 1},

      {0x00d5, 141, 1},

      {0x004a, 24, 1},

      {0x24bf, 2370, 1},

      {0xa74a, 3033, 1},

      {0xa64c, 2883, 1},

      {0x1041c, 3321, 1},

      {0x1e1c, 1754, 1},

      {0x041c, 926, 1},

      {0x011c, 213, 1},

      {0x1f1c, 2118, 1},

      {0x2c1c, 2505, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xa64a, 2880, 1},

      {0x1041a, 3315, 1},

      {0x1e1a, 1751, 1},

      {0x041a, 920, 1},

      {0x011a, 210, 1},

      {0x1f1a, 2112, 1},

      {0x2c1a, 2499, 1},

      {0xabbd, 1679, 1},

      {0x0545, 1394, 1},

      {0x054c, 1415, 1},

      {0x10418, 3309, 1},

      {0x1e18, 1748, 1},

      {0x0418, 914, 1},

      {0x0118, 207, 1},

      {0x1f18, 2106, 1},

      {0x2c18, 2493, 1},

      {0x10bd, 2832, 1},

      {0x2163, 2301, 1},

      {0x054a, 1409, 1},

      {0x1040e, 3279, 1},

      {0x1e0e, 1733, 1},

      {0x040e, 1028, 1},

      {0x010e, 192, 1},

      {0x1f0e, 2100, 1},

      {0x2c0e, 2463, 1},

      {0x1efc, 2076, 1},

      {0x04fc, 1256, 1},

      {0x01fc, 496, 1},

      {0x1ffc, 96, 2},

      {0x051c, 1304, 1},

      {0x1040c, 3273, 1},

      {0x1e0c, 1730, 1},

      {0x040c, 1022, 1},

      {0x010c, 189, 1},

      {0x1f0c, 2094, 1},

      {0x2c0c, 2457, 1},

      {0x1f6d, 2217, 1},

      {0x2c6d, 607, 1},

      {0x051a, 1301, 1},

      {0x24be, 2367, 1},

      {0x10408, 3261, 1},

      {0x1e08, 1724, 1},

      {0x0408, 1010, 1},

      {0x0108, 183, 1},

      {0x1f08, 2082, 1},

      {0x2c08, 2445, 1},

      {0x04c9, 1178, 1},

      {0x0518, 1298, 1},

      {0x1fc9, 2235, 1},
      {0xffffffff, -1, 0},

      {0x24ba, 2355, 1},

      {0x00c9, 105, 1},

      {0x10416, 3303, 1},

      {0x1e16, 1745, 1},

      {0x0416, 908, 1},

      {0x0116, 204, 1},

      {0x050e, 1283, 1},

      {0x2c16, 2487, 1},

      {0x10414, 3297, 1},

      {0x1e14, 1742, 1},

      {0x0414, 902, 1},

      {0x0114, 201, 1},

      {0x042b, 971, 1},

      {0x2c14, 2481, 1},

      {0x1f2b, 2133, 1},

      {0x2c2b, 2550, 1},
      {0xffffffff, -1, 0},

      {0x050c, 1280, 1},

      {0x10406, 3255, 1},

      {0x1e06, 1721, 1},

      {0x0406, 1004, 1},

      {0x0106, 180, 1},

      {0x13fb, 1697, 1},

      {0x2c06, 2439, 1},

      {0x24c2, 2379, 1},

      {0x118bd, 3597, 1},
      {0xffffffff, -1, 0},

      {0x0508, 1274, 1},

      {0x10404, 3249, 1},

      {0x1e04, 1718, 1},

      {0x0404, 998, 1},

      {0x0104, 177, 1},

      {0x1f95, 194, 2},

      {0x2c04, 2433, 1},

      {0x0395, 752, 1},

      {0x24ca, 2403, 1},

      {0xab95, 1559, 1},

      {0x0531, 1334, 1},

      {0x10c95, 3420, 1},

      {0x0516, 1295, 1},

      {0x1e6c, 1875, 1},

      {0x046c, 1052, 1},

      {0x016c, 327, 1},

      {0x1f6c, 2214, 1},

      {0x216d, 2331, 1},

      {0x0514, 1292, 1},

      {0x0245, 697, 1},

      {0x024c, 598, 1},

      {0xa76c, 3084, 1},

      {0x10400, 3237, 1},

      {0x1e00, 1712, 1},

      {0x0400, 986, 1},

      {0x0100, 171, 1},

      {0x24c4, 2385, 1},

      {0x2c00, 2421, 1},

      {0x0506, 1271, 1},

      {0x024a, 595, 1},

      {0x1fab, 224, 2},

      {0xa66c, 2931, 1},

      {0x03ab, 827, 1},

      {0x24cf, 2418, 1},

      {0xabab, 1625, 1},

      {0xa7ab, 631, 1},

      {0x10cab, 3486, 1},
      {0xffffffff, -1, 0},

      {0x0504, 1268, 1},
      {0xffffffff, -1, 0},

      {0x021c, 544, 1},

      {0x01a9, 679, 1},

      {0x1fa9, 214, 2},

      {0x10ab, 2778, 1},

      {0x03a9, 820, 1},

      {0x212b, 92, 1},

      {0xaba9, 1619, 1},

      {0x1e88, 1917, 1},

      {0x10ca9, 3480, 1},

      {0x021a, 541, 1},

      {0x1f88, 129, 2},

      {0x2c88, 2598, 1},

      {0x0388, 730, 1},

      {0x13fd, 1703, 1},

      {0xab88, 1520, 1},

      {0x10a9, 2772, 1},

      {0x10c88, 3381, 1},
      {0xffffffff, -1, 0},

      {0x0218, 538, 1},

      {0x0500, 1262, 1},

      {0x1f4d, 2187, 1},

      {0x01a7, 393, 1},

      {0x1fa7, 244, 2},

      {0x004d, 34, 1},

      {0x03a7, 814, 1},

      {0xa688, 2946, 1},

      {0xaba7, 1613, 1},

      {0x020e, 523, 1},

      {0x10ca7, 3474, 1},

      {0x1e6a, 1872, 1},

      {0x046a, 1049, 1},

      {0x016a, 324, 1},

      {0x1f6a, 2208, 1},
      {0xffffffff, -1, 0},

      {0x216c, 2328, 1},

      {0x10a7, 2766, 1},

      {0x01d1, 435, 1},

      {0xa76a, 3081, 1},

      {0x020c, 520, 1},

      {0x03d1, 762, 1},

      {0x00d1, 129, 1},

      {0x1e68, 1869, 1},

      {0x0468, 1046, 1},

      {0x0168, 321, 1},

      {0x1f68, 2202, 1},
      {0xffffffff, -1, 0},

      {0xff31, 3207, 1},

      {0xa66a, 2928, 1},

      {0x0208, 514, 1},

      {0xa768, 3078, 1},

      {0x1e64, 1863, 1},

      {0x0464, 1040, 1},

      {0x0164, 315, 1},

      {0x054d, 1418, 1},

      {0x2c64, 673, 1},
      {0xffffffff, -1, 0},

      {0xff2b, 3189, 1},
      {0xffffffff, -1, 0},

      {0xa764, 3072, 1},

      {0xa668, 2925, 1},

      {0x0216, 535, 1},
      {0xffffffff, -1, 0},

      {0x118ab, 3543, 1},

      {0x1e62, 1860, 1},

      {0x0462, 1037, 1},

      {0x0162, 312, 1},

      {0x0214, 532, 1},

      {0x2c62, 655, 1},

      {0xa664, 2919, 1},

      {0x1ed2, 2013, 1},

      {0x04d2, 1193, 1},

      {0xa762, 3069, 1},

      {0x1fd2, 20, 3},

      {0x2cd2, 2709, 1},

      {0x118a9, 3537, 1},

      {0x00d2, 132, 1},

      {0x0206, 511, 1},

      {0x10420, 3333, 1},

      {0x1e20, 1760, 1},

      {0x0420, 938, 1},

      {0x0120, 219, 1},

      {0xa662, 2916, 1},

      {0x2c20, 2517, 1},

      {0x1e60, 1856, 1},

      {0x0460, 1034, 1},

      {0x0160, 309, 1},

      {0x0204, 508, 1},

      {0x2c60, 2562, 1},
      {0xffffffff, -1, 0},

      {0x24bd, 2364, 1},

      {0x216a, 2322, 1},

      {0xa760, 3066, 1},
      {0xffffffff, -1, 0},

      {0xfb16, 125, 2},

      {0x118a7, 3531, 1},

      {0x1efa, 2073, 1},

      {0x04fa, 1253, 1},

      {0x01fa, 493, 1},

      {0x1ffa, 2262, 1},

      {0xfb14, 109, 2},

      {0x03fa, 887, 1},

      {0xa660, 2913, 1},

      {0x2168, 2316, 1},

      {0x01b7, 700, 1},

      {0x1fb7, 10, 3},

      {0x1f6b, 2211, 1},

      {0x2c6b, 2577, 1},

      {0x0200, 502, 1},

      {0xabb7, 1661, 1},

      {0xfb06, 29, 2},

      {0x1e56, 1841, 1},

      {0x2164, 2304, 1},

      {0x0156, 294, 1},

      {0x1f56, 62, 3},

      {0x0520, 1310, 1},

      {0x004f, 40, 1},

      {0x0056, 62, 1},

      {0x10b7, 2814, 1},

      {0xa756, 3051, 1},

      {0xfb04, 5, 3},

      {0x1e78, 1893, 1},

      {0x0478, 1070, 1},

      {0x0178, 168, 1},

      {0x1e54, 1838, 1},

      {0x2162, 2298, 1},

      {0x0154, 291, 1},

      {0x1f54, 57, 3},

      {0xab78, 1472, 1},

      {0xa656, 2898, 1},

      {0x0054, 56, 1},

      {0x1e52, 1835, 1},

      {0xa754, 3048, 1},

      {0x0152, 288, 1},

      {0x1f52, 52, 3},

      {0x24c9, 2400, 1},

      {0x1e32, 1787, 1},

      {0x0052, 49, 1},

      {0x0132, 243, 1},

      {0xa752, 3045, 1},
      {0xffffffff, -1, 0},

      {0xfb00, 4, 2},

      {0xa654, 2895, 1},
      {0xffffffff, -1, 0},

      {0xa732, 2997, 1},

      {0x2160, 2292, 1},

      {0x054f, 1424, 1},

      {0x0556, 1445, 1},

      {0x1e50, 1832, 1},

      {0xa652, 2892, 1},

      {0x0150, 285, 1},

      {0x1f50, 84, 2},

      {0x017b, 348, 1},

      {0x1e4e, 1829, 1},

      {0x0050, 43, 1},

      {0x014e, 282, 1},

      {0xa750, 3042, 1},

      {0xab7b, 1481, 1},

      {0xa77b, 3093, 1},

      {0x004e, 37, 1},

      {0x0554, 1439, 1},

      {0xa74e, 3039, 1},

      {0x1e48, 1820, 1},
      {0xffffffff, -1, 0},

      {0x216b, 2325, 1},

      {0x1f48, 2172, 1},

      {0xa650, 2889, 1},

      {0x0552, 1433, 1},

      {0x0048, 21, 1},
      {0xffffffff, -1, 0},

      {0xa748, 3030, 1},

      {0xa64e, 2886, 1},

      {0x0532, 1337, 1},

      {0x1041e, 3327, 1},

      {0x1e1e, 1757, 1},

      {0x041e, 932, 1},

      {0x011e, 216, 1},

      {0x118b7, 3579, 1},

      {0x2c1e, 2511, 1},
      {0xffffffff, -1, 0},

      {0xa648, 2877, 1},

      {0x1ff9, 2253, 1},
      {0xffffffff, -1, 0},

      {0x03f9, 878, 1},

      {0x0550, 1427, 1},

      {0x10412, 3291, 1},

      {0x1e12, 1739, 1},

      {0x0412, 896, 1},

      {0x0112, 198, 1},

      {0x054e, 1421, 1},

      {0x2c12, 2475, 1},

      {0x10410, 3285, 1},

      {0x1e10, 1736, 1},

      {0x0410, 890, 1},

      {0x0110, 195, 1},
      {0xffffffff, -1, 0},

      {0x2c10, 2469, 1},

      {0x2132, 2289, 1},

      {0x0548, 1403, 1},

      {0x1ef8, 2070, 1},

      {0x04f8, 1250, 1},

      {0x01f8, 490, 1},

      {0x1ff8, 2250, 1},

      {0x0220, 381, 1},

      {0x1ee2, 2037, 1},

      {0x04e2, 1217, 1},

      {0x01e2, 462, 1},

      {0x1fe2, 36, 3},

      {0x2ce2, 2733, 1},

      {0x03e2, 857, 1},

      {0x051e, 1307, 1},

      {0x1ede, 2031, 1},

      {0x04de, 1211, 1},

      {0x01de, 456, 1},
      {0xffffffff, -1, 0},

      {0x2cde, 2727, 1},

      {0x03de, 851, 1},

      {0x00de, 165, 1},

      {0x1f69, 2205, 1},

      {0x2c69, 2574, 1},

      {0x1eda, 2025, 1},

      {0x04da, 1205, 1},

      {0x0512, 1289, 1},

      {0x1fda, 2244, 1},

      {0x2cda, 2721, 1},

      {0x03da, 845, 1},

      {0x00da, 153, 1},
      {0xffffffff, -1, 0},

      {0x0510, 1286, 1},

      {0x1ed8, 2022, 1},

      {0x04d8, 1202, 1},
      {0xffffffff, -1, 0},

      {0x1fd8, 2274, 1},

      {0x2cd8, 2718, 1},

      {0x03d8, 842, 1},

      {0x00d8, 147, 1},

      {0x1ed6, 2019, 1},

      {0x04d6, 1199, 1},
      {0xffffffff, -1, 0},

      {0x1fd6, 76, 2},

      {0x2cd6, 2715, 1},

      {0x03d6, 792, 1},

      {0x00d6, 144, 1},

      {0x1ec8, 1998, 1},
      {0xffffffff, -1, 0},

      {0x01c8, 421, 1},

      {0x1fc8, 2232, 1},

      {0x2cc8, 2694, 1},

      {0xff32, 3210, 1},

      {0x00c8, 102, 1},

      {0x04c7, 1175, 1},

      {0x01c7, 421, 1},

      {0x1fc7, 15, 3},

      {0x1ec0, 1986, 1},

      {0x04c0, 1187, 1},

      {0x00c7, 99, 1},
      {0xffffffff, -1, 0},

      {0x2cc0, 2682, 1},

      {0x0179, 345, 1},

      {0x00c0, 77, 1},

      {0x0232, 574, 1},

      {0x01b3, 402, 1},

      {0x1fb3, 62, 2},

      {0xab79, 1475, 1},

      {0xa779, 3090, 1},

      {0x10c7, 2859, 1},

      {0xabb3, 1649, 1},

      {0xa7b3, 3156, 1},

      {0x1fa5, 234, 2},

      {0x10c0, 2841, 1},

      {0x03a5, 807, 1},
      {0xffffffff, -1, 0},

      {0xaba5, 1607, 1},

      {0x01b1, 691, 1},

      {0x10ca5, 3468, 1},

      {0x10b3, 2802, 1},

      {0x2169, 2319, 1},

      {0x024e, 601, 1},

      {0xabb1, 1643, 1},

      {0xa7b1, 682, 1},

      {0x10cb1, 3504, 1},

      {0x10a5, 2760, 1},
      {0xffffffff, -1, 0},

      {0x01af, 399, 1},

      {0x1faf, 244, 2},
      {0xffffffff, -1, 0},

      {0x0248, 592, 1},

      {0x10b1, 2796, 1},

      {0xabaf, 1637, 1},

      {0x1fad, 234, 2},

      {0x10caf, 3498, 1},

      {0x04cd, 1184, 1},

      {0x01cd, 429, 1},

      {0xabad, 1631, 1},

      {0xa7ad, 658, 1},

      {0x10cad, 3492, 1},

      {0x00cd, 117, 1},

      {0x10af, 2790, 1},

      {0x021e, 547, 1},

      {0x1fa3, 224, 2},
      {0xffffffff, -1, 0},

      {0x03a3, 800, 1},

      {0x10ad, 2784, 1},

      {0xaba3, 1601, 1},
      {0xffffffff, -1, 0},

      {0x10ca3, 3462, 1},

      {0x10cd, 2862, 1},

      {0x1fa1, 214, 2},

      {0x24b7, 2346, 1},

      {0x03a1, 796, 1},

      {0x0212, 529, 1},

      {0xaba1, 1595, 1},

      {0x10a3, 2754, 1},

      {0x10ca1, 3456, 1},

      {0x01d3, 438, 1},

      {0x1fd3, 25, 3},

      {0x0210, 526, 1},
      {0xffffffff, -1, 0},

      {0x00d3, 135, 1},

      {0x1e97, 34, 2},

      {0x10a1, 2748, 1},

      {0x0197, 649, 1},

      {0x1f97, 204, 2},
      {0xffffffff, -1, 0},

      {0x0397, 759, 1},

      {0x1041d, 3324, 1},

      {0xab97, 1565, 1},

      {0x041d, 929, 1},

      {0x10c97, 3426, 1},

      {0x1f1d, 2121, 1},

      {0x2c1d, 2508, 1},

      {0x1e72, 1884, 1},

      {0x0472, 1061, 1},

      {0x0172, 336, 1},

      {0x118b3, 3567, 1},

      {0x2c72, 2580, 1},

      {0x0372, 712, 1},

      {0x1041b, 3318, 1},

      {0xab72, 1454, 1},

      {0x041b, 923, 1},

      {0x118a5, 3525, 1},

      {0x1f1b, 2115, 1},

      {0x2c1b, 2502, 1},

      {0x1e70, 1881, 1},

      {0x0470, 1058, 1},

      {0x0170, 333, 1},

      {0x118b1, 3561, 1},

      {0x2c70, 610, 1},

      {0x0370, 709, 1},

      {0x1e46, 1817, 1},

      {0xab70, 1448, 1},

      {0x1e66, 1866, 1},

      {0x0466, 1043, 1},

      {0x0166, 318, 1},

      {0x1e44, 1814, 1},

      {0x0046, 15, 1},

      {0x118af, 3555, 1},

      {0xa746, 3027, 1},
      {0xffffffff, -1, 0},

      {0xa766, 3075, 1},

      {0x0044, 9, 1},

      {0x118ad, 3549, 1},

      {0xa744, 3024, 1},

      {0x1e7a, 1896, 1},

      {0x047a, 1073, 1},

      {0x1e3a, 1799, 1},
      {0xffffffff, -1, 0},

      {0xa646, 2874, 1},

      {0x1f3a, 2154, 1},

      {0xa666, 2922, 1},

      {0xab7a, 1478, 1},

      {0x118a3, 3519, 1},

      {0xa644, 2871, 1},

      {0xa73a, 3009, 1},
      {0xffffffff, -1, 0},

      {0x1ef4, 2064, 1},

      {0x04f4, 1244, 1},

      {0x01f4, 487, 1},

      {0x1ff4, 101, 2},

      {0x118a1, 3513, 1},

      {0x03f4, 762, 1},

      {0x1eec, 2052, 1},

      {0x04ec, 1232, 1},

      {0x01ec, 477, 1},

      {0x1fec, 2286, 1},

      {0x0546, 1397, 1},

      {0x03ec, 872, 1},
      {0xffffffff, -1, 0},

      {0x013f, 261, 1},

      {0x1f3f, 2169, 1},

      {0x0544, 1391, 1},

      {0x1eea, 2049, 1},

      {0x04ea, 1229, 1},

      {0x01ea, 474, 1},

      {0x1fea, 2256, 1},
      {0xffffffff, -1, 0},

      {0x03ea, 869, 1},

      {0x1ee8, 2046, 1},

      {0x04e8, 1226, 1},

      {0x01e8, 471, 1},

      {0x1fe8, 2280, 1},

      {0x053a, 1361, 1},

      {0x03e8, 866, 1},

      {0x1ee6, 2043, 1},

      {0x04e6, 1223, 1},

      {0x01e6, 468, 1},

      {0x1fe6, 88, 2},

      {0x1f4b, 2181, 1},

      {0x03e6, 863, 1},

      {0x1e5e, 1853, 1},

      {0x004b, 27, 1},

      {0x015e, 306, 1},

      {0x2166, 2310, 1},

      {0x1ee4, 2040, 1},

      {0x04e4, 1220, 1},

      {0x01e4, 465, 1},

      {0x1fe4, 80, 2},

      {0xa75e, 3063, 1},

      {0x03e4, 860, 1},

      {0x1ee0, 2034, 1},

      {0x04e0, 1214, 1},

      {0x01e0, 459, 1},

      {0x053f, 1376, 1},

      {0x2ce0, 2730, 1},

      {0x03e0, 854, 1},

      {0x1edc, 2028, 1},

      {0x04dc, 1208, 1},

      {0xa65e, 2910, 1},
      {0xffffffff, -1, 0},

      {0x2cdc, 2724, 1},

      {0x03dc, 848, 1},

      {0x00dc, 159, 1},

      {0x1ed0, 2010, 1},

      {0x04d0, 1190, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x2cd0, 2706, 1},

      {0x03d0, 742, 1},

      {0x00d0, 126, 1},

      {0x1ecc, 2004, 1},

      {0x054b, 1412, 1},
      {0xffffffff, -1, 0},

      {0x1fcc, 71, 2},

      {0x2ccc, 2700, 1},

      {0x1ec6, 1995, 1},

      {0x00cc, 114, 1},
      {0xffffffff, -1, 0},

      {0x1fc6, 67, 2},

      {0x2cc6, 2691, 1},

      {0x24c8, 2397, 1},

      {0x00c6, 96, 1},

      {0x04c5, 1172, 1},

      {0x01c5, 417, 1},
      {0xffffffff, -1, 0},

      {0x1fbb, 2229, 1},

      {0x24c7, 2394, 1},

      {0x00c5, 92, 1},

      {0x1fb9, 2271, 1},

      {0xabbb, 1673, 1},

      {0x24c0, 2373, 1},

      {0x04c3, 1169, 1},

      {0xabb9, 1667, 1},

      {0x1fc3, 71, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x00c3, 86, 1},

      {0x10c5, 2856, 1},

      {0x10bb, 2826, 1},

      {0x1ed4, 2016, 1},

      {0x04d4, 1196, 1},

      {0x10b9, 2820, 1},

      {0x13fc, 1700, 1},

      {0x2cd4, 2712, 1},

      {0x0246, 589, 1},

      {0x00d4, 138, 1},

      {0x10c3, 2850, 1},
      {0xffffffff, -1, 0},

      {0xff3a, 3234, 1},

      {0x0244, 688, 1},

      {0x019f, 670, 1},

      {0x1f9f, 204, 2},
      {0xffffffff, -1, 0},

      {0x039f, 789, 1},
      {0xffffffff, -1, 0},

      {0xab9f, 1589, 1},
      {0xffffffff, -1, 0},

      {0x10c9f, 3450, 1},

      {0x019d, 667, 1},

      {0x1f9d, 194, 2},

      {0x023a, 2565, 1},

      {0x039d, 783, 1},

      {0x1e5a, 1847, 1},

      {0xab9d, 1583, 1},

      {0x015a, 300, 1},

      {0x10c9d, 3444, 1},

      {0x1e9b, 1856, 1},

      {0x24cd, 2412, 1},

      {0x005a, 74, 1},

      {0x1f9b, 184, 2},

      {0xa75a, 3057, 1},

      {0x039b, 776, 1},

      {0x1ece, 2007, 1},

      {0xab9b, 1577, 1},

      {0x1e99, 42, 2},

      {0x10c9b, 3438, 1},

      {0x2cce, 2703, 1},

      {0x1f99, 174, 2},

      {0x00ce, 120, 1},

      {0x0399, 767, 1},

      {0xa65a, 2904, 1},

      {0xab99, 1571, 1},
      {0xffffffff, -1, 0},

      {0x10c99, 3432, 1},

      {0x0193, 634, 1},

      {0x1f93, 184, 2},

      {0x1e58, 1844, 1},

      {0x0393, 746, 1},

      {0x0158, 297, 1},

      {0xab93, 1553, 1},
      {0xffffffff, -1, 0},

      {0x10c93, 3414, 1},

      {0x0058, 68, 1},

      {0x042d, 977, 1},

      {0xa758, 3054, 1},

      {0x1f2d, 2139, 1},

      {0x2c2d, 2556, 1},

      {0x118bb, 3591, 1},

      {0x0191, 369, 1},

      {0x1f91, 174, 2},

      {0x118b9, 3585, 1},

      {0x0391, 739, 1},
      {0xffffffff, -1, 0},

      {0xab91, 1547, 1},

      {0xa658, 2901, 1},

      {0x10c91, 3408, 1},

      {0x018f, 625, 1},

      {0x1f8f, 164, 2},
      {0xffffffff, -1, 0},

      {0x038f, 836, 1},
      {0xffffffff, -1, 0},

      {0xab8f, 1541, 1},
      {0xffffffff, -1, 0},

      {0x10c8f, 3402, 1},

      {0x018b, 366, 1},

      {0x1f8b, 144, 2},
      {0xffffffff, -1, 0},

      {0x0187, 363, 1},

      {0x1f87, 164, 2},

      {0xab8b, 1529, 1},

      {0xa78b, 3111, 1},

      {0x10c8b, 3390, 1},

      {0xab87, 1517, 1},

      {0x04c1, 1166, 1},

      {0x10c87, 3378, 1},

      {0x1e7e, 1902, 1},

      {0x047e, 1079, 1},
      {0xffffffff, -1, 0},

      {0x00c1, 80, 1},

      {0x2c7e, 580, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab7e, 1490, 1},

      {0xa77e, 3096, 1},

      {0x1e76, 1890, 1},

      {0x0476, 1067, 1},

      {0x0176, 342, 1},

      {0x1e42, 1811, 1},

      {0x10c1, 2844, 1},

      {0x0376, 715, 1},

      {0x1e36, 1793, 1},

      {0xab76, 1466, 1},

      {0x0136, 249, 1},

      {0x0042, 3, 1},

      {0x1e3e, 1805, 1},

      {0xa742, 3021, 1},

      {0x1e38, 1796, 1},

      {0x1f3e, 2166, 1},

      {0xa736, 3003, 1},

      {0x1f38, 2148, 1},
      {0xffffffff, -1, 0},

      {0x0587, 105, 2},

      {0xa73e, 3015, 1},
      {0xffffffff, -1, 0},

      {0xa738, 3006, 1},

      {0xa642, 2868, 1},

      {0x1e5c, 1850, 1},

      {0x1e34, 1790, 1},

      {0x015c, 303, 1},

      {0x0134, 246, 1},

      {0x1ef6, 2067, 1},

      {0x04f6, 1247, 1},

      {0x01f6, 372, 1},

      {0x1ff6, 92, 2},

      {0xa75c, 3060, 1},

      {0xa734, 3000, 1},

      {0x1ef0, 2058, 1},

      {0x04f0, 1238, 1},

      {0x01f0, 20, 2},
      {0xffffffff, -1, 0},

      {0x1e30, 1784, 1},

      {0x03f0, 772, 1},

      {0x0130, 261, 2},

      {0x0542, 1385, 1},

      {0xa65c, 2907, 1},

      {0x1f83, 144, 2},

      {0x0536, 1349, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab83, 1505, 1},

      {0x053e, 1373, 1},

      {0x10c83, 3366, 1},

      {0x0538, 1355, 1},

      {0x1eee, 2055, 1},

      {0x04ee, 1235, 1},

      {0x01ee, 480, 1},

      {0x1f8d, 154, 2},
      {0xffffffff, -1, 0},

      {0x03ee, 875, 1},
      {0xffffffff, -1, 0},

      {0xab8d, 1535, 1},

      {0xa78d, 643, 1},

      {0x10c8d, 3396, 1},

      {0x0534, 1343, 1},

      {0x0181, 613, 1},

      {0x1f81, 134, 2},

      {0x013d, 258, 1},

      {0x1f3d, 2163, 1},
      {0xffffffff, -1, 0},

      {0xab81, 1499, 1},

      {0x017f, 52, 1},

      {0x10c81, 3360, 1},

      {0x2c7f, 583, 1},

      {0x037f, 881, 1},

      {0xff2d, 3195, 1},

      {0xab7f, 1493, 1},

      {0x1e74, 1887, 1},

      {0x0474, 1064, 1},

      {0x0174, 339, 1},

      {0x1e3c, 1802, 1},

      {0x0149, 46, 2},

      {0x1f49, 2175, 1},

      {0x1f3c, 2160, 1},

      {0xab74, 1460, 1},

      {0x0049, 3606, 1},

      {0x0143, 267, 1},

      {0x24cc, 2409, 1},

      {0xa73c, 3012, 1},
      {0xffffffff, -1, 0},

      {0x0043, 6, 1},

      {0x0141, 264, 1},

      {0x24c6, 2391, 1},

      {0x013b, 255, 1},

      {0x1f3b, 2157, 1},

      {0x0041, 0, 1},

      {0x0139, 252, 1},

      {0x1f39, 2151, 1},

      {0x24c5, 2388, 1},

      {0x24bb, 2358, 1},

      {0x13fa, 1694, 1},

      {0x053d, 1370, 1},

      {0x24b9, 2352, 1},

      {0x0429, 965, 1},

      {0x2183, 2340, 1},

      {0x1f29, 2127, 1},

      {0x2c29, 2544, 1},

      {0x24c3, 2382, 1},

      {0x10427, 3354, 1},

      {0x10425, 3348, 1},

      {0x0427, 959, 1},

      {0x0425, 953, 1},
      {0xffffffff, -1, 0},

      {0x2c27, 2538, 1},

      {0x2c25, 2532, 1},

      {0x0549, 1406, 1},

      {0x053c, 1367, 1},

      {0x10423, 3342, 1},
      {0xffffffff, -1, 0},

      {0x0423, 947, 1},

      {0x0543, 1388, 1},
      {0xffffffff, -1, 0},

      {0x2c23, 2526, 1},

      {0xff36, 3222, 1},
      {0xffffffff, -1, 0},

      {0x0541, 1382, 1},

      {0x10421, 3336, 1},

      {0x053b, 1364, 1},

      {0x0421, 941, 1},

      {0xff38, 3228, 1},

      {0x0539, 1358, 1},

      {0x2c21, 2520, 1},

      {0x10419, 3312, 1},

      {0x10417, 3306, 1},

      {0x0419, 917, 1},

      {0x0417, 911, 1},

      {0x1f19, 2109, 1},

      {0x2c19, 2496, 1},

      {0x2c17, 2490, 1},

      {0x023e, 2568, 1},

      {0xff34, 3216, 1},

      {0x10415, 3300, 1},

      {0x10413, 3294, 1},

      {0x0415, 905, 1},

      {0x0413, 899, 1},
      {0xffffffff, -1, 0},

      {0x2c15, 2484, 1},

      {0x2c13, 2478, 1},
      {0xffffffff, -1, 0},

      {0x24ce, 2415, 1},

      {0x1040f, 3282, 1},
      {0xffffffff, -1, 0},

      {0x040f, 1031, 1},

      {0xff30, 3204, 1},

      {0x1f0f, 2103, 1},

      {0x2c0f, 2466, 1},

      {0x1040d, 3276, 1},
      {0xffffffff, -1, 0},

      {0x040d, 1025, 1},

      {0x0147, 273, 1},

      {0x1f0d, 2097, 1},

      {0x2c0d, 2460, 1},

      {0x1040b, 3270, 1},

      {0x0047, 18, 1},

      {0x040b, 1019, 1},

      {0x0230, 571, 1},

      {0x1f0b, 2091, 1},

      {0x2c0b, 2454, 1},

      {0x10409, 3264, 1},

      {0x10405, 3252, 1},

      {0x0409, 1013, 1},

      {0x0405, 1001, 1},

      {0x1f09, 2085, 1},

      {0x2c09, 2448, 1},

      {0x2c05, 2436, 1},

      {0x10403, 3246, 1},

      {0x10401, 3240, 1},

      {0x0403, 995, 1},

      {0x0401, 989, 1},
      {0xffffffff, -1, 0},

      {0x2c03, 2430, 1},

      {0x2c01, 2424, 1},

      {0x13f9, 1691, 1},

      {0x042f, 983, 1},
      {0xffffffff, -1, 0},

      {0x1f2f, 2145, 1},

      {0x1041f, 3330, 1},
      {0xffffffff, -1, 0},

      {0x041f, 935, 1},

      {0x023d, 378, 1},

      {0x10411, 3288, 1},

      {0x2c1f, 2514, 1},

      {0x0411, 893, 1},

      {0x0547, 1400, 1},
      {0xffffffff, -1, 0},

      {0x2c11, 2472, 1},

      {0x10407, 3258, 1},
      {0xffffffff, -1, 0},

      {0x0407, 1007, 1},

      {0x24c1, 2376, 1},
      {0xffffffff, -1, 0},

      {0x2c07, 2442, 1},
      {0xffffffff, -1, 0},

      {0x13f8, 1688, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff39, 3231, 1},
      {0xffffffff, -1, 0},

      {0x0243, 354, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x0241, 586, 1},

      {0xff29, 3183, 1},

      {0x023b, 577, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff27, 3177, 1},

      {0xff25, 3171, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff23, 3165, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff21, 3159, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb17, 117, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff2f, 3201, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb15, 113, 2},

      {0xfb13, 121, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb05, 29, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb03, 0, 3},

      {0xfb01, 8, 2}
    };

  if (0 == 0)
    {
      int key = hash(&code);

      if (key <= MAX_HASH_VALUE && key >= 0)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
//flaw_line_below:
          if (code == gcode)
//fix_flaw_line_below:
//          if (code == gcode && wordlist[key].index >= 0)
             return &wordlist[key];
         }
     }
  return 0;
}
",181281,"unicode_unfold_key(OnigCodePoint code)
{
  static const struct ByUnfoldKey wordlist[] =
    {
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0x1040a, 3267, 1},

      {0x1e0a, 1727, 1},

      {0x040a, 1016, 1},

      {0x010a, 186, 1},

      {0x1f0a, 2088, 1},

      {0x2c0a, 2451, 1},

      {0x0189, 619, 1},

      {0x1f89, 134, 2},

      {0x1f85, 154, 2},

      {0x0389, 733, 1},

      {0x03ff, 724, 1},

      {0xab89, 1523, 1},

      {0xab85, 1511, 1},

      {0x10c89, 3384, 1},

      {0x10c85, 3372, 1},

      {0x1e84, 1911, 1},

      {0x03f5, 752, 1},

      {0x0184, 360, 1},

      {0x1f84, 149, 2},

      {0x2c84, 2592, 1},

      {0x017d, 351, 1},

      {0x1ff3, 96, 2},

      {0xab84, 1508, 1},

      {0xa784, 3105, 1},

      {0x10c84, 3369, 1},

      {0xab7d, 1487, 1},

      {0xa77d, 1706, 1},

      {0x1e98, 38, 2},

      {0x0498, 1106, 1},

      {0x0198, 375, 1},

      {0x1f98, 169, 2},

      {0x2c98, 2622, 1},

      {0x0398, 762, 1},

      {0xa684, 2940, 1},

      {0xab98, 1568, 1},

      {0xa798, 3123, 1},

      {0x10c98, 3429, 1},

      {0x050a, 1277, 1},

      {0x1ffb, 2265, 1},

      {0x1e96, 16, 2},

      {0x0496, 1103, 1},

      {0x0196, 652, 1},

      {0x1f96, 199, 2},

      {0x2c96, 2619, 1},

      {0x0396, 756, 1},

      {0xa698, 2970, 1},

      {0xab96, 1562, 1},

      {0xa796, 3120, 1},

      {0x10c96, 3423, 1},

      {0x1feb, 2259, 1},

      {0x2ceb, 2736, 1},

      {0x1e90, 1929, 1},

      {0x0490, 1094, 1},

      {0x0190, 628, 1},

      {0x1f90, 169, 2},

      {0x2c90, 2610, 1},

      {0x0390, 25, 3},

      {0xa696, 2967, 1},

      {0xab90, 1544, 1},

      {0xa790, 3114, 1},

      {0x10c90, 3405, 1},

      {0x01d7, 444, 1},

      {0x1fd7, 31, 3},

      {0x1ea6, 1947, 1},

      {0x04a6, 1127, 1},

      {0x01a6, 676, 1},

      {0x1fa6, 239, 2},

      {0x2ca6, 2643, 1},

      {0x03a6, 810, 1},

      {0xa690, 2958, 1},

      {0xaba6, 1610, 1},

      {0xa7a6, 3144, 1},

      {0x10ca6, 3471, 1},

      {0x1ea4, 1944, 1},

      {0x04a4, 1124, 1},

      {0x01a4, 390, 1},

      {0x1fa4, 229, 2},

      {0x2ca4, 2640, 1},

      {0x03a4, 804, 1},

      {0x10a6, 2763, 1},

      {0xaba4, 1604, 1},

      {0xa7a4, 3141, 1},

      {0x10ca4, 3465, 1},

      {0x1ea0, 1938, 1},

      {0x04a0, 1118, 1},

      {0x01a0, 384, 1},

      {0x1fa0, 209, 2},

      {0x2ca0, 2634, 1},

      {0x03a0, 792, 1},

      {0x10a4, 2757, 1},

      {0xaba0, 1592, 1},

      {0xa7a0, 3135, 1},

      {0x10ca0, 3453, 1},

      {0x1eb2, 1965, 1},

      {0x04b2, 1145, 1},

      {0x01b2, 694, 1},

      {0x1fb2, 249, 2},

      {0x2cb2, 2661, 1},

      {0x03fd, 718, 1},

      {0x10a0, 2745, 1},

      {0xabb2, 1646, 1},

      {0xa7b2, 703, 1},

      {0x10cb2, 3507, 1},

      {0x1eac, 1956, 1},

      {0x04ac, 1136, 1},

      {0x01ac, 396, 1},

      {0x1fac, 229, 2},

      {0x2cac, 2652, 1},

      {0x0537, 1352, 1},

      {0x10b2, 2799, 1},

      {0xabac, 1628, 1},

      {0xa7ac, 637, 1},

      {0x10cac, 3489, 1},

      {0x1eaa, 1953, 1},

      {0x04aa, 1133, 1},

      {0x00dd, 162, 1},

      {0x1faa, 219, 2},

      {0x2caa, 2649, 1},

      {0x03aa, 824, 1},

      {0x10ac, 2781, 1},

      {0xabaa, 1622, 1},

      {0xa7aa, 646, 1},

      {0x10caa, 3483, 1},

      {0x1ea8, 1950, 1},

      {0x04a8, 1130, 1},

      {0x020a, 517, 1},

      {0x1fa8, 209, 2},

      {0x2ca8, 2646, 1},

      {0x03a8, 817, 1},

      {0x10aa, 2775, 1},

      {0xaba8, 1616, 1},

      {0xa7a8, 3147, 1},

      {0x10ca8, 3477, 1},

      {0x1ea2, 1941, 1},

      {0x04a2, 1121, 1},

      {0x01a2, 387, 1},

      {0x1fa2, 219, 2},

      {0x2ca2, 2637, 1},

      {0x118a6, 3528, 1},

      {0x10a8, 2769, 1},

      {0xaba2, 1598, 1},

      {0xa7a2, 3138, 1},

      {0x10ca2, 3459, 1},

      {0x2ced, 2739, 1},

      {0x1fe9, 2283, 1},

      {0x1fe7, 47, 3},

      {0x1eb0, 1962, 1},

      {0x04b0, 1142, 1},

      {0x118a4, 3522, 1},

      {0x10a2, 2751, 1},

      {0x2cb0, 2658, 1},

      {0x03b0, 41, 3},

      {0x1fe3, 41, 3},

      {0xabb0, 1640, 1},

      {0xa7b0, 706, 1},

      {0x10cb0, 3501, 1},

      {0x01d9, 447, 1},

      {0x1fd9, 2277, 1},

      {0x118a0, 3510, 1},

      {0x00df, 24, 2},

      {0x00d9, 150, 1},

      {0xab77, 1469, 1},

      {0x10b0, 2793, 1},

      {0x1eae, 1959, 1},

      {0x04ae, 1139, 1},

      {0x01ae, 685, 1},

      {0x1fae, 239, 2},

      {0x2cae, 2655, 1},

      {0x118b2, 3564, 1},

      {0xab73, 1457, 1},

      {0xabae, 1634, 1},

      {0xab71, 1451, 1},

      {0x10cae, 3495, 1},

      {0x1e2a, 1775, 1},

      {0x042a, 968, 1},

      {0x012a, 234, 1},

      {0x1f2a, 2130, 1},

      {0x2c2a, 2547, 1},

      {0x118ac, 3546, 1},

      {0x10ae, 2787, 1},

      {0x0535, 1346, 1},

      {0xa72a, 2988, 1},

      {0x1e9a, 0, 2},

      {0x049a, 1109, 1},

      {0xff37, 3225, 1},

      {0x1f9a, 179, 2},

      {0x2c9a, 2625, 1},

      {0x039a, 772, 1},

      {0x118aa, 3540, 1},

      {0xab9a, 1574, 1},

      {0xa79a, 3126, 1},

      {0x10c9a, 3435, 1},

      {0x1e94, 1935, 1},

      {0x0494, 1100, 1},

      {0x0194, 640, 1},

      {0x1f94, 189, 2},

      {0x2c94, 2616, 1},

      {0x0394, 749, 1},

      {0x118a8, 3534, 1},

      {0xab94, 1556, 1},

      {0xa69a, 2973, 1},

      {0x10c94, 3417, 1},

      {0x10402, 3243, 1},

      {0x1e02, 1715, 1},

      {0x0402, 992, 1},

      {0x0102, 174, 1},

      {0x0533, 1340, 1},

      {0x2c02, 2427, 1},

      {0x118a2, 3516, 1},

      {0x052a, 1325, 1},

      {0xa694, 2964, 1},

      {0x1e92, 1932, 1},

      {0x0492, 1097, 1},

      {0x2165, 2307, 1},

      {0x1f92, 179, 2},

      {0x2c92, 2613, 1},

      {0x0392, 742, 1},

      {0x2161, 2295, 1},

      {0xab92, 1550, 1},

      {0xa792, 3117, 1},

      {0x10c92, 3411, 1},

      {0x118b0, 3558, 1},

      {0x1f5f, 2199, 1},

      {0x1e8e, 1926, 1},

      {0x048e, 1091, 1},

      {0x018e, 453, 1},

      {0x1f8e, 159, 2},

      {0x2c8e, 2607, 1},

      {0x038e, 833, 1},

      {0xa692, 2961, 1},

      {0xab8e, 1538, 1},

      {0x0055, 59, 1},

      {0x10c8e, 3399, 1},

      {0x1f5d, 2196, 1},

      {0x212a, 27, 1},

      {0x04cb, 1181, 1},

      {0x01cb, 425, 1},

      {0x1fcb, 2241, 1},

      {0x118ae, 3552, 1},

      {0x0502, 1265, 1},

      {0x00cb, 111, 1},

      {0xa68e, 2955, 1},

      {0x1e8a, 1920, 1},

      {0x048a, 1085, 1},

      {0x018a, 622, 1},

      {0x1f8a, 139, 2},

      {0x2c8a, 2601, 1},

      {0x038a, 736, 1},

      {0x2c67, 2571, 1},

      {0xab8a, 1526, 1},

      {0x1e86, 1914, 1},

      {0x10c8a, 3387, 1},

      {0x0186, 616, 1},

      {0x1f86, 159, 2},

      {0x2c86, 2595, 1},

      {0x0386, 727, 1},

      {0xff35, 3219, 1},

      {0xab86, 1514, 1},

      {0xa786, 3108, 1},

      {0x10c86, 3375, 1},

      {0xa68a, 2949, 1},

      {0x0555, 1442, 1},

      {0x1ebc, 1980, 1},

      {0x04bc, 1160, 1},

      {0x01bc, 411, 1},

      {0x1fbc, 62, 2},

      {0x2cbc, 2676, 1},

      {0x1f5b, 2193, 1},

      {0xa686, 2943, 1},

      {0xabbc, 1676, 1},

      {0x1eb8, 1974, 1},

      {0x04b8, 1154, 1},

      {0x01b8, 408, 1},

      {0x1fb8, 2268, 1},

      {0x2cb8, 2670, 1},

      {0x01db, 450, 1},

      {0x1fdb, 2247, 1},

      {0xabb8, 1664, 1},

      {0x10bc, 2829, 1},

      {0x00db, 156, 1},

      {0x1eb6, 1971, 1},

      {0x04b6, 1151, 1},

      {0xff33, 3213, 1},

      {0x1fb6, 58, 2},

      {0x2cb6, 2667, 1},

      {0xff2a, 3186, 1},

      {0x10b8, 2817, 1},

      {0xabb6, 1658, 1},

      {0xa7b6, 3153, 1},

      {0x10426, 3351, 1},

      {0x1e26, 1769, 1},

      {0x0426, 956, 1},

      {0x0126, 228, 1},

      {0x0053, 52, 1},

      {0x2c26, 2535, 1},

      {0x0057, 65, 1},

      {0x10b6, 2811, 1},

      {0x022a, 562, 1},

      {0xa726, 2982, 1},

      {0x1e2e, 1781, 1},

      {0x042e, 980, 1},

      {0x012e, 240, 1},

      {0x1f2e, 2142, 1},

      {0x2c2e, 2559, 1},
      {0xffffffff, -1, 0},

      {0x2167, 2313, 1},
      {0xffffffff, -1, 0},

      {0xa72e, 2994, 1},

      {0x1e2c, 1778, 1},

      {0x042c, 974, 1},

      {0x012c, 237, 1},

      {0x1f2c, 2136, 1},

      {0x2c2c, 2553, 1},

      {0x1f6f, 2223, 1},

      {0x2c6f, 604, 1},

      {0xabbf, 1685, 1},

      {0xa72c, 2991, 1},

      {0x1e28, 1772, 1},

      {0x0428, 962, 1},

      {0x0128, 231, 1},

      {0x1f28, 2124, 1},

      {0x2c28, 2541, 1},
      {0xffffffff, -1, 0},

      {0x0553, 1436, 1},

      {0x10bf, 2838, 1},

      {0xa728, 2985, 1},

      {0x0526, 1319, 1},

      {0x0202, 505, 1},

      {0x1e40, 1808, 1},

      {0x10424, 3345, 1},

      {0x1e24, 1766, 1},

      {0x0424, 950, 1},

      {0x0124, 225, 1},
      {0xffffffff, -1, 0},

      {0x2c24, 2529, 1},

      {0x052e, 1331, 1},

      {0xa740, 3018, 1},

      {0x118bc, 3594, 1},

      {0xa724, 2979, 1},

      {0x1ef2, 2061, 1},

      {0x04f2, 1241, 1},

      {0x01f2, 483, 1},

      {0x1ff2, 257, 2},

      {0x2cf2, 2742, 1},

      {0x052c, 1328, 1},

      {0x118b8, 3582, 1},

      {0xa640, 2865, 1},

      {0x10422, 3339, 1},

      {0x1e22, 1763, 1},

      {0x0422, 944, 1},

      {0x0122, 222, 1},

      {0x2126, 820, 1},

      {0x2c22, 2523, 1},

      {0x0528, 1322, 1},

      {0x01f1, 483, 1},

      {0x118b6, 3576, 1},

      {0xa722, 2976, 1},

      {0x03f1, 796, 1},

      {0x1ebe, 1983, 1},

      {0x04be, 1163, 1},

      {0xfb02, 12, 2},

      {0x1fbe, 767, 1},

      {0x2cbe, 2679, 1},

      {0x01b5, 405, 1},

      {0x0540, 1379, 1},

      {0xabbe, 1682, 1},

      {0x0524, 1316, 1},

      {0x00b5, 779, 1},

      {0xabb5, 1655, 1},

      {0x1eba, 1977, 1},

      {0x04ba, 1157, 1},

      {0x216f, 2337, 1},

      {0x1fba, 2226, 1},

      {0x2cba, 2673, 1},

      {0x10be, 2835, 1},

      {0x0051, 46, 1},

      {0xabba, 1670, 1},

      {0x10b5, 2808, 1},

      {0x1e6e, 1878, 1},

      {0x046e, 1055, 1},

      {0x016e, 330, 1},

      {0x1f6e, 2220, 1},

      {0x2c6e, 664, 1},

      {0x118bf, 3603, 1},

      {0x0522, 1313, 1},

      {0x10ba, 2823, 1},

      {0xa76e, 3087, 1},

      {0x1eb4, 1968, 1},

      {0x04b4, 1148, 1},

      {0x2c75, 2583, 1},

      {0x1fb4, 50, 2},

      {0x2cb4, 2664, 1},

      {0xab75, 1463, 1},

      {0x1ec2, 1989, 1},

      {0xabb4, 1652, 1},

      {0xa7b4, 3150, 1},

      {0x1fc2, 253, 2},

      {0x2cc2, 2685, 1},

      {0x03c2, 800, 1},

      {0x00c2, 83, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff26, 3174, 1},

      {0x10b4, 2805, 1},

      {0x1eca, 2001, 1},

      {0x0551, 1430, 1},

      {0x01ca, 425, 1},

      {0x1fca, 2238, 1},

      {0x2cca, 2697, 1},

      {0x10c2, 2847, 1},

      {0x00ca, 108, 1},

      {0xff2e, 3198, 1},

      {0x1e8c, 1923, 1},

      {0x048c, 1088, 1},

      {0x0226, 556, 1},

      {0x1f8c, 149, 2},

      {0x2c8c, 2604, 1},

      {0x038c, 830, 1},
      {0xffffffff, -1, 0},

      {0xab8c, 1532, 1},

      {0xff2c, 3192, 1},

      {0x10c8c, 3393, 1},

      {0x1ec4, 1992, 1},

      {0x022e, 568, 1},

      {0x01c4, 417, 1},

      {0x1fc4, 54, 2},

      {0x2cc4, 2688, 1},
      {0xffffffff, -1, 0},

      {0x00c4, 89, 1},

      {0xff28, 3180, 1},

      {0xa68c, 2952, 1},

      {0x01cf, 432, 1},

      {0x022c, 565, 1},

      {0x118be, 3600, 1},

      {0x03cf, 839, 1},

      {0x00cf, 123, 1},

      {0x118b5, 3573, 1},
      {0xffffffff, -1, 0},

      {0x10c4, 2853, 1},

      {0x216e, 2334, 1},

      {0x24cb, 2406, 1},

      {0x0228, 559, 1},

      {0xff24, 3168, 1},
      {0xffffffff, -1, 0},

      {0x118ba, 3588, 1},

      {0x1efe, 2079, 1},

      {0x04fe, 1259, 1},

      {0x01fe, 499, 1},

      {0x1e9e, 24, 2},

      {0x049e, 1115, 1},

      {0x03fe, 721, 1},

      {0x1f9e, 199, 2},

      {0x2c9e, 2631, 1},

      {0x039e, 786, 1},

      {0x0224, 553, 1},

      {0xab9e, 1586, 1},

      {0xa79e, 3132, 1},

      {0x10c9e, 3447, 1},

      {0x01f7, 414, 1},

      {0x1ff7, 67, 3},

      {0xff22, 3162, 1},

      {0x03f7, 884, 1},

      {0x118b4, 3570, 1},

      {0x049c, 1112, 1},

      {0x019c, 661, 1},

      {0x1f9c, 189, 2},

      {0x2c9c, 2628, 1},

      {0x039c, 779, 1},

      {0x24bc, 2361, 1},

      {0xab9c, 1580, 1},

      {0xa79c, 3129, 1},

      {0x10c9c, 3441, 1},

      {0x0222, 550, 1},

      {0x1e7c, 1899, 1},

      {0x047c, 1076, 1},

      {0x1e82, 1908, 1},

      {0x24b8, 2349, 1},

      {0x0182, 357, 1},

      {0x1f82, 139, 2},

      {0x2c82, 2589, 1},

      {0xab7c, 1484, 1},
      {0xffffffff, -1, 0},

      {0xab82, 1502, 1},

      {0xa782, 3102, 1},

      {0x10c82, 3363, 1},

      {0x2c63, 1709, 1},

      {0x24b6, 2343, 1},

      {0x1e80, 1905, 1},

      {0x0480, 1082, 1},

      {0x1f59, 2190, 1},

      {0x1f80, 129, 2},

      {0x2c80, 2586, 1},

      {0x0059, 71, 1},

      {0xa682, 2937, 1},

      {0xab80, 1496, 1},

      {0xa780, 3099, 1},

      {0x10c80, 3357, 1},
      {0xffffffff, -1, 0},

      {0x1e4c, 1826, 1},

      {0x0145, 270, 1},

      {0x014c, 279, 1},

      {0x1f4c, 2184, 1},

      {0x0345, 767, 1},

      {0x0045, 12, 1},

      {0x004c, 31, 1},

      {0xa680, 2934, 1},

      {0xa74c, 3036, 1},

      {0x1e4a, 1823, 1},

      {0x01d5, 441, 1},

      {0x014a, 276, 1},

      {0x1f4a, 2178, 1},

      {0x03d5, 810, 1},

      {0x00d5, 141, 1},

      {0x004a, 24, 1},

      {0x24bf, 2370, 1},

      {0xa74a, 3033, 1},

      {0xa64c, 2883, 1},

      {0x1041c, 3321, 1},

      {0x1e1c, 1754, 1},

      {0x041c, 926, 1},

      {0x011c, 213, 1},

      {0x1f1c, 2118, 1},

      {0x2c1c, 2505, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xa64a, 2880, 1},

      {0x1041a, 3315, 1},

      {0x1e1a, 1751, 1},

      {0x041a, 920, 1},

      {0x011a, 210, 1},

      {0x1f1a, 2112, 1},

      {0x2c1a, 2499, 1},

      {0xabbd, 1679, 1},

      {0x0545, 1394, 1},

      {0x054c, 1415, 1},

      {0x10418, 3309, 1},

      {0x1e18, 1748, 1},

      {0x0418, 914, 1},

      {0x0118, 207, 1},

      {0x1f18, 2106, 1},

      {0x2c18, 2493, 1},

      {0x10bd, 2832, 1},

      {0x2163, 2301, 1},

      {0x054a, 1409, 1},

      {0x1040e, 3279, 1},

      {0x1e0e, 1733, 1},

      {0x040e, 1028, 1},

      {0x010e, 192, 1},

      {0x1f0e, 2100, 1},

      {0x2c0e, 2463, 1},

      {0x1efc, 2076, 1},

      {0x04fc, 1256, 1},

      {0x01fc, 496, 1},

      {0x1ffc, 96, 2},

      {0x051c, 1304, 1},

      {0x1040c, 3273, 1},

      {0x1e0c, 1730, 1},

      {0x040c, 1022, 1},

      {0x010c, 189, 1},

      {0x1f0c, 2094, 1},

      {0x2c0c, 2457, 1},

      {0x1f6d, 2217, 1},

      {0x2c6d, 607, 1},

      {0x051a, 1301, 1},

      {0x24be, 2367, 1},

      {0x10408, 3261, 1},

      {0x1e08, 1724, 1},

      {0x0408, 1010, 1},

      {0x0108, 183, 1},

      {0x1f08, 2082, 1},

      {0x2c08, 2445, 1},

      {0x04c9, 1178, 1},

      {0x0518, 1298, 1},

      {0x1fc9, 2235, 1},
      {0xffffffff, -1, 0},

      {0x24ba, 2355, 1},

      {0x00c9, 105, 1},

      {0x10416, 3303, 1},

      {0x1e16, 1745, 1},

      {0x0416, 908, 1},

      {0x0116, 204, 1},

      {0x050e, 1283, 1},

      {0x2c16, 2487, 1},

      {0x10414, 3297, 1},

      {0x1e14, 1742, 1},

      {0x0414, 902, 1},

      {0x0114, 201, 1},

      {0x042b, 971, 1},

      {0x2c14, 2481, 1},

      {0x1f2b, 2133, 1},

      {0x2c2b, 2550, 1},
      {0xffffffff, -1, 0},

      {0x050c, 1280, 1},

      {0x10406, 3255, 1},

      {0x1e06, 1721, 1},

      {0x0406, 1004, 1},

      {0x0106, 180, 1},

      {0x13fb, 1697, 1},

      {0x2c06, 2439, 1},

      {0x24c2, 2379, 1},

      {0x118bd, 3597, 1},
      {0xffffffff, -1, 0},

      {0x0508, 1274, 1},

      {0x10404, 3249, 1},

      {0x1e04, 1718, 1},

      {0x0404, 998, 1},

      {0x0104, 177, 1},

      {0x1f95, 194, 2},

      {0x2c04, 2433, 1},

      {0x0395, 752, 1},

      {0x24ca, 2403, 1},

      {0xab95, 1559, 1},

      {0x0531, 1334, 1},

      {0x10c95, 3420, 1},

      {0x0516, 1295, 1},

      {0x1e6c, 1875, 1},

      {0x046c, 1052, 1},

      {0x016c, 327, 1},

      {0x1f6c, 2214, 1},

      {0x216d, 2331, 1},

      {0x0514, 1292, 1},

      {0x0245, 697, 1},

      {0x024c, 598, 1},

      {0xa76c, 3084, 1},

      {0x10400, 3237, 1},

      {0x1e00, 1712, 1},

      {0x0400, 986, 1},

      {0x0100, 171, 1},

      {0x24c4, 2385, 1},

      {0x2c00, 2421, 1},

      {0x0506, 1271, 1},

      {0x024a, 595, 1},

      {0x1fab, 224, 2},

      {0xa66c, 2931, 1},

      {0x03ab, 827, 1},

      {0x24cf, 2418, 1},

      {0xabab, 1625, 1},

      {0xa7ab, 631, 1},

      {0x10cab, 3486, 1},
      {0xffffffff, -1, 0},

      {0x0504, 1268, 1},
      {0xffffffff, -1, 0},

      {0x021c, 544, 1},

      {0x01a9, 679, 1},

      {0x1fa9, 214, 2},

      {0x10ab, 2778, 1},

      {0x03a9, 820, 1},

      {0x212b, 92, 1},

      {0xaba9, 1619, 1},

      {0x1e88, 1917, 1},

      {0x10ca9, 3480, 1},

      {0x021a, 541, 1},

      {0x1f88, 129, 2},

      {0x2c88, 2598, 1},

      {0x0388, 730, 1},

      {0x13fd, 1703, 1},

      {0xab88, 1520, 1},

      {0x10a9, 2772, 1},

      {0x10c88, 3381, 1},
      {0xffffffff, -1, 0},

      {0x0218, 538, 1},

      {0x0500, 1262, 1},

      {0x1f4d, 2187, 1},

      {0x01a7, 393, 1},

      {0x1fa7, 244, 2},

      {0x004d, 34, 1},

      {0x03a7, 814, 1},

      {0xa688, 2946, 1},

      {0xaba7, 1613, 1},

      {0x020e, 523, 1},

      {0x10ca7, 3474, 1},

      {0x1e6a, 1872, 1},

      {0x046a, 1049, 1},

      {0x016a, 324, 1},

      {0x1f6a, 2208, 1},
      {0xffffffff, -1, 0},

      {0x216c, 2328, 1},

      {0x10a7, 2766, 1},

      {0x01d1, 435, 1},

      {0xa76a, 3081, 1},

      {0x020c, 520, 1},

      {0x03d1, 762, 1},

      {0x00d1, 129, 1},

      {0x1e68, 1869, 1},

      {0x0468, 1046, 1},

      {0x0168, 321, 1},

      {0x1f68, 2202, 1},
      {0xffffffff, -1, 0},

      {0xff31, 3207, 1},

      {0xa66a, 2928, 1},

      {0x0208, 514, 1},

      {0xa768, 3078, 1},

      {0x1e64, 1863, 1},

      {0x0464, 1040, 1},

      {0x0164, 315, 1},

      {0x054d, 1418, 1},

      {0x2c64, 673, 1},
      {0xffffffff, -1, 0},

      {0xff2b, 3189, 1},
      {0xffffffff, -1, 0},

      {0xa764, 3072, 1},

      {0xa668, 2925, 1},

      {0x0216, 535, 1},
      {0xffffffff, -1, 0},

      {0x118ab, 3543, 1},

      {0x1e62, 1860, 1},

      {0x0462, 1037, 1},

      {0x0162, 312, 1},

      {0x0214, 532, 1},

      {0x2c62, 655, 1},

      {0xa664, 2919, 1},

      {0x1ed2, 2013, 1},

      {0x04d2, 1193, 1},

      {0xa762, 3069, 1},

      {0x1fd2, 20, 3},

      {0x2cd2, 2709, 1},

      {0x118a9, 3537, 1},

      {0x00d2, 132, 1},

      {0x0206, 511, 1},

      {0x10420, 3333, 1},

      {0x1e20, 1760, 1},

      {0x0420, 938, 1},

      {0x0120, 219, 1},

      {0xa662, 2916, 1},

      {0x2c20, 2517, 1},

      {0x1e60, 1856, 1},

      {0x0460, 1034, 1},

      {0x0160, 309, 1},

      {0x0204, 508, 1},

      {0x2c60, 2562, 1},
      {0xffffffff, -1, 0},

      {0x24bd, 2364, 1},

      {0x216a, 2322, 1},

      {0xa760, 3066, 1},
      {0xffffffff, -1, 0},

      {0xfb16, 125, 2},

      {0x118a7, 3531, 1},

      {0x1efa, 2073, 1},

      {0x04fa, 1253, 1},

      {0x01fa, 493, 1},

      {0x1ffa, 2262, 1},

      {0xfb14, 109, 2},

      {0x03fa, 887, 1},

      {0xa660, 2913, 1},

      {0x2168, 2316, 1},

      {0x01b7, 700, 1},

      {0x1fb7, 10, 3},

      {0x1f6b, 2211, 1},

      {0x2c6b, 2577, 1},

      {0x0200, 502, 1},

      {0xabb7, 1661, 1},

      {0xfb06, 29, 2},

      {0x1e56, 1841, 1},

      {0x2164, 2304, 1},

      {0x0156, 294, 1},

      {0x1f56, 62, 3},

      {0x0520, 1310, 1},

      {0x004f, 40, 1},

      {0x0056, 62, 1},

      {0x10b7, 2814, 1},

      {0xa756, 3051, 1},

      {0xfb04, 5, 3},

      {0x1e78, 1893, 1},

      {0x0478, 1070, 1},

      {0x0178, 168, 1},

      {0x1e54, 1838, 1},

      {0x2162, 2298, 1},

      {0x0154, 291, 1},

      {0x1f54, 57, 3},

      {0xab78, 1472, 1},

      {0xa656, 2898, 1},

      {0x0054, 56, 1},

      {0x1e52, 1835, 1},

      {0xa754, 3048, 1},

      {0x0152, 288, 1},

      {0x1f52, 52, 3},

      {0x24c9, 2400, 1},

      {0x1e32, 1787, 1},

      {0x0052, 49, 1},

      {0x0132, 243, 1},

      {0xa752, 3045, 1},
      {0xffffffff, -1, 0},

      {0xfb00, 4, 2},

      {0xa654, 2895, 1},
      {0xffffffff, -1, 0},

      {0xa732, 2997, 1},

      {0x2160, 2292, 1},

      {0x054f, 1424, 1},

      {0x0556, 1445, 1},

      {0x1e50, 1832, 1},

      {0xa652, 2892, 1},

      {0x0150, 285, 1},

      {0x1f50, 84, 2},

      {0x017b, 348, 1},

      {0x1e4e, 1829, 1},

      {0x0050, 43, 1},

      {0x014e, 282, 1},

      {0xa750, 3042, 1},

      {0xab7b, 1481, 1},

      {0xa77b, 3093, 1},

      {0x004e, 37, 1},

      {0x0554, 1439, 1},

      {0xa74e, 3039, 1},

      {0x1e48, 1820, 1},
      {0xffffffff, -1, 0},

      {0x216b, 2325, 1},

      {0x1f48, 2172, 1},

      {0xa650, 2889, 1},

      {0x0552, 1433, 1},

      {0x0048, 21, 1},
      {0xffffffff, -1, 0},

      {0xa748, 3030, 1},

      {0xa64e, 2886, 1},

      {0x0532, 1337, 1},

      {0x1041e, 3327, 1},

      {0x1e1e, 1757, 1},

      {0x041e, 932, 1},

      {0x011e, 216, 1},

      {0x118b7, 3579, 1},

      {0x2c1e, 2511, 1},
      {0xffffffff, -1, 0},

      {0xa648, 2877, 1},

      {0x1ff9, 2253, 1},
      {0xffffffff, -1, 0},

      {0x03f9, 878, 1},

      {0x0550, 1427, 1},

      {0x10412, 3291, 1},

      {0x1e12, 1739, 1},

      {0x0412, 896, 1},

      {0x0112, 198, 1},

      {0x054e, 1421, 1},

      {0x2c12, 2475, 1},

      {0x10410, 3285, 1},

      {0x1e10, 1736, 1},

      {0x0410, 890, 1},

      {0x0110, 195, 1},
      {0xffffffff, -1, 0},

      {0x2c10, 2469, 1},

      {0x2132, 2289, 1},

      {0x0548, 1403, 1},

      {0x1ef8, 2070, 1},

      {0x04f8, 1250, 1},

      {0x01f8, 490, 1},

      {0x1ff8, 2250, 1},

      {0x0220, 381, 1},

      {0x1ee2, 2037, 1},

      {0x04e2, 1217, 1},

      {0x01e2, 462, 1},

      {0x1fe2, 36, 3},

      {0x2ce2, 2733, 1},

      {0x03e2, 857, 1},

      {0x051e, 1307, 1},

      {0x1ede, 2031, 1},

      {0x04de, 1211, 1},

      {0x01de, 456, 1},
      {0xffffffff, -1, 0},

      {0x2cde, 2727, 1},

      {0x03de, 851, 1},

      {0x00de, 165, 1},

      {0x1f69, 2205, 1},

      {0x2c69, 2574, 1},

      {0x1eda, 2025, 1},

      {0x04da, 1205, 1},

      {0x0512, 1289, 1},

      {0x1fda, 2244, 1},

      {0x2cda, 2721, 1},

      {0x03da, 845, 1},

      {0x00da, 153, 1},
      {0xffffffff, -1, 0},

      {0x0510, 1286, 1},

      {0x1ed8, 2022, 1},

      {0x04d8, 1202, 1},
      {0xffffffff, -1, 0},

      {0x1fd8, 2274, 1},

      {0x2cd8, 2718, 1},

      {0x03d8, 842, 1},

      {0x00d8, 147, 1},

      {0x1ed6, 2019, 1},

      {0x04d6, 1199, 1},
      {0xffffffff, -1, 0},

      {0x1fd6, 76, 2},

      {0x2cd6, 2715, 1},

      {0x03d6, 792, 1},

      {0x00d6, 144, 1},

      {0x1ec8, 1998, 1},
      {0xffffffff, -1, 0},

      {0x01c8, 421, 1},

      {0x1fc8, 2232, 1},

      {0x2cc8, 2694, 1},

      {0xff32, 3210, 1},

      {0x00c8, 102, 1},

      {0x04c7, 1175, 1},

      {0x01c7, 421, 1},

      {0x1fc7, 15, 3},

      {0x1ec0, 1986, 1},

      {0x04c0, 1187, 1},

      {0x00c7, 99, 1},
      {0xffffffff, -1, 0},

      {0x2cc0, 2682, 1},

      {0x0179, 345, 1},

      {0x00c0, 77, 1},

      {0x0232, 574, 1},

      {0x01b3, 402, 1},

      {0x1fb3, 62, 2},

      {0xab79, 1475, 1},

      {0xa779, 3090, 1},

      {0x10c7, 2859, 1},

      {0xabb3, 1649, 1},

      {0xa7b3, 3156, 1},

      {0x1fa5, 234, 2},

      {0x10c0, 2841, 1},

      {0x03a5, 807, 1},
      {0xffffffff, -1, 0},

      {0xaba5, 1607, 1},

      {0x01b1, 691, 1},

      {0x10ca5, 3468, 1},

      {0x10b3, 2802, 1},

      {0x2169, 2319, 1},

      {0x024e, 601, 1},

      {0xabb1, 1643, 1},

      {0xa7b1, 682, 1},

      {0x10cb1, 3504, 1},

      {0x10a5, 2760, 1},
      {0xffffffff, -1, 0},

      {0x01af, 399, 1},

      {0x1faf, 244, 2},
      {0xffffffff, -1, 0},

      {0x0248, 592, 1},

      {0x10b1, 2796, 1},

      {0xabaf, 1637, 1},

      {0x1fad, 234, 2},

      {0x10caf, 3498, 1},

      {0x04cd, 1184, 1},

      {0x01cd, 429, 1},

      {0xabad, 1631, 1},

      {0xa7ad, 658, 1},

      {0x10cad, 3492, 1},

      {0x00cd, 117, 1},

      {0x10af, 2790, 1},

      {0x021e, 547, 1},

      {0x1fa3, 224, 2},
      {0xffffffff, -1, 0},

      {0x03a3, 800, 1},

      {0x10ad, 2784, 1},

      {0xaba3, 1601, 1},
      {0xffffffff, -1, 0},

      {0x10ca3, 3462, 1},

      {0x10cd, 2862, 1},

      {0x1fa1, 214, 2},

      {0x24b7, 2346, 1},

      {0x03a1, 796, 1},

      {0x0212, 529, 1},

      {0xaba1, 1595, 1},

      {0x10a3, 2754, 1},

      {0x10ca1, 3456, 1},

      {0x01d3, 438, 1},

      {0x1fd3, 25, 3},

      {0x0210, 526, 1},
      {0xffffffff, -1, 0},

      {0x00d3, 135, 1},

      {0x1e97, 34, 2},

      {0x10a1, 2748, 1},

      {0x0197, 649, 1},

      {0x1f97, 204, 2},
      {0xffffffff, -1, 0},

      {0x0397, 759, 1},

      {0x1041d, 3324, 1},

      {0xab97, 1565, 1},

      {0x041d, 929, 1},

      {0x10c97, 3426, 1},

      {0x1f1d, 2121, 1},

      {0x2c1d, 2508, 1},

      {0x1e72, 1884, 1},

      {0x0472, 1061, 1},

      {0x0172, 336, 1},

      {0x118b3, 3567, 1},

      {0x2c72, 2580, 1},

      {0x0372, 712, 1},

      {0x1041b, 3318, 1},

      {0xab72, 1454, 1},

      {0x041b, 923, 1},

      {0x118a5, 3525, 1},

      {0x1f1b, 2115, 1},

      {0x2c1b, 2502, 1},

      {0x1e70, 1881, 1},

      {0x0470, 1058, 1},

      {0x0170, 333, 1},

      {0x118b1, 3561, 1},

      {0x2c70, 610, 1},

      {0x0370, 709, 1},

      {0x1e46, 1817, 1},

      {0xab70, 1448, 1},

      {0x1e66, 1866, 1},

      {0x0466, 1043, 1},

      {0x0166, 318, 1},

      {0x1e44, 1814, 1},

      {0x0046, 15, 1},

      {0x118af, 3555, 1},

      {0xa746, 3027, 1},
      {0xffffffff, -1, 0},

      {0xa766, 3075, 1},

      {0x0044, 9, 1},

      {0x118ad, 3549, 1},

      {0xa744, 3024, 1},

      {0x1e7a, 1896, 1},

      {0x047a, 1073, 1},

      {0x1e3a, 1799, 1},
      {0xffffffff, -1, 0},

      {0xa646, 2874, 1},

      {0x1f3a, 2154, 1},

      {0xa666, 2922, 1},

      {0xab7a, 1478, 1},

      {0x118a3, 3519, 1},

      {0xa644, 2871, 1},

      {0xa73a, 3009, 1},
      {0xffffffff, -1, 0},

      {0x1ef4, 2064, 1},

      {0x04f4, 1244, 1},

      {0x01f4, 487, 1},

      {0x1ff4, 101, 2},

      {0x118a1, 3513, 1},

      {0x03f4, 762, 1},

      {0x1eec, 2052, 1},

      {0x04ec, 1232, 1},

      {0x01ec, 477, 1},

      {0x1fec, 2286, 1},

      {0x0546, 1397, 1},

      {0x03ec, 872, 1},
      {0xffffffff, -1, 0},

      {0x013f, 261, 1},

      {0x1f3f, 2169, 1},

      {0x0544, 1391, 1},

      {0x1eea, 2049, 1},

      {0x04ea, 1229, 1},

      {0x01ea, 474, 1},

      {0x1fea, 2256, 1},
      {0xffffffff, -1, 0},

      {0x03ea, 869, 1},

      {0x1ee8, 2046, 1},

      {0x04e8, 1226, 1},

      {0x01e8, 471, 1},

      {0x1fe8, 2280, 1},

      {0x053a, 1361, 1},

      {0x03e8, 866, 1},

      {0x1ee6, 2043, 1},

      {0x04e6, 1223, 1},

      {0x01e6, 468, 1},

      {0x1fe6, 88, 2},

      {0x1f4b, 2181, 1},

      {0x03e6, 863, 1},

      {0x1e5e, 1853, 1},

      {0x004b, 27, 1},

      {0x015e, 306, 1},

      {0x2166, 2310, 1},

      {0x1ee4, 2040, 1},

      {0x04e4, 1220, 1},

      {0x01e4, 465, 1},

      {0x1fe4, 80, 2},

      {0xa75e, 3063, 1},

      {0x03e4, 860, 1},

      {0x1ee0, 2034, 1},

      {0x04e0, 1214, 1},

      {0x01e0, 459, 1},

      {0x053f, 1376, 1},

      {0x2ce0, 2730, 1},

      {0x03e0, 854, 1},

      {0x1edc, 2028, 1},

      {0x04dc, 1208, 1},

      {0xa65e, 2910, 1},
      {0xffffffff, -1, 0},

      {0x2cdc, 2724, 1},

      {0x03dc, 848, 1},

      {0x00dc, 159, 1},

      {0x1ed0, 2010, 1},

      {0x04d0, 1190, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x2cd0, 2706, 1},

      {0x03d0, 742, 1},

      {0x00d0, 126, 1},

      {0x1ecc, 2004, 1},

      {0x054b, 1412, 1},
      {0xffffffff, -1, 0},

      {0x1fcc, 71, 2},

      {0x2ccc, 2700, 1},

      {0x1ec6, 1995, 1},

      {0x00cc, 114, 1},
      {0xffffffff, -1, 0},

      {0x1fc6, 67, 2},

      {0x2cc6, 2691, 1},

      {0x24c8, 2397, 1},

      {0x00c6, 96, 1},

      {0x04c5, 1172, 1},

      {0x01c5, 417, 1},
      {0xffffffff, -1, 0},

      {0x1fbb, 2229, 1},

      {0x24c7, 2394, 1},

      {0x00c5, 92, 1},

      {0x1fb9, 2271, 1},

      {0xabbb, 1673, 1},

      {0x24c0, 2373, 1},

      {0x04c3, 1169, 1},

      {0xabb9, 1667, 1},

      {0x1fc3, 71, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x00c3, 86, 1},

      {0x10c5, 2856, 1},

      {0x10bb, 2826, 1},

      {0x1ed4, 2016, 1},

      {0x04d4, 1196, 1},

      {0x10b9, 2820, 1},

      {0x13fc, 1700, 1},

      {0x2cd4, 2712, 1},

      {0x0246, 589, 1},

      {0x00d4, 138, 1},

      {0x10c3, 2850, 1},
      {0xffffffff, -1, 0},

      {0xff3a, 3234, 1},

      {0x0244, 688, 1},

      {0x019f, 670, 1},

      {0x1f9f, 204, 2},
      {0xffffffff, -1, 0},

      {0x039f, 789, 1},
      {0xffffffff, -1, 0},

      {0xab9f, 1589, 1},
      {0xffffffff, -1, 0},

      {0x10c9f, 3450, 1},

      {0x019d, 667, 1},

      {0x1f9d, 194, 2},

      {0x023a, 2565, 1},

      {0x039d, 783, 1},

      {0x1e5a, 1847, 1},

      {0xab9d, 1583, 1},

      {0x015a, 300, 1},

      {0x10c9d, 3444, 1},

      {0x1e9b, 1856, 1},

      {0x24cd, 2412, 1},

      {0x005a, 74, 1},

      {0x1f9b, 184, 2},

      {0xa75a, 3057, 1},

      {0x039b, 776, 1},

      {0x1ece, 2007, 1},

      {0xab9b, 1577, 1},

      {0x1e99, 42, 2},

      {0x10c9b, 3438, 1},

      {0x2cce, 2703, 1},

      {0x1f99, 174, 2},

      {0x00ce, 120, 1},

      {0x0399, 767, 1},

      {0xa65a, 2904, 1},

      {0xab99, 1571, 1},
      {0xffffffff, -1, 0},

      {0x10c99, 3432, 1},

      {0x0193, 634, 1},

      {0x1f93, 184, 2},

      {0x1e58, 1844, 1},

      {0x0393, 746, 1},

      {0x0158, 297, 1},

      {0xab93, 1553, 1},
      {0xffffffff, -1, 0},

      {0x10c93, 3414, 1},

      {0x0058, 68, 1},

      {0x042d, 977, 1},

      {0xa758, 3054, 1},

      {0x1f2d, 2139, 1},

      {0x2c2d, 2556, 1},

      {0x118bb, 3591, 1},

      {0x0191, 369, 1},

      {0x1f91, 174, 2},

      {0x118b9, 3585, 1},

      {0x0391, 739, 1},
      {0xffffffff, -1, 0},

      {0xab91, 1547, 1},

      {0xa658, 2901, 1},

      {0x10c91, 3408, 1},

      {0x018f, 625, 1},

      {0x1f8f, 164, 2},
      {0xffffffff, -1, 0},

      {0x038f, 836, 1},
      {0xffffffff, -1, 0},

      {0xab8f, 1541, 1},
      {0xffffffff, -1, 0},

      {0x10c8f, 3402, 1},

      {0x018b, 366, 1},

      {0x1f8b, 144, 2},
      {0xffffffff, -1, 0},

      {0x0187, 363, 1},

      {0x1f87, 164, 2},

      {0xab8b, 1529, 1},

      {0xa78b, 3111, 1},

      {0x10c8b, 3390, 1},

      {0xab87, 1517, 1},

      {0x04c1, 1166, 1},

      {0x10c87, 3378, 1},

      {0x1e7e, 1902, 1},

      {0x047e, 1079, 1},
      {0xffffffff, -1, 0},

      {0x00c1, 80, 1},

      {0x2c7e, 580, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab7e, 1490, 1},

      {0xa77e, 3096, 1},

      {0x1e76, 1890, 1},

      {0x0476, 1067, 1},

      {0x0176, 342, 1},

      {0x1e42, 1811, 1},

      {0x10c1, 2844, 1},

      {0x0376, 715, 1},

      {0x1e36, 1793, 1},

      {0xab76, 1466, 1},

      {0x0136, 249, 1},

      {0x0042, 3, 1},

      {0x1e3e, 1805, 1},

      {0xa742, 3021, 1},

      {0x1e38, 1796, 1},

      {0x1f3e, 2166, 1},

      {0xa736, 3003, 1},

      {0x1f38, 2148, 1},
      {0xffffffff, -1, 0},

      {0x0587, 105, 2},

      {0xa73e, 3015, 1},
      {0xffffffff, -1, 0},

      {0xa738, 3006, 1},

      {0xa642, 2868, 1},

      {0x1e5c, 1850, 1},

      {0x1e34, 1790, 1},

      {0x015c, 303, 1},

      {0x0134, 246, 1},

      {0x1ef6, 2067, 1},

      {0x04f6, 1247, 1},

      {0x01f6, 372, 1},

      {0x1ff6, 92, 2},

      {0xa75c, 3060, 1},

      {0xa734, 3000, 1},

      {0x1ef0, 2058, 1},

      {0x04f0, 1238, 1},

      {0x01f0, 20, 2},
      {0xffffffff, -1, 0},

      {0x1e30, 1784, 1},

      {0x03f0, 772, 1},

      {0x0130, 261, 2},

      {0x0542, 1385, 1},

      {0xa65c, 2907, 1},

      {0x1f83, 144, 2},

      {0x0536, 1349, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab83, 1505, 1},

      {0x053e, 1373, 1},

      {0x10c83, 3366, 1},

      {0x0538, 1355, 1},

      {0x1eee, 2055, 1},

      {0x04ee, 1235, 1},

      {0x01ee, 480, 1},

      {0x1f8d, 154, 2},
      {0xffffffff, -1, 0},

      {0x03ee, 875, 1},
      {0xffffffff, -1, 0},

      {0xab8d, 1535, 1},

      {0xa78d, 643, 1},

      {0x10c8d, 3396, 1},

      {0x0534, 1343, 1},

      {0x0181, 613, 1},

      {0x1f81, 134, 2},

      {0x013d, 258, 1},

      {0x1f3d, 2163, 1},
      {0xffffffff, -1, 0},

      {0xab81, 1499, 1},

      {0x017f, 52, 1},

      {0x10c81, 3360, 1},

      {0x2c7f, 583, 1},

      {0x037f, 881, 1},

      {0xff2d, 3195, 1},

      {0xab7f, 1493, 1},

      {0x1e74, 1887, 1},

      {0x0474, 1064, 1},

      {0x0174, 339, 1},

      {0x1e3c, 1802, 1},

      {0x0149, 46, 2},

      {0x1f49, 2175, 1},

      {0x1f3c, 2160, 1},

      {0xab74, 1460, 1},

      {0x0049, 3606, 1},

      {0x0143, 267, 1},

      {0x24cc, 2409, 1},

      {0xa73c, 3012, 1},
      {0xffffffff, -1, 0},

      {0x0043, 6, 1},

      {0x0141, 264, 1},

      {0x24c6, 2391, 1},

      {0x013b, 255, 1},

      {0x1f3b, 2157, 1},

      {0x0041, 0, 1},

      {0x0139, 252, 1},

      {0x1f39, 2151, 1},

      {0x24c5, 2388, 1},

      {0x24bb, 2358, 1},

      {0x13fa, 1694, 1},

      {0x053d, 1370, 1},

      {0x24b9, 2352, 1},

      {0x0429, 965, 1},

      {0x2183, 2340, 1},

      {0x1f29, 2127, 1},

      {0x2c29, 2544, 1},

      {0x24c3, 2382, 1},

      {0x10427, 3354, 1},

      {0x10425, 3348, 1},

      {0x0427, 959, 1},

      {0x0425, 953, 1},
      {0xffffffff, -1, 0},

      {0x2c27, 2538, 1},

      {0x2c25, 2532, 1},

      {0x0549, 1406, 1},

      {0x053c, 1367, 1},

      {0x10423, 3342, 1},
      {0xffffffff, -1, 0},

      {0x0423, 947, 1},

      {0x0543, 1388, 1},
      {0xffffffff, -1, 0},

      {0x2c23, 2526, 1},

      {0xff36, 3222, 1},
      {0xffffffff, -1, 0},

      {0x0541, 1382, 1},

      {0x10421, 3336, 1},

      {0x053b, 1364, 1},

      {0x0421, 941, 1},

      {0xff38, 3228, 1},

      {0x0539, 1358, 1},

      {0x2c21, 2520, 1},

      {0x10419, 3312, 1},

      {0x10417, 3306, 1},

      {0x0419, 917, 1},

      {0x0417, 911, 1},

      {0x1f19, 2109, 1},

      {0x2c19, 2496, 1},

      {0x2c17, 2490, 1},

      {0x023e, 2568, 1},

      {0xff34, 3216, 1},

      {0x10415, 3300, 1},

      {0x10413, 3294, 1},

      {0x0415, 905, 1},

      {0x0413, 899, 1},
      {0xffffffff, -1, 0},

      {0x2c15, 2484, 1},

      {0x2c13, 2478, 1},
      {0xffffffff, -1, 0},

      {0x24ce, 2415, 1},

      {0x1040f, 3282, 1},
      {0xffffffff, -1, 0},

      {0x040f, 1031, 1},

      {0xff30, 3204, 1},

      {0x1f0f, 2103, 1},

      {0x2c0f, 2466, 1},

      {0x1040d, 3276, 1},
      {0xffffffff, -1, 0},

      {0x040d, 1025, 1},

      {0x0147, 273, 1},

      {0x1f0d, 2097, 1},

      {0x2c0d, 2460, 1},

      {0x1040b, 3270, 1},

      {0x0047, 18, 1},

      {0x040b, 1019, 1},

      {0x0230, 571, 1},

      {0x1f0b, 2091, 1},

      {0x2c0b, 2454, 1},

      {0x10409, 3264, 1},

      {0x10405, 3252, 1},

      {0x0409, 1013, 1},

      {0x0405, 1001, 1},

      {0x1f09, 2085, 1},

      {0x2c09, 2448, 1},

      {0x2c05, 2436, 1},

      {0x10403, 3246, 1},

      {0x10401, 3240, 1},

      {0x0403, 995, 1},

      {0x0401, 989, 1},
      {0xffffffff, -1, 0},

      {0x2c03, 2430, 1},

      {0x2c01, 2424, 1},

      {0x13f9, 1691, 1},

      {0x042f, 983, 1},
      {0xffffffff, -1, 0},

      {0x1f2f, 2145, 1},

      {0x1041f, 3330, 1},
      {0xffffffff, -1, 0},

      {0x041f, 935, 1},

      {0x023d, 378, 1},

      {0x10411, 3288, 1},

      {0x2c1f, 2514, 1},

      {0x0411, 893, 1},

      {0x0547, 1400, 1},
      {0xffffffff, -1, 0},

      {0x2c11, 2472, 1},

      {0x10407, 3258, 1},
      {0xffffffff, -1, 0},

      {0x0407, 1007, 1},

      {0x24c1, 2376, 1},
      {0xffffffff, -1, 0},

      {0x2c07, 2442, 1},
      {0xffffffff, -1, 0},

      {0x13f8, 1688, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff39, 3231, 1},
      {0xffffffff, -1, 0},

      {0x0243, 354, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x0241, 586, 1},

      {0xff29, 3183, 1},

      {0x023b, 577, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff27, 3177, 1},

      {0xff25, 3171, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff23, 3165, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff21, 3159, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb17, 117, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff2f, 3201, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb15, 113, 2},

      {0xfb13, 121, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb05, 29, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb03, 0, 3},

      {0xfb01, 8, 2}
    };

  if (0 == 0)
    {
      int key = hash(&code);

      if (key <= MAX_HASH_VALUE && key >= 0)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
          if (code == gcode)
             return &wordlist[key];
         }
     }
  return 0;
}
","unicode_unfold_key(OnigCodePoint code)
{
  static const struct ByUnfoldKey wordlist[] =
    {
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0x1040a, 3267, 1},

      {0x1e0a, 1727, 1},

      {0x040a, 1016, 1},

      {0x010a, 186, 1},

      {0x1f0a, 2088, 1},

      {0x2c0a, 2451, 1},

      {0x0189, 619, 1},

      {0x1f89, 134, 2},

      {0x1f85, 154, 2},

      {0x0389, 733, 1},

      {0x03ff, 724, 1},

      {0xab89, 1523, 1},

      {0xab85, 1511, 1},

      {0x10c89, 3384, 1},

      {0x10c85, 3372, 1},

      {0x1e84, 1911, 1},

      {0x03f5, 752, 1},

      {0x0184, 360, 1},

      {0x1f84, 149, 2},

      {0x2c84, 2592, 1},

      {0x017d, 351, 1},

      {0x1ff3, 96, 2},

      {0xab84, 1508, 1},

      {0xa784, 3105, 1},

      {0x10c84, 3369, 1},

      {0xab7d, 1487, 1},

      {0xa77d, 1706, 1},

      {0x1e98, 38, 2},

      {0x0498, 1106, 1},

      {0x0198, 375, 1},

      {0x1f98, 169, 2},

      {0x2c98, 2622, 1},

      {0x0398, 762, 1},

      {0xa684, 2940, 1},

      {0xab98, 1568, 1},

      {0xa798, 3123, 1},

      {0x10c98, 3429, 1},

      {0x050a, 1277, 1},

      {0x1ffb, 2265, 1},

      {0x1e96, 16, 2},

      {0x0496, 1103, 1},

      {0x0196, 652, 1},

      {0x1f96, 199, 2},

      {0x2c96, 2619, 1},

      {0x0396, 756, 1},

      {0xa698, 2970, 1},

      {0xab96, 1562, 1},

      {0xa796, 3120, 1},

      {0x10c96, 3423, 1},

      {0x1feb, 2259, 1},

      {0x2ceb, 2736, 1},

      {0x1e90, 1929, 1},

      {0x0490, 1094, 1},

      {0x0190, 628, 1},

      {0x1f90, 169, 2},

      {0x2c90, 2610, 1},

      {0x0390, 25, 3},

      {0xa696, 2967, 1},

      {0xab90, 1544, 1},

      {0xa790, 3114, 1},

      {0x10c90, 3405, 1},

      {0x01d7, 444, 1},

      {0x1fd7, 31, 3},

      {0x1ea6, 1947, 1},

      {0x04a6, 1127, 1},

      {0x01a6, 676, 1},

      {0x1fa6, 239, 2},

      {0x2ca6, 2643, 1},

      {0x03a6, 810, 1},

      {0xa690, 2958, 1},

      {0xaba6, 1610, 1},

      {0xa7a6, 3144, 1},

      {0x10ca6, 3471, 1},

      {0x1ea4, 1944, 1},

      {0x04a4, 1124, 1},

      {0x01a4, 390, 1},

      {0x1fa4, 229, 2},

      {0x2ca4, 2640, 1},

      {0x03a4, 804, 1},

      {0x10a6, 2763, 1},

      {0xaba4, 1604, 1},

      {0xa7a4, 3141, 1},

      {0x10ca4, 3465, 1},

      {0x1ea0, 1938, 1},

      {0x04a0, 1118, 1},

      {0x01a0, 384, 1},

      {0x1fa0, 209, 2},

      {0x2ca0, 2634, 1},

      {0x03a0, 792, 1},

      {0x10a4, 2757, 1},

      {0xaba0, 1592, 1},

      {0xa7a0, 3135, 1},

      {0x10ca0, 3453, 1},

      {0x1eb2, 1965, 1},

      {0x04b2, 1145, 1},

      {0x01b2, 694, 1},

      {0x1fb2, 249, 2},

      {0x2cb2, 2661, 1},

      {0x03fd, 718, 1},

      {0x10a0, 2745, 1},

      {0xabb2, 1646, 1},

      {0xa7b2, 703, 1},

      {0x10cb2, 3507, 1},

      {0x1eac, 1956, 1},

      {0x04ac, 1136, 1},

      {0x01ac, 396, 1},

      {0x1fac, 229, 2},

      {0x2cac, 2652, 1},

      {0x0537, 1352, 1},

      {0x10b2, 2799, 1},

      {0xabac, 1628, 1},

      {0xa7ac, 637, 1},

      {0x10cac, 3489, 1},

      {0x1eaa, 1953, 1},

      {0x04aa, 1133, 1},

      {0x00dd, 162, 1},

      {0x1faa, 219, 2},

      {0x2caa, 2649, 1},

      {0x03aa, 824, 1},

      {0x10ac, 2781, 1},

      {0xabaa, 1622, 1},

      {0xa7aa, 646, 1},

      {0x10caa, 3483, 1},

      {0x1ea8, 1950, 1},

      {0x04a8, 1130, 1},

      {0x020a, 517, 1},

      {0x1fa8, 209, 2},

      {0x2ca8, 2646, 1},

      {0x03a8, 817, 1},

      {0x10aa, 2775, 1},

      {0xaba8, 1616, 1},

      {0xa7a8, 3147, 1},

      {0x10ca8, 3477, 1},

      {0x1ea2, 1941, 1},

      {0x04a2, 1121, 1},

      {0x01a2, 387, 1},

      {0x1fa2, 219, 2},

      {0x2ca2, 2637, 1},

      {0x118a6, 3528, 1},

      {0x10a8, 2769, 1},

      {0xaba2, 1598, 1},

      {0xa7a2, 3138, 1},

      {0x10ca2, 3459, 1},

      {0x2ced, 2739, 1},

      {0x1fe9, 2283, 1},

      {0x1fe7, 47, 3},

      {0x1eb0, 1962, 1},

      {0x04b0, 1142, 1},

      {0x118a4, 3522, 1},

      {0x10a2, 2751, 1},

      {0x2cb0, 2658, 1},

      {0x03b0, 41, 3},

      {0x1fe3, 41, 3},

      {0xabb0, 1640, 1},

      {0xa7b0, 706, 1},

      {0x10cb0, 3501, 1},

      {0x01d9, 447, 1},

      {0x1fd9, 2277, 1},

      {0x118a0, 3510, 1},

      {0x00df, 24, 2},

      {0x00d9, 150, 1},

      {0xab77, 1469, 1},

      {0x10b0, 2793, 1},

      {0x1eae, 1959, 1},

      {0x04ae, 1139, 1},

      {0x01ae, 685, 1},

      {0x1fae, 239, 2},

      {0x2cae, 2655, 1},

      {0x118b2, 3564, 1},

      {0xab73, 1457, 1},

      {0xabae, 1634, 1},

      {0xab71, 1451, 1},

      {0x10cae, 3495, 1},

      {0x1e2a, 1775, 1},

      {0x042a, 968, 1},

      {0x012a, 234, 1},

      {0x1f2a, 2130, 1},

      {0x2c2a, 2547, 1},

      {0x118ac, 3546, 1},

      {0x10ae, 2787, 1},

      {0x0535, 1346, 1},

      {0xa72a, 2988, 1},

      {0x1e9a, 0, 2},

      {0x049a, 1109, 1},

      {0xff37, 3225, 1},

      {0x1f9a, 179, 2},

      {0x2c9a, 2625, 1},

      {0x039a, 772, 1},

      {0x118aa, 3540, 1},

      {0xab9a, 1574, 1},

      {0xa79a, 3126, 1},

      {0x10c9a, 3435, 1},

      {0x1e94, 1935, 1},

      {0x0494, 1100, 1},

      {0x0194, 640, 1},

      {0x1f94, 189, 2},

      {0x2c94, 2616, 1},

      {0x0394, 749, 1},

      {0x118a8, 3534, 1},

      {0xab94, 1556, 1},

      {0xa69a, 2973, 1},

      {0x10c94, 3417, 1},

      {0x10402, 3243, 1},

      {0x1e02, 1715, 1},

      {0x0402, 992, 1},

      {0x0102, 174, 1},

      {0x0533, 1340, 1},

      {0x2c02, 2427, 1},

      {0x118a2, 3516, 1},

      {0x052a, 1325, 1},

      {0xa694, 2964, 1},

      {0x1e92, 1932, 1},

      {0x0492, 1097, 1},

      {0x2165, 2307, 1},

      {0x1f92, 179, 2},

      {0x2c92, 2613, 1},

      {0x0392, 742, 1},

      {0x2161, 2295, 1},

      {0xab92, 1550, 1},

      {0xa792, 3117, 1},

      {0x10c92, 3411, 1},

      {0x118b0, 3558, 1},

      {0x1f5f, 2199, 1},

      {0x1e8e, 1926, 1},

      {0x048e, 1091, 1},

      {0x018e, 453, 1},

      {0x1f8e, 159, 2},

      {0x2c8e, 2607, 1},

      {0x038e, 833, 1},

      {0xa692, 2961, 1},

      {0xab8e, 1538, 1},

      {0x0055, 59, 1},

      {0x10c8e, 3399, 1},

      {0x1f5d, 2196, 1},

      {0x212a, 27, 1},

      {0x04cb, 1181, 1},

      {0x01cb, 425, 1},

      {0x1fcb, 2241, 1},

      {0x118ae, 3552, 1},

      {0x0502, 1265, 1},

      {0x00cb, 111, 1},

      {0xa68e, 2955, 1},

      {0x1e8a, 1920, 1},

      {0x048a, 1085, 1},

      {0x018a, 622, 1},

      {0x1f8a, 139, 2},

      {0x2c8a, 2601, 1},

      {0x038a, 736, 1},

      {0x2c67, 2571, 1},

      {0xab8a, 1526, 1},

      {0x1e86, 1914, 1},

      {0x10c8a, 3387, 1},

      {0x0186, 616, 1},

      {0x1f86, 159, 2},

      {0x2c86, 2595, 1},

      {0x0386, 727, 1},

      {0xff35, 3219, 1},

      {0xab86, 1514, 1},

      {0xa786, 3108, 1},

      {0x10c86, 3375, 1},

      {0xa68a, 2949, 1},

      {0x0555, 1442, 1},

      {0x1ebc, 1980, 1},

      {0x04bc, 1160, 1},

      {0x01bc, 411, 1},

      {0x1fbc, 62, 2},

      {0x2cbc, 2676, 1},

      {0x1f5b, 2193, 1},

      {0xa686, 2943, 1},

      {0xabbc, 1676, 1},

      {0x1eb8, 1974, 1},

      {0x04b8, 1154, 1},

      {0x01b8, 408, 1},

      {0x1fb8, 2268, 1},

      {0x2cb8, 2670, 1},

      {0x01db, 450, 1},

      {0x1fdb, 2247, 1},

      {0xabb8, 1664, 1},

      {0x10bc, 2829, 1},

      {0x00db, 156, 1},

      {0x1eb6, 1971, 1},

      {0x04b6, 1151, 1},

      {0xff33, 3213, 1},

      {0x1fb6, 58, 2},

      {0x2cb6, 2667, 1},

      {0xff2a, 3186, 1},

      {0x10b8, 2817, 1},

      {0xabb6, 1658, 1},

      {0xa7b6, 3153, 1},

      {0x10426, 3351, 1},

      {0x1e26, 1769, 1},

      {0x0426, 956, 1},

      {0x0126, 228, 1},

      {0x0053, 52, 1},

      {0x2c26, 2535, 1},

      {0x0057, 65, 1},

      {0x10b6, 2811, 1},

      {0x022a, 562, 1},

      {0xa726, 2982, 1},

      {0x1e2e, 1781, 1},

      {0x042e, 980, 1},

      {0x012e, 240, 1},

      {0x1f2e, 2142, 1},

      {0x2c2e, 2559, 1},
      {0xffffffff, -1, 0},

      {0x2167, 2313, 1},
      {0xffffffff, -1, 0},

      {0xa72e, 2994, 1},

      {0x1e2c, 1778, 1},

      {0x042c, 974, 1},

      {0x012c, 237, 1},

      {0x1f2c, 2136, 1},

      {0x2c2c, 2553, 1},

      {0x1f6f, 2223, 1},

      {0x2c6f, 604, 1},

      {0xabbf, 1685, 1},

      {0xa72c, 2991, 1},

      {0x1e28, 1772, 1},

      {0x0428, 962, 1},

      {0x0128, 231, 1},

      {0x1f28, 2124, 1},

      {0x2c28, 2541, 1},
      {0xffffffff, -1, 0},

      {0x0553, 1436, 1},

      {0x10bf, 2838, 1},

      {0xa728, 2985, 1},

      {0x0526, 1319, 1},

      {0x0202, 505, 1},

      {0x1e40, 1808, 1},

      {0x10424, 3345, 1},

      {0x1e24, 1766, 1},

      {0x0424, 950, 1},

      {0x0124, 225, 1},
      {0xffffffff, -1, 0},

      {0x2c24, 2529, 1},

      {0x052e, 1331, 1},

      {0xa740, 3018, 1},

      {0x118bc, 3594, 1},

      {0xa724, 2979, 1},

      {0x1ef2, 2061, 1},

      {0x04f2, 1241, 1},

      {0x01f2, 483, 1},

      {0x1ff2, 257, 2},

      {0x2cf2, 2742, 1},

      {0x052c, 1328, 1},

      {0x118b8, 3582, 1},

      {0xa640, 2865, 1},

      {0x10422, 3339, 1},

      {0x1e22, 1763, 1},

      {0x0422, 944, 1},

      {0x0122, 222, 1},

      {0x2126, 820, 1},

      {0x2c22, 2523, 1},

      {0x0528, 1322, 1},

      {0x01f1, 483, 1},

      {0x118b6, 3576, 1},

      {0xa722, 2976, 1},

      {0x03f1, 796, 1},

      {0x1ebe, 1983, 1},

      {0x04be, 1163, 1},

      {0xfb02, 12, 2},

      {0x1fbe, 767, 1},

      {0x2cbe, 2679, 1},

      {0x01b5, 405, 1},

      {0x0540, 1379, 1},

      {0xabbe, 1682, 1},

      {0x0524, 1316, 1},

      {0x00b5, 779, 1},

      {0xabb5, 1655, 1},

      {0x1eba, 1977, 1},

      {0x04ba, 1157, 1},

      {0x216f, 2337, 1},

      {0x1fba, 2226, 1},

      {0x2cba, 2673, 1},

      {0x10be, 2835, 1},

      {0x0051, 46, 1},

      {0xabba, 1670, 1},

      {0x10b5, 2808, 1},

      {0x1e6e, 1878, 1},

      {0x046e, 1055, 1},

      {0x016e, 330, 1},

      {0x1f6e, 2220, 1},

      {0x2c6e, 664, 1},

      {0x118bf, 3603, 1},

      {0x0522, 1313, 1},

      {0x10ba, 2823, 1},

      {0xa76e, 3087, 1},

      {0x1eb4, 1968, 1},

      {0x04b4, 1148, 1},

      {0x2c75, 2583, 1},

      {0x1fb4, 50, 2},

      {0x2cb4, 2664, 1},

      {0xab75, 1463, 1},

      {0x1ec2, 1989, 1},

      {0xabb4, 1652, 1},

      {0xa7b4, 3150, 1},

      {0x1fc2, 253, 2},

      {0x2cc2, 2685, 1},

      {0x03c2, 800, 1},

      {0x00c2, 83, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff26, 3174, 1},

      {0x10b4, 2805, 1},

      {0x1eca, 2001, 1},

      {0x0551, 1430, 1},

      {0x01ca, 425, 1},

      {0x1fca, 2238, 1},

      {0x2cca, 2697, 1},

      {0x10c2, 2847, 1},

      {0x00ca, 108, 1},

      {0xff2e, 3198, 1},

      {0x1e8c, 1923, 1},

      {0x048c, 1088, 1},

      {0x0226, 556, 1},

      {0x1f8c, 149, 2},

      {0x2c8c, 2604, 1},

      {0x038c, 830, 1},
      {0xffffffff, -1, 0},

      {0xab8c, 1532, 1},

      {0xff2c, 3192, 1},

      {0x10c8c, 3393, 1},

      {0x1ec4, 1992, 1},

      {0x022e, 568, 1},

      {0x01c4, 417, 1},

      {0x1fc4, 54, 2},

      {0x2cc4, 2688, 1},
      {0xffffffff, -1, 0},

      {0x00c4, 89, 1},

      {0xff28, 3180, 1},

      {0xa68c, 2952, 1},

      {0x01cf, 432, 1},

      {0x022c, 565, 1},

      {0x118be, 3600, 1},

      {0x03cf, 839, 1},

      {0x00cf, 123, 1},

      {0x118b5, 3573, 1},
      {0xffffffff, -1, 0},

      {0x10c4, 2853, 1},

      {0x216e, 2334, 1},

      {0x24cb, 2406, 1},

      {0x0228, 559, 1},

      {0xff24, 3168, 1},
      {0xffffffff, -1, 0},

      {0x118ba, 3588, 1},

      {0x1efe, 2079, 1},

      {0x04fe, 1259, 1},

      {0x01fe, 499, 1},

      {0x1e9e, 24, 2},

      {0x049e, 1115, 1},

      {0x03fe, 721, 1},

      {0x1f9e, 199, 2},

      {0x2c9e, 2631, 1},

      {0x039e, 786, 1},

      {0x0224, 553, 1},

      {0xab9e, 1586, 1},

      {0xa79e, 3132, 1},

      {0x10c9e, 3447, 1},

      {0x01f7, 414, 1},

      {0x1ff7, 67, 3},

      {0xff22, 3162, 1},

      {0x03f7, 884, 1},

      {0x118b4, 3570, 1},

      {0x049c, 1112, 1},

      {0x019c, 661, 1},

      {0x1f9c, 189, 2},

      {0x2c9c, 2628, 1},

      {0x039c, 779, 1},

      {0x24bc, 2361, 1},

      {0xab9c, 1580, 1},

      {0xa79c, 3129, 1},

      {0x10c9c, 3441, 1},

      {0x0222, 550, 1},

      {0x1e7c, 1899, 1},

      {0x047c, 1076, 1},

      {0x1e82, 1908, 1},

      {0x24b8, 2349, 1},

      {0x0182, 357, 1},

      {0x1f82, 139, 2},

      {0x2c82, 2589, 1},

      {0xab7c, 1484, 1},
      {0xffffffff, -1, 0},

      {0xab82, 1502, 1},

      {0xa782, 3102, 1},

      {0x10c82, 3363, 1},

      {0x2c63, 1709, 1},

      {0x24b6, 2343, 1},

      {0x1e80, 1905, 1},

      {0x0480, 1082, 1},

      {0x1f59, 2190, 1},

      {0x1f80, 129, 2},

      {0x2c80, 2586, 1},

      {0x0059, 71, 1},

      {0xa682, 2937, 1},

      {0xab80, 1496, 1},

      {0xa780, 3099, 1},

      {0x10c80, 3357, 1},
      {0xffffffff, -1, 0},

      {0x1e4c, 1826, 1},

      {0x0145, 270, 1},

      {0x014c, 279, 1},

      {0x1f4c, 2184, 1},

      {0x0345, 767, 1},

      {0x0045, 12, 1},

      {0x004c, 31, 1},

      {0xa680, 2934, 1},

      {0xa74c, 3036, 1},

      {0x1e4a, 1823, 1},

      {0x01d5, 441, 1},

      {0x014a, 276, 1},

      {0x1f4a, 2178, 1},

      {0x03d5, 810, 1},

      {0x00d5, 141, 1},

      {0x004a, 24, 1},

      {0x24bf, 2370, 1},

      {0xa74a, 3033, 1},

      {0xa64c, 2883, 1},

      {0x1041c, 3321, 1},

      {0x1e1c, 1754, 1},

      {0x041c, 926, 1},

      {0x011c, 213, 1},

      {0x1f1c, 2118, 1},

      {0x2c1c, 2505, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xa64a, 2880, 1},

      {0x1041a, 3315, 1},

      {0x1e1a, 1751, 1},

      {0x041a, 920, 1},

      {0x011a, 210, 1},

      {0x1f1a, 2112, 1},

      {0x2c1a, 2499, 1},

      {0xabbd, 1679, 1},

      {0x0545, 1394, 1},

      {0x054c, 1415, 1},

      {0x10418, 3309, 1},

      {0x1e18, 1748, 1},

      {0x0418, 914, 1},

      {0x0118, 207, 1},

      {0x1f18, 2106, 1},

      {0x2c18, 2493, 1},

      {0x10bd, 2832, 1},

      {0x2163, 2301, 1},

      {0x054a, 1409, 1},

      {0x1040e, 3279, 1},

      {0x1e0e, 1733, 1},

      {0x040e, 1028, 1},

      {0x010e, 192, 1},

      {0x1f0e, 2100, 1},

      {0x2c0e, 2463, 1},

      {0x1efc, 2076, 1},

      {0x04fc, 1256, 1},

      {0x01fc, 496, 1},

      {0x1ffc, 96, 2},

      {0x051c, 1304, 1},

      {0x1040c, 3273, 1},

      {0x1e0c, 1730, 1},

      {0x040c, 1022, 1},

      {0x010c, 189, 1},

      {0x1f0c, 2094, 1},

      {0x2c0c, 2457, 1},

      {0x1f6d, 2217, 1},

      {0x2c6d, 607, 1},

      {0x051a, 1301, 1},

      {0x24be, 2367, 1},

      {0x10408, 3261, 1},

      {0x1e08, 1724, 1},

      {0x0408, 1010, 1},

      {0x0108, 183, 1},

      {0x1f08, 2082, 1},

      {0x2c08, 2445, 1},

      {0x04c9, 1178, 1},

      {0x0518, 1298, 1},

      {0x1fc9, 2235, 1},
      {0xffffffff, -1, 0},

      {0x24ba, 2355, 1},

      {0x00c9, 105, 1},

      {0x10416, 3303, 1},

      {0x1e16, 1745, 1},

      {0x0416, 908, 1},

      {0x0116, 204, 1},

      {0x050e, 1283, 1},

      {0x2c16, 2487, 1},

      {0x10414, 3297, 1},

      {0x1e14, 1742, 1},

      {0x0414, 902, 1},

      {0x0114, 201, 1},

      {0x042b, 971, 1},

      {0x2c14, 2481, 1},

      {0x1f2b, 2133, 1},

      {0x2c2b, 2550, 1},
      {0xffffffff, -1, 0},

      {0x050c, 1280, 1},

      {0x10406, 3255, 1},

      {0x1e06, 1721, 1},

      {0x0406, 1004, 1},

      {0x0106, 180, 1},

      {0x13fb, 1697, 1},

      {0x2c06, 2439, 1},

      {0x24c2, 2379, 1},

      {0x118bd, 3597, 1},
      {0xffffffff, -1, 0},

      {0x0508, 1274, 1},

      {0x10404, 3249, 1},

      {0x1e04, 1718, 1},

      {0x0404, 998, 1},

      {0x0104, 177, 1},

      {0x1f95, 194, 2},

      {0x2c04, 2433, 1},

      {0x0395, 752, 1},

      {0x24ca, 2403, 1},

      {0xab95, 1559, 1},

      {0x0531, 1334, 1},

      {0x10c95, 3420, 1},

      {0x0516, 1295, 1},

      {0x1e6c, 1875, 1},

      {0x046c, 1052, 1},

      {0x016c, 327, 1},

      {0x1f6c, 2214, 1},

      {0x216d, 2331, 1},

      {0x0514, 1292, 1},

      {0x0245, 697, 1},

      {0x024c, 598, 1},

      {0xa76c, 3084, 1},

      {0x10400, 3237, 1},

      {0x1e00, 1712, 1},

      {0x0400, 986, 1},

      {0x0100, 171, 1},

      {0x24c4, 2385, 1},

      {0x2c00, 2421, 1},

      {0x0506, 1271, 1},

      {0x024a, 595, 1},

      {0x1fab, 224, 2},

      {0xa66c, 2931, 1},

      {0x03ab, 827, 1},

      {0x24cf, 2418, 1},

      {0xabab, 1625, 1},

      {0xa7ab, 631, 1},

      {0x10cab, 3486, 1},
      {0xffffffff, -1, 0},

      {0x0504, 1268, 1},
      {0xffffffff, -1, 0},

      {0x021c, 544, 1},

      {0x01a9, 679, 1},

      {0x1fa9, 214, 2},

      {0x10ab, 2778, 1},

      {0x03a9, 820, 1},

      {0x212b, 92, 1},

      {0xaba9, 1619, 1},

      {0x1e88, 1917, 1},

      {0x10ca9, 3480, 1},

      {0x021a, 541, 1},

      {0x1f88, 129, 2},

      {0x2c88, 2598, 1},

      {0x0388, 730, 1},

      {0x13fd, 1703, 1},

      {0xab88, 1520, 1},

      {0x10a9, 2772, 1},

      {0x10c88, 3381, 1},
      {0xffffffff, -1, 0},

      {0x0218, 538, 1},

      {0x0500, 1262, 1},

      {0x1f4d, 2187, 1},

      {0x01a7, 393, 1},

      {0x1fa7, 244, 2},

      {0x004d, 34, 1},

      {0x03a7, 814, 1},

      {0xa688, 2946, 1},

      {0xaba7, 1613, 1},

      {0x020e, 523, 1},

      {0x10ca7, 3474, 1},

      {0x1e6a, 1872, 1},

      {0x046a, 1049, 1},

      {0x016a, 324, 1},

      {0x1f6a, 2208, 1},
      {0xffffffff, -1, 0},

      {0x216c, 2328, 1},

      {0x10a7, 2766, 1},

      {0x01d1, 435, 1},

      {0xa76a, 3081, 1},

      {0x020c, 520, 1},

      {0x03d1, 762, 1},

      {0x00d1, 129, 1},

      {0x1e68, 1869, 1},

      {0x0468, 1046, 1},

      {0x0168, 321, 1},

      {0x1f68, 2202, 1},
      {0xffffffff, -1, 0},

      {0xff31, 3207, 1},

      {0xa66a, 2928, 1},

      {0x0208, 514, 1},

      {0xa768, 3078, 1},

      {0x1e64, 1863, 1},

      {0x0464, 1040, 1},

      {0x0164, 315, 1},

      {0x054d, 1418, 1},

      {0x2c64, 673, 1},
      {0xffffffff, -1, 0},

      {0xff2b, 3189, 1},
      {0xffffffff, -1, 0},

      {0xa764, 3072, 1},

      {0xa668, 2925, 1},

      {0x0216, 535, 1},
      {0xffffffff, -1, 0},

      {0x118ab, 3543, 1},

      {0x1e62, 1860, 1},

      {0x0462, 1037, 1},

      {0x0162, 312, 1},

      {0x0214, 532, 1},

      {0x2c62, 655, 1},

      {0xa664, 2919, 1},

      {0x1ed2, 2013, 1},

      {0x04d2, 1193, 1},

      {0xa762, 3069, 1},

      {0x1fd2, 20, 3},

      {0x2cd2, 2709, 1},

      {0x118a9, 3537, 1},

      {0x00d2, 132, 1},

      {0x0206, 511, 1},

      {0x10420, 3333, 1},

      {0x1e20, 1760, 1},

      {0x0420, 938, 1},

      {0x0120, 219, 1},

      {0xa662, 2916, 1},

      {0x2c20, 2517, 1},

      {0x1e60, 1856, 1},

      {0x0460, 1034, 1},

      {0x0160, 309, 1},

      {0x0204, 508, 1},

      {0x2c60, 2562, 1},
      {0xffffffff, -1, 0},

      {0x24bd, 2364, 1},

      {0x216a, 2322, 1},

      {0xa760, 3066, 1},
      {0xffffffff, -1, 0},

      {0xfb16, 125, 2},

      {0x118a7, 3531, 1},

      {0x1efa, 2073, 1},

      {0x04fa, 1253, 1},

      {0x01fa, 493, 1},

      {0x1ffa, 2262, 1},

      {0xfb14, 109, 2},

      {0x03fa, 887, 1},

      {0xa660, 2913, 1},

      {0x2168, 2316, 1},

      {0x01b7, 700, 1},

      {0x1fb7, 10, 3},

      {0x1f6b, 2211, 1},

      {0x2c6b, 2577, 1},

      {0x0200, 502, 1},

      {0xabb7, 1661, 1},

      {0xfb06, 29, 2},

      {0x1e56, 1841, 1},

      {0x2164, 2304, 1},

      {0x0156, 294, 1},

      {0x1f56, 62, 3},

      {0x0520, 1310, 1},

      {0x004f, 40, 1},

      {0x0056, 62, 1},

      {0x10b7, 2814, 1},

      {0xa756, 3051, 1},

      {0xfb04, 5, 3},

      {0x1e78, 1893, 1},

      {0x0478, 1070, 1},

      {0x0178, 168, 1},

      {0x1e54, 1838, 1},

      {0x2162, 2298, 1},

      {0x0154, 291, 1},

      {0x1f54, 57, 3},

      {0xab78, 1472, 1},

      {0xa656, 2898, 1},

      {0x0054, 56, 1},

      {0x1e52, 1835, 1},

      {0xa754, 3048, 1},

      {0x0152, 288, 1},

      {0x1f52, 52, 3},

      {0x24c9, 2400, 1},

      {0x1e32, 1787, 1},

      {0x0052, 49, 1},

      {0x0132, 243, 1},

      {0xa752, 3045, 1},
      {0xffffffff, -1, 0},

      {0xfb00, 4, 2},

      {0xa654, 2895, 1},
      {0xffffffff, -1, 0},

      {0xa732, 2997, 1},

      {0x2160, 2292, 1},

      {0x054f, 1424, 1},

      {0x0556, 1445, 1},

      {0x1e50, 1832, 1},

      {0xa652, 2892, 1},

      {0x0150, 285, 1},

      {0x1f50, 84, 2},

      {0x017b, 348, 1},

      {0x1e4e, 1829, 1},

      {0x0050, 43, 1},

      {0x014e, 282, 1},

      {0xa750, 3042, 1},

      {0xab7b, 1481, 1},

      {0xa77b, 3093, 1},

      {0x004e, 37, 1},

      {0x0554, 1439, 1},

      {0xa74e, 3039, 1},

      {0x1e48, 1820, 1},
      {0xffffffff, -1, 0},

      {0x216b, 2325, 1},

      {0x1f48, 2172, 1},

      {0xa650, 2889, 1},

      {0x0552, 1433, 1},

      {0x0048, 21, 1},
      {0xffffffff, -1, 0},

      {0xa748, 3030, 1},

      {0xa64e, 2886, 1},

      {0x0532, 1337, 1},

      {0x1041e, 3327, 1},

      {0x1e1e, 1757, 1},

      {0x041e, 932, 1},

      {0x011e, 216, 1},

      {0x118b7, 3579, 1},

      {0x2c1e, 2511, 1},
      {0xffffffff, -1, 0},

      {0xa648, 2877, 1},

      {0x1ff9, 2253, 1},
      {0xffffffff, -1, 0},

      {0x03f9, 878, 1},

      {0x0550, 1427, 1},

      {0x10412, 3291, 1},

      {0x1e12, 1739, 1},

      {0x0412, 896, 1},

      {0x0112, 198, 1},

      {0x054e, 1421, 1},

      {0x2c12, 2475, 1},

      {0x10410, 3285, 1},

      {0x1e10, 1736, 1},

      {0x0410, 890, 1},

      {0x0110, 195, 1},
      {0xffffffff, -1, 0},

      {0x2c10, 2469, 1},

      {0x2132, 2289, 1},

      {0x0548, 1403, 1},

      {0x1ef8, 2070, 1},

      {0x04f8, 1250, 1},

      {0x01f8, 490, 1},

      {0x1ff8, 2250, 1},

      {0x0220, 381, 1},

      {0x1ee2, 2037, 1},

      {0x04e2, 1217, 1},

      {0x01e2, 462, 1},

      {0x1fe2, 36, 3},

      {0x2ce2, 2733, 1},

      {0x03e2, 857, 1},

      {0x051e, 1307, 1},

      {0x1ede, 2031, 1},

      {0x04de, 1211, 1},

      {0x01de, 456, 1},
      {0xffffffff, -1, 0},

      {0x2cde, 2727, 1},

      {0x03de, 851, 1},

      {0x00de, 165, 1},

      {0x1f69, 2205, 1},

      {0x2c69, 2574, 1},

      {0x1eda, 2025, 1},

      {0x04da, 1205, 1},

      {0x0512, 1289, 1},

      {0x1fda, 2244, 1},

      {0x2cda, 2721, 1},

      {0x03da, 845, 1},

      {0x00da, 153, 1},
      {0xffffffff, -1, 0},

      {0x0510, 1286, 1},

      {0x1ed8, 2022, 1},

      {0x04d8, 1202, 1},
      {0xffffffff, -1, 0},

      {0x1fd8, 2274, 1},

      {0x2cd8, 2718, 1},

      {0x03d8, 842, 1},

      {0x00d8, 147, 1},

      {0x1ed6, 2019, 1},

      {0x04d6, 1199, 1},
      {0xffffffff, -1, 0},

      {0x1fd6, 76, 2},

      {0x2cd6, 2715, 1},

      {0x03d6, 792, 1},

      {0x00d6, 144, 1},

      {0x1ec8, 1998, 1},
      {0xffffffff, -1, 0},

      {0x01c8, 421, 1},

      {0x1fc8, 2232, 1},

      {0x2cc8, 2694, 1},

      {0xff32, 3210, 1},

      {0x00c8, 102, 1},

      {0x04c7, 1175, 1},

      {0x01c7, 421, 1},

      {0x1fc7, 15, 3},

      {0x1ec0, 1986, 1},

      {0x04c0, 1187, 1},

      {0x00c7, 99, 1},
      {0xffffffff, -1, 0},

      {0x2cc0, 2682, 1},

      {0x0179, 345, 1},

      {0x00c0, 77, 1},

      {0x0232, 574, 1},

      {0x01b3, 402, 1},

      {0x1fb3, 62, 2},

      {0xab79, 1475, 1},

      {0xa779, 3090, 1},

      {0x10c7, 2859, 1},

      {0xabb3, 1649, 1},

      {0xa7b3, 3156, 1},

      {0x1fa5, 234, 2},

      {0x10c0, 2841, 1},

      {0x03a5, 807, 1},
      {0xffffffff, -1, 0},

      {0xaba5, 1607, 1},

      {0x01b1, 691, 1},

      {0x10ca5, 3468, 1},

      {0x10b3, 2802, 1},

      {0x2169, 2319, 1},

      {0x024e, 601, 1},

      {0xabb1, 1643, 1},

      {0xa7b1, 682, 1},

      {0x10cb1, 3504, 1},

      {0x10a5, 2760, 1},
      {0xffffffff, -1, 0},

      {0x01af, 399, 1},

      {0x1faf, 244, 2},
      {0xffffffff, -1, 0},

      {0x0248, 592, 1},

      {0x10b1, 2796, 1},

      {0xabaf, 1637, 1},

      {0x1fad, 234, 2},

      {0x10caf, 3498, 1},

      {0x04cd, 1184, 1},

      {0x01cd, 429, 1},

      {0xabad, 1631, 1},

      {0xa7ad, 658, 1},

      {0x10cad, 3492, 1},

      {0x00cd, 117, 1},

      {0x10af, 2790, 1},

      {0x021e, 547, 1},

      {0x1fa3, 224, 2},
      {0xffffffff, -1, 0},

      {0x03a3, 800, 1},

      {0x10ad, 2784, 1},

      {0xaba3, 1601, 1},
      {0xffffffff, -1, 0},

      {0x10ca3, 3462, 1},

      {0x10cd, 2862, 1},

      {0x1fa1, 214, 2},

      {0x24b7, 2346, 1},

      {0x03a1, 796, 1},

      {0x0212, 529, 1},

      {0xaba1, 1595, 1},

      {0x10a3, 2754, 1},

      {0x10ca1, 3456, 1},

      {0x01d3, 438, 1},

      {0x1fd3, 25, 3},

      {0x0210, 526, 1},
      {0xffffffff, -1, 0},

      {0x00d3, 135, 1},

      {0x1e97, 34, 2},

      {0x10a1, 2748, 1},

      {0x0197, 649, 1},

      {0x1f97, 204, 2},
      {0xffffffff, -1, 0},

      {0x0397, 759, 1},

      {0x1041d, 3324, 1},

      {0xab97, 1565, 1},

      {0x041d, 929, 1},

      {0x10c97, 3426, 1},

      {0x1f1d, 2121, 1},

      {0x2c1d, 2508, 1},

      {0x1e72, 1884, 1},

      {0x0472, 1061, 1},

      {0x0172, 336, 1},

      {0x118b3, 3567, 1},

      {0x2c72, 2580, 1},

      {0x0372, 712, 1},

      {0x1041b, 3318, 1},

      {0xab72, 1454, 1},

      {0x041b, 923, 1},

      {0x118a5, 3525, 1},

      {0x1f1b, 2115, 1},

      {0x2c1b, 2502, 1},

      {0x1e70, 1881, 1},

      {0x0470, 1058, 1},

      {0x0170, 333, 1},

      {0x118b1, 3561, 1},

      {0x2c70, 610, 1},

      {0x0370, 709, 1},

      {0x1e46, 1817, 1},

      {0xab70, 1448, 1},

      {0x1e66, 1866, 1},

      {0x0466, 1043, 1},

      {0x0166, 318, 1},

      {0x1e44, 1814, 1},

      {0x0046, 15, 1},

      {0x118af, 3555, 1},

      {0xa746, 3027, 1},
      {0xffffffff, -1, 0},

      {0xa766, 3075, 1},

      {0x0044, 9, 1},

      {0x118ad, 3549, 1},

      {0xa744, 3024, 1},

      {0x1e7a, 1896, 1},

      {0x047a, 1073, 1},

      {0x1e3a, 1799, 1},
      {0xffffffff, -1, 0},

      {0xa646, 2874, 1},

      {0x1f3a, 2154, 1},

      {0xa666, 2922, 1},

      {0xab7a, 1478, 1},

      {0x118a3, 3519, 1},

      {0xa644, 2871, 1},

      {0xa73a, 3009, 1},
      {0xffffffff, -1, 0},

      {0x1ef4, 2064, 1},

      {0x04f4, 1244, 1},

      {0x01f4, 487, 1},

      {0x1ff4, 101, 2},

      {0x118a1, 3513, 1},

      {0x03f4, 762, 1},

      {0x1eec, 2052, 1},

      {0x04ec, 1232, 1},

      {0x01ec, 477, 1},

      {0x1fec, 2286, 1},

      {0x0546, 1397, 1},

      {0x03ec, 872, 1},
      {0xffffffff, -1, 0},

      {0x013f, 261, 1},

      {0x1f3f, 2169, 1},

      {0x0544, 1391, 1},

      {0x1eea, 2049, 1},

      {0x04ea, 1229, 1},

      {0x01ea, 474, 1},

      {0x1fea, 2256, 1},
      {0xffffffff, -1, 0},

      {0x03ea, 869, 1},

      {0x1ee8, 2046, 1},

      {0x04e8, 1226, 1},

      {0x01e8, 471, 1},

      {0x1fe8, 2280, 1},

      {0x053a, 1361, 1},

      {0x03e8, 866, 1},

      {0x1ee6, 2043, 1},

      {0x04e6, 1223, 1},

      {0x01e6, 468, 1},

      {0x1fe6, 88, 2},

      {0x1f4b, 2181, 1},

      {0x03e6, 863, 1},

      {0x1e5e, 1853, 1},

      {0x004b, 27, 1},

      {0x015e, 306, 1},

      {0x2166, 2310, 1},

      {0x1ee4, 2040, 1},

      {0x04e4, 1220, 1},

      {0x01e4, 465, 1},

      {0x1fe4, 80, 2},

      {0xa75e, 3063, 1},

      {0x03e4, 860, 1},

      {0x1ee0, 2034, 1},

      {0x04e0, 1214, 1},

      {0x01e0, 459, 1},

      {0x053f, 1376, 1},

      {0x2ce0, 2730, 1},

      {0x03e0, 854, 1},

      {0x1edc, 2028, 1},

      {0x04dc, 1208, 1},

      {0xa65e, 2910, 1},
      {0xffffffff, -1, 0},

      {0x2cdc, 2724, 1},

      {0x03dc, 848, 1},

      {0x00dc, 159, 1},

      {0x1ed0, 2010, 1},

      {0x04d0, 1190, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x2cd0, 2706, 1},

      {0x03d0, 742, 1},

      {0x00d0, 126, 1},

      {0x1ecc, 2004, 1},

      {0x054b, 1412, 1},
      {0xffffffff, -1, 0},

      {0x1fcc, 71, 2},

      {0x2ccc, 2700, 1},

      {0x1ec6, 1995, 1},

      {0x00cc, 114, 1},
      {0xffffffff, -1, 0},

      {0x1fc6, 67, 2},

      {0x2cc6, 2691, 1},

      {0x24c8, 2397, 1},

      {0x00c6, 96, 1},

      {0x04c5, 1172, 1},

      {0x01c5, 417, 1},
      {0xffffffff, -1, 0},

      {0x1fbb, 2229, 1},

      {0x24c7, 2394, 1},

      {0x00c5, 92, 1},

      {0x1fb9, 2271, 1},

      {0xabbb, 1673, 1},

      {0x24c0, 2373, 1},

      {0x04c3, 1169, 1},

      {0xabb9, 1667, 1},

      {0x1fc3, 71, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x00c3, 86, 1},

      {0x10c5, 2856, 1},

      {0x10bb, 2826, 1},

      {0x1ed4, 2016, 1},

      {0x04d4, 1196, 1},

      {0x10b9, 2820, 1},

      {0x13fc, 1700, 1},

      {0x2cd4, 2712, 1},

      {0x0246, 589, 1},

      {0x00d4, 138, 1},

      {0x10c3, 2850, 1},
      {0xffffffff, -1, 0},

      {0xff3a, 3234, 1},

      {0x0244, 688, 1},

      {0x019f, 670, 1},

      {0x1f9f, 204, 2},
      {0xffffffff, -1, 0},

      {0x039f, 789, 1},
      {0xffffffff, -1, 0},

      {0xab9f, 1589, 1},
      {0xffffffff, -1, 0},

      {0x10c9f, 3450, 1},

      {0x019d, 667, 1},

      {0x1f9d, 194, 2},

      {0x023a, 2565, 1},

      {0x039d, 783, 1},

      {0x1e5a, 1847, 1},

      {0xab9d, 1583, 1},

      {0x015a, 300, 1},

      {0x10c9d, 3444, 1},

      {0x1e9b, 1856, 1},

      {0x24cd, 2412, 1},

      {0x005a, 74, 1},

      {0x1f9b, 184, 2},

      {0xa75a, 3057, 1},

      {0x039b, 776, 1},

      {0x1ece, 2007, 1},

      {0xab9b, 1577, 1},

      {0x1e99, 42, 2},

      {0x10c9b, 3438, 1},

      {0x2cce, 2703, 1},

      {0x1f99, 174, 2},

      {0x00ce, 120, 1},

      {0x0399, 767, 1},

      {0xa65a, 2904, 1},

      {0xab99, 1571, 1},
      {0xffffffff, -1, 0},

      {0x10c99, 3432, 1},

      {0x0193, 634, 1},

      {0x1f93, 184, 2},

      {0x1e58, 1844, 1},

      {0x0393, 746, 1},

      {0x0158, 297, 1},

      {0xab93, 1553, 1},
      {0xffffffff, -1, 0},

      {0x10c93, 3414, 1},

      {0x0058, 68, 1},

      {0x042d, 977, 1},

      {0xa758, 3054, 1},

      {0x1f2d, 2139, 1},

      {0x2c2d, 2556, 1},

      {0x118bb, 3591, 1},

      {0x0191, 369, 1},

      {0x1f91, 174, 2},

      {0x118b9, 3585, 1},

      {0x0391, 739, 1},
      {0xffffffff, -1, 0},

      {0xab91, 1547, 1},

      {0xa658, 2901, 1},

      {0x10c91, 3408, 1},

      {0x018f, 625, 1},

      {0x1f8f, 164, 2},
      {0xffffffff, -1, 0},

      {0x038f, 836, 1},
      {0xffffffff, -1, 0},

      {0xab8f, 1541, 1},
      {0xffffffff, -1, 0},

      {0x10c8f, 3402, 1},

      {0x018b, 366, 1},

      {0x1f8b, 144, 2},
      {0xffffffff, -1, 0},

      {0x0187, 363, 1},

      {0x1f87, 164, 2},

      {0xab8b, 1529, 1},

      {0xa78b, 3111, 1},

      {0x10c8b, 3390, 1},

      {0xab87, 1517, 1},

      {0x04c1, 1166, 1},

      {0x10c87, 3378, 1},

      {0x1e7e, 1902, 1},

      {0x047e, 1079, 1},
      {0xffffffff, -1, 0},

      {0x00c1, 80, 1},

      {0x2c7e, 580, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab7e, 1490, 1},

      {0xa77e, 3096, 1},

      {0x1e76, 1890, 1},

      {0x0476, 1067, 1},

      {0x0176, 342, 1},

      {0x1e42, 1811, 1},

      {0x10c1, 2844, 1},

      {0x0376, 715, 1},

      {0x1e36, 1793, 1},

      {0xab76, 1466, 1},

      {0x0136, 249, 1},

      {0x0042, 3, 1},

      {0x1e3e, 1805, 1},

      {0xa742, 3021, 1},

      {0x1e38, 1796, 1},

      {0x1f3e, 2166, 1},

      {0xa736, 3003, 1},

      {0x1f38, 2148, 1},
      {0xffffffff, -1, 0},

      {0x0587, 105, 2},

      {0xa73e, 3015, 1},
      {0xffffffff, -1, 0},

      {0xa738, 3006, 1},

      {0xa642, 2868, 1},

      {0x1e5c, 1850, 1},

      {0x1e34, 1790, 1},

      {0x015c, 303, 1},

      {0x0134, 246, 1},

      {0x1ef6, 2067, 1},

      {0x04f6, 1247, 1},

      {0x01f6, 372, 1},

      {0x1ff6, 92, 2},

      {0xa75c, 3060, 1},

      {0xa734, 3000, 1},

      {0x1ef0, 2058, 1},

      {0x04f0, 1238, 1},

      {0x01f0, 20, 2},
      {0xffffffff, -1, 0},

      {0x1e30, 1784, 1},

      {0x03f0, 772, 1},

      {0x0130, 261, 2},

      {0x0542, 1385, 1},

      {0xa65c, 2907, 1},

      {0x1f83, 144, 2},

      {0x0536, 1349, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xab83, 1505, 1},

      {0x053e, 1373, 1},

      {0x10c83, 3366, 1},

      {0x0538, 1355, 1},

      {0x1eee, 2055, 1},

      {0x04ee, 1235, 1},

      {0x01ee, 480, 1},

      {0x1f8d, 154, 2},
      {0xffffffff, -1, 0},

      {0x03ee, 875, 1},
      {0xffffffff, -1, 0},

      {0xab8d, 1535, 1},

      {0xa78d, 643, 1},

      {0x10c8d, 3396, 1},

      {0x0534, 1343, 1},

      {0x0181, 613, 1},

      {0x1f81, 134, 2},

      {0x013d, 258, 1},

      {0x1f3d, 2163, 1},
      {0xffffffff, -1, 0},

      {0xab81, 1499, 1},

      {0x017f, 52, 1},

      {0x10c81, 3360, 1},

      {0x2c7f, 583, 1},

      {0x037f, 881, 1},

      {0xff2d, 3195, 1},

      {0xab7f, 1493, 1},

      {0x1e74, 1887, 1},

      {0x0474, 1064, 1},

      {0x0174, 339, 1},

      {0x1e3c, 1802, 1},

      {0x0149, 46, 2},

      {0x1f49, 2175, 1},

      {0x1f3c, 2160, 1},

      {0xab74, 1460, 1},

      {0x0049, 3606, 1},

      {0x0143, 267, 1},

      {0x24cc, 2409, 1},

      {0xa73c, 3012, 1},
      {0xffffffff, -1, 0},

      {0x0043, 6, 1},

      {0x0141, 264, 1},

      {0x24c6, 2391, 1},

      {0x013b, 255, 1},

      {0x1f3b, 2157, 1},

      {0x0041, 0, 1},

      {0x0139, 252, 1},

      {0x1f39, 2151, 1},

      {0x24c5, 2388, 1},

      {0x24bb, 2358, 1},

      {0x13fa, 1694, 1},

      {0x053d, 1370, 1},

      {0x24b9, 2352, 1},

      {0x0429, 965, 1},

      {0x2183, 2340, 1},

      {0x1f29, 2127, 1},

      {0x2c29, 2544, 1},

      {0x24c3, 2382, 1},

      {0x10427, 3354, 1},

      {0x10425, 3348, 1},

      {0x0427, 959, 1},

      {0x0425, 953, 1},
      {0xffffffff, -1, 0},

      {0x2c27, 2538, 1},

      {0x2c25, 2532, 1},

      {0x0549, 1406, 1},

      {0x053c, 1367, 1},

      {0x10423, 3342, 1},
      {0xffffffff, -1, 0},

      {0x0423, 947, 1},

      {0x0543, 1388, 1},
      {0xffffffff, -1, 0},

      {0x2c23, 2526, 1},

      {0xff36, 3222, 1},
      {0xffffffff, -1, 0},

      {0x0541, 1382, 1},

      {0x10421, 3336, 1},

      {0x053b, 1364, 1},

      {0x0421, 941, 1},

      {0xff38, 3228, 1},

      {0x0539, 1358, 1},

      {0x2c21, 2520, 1},

      {0x10419, 3312, 1},

      {0x10417, 3306, 1},

      {0x0419, 917, 1},

      {0x0417, 911, 1},

      {0x1f19, 2109, 1},

      {0x2c19, 2496, 1},

      {0x2c17, 2490, 1},

      {0x023e, 2568, 1},

      {0xff34, 3216, 1},

      {0x10415, 3300, 1},

      {0x10413, 3294, 1},

      {0x0415, 905, 1},

      {0x0413, 899, 1},
      {0xffffffff, -1, 0},

      {0x2c15, 2484, 1},

      {0x2c13, 2478, 1},
      {0xffffffff, -1, 0},

      {0x24ce, 2415, 1},

      {0x1040f, 3282, 1},
      {0xffffffff, -1, 0},

      {0x040f, 1031, 1},

      {0xff30, 3204, 1},

      {0x1f0f, 2103, 1},

      {0x2c0f, 2466, 1},

      {0x1040d, 3276, 1},
      {0xffffffff, -1, 0},

      {0x040d, 1025, 1},

      {0x0147, 273, 1},

      {0x1f0d, 2097, 1},

      {0x2c0d, 2460, 1},

      {0x1040b, 3270, 1},

      {0x0047, 18, 1},

      {0x040b, 1019, 1},

      {0x0230, 571, 1},

      {0x1f0b, 2091, 1},

      {0x2c0b, 2454, 1},

      {0x10409, 3264, 1},

      {0x10405, 3252, 1},

      {0x0409, 1013, 1},

      {0x0405, 1001, 1},

      {0x1f09, 2085, 1},

      {0x2c09, 2448, 1},

      {0x2c05, 2436, 1},

      {0x10403, 3246, 1},

      {0x10401, 3240, 1},

      {0x0403, 995, 1},

      {0x0401, 989, 1},
      {0xffffffff, -1, 0},

      {0x2c03, 2430, 1},

      {0x2c01, 2424, 1},

      {0x13f9, 1691, 1},

      {0x042f, 983, 1},
      {0xffffffff, -1, 0},

      {0x1f2f, 2145, 1},

      {0x1041f, 3330, 1},
      {0xffffffff, -1, 0},

      {0x041f, 935, 1},

      {0x023d, 378, 1},

      {0x10411, 3288, 1},

      {0x2c1f, 2514, 1},

      {0x0411, 893, 1},

      {0x0547, 1400, 1},
      {0xffffffff, -1, 0},

      {0x2c11, 2472, 1},

      {0x10407, 3258, 1},
      {0xffffffff, -1, 0},

      {0x0407, 1007, 1},

      {0x24c1, 2376, 1},
      {0xffffffff, -1, 0},

      {0x2c07, 2442, 1},
      {0xffffffff, -1, 0},

      {0x13f8, 1688, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff39, 3231, 1},
      {0xffffffff, -1, 0},

      {0x0243, 354, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0x0241, 586, 1},

      {0xff29, 3183, 1},

      {0x023b, 577, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff27, 3177, 1},

      {0xff25, 3171, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff23, 3165, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff21, 3159, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb17, 117, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xff2f, 3201, 1},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb15, 113, 2},

      {0xfb13, 121, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
      {0xffffffff, -1, 0},

      {0xfb05, 29, 2},
      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},

      {0xfb03, 0, 3},

      {0xfb01, 8, 2}
    };

  if (0 == 0)
    {
      int key = hash(&code);

      if (key <= MAX_HASH_VALUE && key >= 0)
         {
           OnigCodePoint gcode = wordlist[key].code;
 
          if (code == gcode && wordlist[key].index >= 0)
             return &wordlist[key];
         }
     }
  return 0;
}
","The vulnerability in the original `unicode_unfold_key` function arises from the lack of validation for the `index` field in the `wordlist` structure. Specifically, the code checks if the `key` is within valid bounds but does not ensure that the corresponding `index` is non-negative, which could lead to unintended behavior or memory access issues. In the fixed code, the condition `wordlist[key].index >= 0` was added to the existing check, ensuring that only valid entries with a non-negative index are returned. This additional validation mitigates potential exploitation by preventing access to invalid or harmful data.","The vulnerability in the original code stems from insufficient validation of data being accessed, specifically regarding the index associated with entries in a data structure. This oversight allows for the possibility of accessing invalid or unintended memory locations, which could lead to crashes or exploitation by malicious actors. The fix implemented in the revised code introduces an additional check to ensure that the index is non-negative before proceeding with data retrieval. This enhancement effectively prevents the function from returning potentially harmful or erroneous data, thereby improving the overall security and stability of the code.",1,"4

The explanation gives a fairly comprehensive look at the code structure and what it aims to achieve - taking a code point and looking up data in a static wordlist table. However, it's not completely clear about the specific problem being fixed (validating the index field) and could be more focused on explaining the significance of checking for index >= 0. The code snippet and explanation are directly relevant to each other but could be more tightly connected in explaining the repair.",1,0
19,19,181416,181416,,Remote,Not required,Partial,CVE-2017-7875,https://www.cvedetails.com/cve/CVE-2017-7875/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,"In wallpaper.c in feh before v2.18.3, if a malicious client pretends to be the E17 window manager, it is possible to trigger an out-of-boundary heap write while receiving an IPC message. An integer overflow leads to a buffer overflow and/or a double free.",2017-07-10,Overflow ,1,https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,"Fix double-free/OOB-write while receiving IPC data

If a malicious client pretends to be the E17 window manager, it is
possible to trigger an out of boundary heap write while receiving an
IPC message.

The length of the already received message is stored in an unsigned
short, which overflows after receiving 64 KB of data. It's comparably
small amount of data and therefore achievable for an attacker.

When len overflows, realloc() will either be called with a small value
and therefore chars will be appended out of bounds, or len + 1 will be
exactly 0, in which case realloc() behaves like free(). This could be
abused for a later double-free attack as it's even possible to overwrite
the free information -- but this depends on the malloc implementation.

Signed-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>",1,src/wallpaper.c,"{""sha"": ""93994b3d6a9f34cea681de98192119e35faa661e"", ""filename"": ""src/wallpaper.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/derf/feh/blob/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d/src/wallpaper.c"", ""raw_url"": ""https://github.com/derf/feh/raw/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d/src/wallpaper.c"", ""contents_url"": ""https://api.github.com/repos/derf/feh/contents/src/wallpaper.c?ref=f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d"", ""patch"": ""@@ -795,7 +795,7 @@ char *enl_ipc_get(const char *msg_data)\n {\n \n \tstatic char *message = NULL;\n-\tstatic unsigned short len = 0;\n+\tstatic size_t len = 0;\n \tchar buff[13], *ret_msg = NULL;\n \tregister unsigned char i;\n \tunsigned char blen;""}","char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
","char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static unsigned short len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
",C,"	static size_t len = 0;
","	static unsigned short len = 0;
",,"@@ -795,7 +795,7 @@ char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
-	static unsigned short len = 0;
+	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;",feh,f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,a0072d60705b9764970d435ec59dfc5c53158748,1,"char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
//flaw_line_below:
	static unsigned short len = 0;
//fix_flaw_line_below:
//	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
",181416,"char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static unsigned short len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
","char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
","The vulnerability in the original code arises from the use of an `unsigned short` type for the variable `len`, which can lead to integer overflow when accumulating the length of the `message`. This overflow can cause memory corruption when reallocating memory with `erealloc`, potentially leading to security issues such as buffer overflows. In the fixed code, the type of `len` was changed from `unsigned short` to `size_t`, which is designed to hold larger values and is more appropriate for memory size calculations. This change mitigates the risk of overflow, enhancing the overall security of the function.","The vulnerability in the original code stems from the use of a data type that cannot adequately handle large values, leading to potential integer overflow when calculating the total length of a dynamically allocated memory block. This overflow can result in memory corruption, which may be exploited to cause buffer overflows or other security issues. In the revised code, the data type was changed to a more suitable one that can accommodate larger values, effectively preventing overflow during memory size calculations. This adjustment enhances the function's robustness and security by ensuring safer memory management practices.",0,5,1,2
20,20,181417,181417,,Remote,Not required,Partial,CVE-2017-7866,https://www.cvedetails.com/cve/CVE-2017-7866/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,2017-04-20,Overflow ,3,https://github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264,e371f031b942d73e02c090170975561fabd5c264,"avcodec/pngdec: Fix off by 1 size in decode_zbuf()

Fixes out of array access
Fixes: 444/fuzz-2-ffmpeg_VIDEO_AV_CODEC_ID_PNG_fuzzer

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",3,libavcodec/pngdec.c,"{""sha"": ""50a0a296b3775ffdfd4b4aa541396b71817ed43a"", ""filename"": ""libavcodec/pngdec.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/e371f031b942d73e02c090170975561fabd5c264/libavcodec/pngdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/e371f031b942d73e02c090170975561fabd5c264/libavcodec/pngdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/pngdec.c?ref=e371f031b942d73e02c090170975561fabd5c264"", ""patch"": ""@@ -437,13 +437,13 @@ static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n     av_bprint_init(bp, 0, -1);\n \n     while (zstream.avail_in > 0) {\n-        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n-        if (!buf_size) {\n+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n+        if (buf_size < 2) {\n             ret = AVERROR(ENOMEM);\n             goto fail;\n         }\n         zstream.next_out  = buf;\n-        zstream.avail_out = buf_size;\n+        zstream.avail_out = buf_size - 1;\n         ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END) {\n             ret = AVERROR_EXTERNAL;""}","static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                       const uint8_t *data_end)
{
    z_stream zstream;
    unsigned char *buf;
    unsigned buf_size;
    int ret;

    zstream.zalloc = ff_png_zalloc;
    zstream.zfree  = ff_png_zfree;
    zstream.opaque = NULL;
    if (inflateInit(&zstream) != Z_OK)
        return AVERROR_EXTERNAL;
    zstream.next_in  = (unsigned char *)data;
    zstream.avail_in = data_end - data;
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
        zstream.avail_out = buf_size - 1;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;
            goto fail;
        }
        bp->len += zstream.next_out - buf;
        if (ret == Z_STREAM_END)
            break;
    }
    inflateEnd(&zstream);
    bp->str[bp->len] = 0;
    return 0;

fail:
    inflateEnd(&zstream);
    av_bprint_finalize(bp, NULL);
    return ret;
}
","static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                       const uint8_t *data_end)
{
    z_stream zstream;
    unsigned char *buf;
    unsigned buf_size;
    int ret;

    zstream.zalloc = ff_png_zalloc;
    zstream.zfree  = ff_png_zfree;
    zstream.opaque = NULL;
    if (inflateInit(&zstream) != Z_OK)
        return AVERROR_EXTERNAL;
    zstream.next_in  = (unsigned char *)data;
    zstream.avail_in = data_end - data;
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
        if (!buf_size) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
        zstream.avail_out = buf_size;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;
            goto fail;
        }
        bp->len += zstream.next_out - buf;
        if (ret == Z_STREAM_END)
            break;
    }
    inflateEnd(&zstream);
    bp->str[bp->len] = 0;
    return 0;

fail:
    inflateEnd(&zstream);
    av_bprint_finalize(bp, NULL);
    return ret;
}
",C,"        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
        if (buf_size < 2) {
        zstream.avail_out = buf_size - 1;
","        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
        if (!buf_size) {
        zstream.avail_out = buf_size;
",,"@@ -437,13 +437,13 @@ static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
-        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
-        if (!buf_size) {
+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
-        zstream.avail_out = buf_size;
+        zstream.avail_out = buf_size - 1;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;",FFmpeg,e371f031b942d73e02c090170975561fabd5c264,a0341b4d74f4db289e15dac0d2988eaa2d18a1bb,1,"static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                       const uint8_t *data_end)
{
    z_stream zstream;
    unsigned char *buf;
    unsigned buf_size;
    int ret;

    zstream.zalloc = ff_png_zalloc;
    zstream.zfree  = ff_png_zfree;
    zstream.opaque = NULL;
    if (inflateInit(&zstream) != Z_OK)
        return AVERROR_EXTERNAL;
    zstream.next_in  = (unsigned char *)data;
    zstream.avail_in = data_end - data;
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
//flaw_line_below:
        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
//flaw_line_below:
        if (!buf_size) {
//fix_flaw_line_below:
//        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
//fix_flaw_line_below:
//        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
//flaw_line_below:
        zstream.avail_out = buf_size;
//fix_flaw_line_below:
//        zstream.avail_out = buf_size - 1;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;
            goto fail;
        }
        bp->len += zstream.next_out - buf;
        if (ret == Z_STREAM_END)
            break;
    }
    inflateEnd(&zstream);
    bp->str[bp->len] = 0;
    return 0;

fail:
    inflateEnd(&zstream);
    av_bprint_finalize(bp, NULL);
    return ret;
}
",181417,"static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                       const uint8_t *data_end)
{
    z_stream zstream;
    unsigned char *buf;
    unsigned buf_size;
    int ret;

    zstream.zalloc = ff_png_zalloc;
    zstream.zfree  = ff_png_zfree;
    zstream.opaque = NULL;
    if (inflateInit(&zstream) != Z_OK)
        return AVERROR_EXTERNAL;
    zstream.next_in  = (unsigned char *)data;
    zstream.avail_in = data_end - data;
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
        if (!buf_size) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
        zstream.avail_out = buf_size;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;
            goto fail;
        }
        bp->len += zstream.next_out - buf;
        if (ret == Z_STREAM_END)
            break;
    }
    inflateEnd(&zstream);
    bp->str[bp->len] = 0;
    return 0;

fail:
    inflateEnd(&zstream);
    av_bprint_finalize(bp, NULL);
    return ret;
}
","static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                       const uint8_t *data_end)
{
    z_stream zstream;
    unsigned char *buf;
    unsigned buf_size;
    int ret;

    zstream.zalloc = ff_png_zalloc;
    zstream.zfree  = ff_png_zfree;
    zstream.opaque = NULL;
    if (inflateInit(&zstream) != Z_OK)
        return AVERROR_EXTERNAL;
    zstream.next_in  = (unsigned char *)data;
    zstream.avail_in = data_end - data;
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
        zstream.avail_out = buf_size - 1;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;
            goto fail;
        }
        bp->len += zstream.next_out - buf;
        if (ret == Z_STREAM_END)
            break;
    }
    inflateEnd(&zstream);
    bp->str[bp->len] = 0;
    return 0;

fail:
    inflateEnd(&zstream);
    av_bprint_finalize(bp, NULL);
    return ret;
}
","The vulnerability in the original code arises from the use of `av_bprint_get_buffer(bp, 1, &buf, &buf_size);`, which allocates a buffer of size 1, potentially leading to buffer overflows when `zstream.avail_out` is set to `buf_size`. This can cause memory corruption if more than one byte is written to `buf`. The fix modifies this line to `av_bprint_get_buffer(bp, 2, &buf, &buf_size);` and checks that `buf_size` is at least 2, ensuring sufficient space for output. Additionally, `zstream.avail_out` is set to `buf_size - 1`, preventing overflow and enhancing memory safety.","The vulnerability in the original code stems from inadequate buffer allocation, which can lead to buffer overflows when writing data. Specifically, the code allocates a buffer that may not be large enough to accommodate the output, risking memory corruption if more data is written than the buffer can hold. The fix addresses this issue by increasing the buffer size during allocation and ensuring that there is a minimum size requirement. This change prevents overflow by guaranteeing that sufficient space is available for the output, thereby enhancing the overall memory safety of the code.",4,5,3,5
21,21,181418,181418,,Remote,Not required,Partial,CVE-2017-7865,https://www.cvedetails.com/cve/CVE-2017-7865/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FFmpeg before 2017-01-24 has an out-of-bounds write caused by a heap-based buffer overflow related to the ipvideo_decode_block_opcode_0xA function in libavcodec/interplayvideo.c and the avcodec_align_dimensions2 function in libavcodec/utils.c.,2017-04-20,Overflow ,6,https://github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb,2080bc33717955a0e4268e738acf8c1eeddbf8cb,"avcodec/utils: correct align value for interplay

Fixes out of array access
Fixes: 452/fuzz-1-ffmpeg_VIDEO_AV_CODEC_ID_INTERPLAY_VIDEO_fuzzer

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavcodec/utils.c,"{""sha"": ""4ae752ff2ffad74045545b8e4ac3d4c28eec5834"", ""filename"": ""libavcodec/utils.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/2080bc33717955a0e4268e738acf8c1eeddbf8cb/libavcodec/utils.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/2080bc33717955a0e4268e738acf8c1eeddbf8cb/libavcodec/utils.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/utils.c?ref=2080bc33717955a0e4268e738acf8c1eeddbf8cb"", ""patch"": ""@@ -376,6 +376,10 @@ void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n             w_align = 4;\n             h_align = 4;\n         }\n+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n+            w_align = 8;\n+            h_align = 8;\n+        }\n         break;\n     case AV_PIX_FMT_PAL8:\n     case AV_PIX_FMT_BGR8:\n@@ -385,7 +389,8 @@ void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n             w_align = 4;\n             h_align = 4;\n         }\n-        if (s->codec_id == AV_CODEC_ID_JV) {\n+        if (s->codec_id == AV_CODEC_ID_JV ||\n+            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n             w_align = 8;\n             h_align = 8;\n         }""}","void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        w_align = 16; //FIXME assume 16 pixel per macroblock
        h_align = 16 * 2; // interlaced needs 2 macroblocks height
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        w_align = 32;
        h_align = 16 * 2;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            w_align = 64;
            h_align = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            w_align = 8;
            h_align = 8;
        }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_JV ||
            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        w_align = FFMAX(w_align, 8);
    }

    *width  = FFALIGN(*width, w_align);
    *height = FFALIGN(*height, h_align);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
        *height += 2;

        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}
","void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        w_align = 16; //FIXME assume 16 pixel per macroblock
        h_align = 16 * 2; // interlaced needs 2 macroblocks height
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        w_align = 32;
        h_align = 16 * 2;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            w_align = 64;
            h_align = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
             w_align = 4;
             h_align = 4;
         }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_JV) {
             w_align = 8;
             h_align = 8;
         }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        w_align = FFMAX(w_align, 8);
    }

    *width  = FFALIGN(*width, w_align);
    *height = FFALIGN(*height, h_align);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
        *height += 2;

        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}
",C,"        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            w_align = 8;
            h_align = 8;
        }
        if (s->codec_id == AV_CODEC_ID_JV ||
            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
","        if (s->codec_id == AV_CODEC_ID_JV) {
",,"@@ -376,6 +376,10 @@ void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
             w_align = 4;
             h_align = 4;
         }
+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
+            w_align = 8;
+            h_align = 8;
+        }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
@@ -385,7 +389,8 @@ void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
             w_align = 4;
             h_align = 4;
         }
-        if (s->codec_id == AV_CODEC_ID_JV) {
+        if (s->codec_id == AV_CODEC_ID_JV ||
+            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }",FFmpeg,2080bc33717955a0e4268e738acf8c1eeddbf8cb,0b607228bf7260a13404ef98bf87bafeaeecbfa8,1,"void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        w_align = 16; //FIXME assume 16 pixel per macroblock
        h_align = 16 * 2; // interlaced needs 2 macroblocks height
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        w_align = 32;
        h_align = 16 * 2;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            w_align = 64;
            h_align = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
             w_align = 4;
             h_align = 4;
         }
//fix_flaw_line_below:
//        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
//fix_flaw_line_below:
//            w_align = 8;
//fix_flaw_line_below:
//            h_align = 8;
//fix_flaw_line_below:
//        }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
             w_align = 4;
             h_align = 4;
         }
//flaw_line_below:
        if (s->codec_id == AV_CODEC_ID_JV) {
//fix_flaw_line_below:
//        if (s->codec_id == AV_CODEC_ID_JV ||
//fix_flaw_line_below:
//            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        w_align = FFMAX(w_align, 8);
    }

    *width  = FFALIGN(*width, w_align);
    *height = FFALIGN(*height, h_align);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
        // some of the optimized chroma MC reads one line too much
        // which is also done in mpeg decoders with lowres > 0
        *height += 2;

        // H.264 uses edge emulation for out of frame motion vectors, for this
        // it requires a temporary area large enough to hold a 21x21 block,
        // increasing witdth ensure that the temporary area is large enough,
        // the next rounded up width is 32
        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}
",181418,"void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        w_align = 16; //FIXME assume 16 pixel per macroblock
        h_align = 16 * 2; // interlaced needs 2 macroblocks height
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        w_align = 32;
        h_align = 16 * 2;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            w_align = 64;
            h_align = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_PAL8:
    case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        if (s->codec_id == AV_CODEC_ID_JV) {
            w_align = 8;
            h_align = 8;
        }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        w_align = FFMAX(w_align, 8);
    }

    *width  = FFALIGN(*width, w_align);
    *height = FFALIGN(*height, h_align);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
        // some of the optimized chroma MC reads one line too much
        // which is also done in mpeg decoders with lowres > 0
        *height += 2;

        // H.264 uses edge emulation for out of frame motion vectors, for this
        // it requires a temporary area large enough to hold a 21x21 block,
        // increasing witdth ensure that the temporary area is large enough,
        // the next rounded up width is 32
        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}","void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int w_align = 1;
    int h_align = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        w_align = 1 << desc->log2_chroma_w;
        h_align = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        w_align = 16; //FIXME assume 16 pixel per macroblock
        h_align = 16 * 2; // interlaced needs 2 macroblocks height
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        w_align = 32;
        h_align = 16 * 2;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            w_align = 64;
            h_align = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            w_align = 8;
            h_align = 8;
        }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_JV ||
            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            w_align = 4;
            h_align = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            w_align = 4;
            h_align = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        w_align = FFMAX(w_align, 8);
    }

    *width  = FFALIGN(*width, w_align);
    *height = FFALIGN(*height, h_align);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
        *height += 2;

        *width = FFMAX(*width, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}
","The vulnerability in the original code lies in the handling of pixel formats and codec IDs, particularly in the cases for `AV_PIX_FMT_RGB555` and `AV_PIX_FMT_PAL8`, where specific codec IDs were not adequately checked, potentially leading to incorrect alignment values for `w_align` and `h_align`. This could result in memory misalignment, causing crashes or undefined behavior. The fixed code addresses this by adding checks for `AV_CODEC_ID_INTERPLAY_VIDEO` in both cases, ensuring that the alignment values are correctly set based on the codec, thus enhancing the robustness and security of the function.","The vulnerability in the original code stems from inadequate handling of specific codec IDs, which could lead to incorrect memory alignment calculations. This oversight might result in crashes or unpredictable behavior when processing certain pixel formats, as the alignment values could be improperly set. The fixed code rectifies this issue by introducing additional checks for specific codec IDs, ensuring that the alignment calculations are accurate and appropriate for the given context. This enhancement improves the overall stability and security of the function, preventing potential exploitation through misalignment vulnerabilities.",3,5,3,4
22,22,181419,181419,,Remote,Not required,Partial,CVE-2017-7863,https://www.cvedetails.com/cve/CVE-2017-7863/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,2017-04-20,Overflow ,2,https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e,e477f09d0b3619f3d29173b2cd593e17e2d1978e,"avcodec/pngdec: Check trns more completely

Fixes out of array access
Fixes: 546/clusterfuzz-testcase-4809433909559296

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavcodec/pngdec.c,"{""sha"": ""e87c2aa03bac6d61c9c0729c26fb9f3e0430de90"", ""filename"": ""libavcodec/pngdec.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/e477f09d0b3619f3d29173b2cd593e17e2d1978e/libavcodec/pngdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/e477f09d0b3619f3d29173b2cd593e17e2d1978e/libavcodec/pngdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/pngdec.c?ref=e477f09d0b3619f3d29173b2cd593e17e2d1978e"", ""patch"": ""@@ -772,6 +772,16 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n {\n     int v, i;\n \n+    if (!(s->state & PNG_IHDR)) {\n+        av_log(avctx, AV_LOG_ERROR, \""trns before IHDR\\n\"");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n+    if (s->state & PNG_IDAT) {\n+        av_log(avctx, AV_LOG_ERROR, \""trns after IDAT\\n\"");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n         if (length > 256 || !(s->state & PNG_PLTE))\n             return AVERROR_INVALIDDATA;\n@@ -782,7 +792,8 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n         }\n     } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n         if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n-            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n+            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||\n+            s->bit_depth == 1)\n             return AVERROR_INVALIDDATA;\n \n         for (i = 0; i < length / 2; i++) {\n@@ -1242,6 +1253,8 @@ static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n+        av_assert0(s->bit_depth > 1);\n+\n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n ""}","static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                               AVFrame *p, AVPacket *avpkt)
{
    AVDictionary *metadata  = NULL;
    uint32_t tag, length;
    int decode_next_dat = 0;
    int ret;

    for (;;) {
        length = bytestream2_get_bytes_left(&s->gb);
        if (length <= 0) {

            if (avctx->codec_id == AV_CODEC_ID_PNG &&
                avctx->skip_frame == AVDISCARD_ALL) {
                av_frame_set_metadata(p, metadata);
                return 0;
            }

            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                if (!(s->state & PNG_IDAT))
                    return 0;
                else
                    goto exit_loop;
            }
            av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
            if (   s->state & PNG_ALLIMAGE
                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                goto exit_loop;
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

        length = bytestream2_get_be32(&s->gb);
        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        tag = bytestream2_get_le32(&s->gb);
        if (avctx->debug & FF_DEBUG_STARTCODE)
            av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                (tag & 0xff),
                ((tag >> 8) & 0xff),
                ((tag >> 16) & 0xff),
                ((tag >> 24) & 0xff), length);

        if (avctx->codec_id == AV_CODEC_ID_PNG &&
            avctx->skip_frame == AVDISCARD_ALL) {
            switch(tag) {
            case MKTAG('I', 'H', 'D', 'R'):
            case MKTAG('p', 'H', 'Y', 's'):
            case MKTAG('t', 'E', 'X', 't'):
            case MKTAG('I', 'D', 'A', 'T'):
            case MKTAG('t', 'R', 'N', 'S'):
                break;
            default:
                goto skip_tag;
            }
        }

        switch (tag) {
        case MKTAG('I', 'H', 'D', 'R'):
            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                goto fail;
            break;
        case MKTAG('p', 'H', 'Y', 's'):
            if ((ret = decode_phys_chunk(avctx, s)) < 0)
                goto fail;
            break;
        case MKTAG('f', 'c', 'T', 'L'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                goto fail;
            decode_next_dat = 1;
            break;
        case MKTAG('f', 'd', 'A', 'T'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if (!decode_next_dat) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_get_be32(&s->gb);
            length -= 4;
            /* fallthrough */
        case MKTAG('I', 'D', 'A', 'T'):
            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                goto skip_tag;
            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                goto fail;
            break;
        case MKTAG('P', 'L', 'T', 'E'):
            if (decode_plte_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'R', 'N', 'S'):
            if (decode_trns_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'E', 'X', 't'):
            if (decode_text_chunk(s, length, 0, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('z', 'T', 'X', 't'):
            if (decode_text_chunk(s, length, 1, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('s', 'T', 'E', 'R'): {
            int mode = bytestream2_get_byte(&s->gb);
            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
            if (!stereo3d)
                goto fail;

            if (mode == 0 || mode == 1) {
                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
            } else {
                 av_log(avctx, AV_LOG_WARNING,
                        ""Unknown value in sTER chunk (%d)\n"", mode);
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            break;
        }
        case MKTAG('I', 'E', 'N', 'D'):
            if (!(s->state & PNG_ALLIMAGE))
                av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            goto exit_loop;
        default:
            /* skip tag */
skip_tag:
            bytestream2_skip(&s->gb, length + 4);
            break;
        }
    }
exit_loop:
    if (avctx->codec_id == AV_CODEC_ID_PNG &&
        avctx->skip_frame == AVDISCARD_ALL) {
        av_frame_set_metadata(p, metadata);
        return 0;
    }

    if (s->bits_per_pixel <= 4)
        handle_small_bpp(s, p);

    /* apply transparency if needed */
    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
        av_assert0(s->bit_depth > 1);

         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 
            /* since we're updating in-place, we have to go from right to left */
            for (x = s->width; x > 0; --x) {
                uint8_t *pixel = &row[s->bpp * (x - 1)];
                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);

                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                    memset(&pixel[raw_bpp], 0, byte_depth);
                } else {
                    memset(&pixel[raw_bpp], 0xff, byte_depth);
                }
            }
        }
    }

    /* handle P-frames only if a predecessor frame is available */
    if (s->last_picture.f->data[0]) {
        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
            && s->last_picture.f->width == p->width
            && s->last_picture.f->height== p->height
            && s->last_picture.f->format== p->format
         ) {
            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                handle_p_frame_png(s, p);
            else if (CONFIG_APNG_DECODER &&
                     avctx->codec_id == AV_CODEC_ID_APNG &&
                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                goto fail;
        }
    }
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);

    av_frame_set_metadata(p, metadata);
    metadata   = NULL;
    return 0;

fail:
    av_dict_free(&metadata);
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
    return ret;
}
","static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                               AVFrame *p, AVPacket *avpkt)
{
    AVDictionary *metadata  = NULL;
    uint32_t tag, length;
    int decode_next_dat = 0;
    int ret;

    for (;;) {
        length = bytestream2_get_bytes_left(&s->gb);
        if (length <= 0) {

            if (avctx->codec_id == AV_CODEC_ID_PNG &&
                avctx->skip_frame == AVDISCARD_ALL) {
                av_frame_set_metadata(p, metadata);
                return 0;
            }

            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                if (!(s->state & PNG_IDAT))
                    return 0;
                else
                    goto exit_loop;
            }
            av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
            if (   s->state & PNG_ALLIMAGE
                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                goto exit_loop;
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

        length = bytestream2_get_be32(&s->gb);
        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        tag = bytestream2_get_le32(&s->gb);
        if (avctx->debug & FF_DEBUG_STARTCODE)
            av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                (tag & 0xff),
                ((tag >> 8) & 0xff),
                ((tag >> 16) & 0xff),
                ((tag >> 24) & 0xff), length);

        if (avctx->codec_id == AV_CODEC_ID_PNG &&
            avctx->skip_frame == AVDISCARD_ALL) {
            switch(tag) {
            case MKTAG('I', 'H', 'D', 'R'):
            case MKTAG('p', 'H', 'Y', 's'):
            case MKTAG('t', 'E', 'X', 't'):
            case MKTAG('I', 'D', 'A', 'T'):
            case MKTAG('t', 'R', 'N', 'S'):
                break;
            default:
                goto skip_tag;
            }
        }

        switch (tag) {
        case MKTAG('I', 'H', 'D', 'R'):
            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                goto fail;
            break;
        case MKTAG('p', 'H', 'Y', 's'):
            if ((ret = decode_phys_chunk(avctx, s)) < 0)
                goto fail;
            break;
        case MKTAG('f', 'c', 'T', 'L'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                goto fail;
            decode_next_dat = 1;
            break;
        case MKTAG('f', 'd', 'A', 'T'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if (!decode_next_dat) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_get_be32(&s->gb);
            length -= 4;
            /* fallthrough */
        case MKTAG('I', 'D', 'A', 'T'):
            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                goto skip_tag;
            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                goto fail;
            break;
        case MKTAG('P', 'L', 'T', 'E'):
            if (decode_plte_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'R', 'N', 'S'):
            if (decode_trns_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'E', 'X', 't'):
            if (decode_text_chunk(s, length, 0, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('z', 'T', 'X', 't'):
            if (decode_text_chunk(s, length, 1, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('s', 'T', 'E', 'R'): {
            int mode = bytestream2_get_byte(&s->gb);
            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
            if (!stereo3d)
                goto fail;

            if (mode == 0 || mode == 1) {
                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
            } else {
                 av_log(avctx, AV_LOG_WARNING,
                        ""Unknown value in sTER chunk (%d)\n"", mode);
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            break;
        }
        case MKTAG('I', 'E', 'N', 'D'):
            if (!(s->state & PNG_ALLIMAGE))
                av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            goto exit_loop;
        default:
            /* skip tag */
skip_tag:
            bytestream2_skip(&s->gb, length + 4);
            break;
        }
    }
exit_loop:
    if (avctx->codec_id == AV_CODEC_ID_PNG &&
        avctx->skip_frame == AVDISCARD_ALL) {
        av_frame_set_metadata(p, metadata);
        return 0;
    }

    if (s->bits_per_pixel <= 4)
        handle_small_bpp(s, p);

    /* apply transparency if needed */
    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 
            /* since we're updating in-place, we have to go from right to left */
            for (x = s->width; x > 0; --x) {
                uint8_t *pixel = &row[s->bpp * (x - 1)];
                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);

                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                    memset(&pixel[raw_bpp], 0, byte_depth);
                } else {
                    memset(&pixel[raw_bpp], 0xff, byte_depth);
                }
            }
        }
    }

    /* handle P-frames only if a predecessor frame is available */
    if (s->last_picture.f->data[0]) {
        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
            && s->last_picture.f->width == p->width
            && s->last_picture.f->height== p->height
            && s->last_picture.f->format== p->format
         ) {
            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                handle_p_frame_png(s, p);
            else if (CONFIG_APNG_DECODER &&
                     avctx->codec_id == AV_CODEC_ID_APNG &&
                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                goto fail;
        }
    }
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);

    av_frame_set_metadata(p, metadata);
    metadata   = NULL;
    return 0;

fail:
    av_dict_free(&metadata);
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
    return ret;
}
",C,"        av_assert0(s->bit_depth > 1);

",,,"@@ -772,6 +772,16 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
 {
     int v, i;
 
+    if (!(s->state & PNG_IHDR)) {
+        av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (s->state & PNG_IDAT) {
+        av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
+        return AVERROR_INVALIDDATA;
+    }
+
     if (s->color_type == PNG_COLOR_TYPE_PALETTE) {
         if (length > 256 || !(s->state & PNG_PLTE))
             return AVERROR_INVALIDDATA;
@@ -782,7 +792,8 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
         }
     } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {
         if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||
-            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))
+            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||
+            s->bit_depth == 1)
             return AVERROR_INVALIDDATA;
 
         for (i = 0; i < length / 2; i++) {
@@ -1242,6 +1253,8 @@ static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
+        av_assert0(s->bit_depth > 1);
+
         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 ",FFmpeg,e477f09d0b3619f3d29173b2cd593e17e2d1978e,084f3addda7531a22d656b769120c6453e880226,1,"static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                               AVFrame *p, AVPacket *avpkt)
{
    AVDictionary *metadata  = NULL;
    uint32_t tag, length;
    int decode_next_dat = 0;
    int ret;

    for (;;) {
        length = bytestream2_get_bytes_left(&s->gb);
        if (length <= 0) {

            if (avctx->codec_id == AV_CODEC_ID_PNG &&
                avctx->skip_frame == AVDISCARD_ALL) {
                av_frame_set_metadata(p, metadata);
                return 0;
            }

            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                if (!(s->state & PNG_IDAT))
                    return 0;
                else
                    goto exit_loop;
            }
            av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
            if (   s->state & PNG_ALLIMAGE
                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                goto exit_loop;
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

        length = bytestream2_get_be32(&s->gb);
        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        tag = bytestream2_get_le32(&s->gb);
        if (avctx->debug & FF_DEBUG_STARTCODE)
            av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                (tag & 0xff),
                ((tag >> 8) & 0xff),
                ((tag >> 16) & 0xff),
                ((tag >> 24) & 0xff), length);

        if (avctx->codec_id == AV_CODEC_ID_PNG &&
            avctx->skip_frame == AVDISCARD_ALL) {
            switch(tag) {
            case MKTAG('I', 'H', 'D', 'R'):
            case MKTAG('p', 'H', 'Y', 's'):
            case MKTAG('t', 'E', 'X', 't'):
            case MKTAG('I', 'D', 'A', 'T'):
            case MKTAG('t', 'R', 'N', 'S'):
                break;
            default:
                goto skip_tag;
            }
        }

        switch (tag) {
        case MKTAG('I', 'H', 'D', 'R'):
            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                goto fail;
            break;
        case MKTAG('p', 'H', 'Y', 's'):
            if ((ret = decode_phys_chunk(avctx, s)) < 0)
                goto fail;
            break;
        case MKTAG('f', 'c', 'T', 'L'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                goto fail;
            decode_next_dat = 1;
            break;
        case MKTAG('f', 'd', 'A', 'T'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if (!decode_next_dat) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_get_be32(&s->gb);
            length -= 4;
            /* fallthrough */
        case MKTAG('I', 'D', 'A', 'T'):
            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                goto skip_tag;
            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                goto fail;
            break;
        case MKTAG('P', 'L', 'T', 'E'):
            if (decode_plte_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'R', 'N', 'S'):
            if (decode_trns_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'E', 'X', 't'):
            if (decode_text_chunk(s, length, 0, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('z', 'T', 'X', 't'):
            if (decode_text_chunk(s, length, 1, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('s', 'T', 'E', 'R'): {
            int mode = bytestream2_get_byte(&s->gb);
            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
            if (!stereo3d)
                goto fail;

            if (mode == 0 || mode == 1) {
                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
            } else {
                 av_log(avctx, AV_LOG_WARNING,
                        ""Unknown value in sTER chunk (%d)\n"", mode);
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            break;
        }
        case MKTAG('I', 'E', 'N', 'D'):
            if (!(s->state & PNG_ALLIMAGE))
                av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            goto exit_loop;
        default:
            /* skip tag */
skip_tag:
            bytestream2_skip(&s->gb, length + 4);
            break;
        }
    }
exit_loop:
    if (avctx->codec_id == AV_CODEC_ID_PNG &&
        avctx->skip_frame == AVDISCARD_ALL) {
        av_frame_set_metadata(p, metadata);
        return 0;
    }

    if (s->bits_per_pixel <= 4)
        handle_small_bpp(s, p);

    /* apply transparency if needed */
    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
//fix_flaw_line_below:
//        av_assert0(s->bit_depth > 1);
//fix_flaw_line_below:
//
         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 
            /* since we're updating in-place, we have to go from right to left */
            for (x = s->width; x > 0; --x) {
                uint8_t *pixel = &row[s->bpp * (x - 1)];
                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);

                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                    memset(&pixel[raw_bpp], 0, byte_depth);
                } else {
                    memset(&pixel[raw_bpp], 0xff, byte_depth);
                }
            }
        }
    }

    /* handle P-frames only if a predecessor frame is available */
    if (s->last_picture.f->data[0]) {
        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
            && s->last_picture.f->width == p->width
            && s->last_picture.f->height== p->height
            && s->last_picture.f->format== p->format
         ) {
            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                handle_p_frame_png(s, p);
            else if (CONFIG_APNG_DECODER &&
                     avctx->codec_id == AV_CODEC_ID_APNG &&
                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                goto fail;
        }
    }
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);

    av_frame_set_metadata(p, metadata);
    metadata   = NULL;
    return 0;

fail:
    av_dict_free(&metadata);
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
    return ret;
}
",181419,"static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                               AVFrame *p, AVPacket *avpkt)
{
    AVDictionary *metadata  = NULL;
    uint32_t tag, length;
    int decode_next_dat = 0;
    int ret;

    for (;;) {
        length = bytestream2_get_bytes_left(&s->gb);
        if (length <= 0) {

            if (avctx->codec_id == AV_CODEC_ID_PNG &&
                avctx->skip_frame == AVDISCARD_ALL) {
                av_frame_set_metadata(p, metadata);
                return 0;
            }

            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                if (!(s->state & PNG_IDAT))
                    return 0;
                else
                    goto exit_loop;
            }
            av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
            if (   s->state & PNG_ALLIMAGE
                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                goto exit_loop;
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

        length = bytestream2_get_be32(&s->gb);
        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        tag = bytestream2_get_le32(&s->gb);
        if (avctx->debug & FF_DEBUG_STARTCODE)
            av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                (tag & 0xff),
                ((tag >> 8) & 0xff),
                ((tag >> 16) & 0xff),
                ((tag >> 24) & 0xff), length);

        if (avctx->codec_id == AV_CODEC_ID_PNG &&
            avctx->skip_frame == AVDISCARD_ALL) {
            switch(tag) {
            case MKTAG('I', 'H', 'D', 'R'):
            case MKTAG('p', 'H', 'Y', 's'):
            case MKTAG('t', 'E', 'X', 't'):
            case MKTAG('I', 'D', 'A', 'T'):
            case MKTAG('t', 'R', 'N', 'S'):
                break;
            default:
                goto skip_tag;
            }
        }

        switch (tag) {
        case MKTAG('I', 'H', 'D', 'R'):
            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                goto fail;
            break;
        case MKTAG('p', 'H', 'Y', 's'):
            if ((ret = decode_phys_chunk(avctx, s)) < 0)
                goto fail;
            break;
        case MKTAG('f', 'c', 'T', 'L'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                goto fail;
            decode_next_dat = 1;
            break;
        case MKTAG('f', 'd', 'A', 'T'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if (!decode_next_dat) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_get_be32(&s->gb);
            length -= 4;
            /* fallthrough */
        case MKTAG('I', 'D', 'A', 'T'):
            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                goto skip_tag;
            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                goto fail;
            break;
        case MKTAG('P', 'L', 'T', 'E'):
            if (decode_plte_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'R', 'N', 'S'):
            if (decode_trns_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'E', 'X', 't'):
            if (decode_text_chunk(s, length, 0, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('z', 'T', 'X', 't'):
            if (decode_text_chunk(s, length, 1, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('s', 'T', 'E', 'R'): {
            int mode = bytestream2_get_byte(&s->gb);
            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
            if (!stereo3d)
                goto fail;

            if (mode == 0 || mode == 1) {
                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
            } else {
                 av_log(avctx, AV_LOG_WARNING,
                        ""Unknown value in sTER chunk (%d)\n"", mode);
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            break;
        }
        case MKTAG('I', 'E', 'N', 'D'):
            if (!(s->state & PNG_ALLIMAGE))
                av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            goto exit_loop;
        default:
            /* skip tag */
skip_tag:
            bytestream2_skip(&s->gb, length + 4);
            break;
        }
    }
exit_loop:
    if (avctx->codec_id == AV_CODEC_ID_PNG &&
        avctx->skip_frame == AVDISCARD_ALL) {
        av_frame_set_metadata(p, metadata);
        return 0;
    }

    if (s->bits_per_pixel <= 4)
        handle_small_bpp(s, p);

    /* apply transparency if needed */
    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 
            /* since we're updating in-place, we have to go from right to left */
            for (x = s->width; x > 0; --x) {
                uint8_t *pixel = &row[s->bpp * (x - 1)];
                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);

                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                    memset(&pixel[raw_bpp], 0, byte_depth);
                } else {
                    memset(&pixel[raw_bpp], 0xff, byte_depth);
                }
            }
        }
    }

    /* handle P-frames only if a predecessor frame is available */
    if (s->last_picture.f->data[0]) {
        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
            && s->last_picture.f->width == p->width
            && s->last_picture.f->height== p->height
            && s->last_picture.f->format== p->format
         ) {
            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                handle_p_frame_png(s, p);
            else if (CONFIG_APNG_DECODER &&
                     avctx->codec_id == AV_CODEC_ID_APNG &&
                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                goto fail;
        }
    }
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);

    av_frame_set_metadata(p, metadata);
    metadata   = NULL;
    return 0;

fail:
    av_dict_free(&metadata);
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
    return ret;
}
","static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                               AVFrame *p, AVPacket *avpkt)
{
    AVDictionary *metadata  = NULL;
    uint32_t tag, length;
    int decode_next_dat = 0;
    int ret;

    for (;;) {
        length = bytestream2_get_bytes_left(&s->gb);
        if (length <= 0) {

            if (avctx->codec_id == AV_CODEC_ID_PNG &&
                avctx->skip_frame == AVDISCARD_ALL) {
                av_frame_set_metadata(p, metadata);
                return 0;
            }

            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                if (!(s->state & PNG_IDAT))
                    return 0;
                else
                    goto exit_loop;
            }
            av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
            if (   s->state & PNG_ALLIMAGE
                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                goto exit_loop;
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

        length = bytestream2_get_be32(&s->gb);
        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }
        tag = bytestream2_get_le32(&s->gb);
        if (avctx->debug & FF_DEBUG_STARTCODE)
            av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                (tag & 0xff),
                ((tag >> 8) & 0xff),
                ((tag >> 16) & 0xff),
                ((tag >> 24) & 0xff), length);

        if (avctx->codec_id == AV_CODEC_ID_PNG &&
            avctx->skip_frame == AVDISCARD_ALL) {
            switch(tag) {
            case MKTAG('I', 'H', 'D', 'R'):
            case MKTAG('p', 'H', 'Y', 's'):
            case MKTAG('t', 'E', 'X', 't'):
            case MKTAG('I', 'D', 'A', 'T'):
            case MKTAG('t', 'R', 'N', 'S'):
                break;
            default:
                goto skip_tag;
            }
        }

        switch (tag) {
        case MKTAG('I', 'H', 'D', 'R'):
            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                goto fail;
            break;
        case MKTAG('p', 'H', 'Y', 's'):
            if ((ret = decode_phys_chunk(avctx, s)) < 0)
                goto fail;
            break;
        case MKTAG('f', 'c', 'T', 'L'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                goto fail;
            decode_next_dat = 1;
            break;
        case MKTAG('f', 'd', 'A', 'T'):
            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                goto skip_tag;
            if (!decode_next_dat) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_get_be32(&s->gb);
            length -= 4;
            /* fallthrough */
        case MKTAG('I', 'D', 'A', 'T'):
            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                goto skip_tag;
            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                goto fail;
            break;
        case MKTAG('P', 'L', 'T', 'E'):
            if (decode_plte_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'R', 'N', 'S'):
            if (decode_trns_chunk(avctx, s, length) < 0)
                goto skip_tag;
            break;
        case MKTAG('t', 'E', 'X', 't'):
            if (decode_text_chunk(s, length, 0, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('z', 'T', 'X', 't'):
            if (decode_text_chunk(s, length, 1, &metadata) < 0)
                av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
            bytestream2_skip(&s->gb, length + 4);
            break;
        case MKTAG('s', 'T', 'E', 'R'): {
            int mode = bytestream2_get_byte(&s->gb);
            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
            if (!stereo3d)
                goto fail;

            if (mode == 0 || mode == 1) {
                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
            } else {
                 av_log(avctx, AV_LOG_WARNING,
                        ""Unknown value in sTER chunk (%d)\n"", mode);
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            break;
        }
        case MKTAG('I', 'E', 'N', 'D'):
            if (!(s->state & PNG_ALLIMAGE))
                av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                ret = AVERROR_INVALIDDATA;
                goto fail;
            }
            bytestream2_skip(&s->gb, 4); /* crc */
            goto exit_loop;
        default:
            /* skip tag */
skip_tag:
            bytestream2_skip(&s->gb, length + 4);
            break;
        }
    }
exit_loop:
    if (avctx->codec_id == AV_CODEC_ID_PNG &&
        avctx->skip_frame == AVDISCARD_ALL) {
        av_frame_set_metadata(p, metadata);
        return 0;
    }

    if (s->bits_per_pixel <= 4)
        handle_small_bpp(s, p);

    /* apply transparency if needed */
    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
        av_assert0(s->bit_depth > 1);

         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 
            /* since we're updating in-place, we have to go from right to left */
            for (x = s->width; x > 0; --x) {
                uint8_t *pixel = &row[s->bpp * (x - 1)];
                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);

                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                    memset(&pixel[raw_bpp], 0, byte_depth);
                } else {
                    memset(&pixel[raw_bpp], 0xff, byte_depth);
                }
            }
        }
    }

    /* handle P-frames only if a predecessor frame is available */
    if (s->last_picture.f->data[0]) {
        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
            && s->last_picture.f->width == p->width
            && s->last_picture.f->height== p->height
            && s->last_picture.f->format== p->format
         ) {
            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                handle_p_frame_png(s, p);
            else if (CONFIG_APNG_DECODER &&
                     avctx->codec_id == AV_CODEC_ID_APNG &&
                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                goto fail;
        }
    }
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);

    av_frame_set_metadata(p, metadata);
    metadata   = NULL;
    return 0;

fail:
    av_dict_free(&metadata);
    ff_thread_report_progress(&s->picture, INT_MAX, 0);
    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
    return ret;
}
","The vulnerability in the original code lies in the lack of validation for the `length` variable after it is set by `bytestream2_get_be32(&s->gb)`. If `length` is excessively large (greater than `0x7fffffff`) or exceeds the available bytes in the stream, it could lead to buffer overflows or memory corruption when processing chunks, particularly in the `decode_idat_chunk` function. The fix introduces an assertion `av_assert0(s->bit_depth > 1);` before processing transparency, ensuring that the bit depth is valid, thus preventing potential misuse of uninitialized or invalid data that could lead to crashes or security issues.","The vulnerability in the original code stems from inadequate validation of input data, particularly regarding the size of chunks being processed. This oversight could lead to buffer overflows or memory corruption, as excessively large or malformed data could be mishandled during decoding operations. The fix addresses this issue by introducing a validation check that ensures the data being processed adheres to expected constraints, thereby preventing potential exploitation through malformed input. This enhancement improves the overall robustness and security of the code by ensuring that only valid data is processed, mitigating risks associated with buffer overflows.",3,5,4,5
23,23,181421,181421,,Remote,Not required,Partial,CVE-2017-7862,https://www.cvedetails.com/cve/CVE-2017-7862/,CWE-787,Low,Partial,Partial,,2017-04-14,7.5,FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.,2018-11-27,Overflow ,1,https://github.com/FFmpeg/FFmpeg/commit/8c2ea3030af7b40a3c4275696fb5c76cdb80950a,8c2ea3030af7b40a3c4275696fb5c76cdb80950a,"avcodec/pictordec: Fix logic error

Fixes: 559/clusterfuzz-testcase-6424225917173760

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavcodec/pictordec.c,"{""sha"": ""0cfc785832654c8fca13247d7b8ea8f86092e533"", ""filename"": ""libavcodec/pictordec.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/8c2ea3030af7b40a3c4275696fb5c76cdb80950a/libavcodec/pictordec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/8c2ea3030af7b40a3c4275696fb5c76cdb80950a/libavcodec/pictordec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/pictordec.c?ref=8c2ea3030af7b40a3c4275696fb5c76cdb80950a"", ""patch"": ""@@ -142,7 +142,7 @@ static int decode_frame(AVCodecContext *avctx,\n \n     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n         return -1;\n-    if (s->width != avctx->width && s->height != avctx->height) {\n+    if (s->width != avctx->width || s->height != avctx->height) {\n         ret = ff_set_dimensions(avctx, s->width, s->height);\n         if (ret < 0)\n             return ret;""}","static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}
","static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
    if (s->width != avctx->width && s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}
",C,"    if (s->width != avctx->width || s->height != avctx->height) {
","    if (s->width != avctx->width && s->height != avctx->height) {
",,"@@ -142,7 +142,7 @@ static int decode_frame(AVCodecContext *avctx,
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
-    if (s->width != avctx->width && s->height != avctx->height) {
+    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;",FFmpeg,8c2ea3030af7b40a3c4275696fb5c76cdb80950a,dface53497c3531da101b2872df301acca313142,1,"static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
//flaw_line_below:
    if (s->width != avctx->width && s->height != avctx->height) {
//fix_flaw_line_below:
//    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    // fill remaining palette entries
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    // skip remaining palette bytes
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            // ignore uncompressed block size
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}
",181421,"static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;

    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
        return -1;
    if (s->width != avctx->width && s->height != avctx->height) {
        ret = ff_set_dimensions(avctx, s->width, s->height);
        if (ret < 0)
            return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    // fill remaining palette entries
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    // skip remaining palette bytes
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            // ignore uncompressed block size
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}","static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}
","The vulnerability in the original code arises from the lack of proper validation for the dimensions of the image being decoded. Specifically, the check for dimensions only verifies if they are not equal to the codec context's dimensions, but it does not ensure that the width and height are within acceptable limits. This could lead to buffer overflows or memory corruption when accessing `frame->data[0]` or `palette`. The fix improves this by changing the condition from `if (s->width != avctx->width && s->height != avctx->height)` to `if (s->width != avctx->width || s->height != avctx->height)`, ensuring that any mismatch triggers a dimension adjustment, thus enhancing safety.","The vulnerability in the original code stems from inadequate validation of the image dimensions, which could allow for buffer overflows or memory corruption if the decoded dimensions exceed expected limits. Specifically, the code only checks if the dimensions differ from the codec context's dimensions, failing to ensure they are within safe bounds. The fix addresses this issue by modifying the condition to ensure that any mismatch in dimensions prompts a proper adjustment, thereby enforcing stricter validation and enhancing the overall safety of memory operations during the decoding process.",3,5,4,5
24,24,181506,181506,,Local,Not required,Partial,CVE-2017-6439,https://www.cvedetails.com/cve/CVE-2017-6439/,CWE-787,Medium,,,,2017-03-15,1.9,Heap-based buffer overflow in the parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (out-of-bounds write) via a crafted plist file.,2017-04-03,DoS Overflow ,6,https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,32ee5213fe64f1e10ec76c1ee861ee6f233120dd,"bplist: Fix data range check for string/data/dict/array nodes

Passing a size of 0xFFFFFFFFFFFFFFFF to parse_string_node() might result
in a memcpy with a size of -1, leading to undefined behavior.
This commit makes sure that the actual node data (which depends on the size)
is in the range start_of_object..start_of_object+size.

Credit to OSS-Fuzz",6,src/bplist.c,"{""sha"": ""7d21b273b865d734155a4e96e88e67a2145d4760"", ""filename"": ""src/bplist.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/libimobiledevice/libplist/blob/32ee5213fe64f1e10ec76c1ee861ee6f233120dd/src/bplist.c"", ""raw_url"": ""https://github.com/libimobiledevice/libplist/raw/32ee5213fe64f1e10ec76c1ee861ee6f233120dd/src/bplist.c"", ""contents_url"": ""https://api.github.com/repos/libimobiledevice/libplist/contents/src/bplist.c?ref=32ee5213fe64f1e10ec76c1ee861ee6f233120dd"", ""patch"": ""@@ -654,14 +654,14 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n         return parse_date_node(object, size);\n \n     case BPLIST_DATA:\n-        if (*object + size > bplist->offset_table) {\n+        if (*object + size < *object || *object + size > bplist->offset_table) {\n             PLIST_BIN_ERR(\""%s: BPLIST_DATA data bytes point outside of valid range\\n\"", __func__);\n             return NULL;\n         }\n         return parse_data_node(object, size);\n \n     case BPLIST_STRING:\n-        if (*object + size > bplist->offset_table) {\n+        if (*object + size < *object || *object + size > bplist->offset_table) {\n             PLIST_BIN_ERR(\""%s: BPLIST_STRING data bytes point outside of valid range\\n\"", __func__);\n             return NULL;\n         }\n@@ -672,15 +672,15 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n             PLIST_BIN_ERR(\""%s: Integer overflow when calculating BPLIST_UNICODE data size.\\n\"", __func__);\n             return NULL;\n         }\n-        if (*object + size*2 > bplist->offset_table) {\n+        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {\n             PLIST_BIN_ERR(\""%s: BPLIST_UNICODE data bytes point outside of valid range\\n\"", __func__);\n             return NULL;\n         }\n         return parse_unicode_node(object, size);\n \n     case BPLIST_SET:\n     case BPLIST_ARRAY:\n-        if (*object + size > bplist->offset_table) {\n+        if (*object + size < *object || *object + size > bplist->offset_table) {\n             PLIST_BIN_ERR(\""%s: BPLIST_ARRAY data bytes point outside of valid range\\n\"", __func__);\n             return NULL;\n         }\n@@ -694,8 +694,8 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n         return parse_uid_node(object, size);\n \n     case BPLIST_DICT:\n-        if (*object + size > bplist->offset_table) {\n-            PLIST_BIN_ERR(\""%s: BPLIST_REAL data bytes point outside of valid range\\n\"", __func__);\n+        if (*object + size < *object || *object + size > bplist->offset_table) {\n+            PLIST_BIN_ERR(\""%s: BPLIST_DICT data bytes point outside of valid range\\n\"", __func__);\n             return NULL;\n         }\n         return parse_dict_node(bplist, object, size);""}","static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
","static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
",C,"        if (*object + size < *object || *object + size > bplist->offset_table) {
        if (*object + size < *object || *object + size > bplist->offset_table) {
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
        if (*object + size < *object || *object + size > bplist->offset_table) {
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
","        if (*object + size > bplist->offset_table) {
        if (*object + size > bplist->offset_table) {
        if (*object + size*2 > bplist->offset_table) {
        if (*object + size > bplist->offset_table) {
        if (*object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
",,"@@ -654,14 +654,14 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
-        if (*object + size > bplist->offset_table) {
+        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
-        if (*object + size > bplist->offset_table) {
+        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
@@ -672,15 +672,15 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
-        if (*object + size*2 > bplist->offset_table) {
+        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
-        if (*object + size > bplist->offset_table) {
+        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
@@ -694,8 +694,8 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
-        if (*object + size > bplist->offset_table) {
-            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
+        if (*object + size < *object || *object + size > bplist->offset_table) {
+            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);",libplist,32ee5213fe64f1e10ec76c1ee861ee6f233120dd,72f7cf803635a127c63bcd37ab35ced28636410a,1,"static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
//flaw_line_below:
        if (*object + size > bplist->offset_table) {
//fix_flaw_line_below:
//        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
//flaw_line_below:
        if (*object + size > bplist->offset_table) {
//fix_flaw_line_below:
//        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
//flaw_line_below:
        if (*object + size*2 > bplist->offset_table) {
//fix_flaw_line_below:
//        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
//flaw_line_below:
        if (*object + size > bplist->offset_table) {
//fix_flaw_line_below:
//        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
//flaw_line_below:
        if (*object + size > bplist->offset_table) {
//flaw_line_below:
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
//fix_flaw_line_below:
//        if (*object + size < *object || *object + size > bplist->offset_table) {
//fix_flaw_line_below:
//            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
",181506,"static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
","static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
","The vulnerability in the original code lies in the checks for buffer overflows when accessing memory with the `*object` pointer. Specifically, the conditions like `if (*object + size > bplist->offset_table)` do not adequately prevent potential underflows or overflows, which could lead to accessing invalid memory locations. In the fixed code, these checks were enhanced by adding conditions such as `if (*object + size < *object || *object + size > bplist->offset_table)`, ensuring that both underflow and overflow scenarios are addressed, thus preventing potential memory corruption and improving overall safety when parsing binary plist nodes.","The vulnerability in the original code stems from inadequate checks for buffer overflows when accessing memory, which could lead to reading or writing outside valid memory boundaries. This oversight could result in memory corruption or crashes, especially when handling various data types. The fixed code addresses this issue by implementing more robust conditions that check for both underflow and overflow scenarios before accessing memory. By ensuring that the memory access remains within valid limits, the revised code enhances safety and stability, effectively mitigating the risk of potential exploitation or undefined behavior.",4,5,5,5
25,25,182148,182148,,Remote,Not required,Partial,CVE-2018-19198,https://www.cvedetails.com/cve/CVE-2018-19198/,CWE-787,Low,Partial,Partial,,2018-11-12,7.5,An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an out-of-bounds write via a uriComposeQuery* or uriComposeQueryEx* function because the '&' character is mishandled in certain contexts.,2019-08-06,,1,https://github.com/uriparser/uriparser/commit/864f5d4c127def386dd5cc926ad96934b297f04e,864f5d4c127def386dd5cc926ad96934b297f04e,"UriQuery.c: Fix out-of-bounds-write in ComposeQuery and ...Ex

Reported by Google Autofuzz team",0,src/UriQuery.c,"{""sha"": ""eb221576efd980e714cbc21ef4ce0c1230f9fc89"", ""filename"": ""src/UriQuery.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/uriparser/uriparser/blob/864f5d4c127def386dd5cc926ad96934b297f04e/src/UriQuery.c"", ""raw_url"": ""https://github.com/uriparser/uriparser/raw/864f5d4c127def386dd5cc926ad96934b297f04e/src/UriQuery.c"", ""contents_url"": ""https://api.github.com/repos/uriparser/uriparser/contents/src/UriQuery.c?ref=864f5d4c127def386dd5cc926ad96934b297f04e"", ""patch"": ""@@ -223,6 +223,7 @@ int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n \n \t\t\t/* Copy key */\n \t\t\tif (firstItem == URI_TRUE) {\n+\t\t\t\tampersandLen = 1;\n \t\t\t\tfirstItem = URI_FALSE;\n \t\t\t} else {\n \t\t\t\twrite[0] = _UT('&');""}<_**next**_>{""sha"": ""dbb8adb570d535d923b8588280ddf36bced6a766"", ""filename"": ""test/test.cpp"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 0, ""changes"": 32, ""blob_url"": ""https://github.com/uriparser/uriparser/blob/864f5d4c127def386dd5cc926ad96934b297f04e/test/test.cpp"", ""raw_url"": ""https://github.com/uriparser/uriparser/raw/864f5d4c127def386dd5cc926ad96934b297f04e/test/test.cpp"", ""contents_url"": ""https://api.github.com/repos/uriparser/uriparser/contents/test/test.cpp?ref=864f5d4c127def386dd5cc926ad96934b297f04e"", ""patch"": ""@@ -104,6 +104,7 @@ class UriSuite : public Suite {\n \t\tTEST_ADD(UriSuite::testQueryList)\n \t\tTEST_ADD(UriSuite::testQueryListPair)\n \t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n+\t\tTEST_ADD(UriSuite::testQueryCompositionMathWrite_GoogleAutofuzz113244572)\n \t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n \t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n \t\tTEST_ADD(UriSuite::testRangeComparison)\n@@ -1749,6 +1750,37 @@ Rule                                | Example | hostSet | absPath | emptySeg\n \t\turiFreeQueryListA(queryList);\n \t}\n \n+\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n+\t\tUriQueryListA second = { .key = \""\\x11\"", .value = NULL, .next = NULL };\n+\t\tUriQueryListA first = { .key = \""\\x01\"", .value = \""\\x02\"", .next = &second };\n+\n+\t\tconst UriBool spaceToPlus = URI_TRUE;\n+\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n+\n+\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n+\n+\t\t{\n+\t\t\t// Minimum space to hold everything fine\n+\t\t\tconst char * const expected = \""%01=%02\"" \""&\"" \""%11\"";\n+\t\t\tchar dest[charsRequired + 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_SUCCESS);\n+\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n+\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n+\t\t}\n+\n+\t\t{\n+\t\t\t// Previous math failed to take ampersand into account\n+\t\t\tchar dest[charsRequired + 1 - 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n+\t\t}\n+\t}\n+\n \tvoid testFreeCrash_Bug20080827() {\n \t\tchar const * const sourceUri = \""abc\"";\n \t\tchar const * const baseUri = \""http://www.example.org/\"";""}","int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
		const URI_TYPE(QueryList) * queryList,
		int maxChars, int * charsWritten, int * charsRequired,
		UriBool spaceToPlus, UriBool normalizeBreaks) {
	UriBool firstItem = URI_TRUE;
	int ampersandLen = 0;  /* increased to 1 from second item on */
	URI_CHAR * write = dest;

	/* Subtract terminator */
	if (dest == NULL) {
		*charsRequired = 0;
	} else {
		maxChars--;
	}
			
	while (queryList != NULL) {
		const URI_CHAR * const key = queryList->key;
		const URI_CHAR * const value = queryList->value;
		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
		const int keyRequiredChars = worstCase * keyLen;
		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
		const int valueRequiredChars = worstCase * valueLen;

		if (dest == NULL) {
			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
				firstItem = URI_FALSE;
			}

			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
						? 0
						: 1 + valueRequiredChars);
		} else {
			URI_CHAR * afterKey;

			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
				return URI_ERROR_OUTPUT_TOO_LARGE;
			}
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');
				write++;
			}
			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
					write, spaceToPlus, normalizeBreaks);
			write += (afterKey - write);

			if (value != NULL) {
				URI_CHAR * afterValue;

				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
					return URI_ERROR_OUTPUT_TOO_LARGE;
				}

				/* Copy value */
				write[0] = _UT('=');
				write++;
				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
						write, spaceToPlus, normalizeBreaks);
				write += (afterValue - write);
			}
		}

		queryList = queryList->next;
	}

	if (dest != NULL) {
		write[0] = _UT('\0');
		if (charsWritten != NULL) {
			*charsWritten = (int)(write - dest) + 1; /* .. for terminator */
		}
	}

	return URI_SUCCESS;
}
","int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
		const URI_TYPE(QueryList) * queryList,
		int maxChars, int * charsWritten, int * charsRequired,
		UriBool spaceToPlus, UriBool normalizeBreaks) {
	UriBool firstItem = URI_TRUE;
	int ampersandLen = 0;  /* increased to 1 from second item on */
	URI_CHAR * write = dest;

	/* Subtract terminator */
	if (dest == NULL) {
		*charsRequired = 0;
	} else {
		maxChars--;
	}
			
	while (queryList != NULL) {
		const URI_CHAR * const key = queryList->key;
		const URI_CHAR * const value = queryList->value;
		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
		const int keyRequiredChars = worstCase * keyLen;
		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
		const int valueRequiredChars = worstCase * valueLen;

		if (dest == NULL) {
			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
				firstItem = URI_FALSE;
			}

			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
						? 0
						: 1 + valueRequiredChars);
		} else {
			URI_CHAR * afterKey;

			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
				return URI_ERROR_OUTPUT_TOO_LARGE;
			}
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');
				write++;
			}
			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
					write, spaceToPlus, normalizeBreaks);
			write += (afterKey - write);

			if (value != NULL) {
				URI_CHAR * afterValue;

				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
					return URI_ERROR_OUTPUT_TOO_LARGE;
				}

				/* Copy value */
				write[0] = _UT('=');
				write++;
				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
						write, spaceToPlus, normalizeBreaks);
				write += (afterValue - write);
			}
		}

		queryList = queryList->next;
	}

	if (dest != NULL) {
		write[0] = _UT('\0');
		if (charsWritten != NULL) {
			*charsWritten = (int)(write - dest) + 1; /* .. for terminator */
		}
	}

	return URI_SUCCESS;
}
",C,"				ampersandLen = 1;
",,,"@@ -223,6 +223,7 @@ int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
+				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');",uriparser,864f5d4c127def386dd5cc926ad96934b297f04e,f7230d6a0c1b12c9857cf8562a47e2f616713070,1,"int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
		const URI_TYPE(QueryList) * queryList,
		int maxChars, int * charsWritten, int * charsRequired,
		UriBool spaceToPlus, UriBool normalizeBreaks) {
	UriBool firstItem = URI_TRUE;
	int ampersandLen = 0;  /* increased to 1 from second item on */
	URI_CHAR * write = dest;

	/* Subtract terminator */
	if (dest == NULL) {
		*charsRequired = 0;
	} else {
		maxChars--;
	}
			
	while (queryList != NULL) {
		const URI_CHAR * const key = queryList->key;
		const URI_CHAR * const value = queryList->value;
		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
		const int keyRequiredChars = worstCase * keyLen;
		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
		const int valueRequiredChars = worstCase * valueLen;

		if (dest == NULL) {
			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
				firstItem = URI_FALSE;
			}

			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
						? 0
						: 1 + valueRequiredChars);
		} else {
			URI_CHAR * afterKey;

			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
				return URI_ERROR_OUTPUT_TOO_LARGE;
			}
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
//fix_flaw_line_below:
//				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');
				write++;
			}
			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
					write, spaceToPlus, normalizeBreaks);
			write += (afterKey - write);

			if (value != NULL) {
				URI_CHAR * afterValue;

				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
					return URI_ERROR_OUTPUT_TOO_LARGE;
				}

				/* Copy value */
				write[0] = _UT('=');
				write++;
				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
						write, spaceToPlus, normalizeBreaks);
				write += (afterValue - write);
			}
		}

		queryList = queryList->next;
	}

	if (dest != NULL) {
		write[0] = _UT('\0');
		if (charsWritten != NULL) {
			*charsWritten = (int)(write - dest) + 1; /* .. for terminator */
		}
	}

	return URI_SUCCESS;
}
",182148,"int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
		const URI_TYPE(QueryList) * queryList,
		int maxChars, int * charsWritten, int * charsRequired,
		UriBool spaceToPlus, UriBool normalizeBreaks) {
	UriBool firstItem = URI_TRUE;
	int ampersandLen = 0;  /* increased to 1 from second item on */
	URI_CHAR * write = dest;

	/* Subtract terminator */
	if (dest == NULL) {
		*charsRequired = 0;
	} else {
		maxChars--;
	}
			
	while (queryList != NULL) {
		const URI_CHAR * const key = queryList->key;
		const URI_CHAR * const value = queryList->value;
		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
		const int keyRequiredChars = worstCase * keyLen;
		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
		const int valueRequiredChars = worstCase * valueLen;

		if (dest == NULL) {
			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
				firstItem = URI_FALSE;
			}

			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
						? 0
						: 1 + valueRequiredChars);
		} else {
			URI_CHAR * afterKey;

			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
				return URI_ERROR_OUTPUT_TOO_LARGE;
			}
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');
				write++;
			}
			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
					write, spaceToPlus, normalizeBreaks);
			write += (afterKey - write);

			if (value != NULL) {
				URI_CHAR * afterValue;

				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
					return URI_ERROR_OUTPUT_TOO_LARGE;
				}

				/* Copy value */
				write[0] = _UT('=');
				write++;
				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
						write, spaceToPlus, normalizeBreaks);
				write += (afterValue - write);
			}
		}

		queryList = queryList->next;
	}

	if (dest != NULL) {
		write[0] = _UT('\0');
		if (charsWritten != NULL) {
			*charsWritten = (int)(write - dest) + 1; /* .. for terminator */
		}
	}

	return URI_SUCCESS;
}
","int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
		const URI_TYPE(QueryList) * queryList,
		int maxChars, int * charsWritten, int * charsRequired,
		UriBool spaceToPlus, UriBool normalizeBreaks) {
	UriBool firstItem = URI_TRUE;
	int ampersandLen = 0;  /* increased to 1 from second item on */
	URI_CHAR * write = dest;

	/* Subtract terminator */
	if (dest == NULL) {
		*charsRequired = 0;
	} else {
		maxChars--;
	}
			
	while (queryList != NULL) {
		const URI_CHAR * const key = queryList->key;
		const URI_CHAR * const value = queryList->value;
		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
		const int keyRequiredChars = worstCase * keyLen;
		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
		const int valueRequiredChars = worstCase * valueLen;

		if (dest == NULL) {
			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
				firstItem = URI_FALSE;
			}

			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
						? 0
						: 1 + valueRequiredChars);
		} else {
			URI_CHAR * afterKey;

			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
				return URI_ERROR_OUTPUT_TOO_LARGE;
			}
 
 			/* Copy key */
 			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');
				write++;
			}
			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
					write, spaceToPlus, normalizeBreaks);
			write += (afterKey - write);

			if (value != NULL) {
				URI_CHAR * afterValue;

				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
					return URI_ERROR_OUTPUT_TOO_LARGE;
				}

				/* Copy value */
				write[0] = _UT('=');
				write++;
				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
						write, spaceToPlus, normalizeBreaks);
				write += (afterValue - write);
			}
		}

		queryList = queryList->next;
	}

	if (dest != NULL) {
		write[0] = _UT('\0');
		if (charsWritten != NULL) {
			*charsWritten = (int)(write - dest) + 1; /* .. for terminator */
		}
	}

	return URI_SUCCESS;
}
","The vulnerability in the original code lies in the handling of the `ampersandLen` variable, which was only set to 1 when the first item was processed. This could lead to incorrect calculations of the required buffer size, potentially causing a buffer overflow when writing to `dest`. In the fixed code, `ampersandLen` is now correctly set to 1 regardless of whether it's the first item or not, ensuring that the size calculations for `keyRequiredChars` and `valueRequiredChars` are accurate. This change prevents the risk of exceeding `maxChars` and ensures safe memory operations.","The vulnerability in the original code arises from improper handling of buffer size calculations, which could lead to buffer overflows. Specifically, the logic for determining the length of the output string did not account for the correct number of characters needed when processing multiple items, particularly the first item. This oversight could result in writing beyond the allocated memory for the destination buffer. The fixed code addresses this issue by ensuring that the length calculations are consistently accurate, thereby preventing potential overflows and ensuring that memory operations remain within safe bounds.",4,5,4,4
26,26,182214,182214,,Remote,Not required,Partial,CVE-2018-16642,https://www.cvedetails.com/cve/CVE-2018-16642/,CWE-787,Medium,,,,2018-09-06,4.3,The function InsertRow in coders/cut.c in ImageMagick 7.0.7-37 allows remote attackers to cause a denial of service via a crafted image file due to an out-of-bounds write.,2018-10-25,DoS ,94,https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,https://github.com/ImageMagick/ImageMagick/issues/1162,58,coders/cut.c,"{""sha"": ""1064c02f76b36e10e5fefebff2b9c209c43c0b9a"", ""filename"": ""coders/cut.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 61, ""changes"": 155, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e/coders/cut.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e/coders/cut.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/cut.c?ref=cc4ac341f29fa368da6ef01c207deaf8c61f6a2e"", ""patch"": ""@@ -95,132 +95,165 @@ typedef struct\n } CUTPalHeader;\n \n \f\n-static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,\n-  ExceptionInfo *exception)\n+static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,\n+  ssize_t y,ExceptionInfo *exception)\n {\n-  size_t bit; ssize_t x;\n-  register Quantum *q;\n-  Quantum index;\n+  int\n+    bit;\n \n-  index=0;\n-  switch (depth)\n-  {\n+  Quantum\n+    index;\n+\n+  register Quantum\n+    *q;\n+\n+  ssize_t\n+    x;\n+\n+  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n+  if (q == (Quantum *) NULL)\n+    return(MagickFalse);\n+  switch (bpp)\n+    {\n     case 1:  /* Convert bitmap scanline. */\n       {\n-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n-        if (q == (Quantum *) NULL)\n-          break;\n         for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n         {\n           for (bit=0; bit < 8; bit++)\n           {\n-            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n+            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n             SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n             q+=GetPixelChannels(image);\n           }\n           p++;\n         }\n         if ((image->columns % 8) != 0)\n           {\n-            for (bit=0; bit < (image->columns % 8); bit++)\n-              {\n-                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n-                SetPixelIndex(image,index,q);\n-                q+=GetPixelChannels(image);\n-              }\n+            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n+            {\n+              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n+              SetPixelIndex(image,index,q);\n+              if (index < image->colors)\n+                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+              q+=GetPixelChannels(image);\n+            }\n             p++;\n           }\n-        (void) SyncAuthenticPixels(image,exception);\n         break;\n       }\n     case 2:  /* Convert PseudoColor scanline. */\n       {\n-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n-        if (q == (Quantum *) NULL)\n-          break;\n-        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n+        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n         {\n-          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n-          SetPixelIndex(image,index,q);\n-          q+=GetPixelChannels(image);\n-          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n-          SetPixelIndex(image,index,q);\n-          q+=GetPixelChannels(image);\n-          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n-          SetPixelIndex(image,index,q);\n-          q+=GetPixelChannels(image);\n-          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n-          SetPixelIndex(image,index,q);\n-          q+=GetPixelChannels(image);\n-          p++;\n+            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n+            SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+            q+=GetPixelChannels(image);\n+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n+            SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+            q+=GetPixelChannels(image);\n+            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n+            SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+            q+=GetPixelChannels(image);\n+            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n+            SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+            q+=GetPixelChannels(image);\n+            p++;\n         }\n-        if ((image->columns % 4) != 0)\n+       if ((image->columns % 4) != 0)\n           {\n             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n             SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n             q+=GetPixelChannels(image);\n-            if ((image->columns % 4) >= 1)\n-\n+            if ((image->columns % 4) > 1)\n               {\n                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                 SetPixelIndex(image,index,q);\n+                if (index < image->colors)\n+                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                 q+=GetPixelChannels(image);\n-                if ((image->columns % 4) >= 2)\n-\n+                if ((image->columns % 4) > 2)\n                   {\n                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                       exception);\n                     SetPixelIndex(image,index,q);\n+                    if (index < image->colors)\n+                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n+                        index,q);\n                     q+=GetPixelChannels(image);\n                   }\n               }\n             p++;\n           }\n-        (void) SyncAuthenticPixels(image,exception);\n         break;\n       }\n \n     case 4:  /* Convert PseudoColor scanline. */\n       {\n-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n-        if (q == (Quantum *) NULL)\n-          break;\n         for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n-        {\n-            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n+          {\n+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n             SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n             q+=GetPixelChannels(image);\n-            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);\n+            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n             SetPixelIndex(image,index,q);\n-            q+=GetPixelChannels(image);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n             p++;\n+            q+=GetPixelChannels(image);\n           }\n         if ((image->columns % 2) != 0)\n           {\n-            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n             SetPixelIndex(image,index,q);\n-            q+=GetPixelChannels(image);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n             p++;\n+            q+=GetPixelChannels(image);\n           }\n-        (void) SyncAuthenticPixels(image,exception);\n         break;\n       }\n     case 8: /* Convert PseudoColor scanline. */\n       {\n-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n-        if (q == (Quantum *) NULL)\n-          break;\n         for (x=0; x < (ssize_t) image->columns; x++)\n+          {\n+            index=ConstrainColormapIndex(image,*p,exception);\n+            SetPixelIndex(image,index,q);\n+            if (index < image->colors)\n+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n+            p++;\n+            q+=GetPixelChannels(image);\n+          }\n+      }\n+      break;\n+\n+    case 24:     /*  Convert DirectColor scanline.  */\n+      for (x=0; x < (ssize_t) image->columns; x++)\n         {\n-          index=ConstrainColormapIndex(image,*p,exception);\n-          SetPixelIndex(image,index,q);\n-          p++;\n+          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n+          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n+          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n           q+=GetPixelChannels(image);\n         }\n-        (void) SyncAuthenticPixels(image,exception);\n-        break;\n-      }\n+      break;\n     }\n+  if (!SyncAuthenticPixels(image,exception))\n+    return(MagickFalse);\n+  return(MagickTrue);\n }\n \n /*""}","static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
  ssize_t y,ExceptionInfo *exception)
 {
  int
    bit;
 
  Quantum
    index;

  register Quantum
    *q;

  ssize_t
    x;

  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    return(MagickFalse);
  switch (bpp)
    {
     case 1:  /* Convert bitmap scanline. */
       {
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
            {
              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              if (index < image->colors)
                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              q+=GetPixelChannels(image);
            }
             p++;
           }
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            p++;
         }
       if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
                if (index < image->colors)
                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                 q+=GetPixelChannels(image);
                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
                    if (index < image->colors)
                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
                        index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         if ((image->columns % 2) != 0)
           {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
         for (x=0; x < (ssize_t) image->columns; x++)
          {
            index=ConstrainColormapIndex(image,*p,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            p++;
            q+=GetPixelChannels(image);
          }
      }
      break;

    case 24:     /*  Convert DirectColor scanline.  */
      for (x=0; x < (ssize_t) image->columns; x++)
         {
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
           q+=GetPixelChannels(image);
         }
      break;
     }
  if (!SyncAuthenticPixels(image,exception))
    return(MagickFalse);
  return(MagickTrue);
 }
","static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
  ExceptionInfo *exception)
 {
  size_t bit; ssize_t x;
  register Quantum *q;
  Quantum index;
 
  index=0;
  switch (depth)
  {
     case 1:  /* Convert bitmap scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
            for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
         {
          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          p++;
         }
        if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
            if ((image->columns % 4) >= 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
                 q+=GetPixelChannels(image);
                if ((image->columns % 4) >= 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
        {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);
             SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
             p++;
           }
         if ((image->columns % 2) != 0)
           {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
             SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < (ssize_t) image->columns; x++)
         {
          index=ConstrainColormapIndex(image,*p,exception);
          SetPixelIndex(image,index,q);
          p++;
           q+=GetPixelChannels(image);
         }
        (void) SyncAuthenticPixels(image,exception);
        break;
      }
     }
 }
",C,"static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
  ssize_t y,ExceptionInfo *exception)
  int
    bit;
  Quantum
    index;

  register Quantum
    *q;

  ssize_t
    x;

  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    return(MagickFalse);
  switch (bpp)
    {
            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
            {
              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              if (index < image->colors)
                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              q+=GetPixelChannels(image);
            }
        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            p++;
       if ((image->columns % 4) != 0)
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            if ((image->columns % 4) > 1)
                if (index < image->colors)
                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                if ((image->columns % 4) > 2)
                    if (index < image->colors)
                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
                        index,q);
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
          {
            index=ConstrainColormapIndex(image,*p,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            p++;
            q+=GetPixelChannels(image);
          }
      }
      break;

    case 24:     /*  Convert DirectColor scanline.  */
      for (x=0; x < (ssize_t) image->columns; x++)
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
      break;
  if (!SyncAuthenticPixels(image,exception))
    return(MagickFalse);
  return(MagickTrue);
","  ExceptionInfo *exception)
  size_t bit; ssize_t x;
  register Quantum *q;
  Quantum index;
  index=0;
  switch (depth)
  {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
            for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
        (void) SyncAuthenticPixels(image,exception);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          p++;
        if ((image->columns % 4) != 0)
            if ((image->columns % 4) >= 1)
                if ((image->columns % 4) >= 2)
        (void) SyncAuthenticPixels(image,exception);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
            q+=GetPixelChannels(image);
        (void) SyncAuthenticPixels(image,exception);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
          index=ConstrainColormapIndex(image,*p,exception);
          SetPixelIndex(image,index,q);
          p++;
        (void) SyncAuthenticPixels(image,exception);
        break;
      }
",,"@@ -95,132 +95,165 @@ typedef struct
 } CUTPalHeader;
 
 
-static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
-  ExceptionInfo *exception)
+static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
+  ssize_t y,ExceptionInfo *exception)
 {
-  size_t bit; ssize_t x;
-  register Quantum *q;
-  Quantum index;
+  int
+    bit;
 
-  index=0;
-  switch (depth)
-  {
+  Quantum
+    index;
+
+  register Quantum
+    *q;
+
+  ssize_t
+    x;
+
+  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
+  if (q == (Quantum *) NULL)
+    return(MagickFalse);
+  switch (bpp)
+    {
     case 1:  /* Convert bitmap scanline. */
       {
-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
-        if (q == (Quantum *) NULL)
-          break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
-            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
+            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
-            for (bit=0; bit < (image->columns % 8); bit++)
-              {
-                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
-                SetPixelIndex(image,index,q);
-                q+=GetPixelChannels(image);
-              }
+            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
+            {
+              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
+              SetPixelIndex(image,index,q);
+              if (index < image->colors)
+                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+              q+=GetPixelChannels(image);
+            }
             p++;
           }
-        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
-        if (q == (Quantum *) NULL)
-          break;
-        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
+        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
-          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
-          SetPixelIndex(image,index,q);
-          q+=GetPixelChannels(image);
-          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
-          SetPixelIndex(image,index,q);
-          q+=GetPixelChannels(image);
-          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
-          SetPixelIndex(image,index,q);
-          q+=GetPixelChannels(image);
-          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
-          SetPixelIndex(image,index,q);
-          q+=GetPixelChannels(image);
-          p++;
+            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
+            SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+            q+=GetPixelChannels(image);
+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
+            SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+            q+=GetPixelChannels(image);
+            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
+            SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+            q+=GetPixelChannels(image);
+            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
+            SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+            q+=GetPixelChannels(image);
+            p++;
         }
-        if ((image->columns % 4) != 0)
+       if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
-            if ((image->columns % 4) >= 1)
-
+            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
+                if (index < image->colors)
+                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                 q+=GetPixelChannels(image);
-                if ((image->columns % 4) >= 2)
-
+                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
+                    if (index < image->colors)
+                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
+                        index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
-        (void) SyncAuthenticPixels(image,exception);
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
-        if (q == (Quantum *) NULL)
-          break;
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
-        {
-            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
+          {
+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
-            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);
+            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
             SetPixelIndex(image,index,q);
-            q+=GetPixelChannels(image);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
+            q+=GetPixelChannels(image);
           }
         if ((image->columns % 2) != 0)
           {
-            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
+            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
-            q+=GetPixelChannels(image);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
+            q+=GetPixelChannels(image);
           }
-        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
-        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
-        if (q == (Quantum *) NULL)
-          break;
         for (x=0; x < (ssize_t) image->columns; x++)
+          {
+            index=ConstrainColormapIndex(image,*p,exception);
+            SetPixelIndex(image,index,q);
+            if (index < image->colors)
+              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
+            p++;
+            q+=GetPixelChannels(image);
+          }
+      }
+      break;
+
+    case 24:     /*  Convert DirectColor scanline.  */
+      for (x=0; x < (ssize_t) image->columns; x++)
         {
-          index=ConstrainColormapIndex(image,*p,exception);
-          SetPixelIndex(image,index,q);
-          p++;
+          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
+          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
+          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
           q+=GetPixelChannels(image);
         }
-        (void) SyncAuthenticPixels(image,exception);
-        break;
-      }
+      break;
     }
+  if (!SyncAuthenticPixels(image,exception))
+    return(MagickFalse);
+  return(MagickTrue);
 }
 
 /*",ImageMagick,cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,c45dd7ac94939b0fd3e243900becfa07f995a5ea,1,"static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
//flaw_line_below:
  ExceptionInfo *exception)
//fix_flaw_line_below:
//static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
//fix_flaw_line_below:
//  ssize_t y,ExceptionInfo *exception)
 {
//flaw_line_below:
  size_t bit; ssize_t x;
//flaw_line_below:
  register Quantum *q;
//flaw_line_below:
  Quantum index;
//fix_flaw_line_below:
//  int
//fix_flaw_line_below:
//    bit;
 
//flaw_line_below:
  index=0;
//flaw_line_below:
  switch (depth)
//flaw_line_below:
  {
//fix_flaw_line_below:
//  Quantum
//fix_flaw_line_below:
//    index;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  register Quantum
//fix_flaw_line_below:
//    *q;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  ssize_t
//fix_flaw_line_below:
//    x;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
//fix_flaw_line_below:
//  if (q == (Quantum *) NULL)
//fix_flaw_line_below:
//    return(MagickFalse);
//fix_flaw_line_below:
//  switch (bpp)
//fix_flaw_line_below:
//    {
     case 1:  /* Convert bitmap scanline. */
       {
//flaw_line_below:
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
//flaw_line_below:
        if (q == (Quantum *) NULL)
//flaw_line_below:
          break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
//flaw_line_below:
            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
//fix_flaw_line_below:
//            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
//flaw_line_below:
            for (bit=0; bit < (image->columns % 8); bit++)
//flaw_line_below:
              {
//flaw_line_below:
                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
//flaw_line_below:
                SetPixelIndex(image,index,q);
//flaw_line_below:
                q+=GetPixelChannels(image);
//flaw_line_below:
              }
//fix_flaw_line_below:
//            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
//fix_flaw_line_below:
//            {
//fix_flaw_line_below:
//              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
//fix_flaw_line_below:
//              SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//              if (index < image->colors)
//fix_flaw_line_below:
//                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//              q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            }
             p++;
           }
//flaw_line_below:
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
//flaw_line_below:
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
//flaw_line_below:
        if (q == (Quantum *) NULL)
//flaw_line_below:
          break;
//flaw_line_below:
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
//fix_flaw_line_below:
//        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
//flaw_line_below:
          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
//flaw_line_below:
          SetPixelIndex(image,index,q);
//flaw_line_below:
          q+=GetPixelChannels(image);
//flaw_line_below:
          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
//flaw_line_below:
          SetPixelIndex(image,index,q);
//flaw_line_below:
          q+=GetPixelChannels(image);
//flaw_line_below:
          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
//flaw_line_below:
          SetPixelIndex(image,index,q);
//flaw_line_below:
          q+=GetPixelChannels(image);
//flaw_line_below:
          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
//flaw_line_below:
          SetPixelIndex(image,index,q);
//flaw_line_below:
          q+=GetPixelChannels(image);
//flaw_line_below:
          p++;
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
//fix_flaw_line_below:
//            SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
//fix_flaw_line_below:
//            SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
//fix_flaw_line_below:
//            SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
//fix_flaw_line_below:
//            SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            p++;
         }
//flaw_line_below:
        if ((image->columns % 4) != 0)
//fix_flaw_line_below:
//       if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
//flaw_line_below:
            if ((image->columns % 4) >= 1)
//flaw_line_below:

//fix_flaw_line_below:
//            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//                if (index < image->colors)
//fix_flaw_line_below:
//                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                 q+=GetPixelChannels(image);
//flaw_line_below:
                if ((image->columns % 4) >= 2)
//flaw_line_below:

//fix_flaw_line_below:
//                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//                    if (index < image->colors)
//fix_flaw_line_below:
//                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
//fix_flaw_line_below:
//                        index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
//flaw_line_below:
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
//flaw_line_below:
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
//flaw_line_below:
        if (q == (Quantum *) NULL)
//flaw_line_below:
          break;
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
//flaw_line_below:
        {
//flaw_line_below:
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
//fix_flaw_line_below:
//          {
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
//flaw_line_below:
            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
             SetPixelIndex(image,index,q);
//flaw_line_below:
            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
           }
         if ((image->columns % 2) != 0)
           {
//flaw_line_below:
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
//flaw_line_below:
            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
           }
//flaw_line_below:
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
//flaw_line_below:
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
//flaw_line_below:
        if (q == (Quantum *) NULL)
//flaw_line_below:
          break;
         for (x=0; x < (ssize_t) image->columns; x++)
//fix_flaw_line_below:
//          {
//fix_flaw_line_below:
//            index=ConstrainColormapIndex(image,*p,exception);
//fix_flaw_line_below:
//            SetPixelIndex(image,index,q);
//fix_flaw_line_below:
//            if (index < image->colors)
//fix_flaw_line_below:
//              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
//fix_flaw_line_below:
//            p++;
//fix_flaw_line_below:
//            q+=GetPixelChannels(image);
//fix_flaw_line_below:
//          }
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//      break;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    case 24:     /*  Convert DirectColor scanline.  */
//fix_flaw_line_below:
//      for (x=0; x < (ssize_t) image->columns; x++)
         {
//flaw_line_below:
          index=ConstrainColormapIndex(image,*p,exception);
//flaw_line_below:
          SetPixelIndex(image,index,q);
//flaw_line_below:
          p++;
//fix_flaw_line_below:
//          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
//fix_flaw_line_below:
//          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
//fix_flaw_line_below:
//          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
           q+=GetPixelChannels(image);
         }
//flaw_line_below:
        (void) SyncAuthenticPixels(image,exception);
//flaw_line_below:
        break;
//flaw_line_below:
      }
//fix_flaw_line_below:
//      break;
     }
//fix_flaw_line_below:
//  if (!SyncAuthenticPixels(image,exception))
//fix_flaw_line_below:
//    return(MagickFalse);
//fix_flaw_line_below:
//  return(MagickTrue);
 }
",182214,"static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
  ExceptionInfo *exception)
 {
  size_t bit; ssize_t x;
  register Quantum *q;
  Quantum index;
 
  index=0;
  switch (depth)
  {
     case 1:  /* Convert bitmap scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
            for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-1); x+=2)
         {
          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          p++;
         }
        if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
            if ((image->columns % 4) >= 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
                 q+=GetPixelChannels(image);
                if ((image->columns % 4) >= 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
        {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
             SetPixelIndex(image,index,q);
             q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);
             SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
             p++;
           }
         if ((image->columns % 2) != 0)
           {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);
             SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
             p++;
           }
        (void) SyncAuthenticPixels(image,exception);
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
         for (x=0; x < (ssize_t) image->columns; x++)
         {
          index=ConstrainColormapIndex(image,*p,exception);
          SetPixelIndex(image,index,q);
          p++;
           q+=GetPixelChannels(image);
         }
        (void) SyncAuthenticPixels(image,exception);
        break;
      }
     }
 }
","static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,
static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
  ssize_t y,ExceptionInfo *exception)
 {
  int
    bit;
 
  Quantum
    index;

  register Quantum
    *q;

  ssize_t
    x;

  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    return(MagickFalse);
  switch (bpp)
    {
     case 1:  /* Convert bitmap scanline. */
       {
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
            {
              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              if (index < image->colors)
                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              q+=GetPixelChannels(image);
            }
             p++;
           }
         break;
       }
     case 2:  /* Convert PseudoColor scanline. */
       {
        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            p++;
         }
       if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
                if (index < image->colors)
                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                 q+=GetPixelChannels(image);
                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
                    if (index < image->colors)
                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
                        index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
         break;
       }
 
     case 4:  /* Convert PseudoColor scanline. */
       {
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         if ((image->columns % 2) != 0)
           {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         break;
       }
     case 8: /* Convert PseudoColor scanline. */
       {
         for (x=0; x < (ssize_t) image->columns; x++)
          {
            index=ConstrainColormapIndex(image,*p,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            p++;
            q+=GetPixelChannels(image);
          }
      }
      break;

    case 24:     /*  Convert DirectColor scanline.  */
      for (x=0; x < (ssize_t) image->columns; x++)
         {
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
           q+=GetPixelChannels(image);
         }
      break;
     }
  if (!SyncAuthenticPixels(image,exception))
    return(MagickFalse);
  return(MagickTrue);
 }
","The vulnerability in the original code lies in the lack of bounds checking when accessing the colormap, specifically when using the `index` variable to set pixel values. If `index` exceeds the number of colors in the colormap, it could lead to out-of-bounds memory access, potentially causing crashes or security issues. The fixed code addresses this vulnerability by adding a check: `if (index < image->colors)` before calling `SetPixelViaPixelInfo(image, image->colormap + (ssize_t) index, q)`. This ensures that `index` is always within valid bounds, preventing unsafe memory access and enhancing overall stability.","The vulnerability in the original code stems from inadequate bounds checking when accessing an array, which could lead to out-of-bounds memory access. This situation arises when the code attempts to use an index that exceeds the valid range of the array, potentially resulting in crashes or exploitation by malicious actors. The revised code mitigates this risk by implementing checks to ensure that the index remains within the valid limits of the array before any access occurs. This enhancement effectively prevents unsafe memory operations, thereby improving the code's security and stability.",2,4,4,3
27,27,182283,182283,,Remote,Not required,Partial,CVE-2018-14681,https://www.cvedetails.com/cve/CVE-2018-14681/,CWE-787,Medium,Partial,Partial,,2018-07-28,6.8,An issue was discovered in kwajd_read_headers in mspack/kwajd.c in libmspack before 0.7alpha. Bad KWAJ file header extensions could cause a one or two byte overwrite.,2019-03-28,,19,https://github.com/kyz/libmspack/commit/0b0ef9344255ff5acfac6b7af09198ac9c9756c8,0b0ef9344255ff5acfac6b7af09198ac9c9756c8,kwaj_read_headers(): fix handling of non-terminated strings,12,libmspack/mspack/kwajd.c,"{""sha"": ""44cf81a587adfe9cc5ed0f98c8ac7393e990968f"", ""filename"": ""libmspack/ChangeLog"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/ChangeLog"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/ChangeLog?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -1,3 +1,11 @@\n+2017-11-26  Stuart Caie <kyzer@cabextract.org.uk>\n+\n+\t* kwajd_read_headers(): fix up the logic of reading the filename and\n+\textension headers to avoid a one or two byte overwrite. Thanks to\n+\tJakub Wilk for finding the issue.\n+\n+\t* test/kwajd_test.c: add tests for KWAJ filename.ext handling\n+\n 2017-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* test/cabd_test.c: update the short string tests to expect not only""}<_**next**_>{""sha"": ""e2d0c96a7ffaffaeb4d50482d793219a05629e32"", ""filename"": ""libmspack/Makefile.am"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/Makefile.am"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/Makefile.am?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -24,7 +24,7 @@ lib_LTLIBRARIES =\tlibmspack.la\n noinst_LTLIBRARIES =\tlibmscabd.la libmschmd.la\n noinst_PROGRAMS =\texamples/cabd_memory examples/multifh test/cabd_md5 \\\n \t\t\ttest/cabd_test test/chmd_find test/chmd_md5 \\\n-\t\t\ttest/chmd_order test/chminfo\n+\t\t\ttest/chmd_order test/chminfo test/kwajd_test\n \n libmspack_la_SOURCES =\tmspack/mspack.h \\\n \t\t\tmspack/system.h mspack/system.c \\\n@@ -89,3 +89,5 @@ test_chmd_order_SOURCES =\ttest/chmd_order.c test/md5.c test/md5.h \\\n test_chmd_order_LDADD =\t\tlibmschmd.la\n test_chminfo_SOURCES =\t\ttest/chminfo.c libmschmd.la\n test_chminfo_LDADD =\t\tlibmschmd.la\n+test_kwajd_test_SOURCES =\ttest/kwajd_test.c libmspack.la\n+test_kwajd_test_LDADD = \tlibmspack.la""}<_**next**_>{""sha"": ""50be257023303ca8a46af8c8a71b7d306b821f95"", ""filename"": ""libmspack/mspack/kwajd.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 13, ""changes"": 32, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/mspack/kwajd.c"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/mspack/kwajd.c"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/mspack/kwajd.c?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -198,30 +198,36 @@ static int kwajd_read_headers(struct mspack_system *sys,\n \n     /* filename and extension */\n     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {\n-\toff_t pos = sys->tell(fh);\n-\tchar *fn = (char *) sys->alloc(sys, (size_t) 13);\n-\n+\tint len;\n \t/* allocate memory for maximum length filename */\n-\tif (! fn) return MSPACK_ERR_NOMEMORY;\n-\thdr->filename = fn;\n+\tchar *fn = (char *) sys->alloc(sys, (size_t) 13);\n+\tif (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;\n \n \t/* copy filename if present */\n \tif (hdr->headers & MSKWAJ_HDR_HASFILENAME) {\n-\t    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;\n-\t    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;\n-\t    pos += (i < 9) ? i+1 : 9;\n-\t    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))\n+\t    /* read and copy up to 9 bytes of a null terminated string */\n+\t    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;\n+\t    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;\n+\t    /* if string was 9 bytes with no null terminator, reject it */\n+\t    if (i == 9 && buf[8] != '\\0') return MSPACK_ERR_DATAFORMAT;\n+\t    /* seek to byte after string ended in file */\n+\t    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))\n \t\treturn MSPACK_ERR_SEEK;\n+\t    fn--; /* remove the null terminator */\n \t}\n \n \t/* copy extension if present */\n \tif (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {\n \t    *fn++ = '.';\n-\t    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;\n-\t    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;\n-\t    pos += (i < 4) ? i+1 : 4;\n-\t    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))\n+\t    /* read and copy up to 4 bytes of a null terminated string */\n+\t    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;\n+\t    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;\n+\t    /* if string was 4 bytes with no null terminator, reject it */\n+\t    if (i == 4 && buf[3] != '\\0') return MSPACK_ERR_DATAFORMAT;\n+\t    /* seek to byte after string ended in file */\n+\t    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))\n \t\treturn MSPACK_ERR_SEEK;\n+\t    fn--; /* remove the null terminator */\n \t}\n \t*fn = '\\0';\n     }""}<_**next**_>{""sha"": ""ee9c6d9fdc1630ae5873cae7acd98181fc873cbb"", ""filename"": ""libmspack/test/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/.gitignore"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/.gitignore"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/.gitignore?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -8,3 +8,4 @@ chmd_find\n chmd_md5\n chmd_order\n chminfo\n+kwajd_test""}<_**next**_>{""sha"": ""4ee10f9c3fb99e8baf28025f2b0180197d544fb1"", ""filename"": ""libmspack/test/kwajd_test.c"", ""status"": ""added"", ""additions"": 116, ""deletions"": 0, ""changes"": 116, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/kwajd_test.c"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/kwajd_test.c"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/kwajd_test.c?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -0,0 +1,116 @@\n+/* KWAJ regression test suite */\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <mspack.h>\n+\n+unsigned int test_count = 0;\n+#define TEST(x) do {\\\n+    test_count++; \\\n+    if (!(x)) {printf(\""%s:%d FAILED %s\\n\"",__FUNCTION__,__LINE__,#x);exit(1);} \\\n+} while (0)\n+\n+/* test parsing of KWAJ filename/extension headers */\n+void kwajd_open_test_01() {\n+    struct mskwaj_decompressor *kwajd;\n+    struct mskwajd_header *hdr;\n+\n+    kwajd = mspack_create_kwaj_decompressor(NULL);\n+    TEST(kwajd != NULL);\n+\n+    hdr = kwajd->open(kwajd, \""test_files/kwajd/f00.kwj\"");\n+    TEST(hdr != NULL);\n+    TEST(hdr->filename == NULL);\n+    kwajd->close(kwajd, hdr);\n+\n+#define TEST_FNAME(testfile, fname)      \\\n+    hdr = kwajd->open(kwajd, testfile);  \\\n+    TEST(hdr != NULL);                   \\\n+    TEST(hdr->filename != NULL);         \\\n+    TEST(!strcmp(fname, hdr->filename)); \\\n+    kwajd->close(kwajd, hdr)\n+#define TEST_FNAME_BAD(testfile)         \\\n+    hdr = kwajd->open(kwajd, testfile);  \\\n+    TEST(hdr == NULL);                   \\\n+    TEST(kwajd->last_error(kwajd) == MSPACK_ERR_DATAFORMAT)\n+\n+    TEST_FNAME(\""test_files/kwajd/f01.kwj\"", \"".1\"");\n+    TEST_FNAME(\""test_files/kwajd/f02.kwj\"", \"".12\"");\n+    TEST_FNAME(\""test_files/kwajd/f03.kwj\"", \"".123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f10.kwj\"", \""1\"");\n+    TEST_FNAME(\""test_files/kwajd/f11.kwj\"", \""1.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f12.kwj\"", \""1.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f13.kwj\"", \""1.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f20.kwj\"", \""12\"");\n+    TEST_FNAME(\""test_files/kwajd/f21.kwj\"", \""12.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f22.kwj\"", \""12.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f23.kwj\"", \""12.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f30.kwj\"", \""123\"");\n+    TEST_FNAME(\""test_files/kwajd/f31.kwj\"", \""123.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f32.kwj\"", \""123.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f33.kwj\"", \""123.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f40.kwj\"", \""1234\"");\n+    TEST_FNAME(\""test_files/kwajd/f41.kwj\"", \""1234.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f42.kwj\"", \""1234.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f43.kwj\"", \""1234.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f50.kwj\"", \""12345\"");\n+    TEST_FNAME(\""test_files/kwajd/f51.kwj\"", \""12345.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f52.kwj\"", \""12345.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f53.kwj\"", \""12345.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f60.kwj\"", \""123456\"");\n+    TEST_FNAME(\""test_files/kwajd/f61.kwj\"", \""123456.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f62.kwj\"", \""123456.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f63.kwj\"", \""123456.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f70.kwj\"", \""1234567\"");\n+    TEST_FNAME(\""test_files/kwajd/f71.kwj\"", \""1234567.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f72.kwj\"", \""1234567.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f73.kwj\"", \""1234567.123\"");\n+\n+    TEST_FNAME(\""test_files/kwajd/f80.kwj\"", \""12345678\"");\n+    TEST_FNAME(\""test_files/kwajd/f81.kwj\"", \""12345678.1\"");\n+    TEST_FNAME(\""test_files/kwajd/f82.kwj\"", \""12345678.12\"");\n+    TEST_FNAME(\""test_files/kwajd/f83.kwj\"", \""12345678.123\"");\n+\n+    TEST_FNAME_BAD(\""test_files/kwajd/f04.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f14.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f24.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f34.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f44.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f54.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f64.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f74.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f84.kwj\"");\n+\n+    TEST_FNAME_BAD(\""test_files/kwajd/f90.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f91.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f92.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f93.kwj\"");\n+    TEST_FNAME_BAD(\""test_files/kwajd/f94.kwj\"");\n+\n+\n+    mspack_destroy_kwaj_decompressor(kwajd);\n+}\n+\n+int main() {\n+  int selftest;\n+\n+  MSPACK_SYS_SELFTEST(selftest);\n+  TEST(selftest == MSPACK_ERR_OK);\n+\n+  kwajd_open_test_01();\n+\n+  printf(\""ALL %d TESTS PASSED.\\n\"", test_count);\n+  return 0;\n+}""}<_**next**_>{""sha"": ""1aa817ee77bd8ec8dc617e22576d2a3d21be3130"", ""filename"": ""libmspack/test/test_files/kwajd/f00.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f00.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f00.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f00.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""9fbeddab9d31eec1958b97de12728b2c23bc6d40"", ""filename"": ""libmspack/test/test_files/kwajd/f01.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f01.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f01.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f01.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""a81a863b4f7d3b10ea9366de4f8fb806899dcf8a"", ""filename"": ""libmspack/test/test_files/kwajd/f02.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f02.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f02.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f02.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""52bfb1eb9f9381fbf2d58dfa868c1657c0ad9981"", ""filename"": ""libmspack/test/test_files/kwajd/f03.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f03.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f03.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f03.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""1775433bb4723694a88a9b09c794167292a8ed05"", ""filename"": ""libmspack/test/test_files/kwajd/f04.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f04.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f04.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f04.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""40f944bd7ff6a51afd21f40e71f3c450179ea330"", ""filename"": ""libmspack/test/test_files/kwajd/f10.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f10.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f10.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f10.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""eca53c9ec9e6945ae3699cd0bef8bd2b786309bc"", ""filename"": ""libmspack/test/test_files/kwajd/f11.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f11.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f11.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f11.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""767c3550b7abe498b7be6b732b4ffa62314c7003"", ""filename"": ""libmspack/test/test_files/kwajd/f12.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f12.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f12.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f12.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""f8d7fb630f5bb714cf33ac1666ea411ec3b01318"", ""filename"": ""libmspack/test/test_files/kwajd/f13.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f13.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f13.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f13.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""486e580d5ecf6d3bb188815ea11c8acc6bc40d46"", ""filename"": ""libmspack/test/test_files/kwajd/f14.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f14.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f14.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f14.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""89de0effc09b5beac30b8b8d9faadc29ab616ebb"", ""filename"": ""libmspack/test/test_files/kwajd/f20.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f20.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f20.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f20.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""a4c3a8cf29bc11a58a2f262021e8f8e061ff2fb3"", ""filename"": ""libmspack/test/test_files/kwajd/f21.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f21.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f21.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f21.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""fa9c35d0a9900c78a67835faea176a016d2da52b"", ""filename"": ""libmspack/test/test_files/kwajd/f22.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f22.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f22.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f22.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""c10cc71f5ce148cc2bfccbc5141a1ad1fa8223de"", ""filename"": ""libmspack/test/test_files/kwajd/f23.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f23.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f23.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f23.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""75858e7dd97e9a37e448abc5d85ba878026da756"", ""filename"": ""libmspack/test/test_files/kwajd/f24.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f24.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f24.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f24.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""e2b452e880672fecedb3937829d1200eeb7b9195"", ""filename"": ""libmspack/test/test_files/kwajd/f30.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f30.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f30.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f30.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""05e0ce11a1eb8eb490ab94ab78088433bbe9ea66"", ""filename"": ""libmspack/test/test_files/kwajd/f31.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f31.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f31.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f31.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""96a57399057adc795770f2cd685b44ec73027789"", ""filename"": ""libmspack/test/test_files/kwajd/f32.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f32.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f32.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f32.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""935d6df79e1691894ef2d35d3bb460bf4c550112"", ""filename"": ""libmspack/test/test_files/kwajd/f33.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f33.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f33.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f33.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""d7084c5c82e0661046f0d23cc6375913b7dca6fb"", ""filename"": ""libmspack/test/test_files/kwajd/f34.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f34.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f34.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f34.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""64cfc84f171e642ace2ba37aa436c76cfae787de"", ""filename"": ""libmspack/test/test_files/kwajd/f40.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f40.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f40.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f40.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""657177ae744dd94a47de95ae880ce727f3ce65ad"", ""filename"": ""libmspack/test/test_files/kwajd/f41.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f41.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f41.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f41.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""6ff2b22f6f9c94f9418d58652461c575b05bb6a6"", ""filename"": ""libmspack/test/test_files/kwajd/f42.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f42.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f42.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f42.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""52c6c10ba7ec12eec195a8a1ad1e3f4feaa41f16"", ""filename"": ""libmspack/test/test_files/kwajd/f43.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f43.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f43.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f43.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""bc4d5106eeff2cbb97c08ebc2729675631533477"", ""filename"": ""libmspack/test/test_files/kwajd/f44.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f44.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f44.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f44.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""31bf36783cff8590e7e3c33be904538af9cede7b"", ""filename"": ""libmspack/test/test_files/kwajd/f50.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f50.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f50.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f50.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""c63c06112c681a8453423f32bb8c83331ecc5354"", ""filename"": ""libmspack/test/test_files/kwajd/f51.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f51.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f51.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f51.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""9ab97164e0c3620634156af3228f3f33a8f42ab0"", ""filename"": ""libmspack/test/test_files/kwajd/f52.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f52.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f52.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f52.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""e9736261dd771f1f5f52399d531edcf48ce297ee"", ""filename"": ""libmspack/test/test_files/kwajd/f53.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f53.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f53.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f53.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""f3b288749d831c586bdcfd234aa51aa3226f380a"", ""filename"": ""libmspack/test/test_files/kwajd/f54.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f54.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f54.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f54.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""af39e5828e92b7a5e23899ea426cab25f32599b7"", ""filename"": ""libmspack/test/test_files/kwajd/f60.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f60.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f60.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f60.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""a8d627831cd01649523556637bc91bde98211c71"", ""filename"": ""libmspack/test/test_files/kwajd/f61.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f61.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f61.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f61.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""225f8df70b4b57998a181174fe092e0ed14080b8"", ""filename"": ""libmspack/test/test_files/kwajd/f62.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f62.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f62.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f62.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""50f79802ca6b3dffa611ac486bd47fa3a1c1dc57"", ""filename"": ""libmspack/test/test_files/kwajd/f63.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f63.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f63.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f63.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""84c267921e5d65e03229c6a08304a78626b5be8d"", ""filename"": ""libmspack/test/test_files/kwajd/f64.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f64.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f64.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f64.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""3507550389f19581db05450f1f4311cfa1152bd4"", ""filename"": ""libmspack/test/test_files/kwajd/f70.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f70.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f70.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f70.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""92c2141c571b38fd4b252093d404a523a81e18f9"", ""filename"": ""libmspack/test/test_files/kwajd/f71.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f71.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f71.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f71.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""a2e57ab342c435998617f13ffb31c1c9a9c7b587"", ""filename"": ""libmspack/test/test_files/kwajd/f72.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f72.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f72.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f72.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""77b1cad948681ac438877f9e46db843207e35508"", ""filename"": ""libmspack/test/test_files/kwajd/f73.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f73.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f73.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f73.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""a760b8e3314b4ac2fc7a5da642df3f1eef197fb7"", ""filename"": ""libmspack/test/test_files/kwajd/f74.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f74.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f74.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f74.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""b2e106f5c1e096ad5edbad2cb9c77dc3b7aca436"", ""filename"": ""libmspack/test/test_files/kwajd/f80.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f80.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f80.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f80.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""6f5bdddcc0dfd09808e5c09c43d084334fb46204"", ""filename"": ""libmspack/test/test_files/kwajd/f81.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f81.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f81.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f81.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""eea7493b144c2fc661c2c23269fde83eb6657d53"", ""filename"": ""libmspack/test/test_files/kwajd/f82.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f82.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f82.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f82.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""161a9408ed4e48f2cba857d3a7abc0799b86bde8"", ""filename"": ""libmspack/test/test_files/kwajd/f83.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f83.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f83.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f83.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""d0e02338cc28e41db5175e1b1576de51abc84f6e"", ""filename"": ""libmspack/test/test_files/kwajd/f84.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f84.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f84.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f84.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""8605aca7a6bd739560b66d460bfb7ea9ad0099fe"", ""filename"": ""libmspack/test/test_files/kwajd/f90.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f90.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f90.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f90.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""2fadfc7abc754e45b2dbdfe86f32cbdc7645eaaf"", ""filename"": ""libmspack/test/test_files/kwajd/f91.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f91.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f91.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f91.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""c8a99ae9c0437b9f64fe07829ddfe828c09176db"", ""filename"": ""libmspack/test/test_files/kwajd/f92.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f92.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f92.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f92.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""559faa9a7e5188b4da9b14fda99d9dfef1ebf8ef"", ""filename"": ""libmspack/test/test_files/kwajd/f93.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f93.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f93.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f93.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""c52dfeb0d929c3838a3d24654a4a009c527b08c7"", ""filename"": ""libmspack/test/test_files/kwajd/f94.kwj"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f94.kwj"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/f94.kwj"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/f94.kwj?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8""}<_**next**_>{""sha"": ""ae73038e25e80433264008d364c92a82313d0cc0"", ""filename"": ""libmspack/test/test_files/kwajd/make.pl"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/kyz/libmspack/blob/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/make.pl"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/0b0ef9344255ff5acfac6b7af09198ac9c9756c8/libmspack/test/test_files/kwajd/make.pl"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/test/test_files/kwajd/make.pl?ref=0b0ef9344255ff5acfac6b7af09198ac9c9756c8"", ""patch"": ""@@ -0,0 +1,17 @@\n+#!/usr/bin/perl -w\n+use strict;\n+my $name = '123456789';\n+for my $file (0 .. 9) {\n+    for my $ext (0 .. 4) {\n+\topen my $fh, '>', \""f$file$ext.kwj\"";\n+        my $offset = 14  + $file + $ext;\n+\tmy $flags  = ($file > 0 ? 8 : 0) | ($ext > 0 ? 16 : 0);\n+\tprint $fh pack 'A4Vvvv', 'KWAJ', 0xD127F088, 0, $offset, $flags;\n+\tprint $fh substr $name, 0, $file if $file > 0;\n+\tprint $fh \""\\0\"" if $file > 0 && $file < 9;\n+\tprint $fh substr $name, 0, $ext if $ext > 0;\n+\tprint $fh \""\\0\"" if $ext > 0 && $ext < 4;\n+        print $fh \""\\xFF\"";\n+\tclose $fh;\n+    }\n+}""}","static int kwajd_read_headers(struct mspack_system *sys,
			      struct mspack_file *fh,
			      struct mskwajd_header *hdr)
{
    unsigned char buf[16];
    int i;

    /* read in the header */
    if (sys->read(fh, &buf[0], kwajh_SIZEOF) != kwajh_SIZEOF) {
	return MSPACK_ERR_READ;
    }

    /* check for ""KWAJ"" signature */
    if (((unsigned int) EndGetI32(&buf[kwajh_Signature1]) != 0x4A41574B) ||
	((unsigned int) EndGetI32(&buf[kwajh_Signature2]) != 0xD127F088))
    {
	return MSPACK_ERR_SIGNATURE;
    }

    /* basic header fields */
    hdr->comp_type    = EndGetI16(&buf[kwajh_CompMethod]);
    hdr->data_offset  = EndGetI16(&buf[kwajh_DataOffset]);
    hdr->headers      = EndGetI16(&buf[kwajh_Flags]);
    hdr->length       = 0;
    hdr->filename     = NULL;
    hdr->extra        = NULL;
    hdr->extra_length = 0;

    /* optional headers */

    /* 4 bytes: length of unpacked file */
    if (hdr->headers & MSKWAJ_HDR_HASLENGTH) {
	if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	hdr->length = EndGetI32(&buf[0]);
    }

    /* 2 bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN1) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
    }

    /* 2 bytes: length of section, then [length] bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN2) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	if (sys->seek(fh, (off_t)i, MSPACK_SYS_SEEK_CUR)) return MSPACK_ERR_SEEK;
    }
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
	int len;
 	/* allocate memory for maximum length filename */
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
	if (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
	    /* read and copy up to 9 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 9 bytes with no null terminator, reject it */
	    if (i == 9 && buf[8] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
	    fn--; /* remove the null terminator */
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
	    /* read and copy up to 4 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 4 bytes with no null terminator, reject it */
	    if (i == 4 && buf[3] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
	    fn--; /* remove the null terminator */
 	}
 	*fn = '\0';
     }

    /* 2 bytes: extra text length then [length] bytes of extra text data */
    if (hdr->headers & MSKWAJ_HDR_HASEXTRATEXT) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	hdr->extra = (char *) sys->alloc(sys, (size_t)i+1);
	if (! hdr->extra) return MSPACK_ERR_NOMEMORY;
	if (sys->read(fh, hdr->extra, i) != i) return MSPACK_ERR_READ;
	hdr->extra[i] = '\0';
	hdr->extra_length = i;
    }
    return MSPACK_ERR_OK;
}
","static int kwajd_read_headers(struct mspack_system *sys,
			      struct mspack_file *fh,
			      struct mskwajd_header *hdr)
{
    unsigned char buf[16];
    int i;

    /* read in the header */
    if (sys->read(fh, &buf[0], kwajh_SIZEOF) != kwajh_SIZEOF) {
	return MSPACK_ERR_READ;
    }

    /* check for ""KWAJ"" signature */
    if (((unsigned int) EndGetI32(&buf[kwajh_Signature1]) != 0x4A41574B) ||
	((unsigned int) EndGetI32(&buf[kwajh_Signature2]) != 0xD127F088))
    {
	return MSPACK_ERR_SIGNATURE;
    }

    /* basic header fields */
    hdr->comp_type    = EndGetI16(&buf[kwajh_CompMethod]);
    hdr->data_offset  = EndGetI16(&buf[kwajh_DataOffset]);
    hdr->headers      = EndGetI16(&buf[kwajh_Flags]);
    hdr->length       = 0;
    hdr->filename     = NULL;
    hdr->extra        = NULL;
    hdr->extra_length = 0;

    /* optional headers */

    /* 4 bytes: length of unpacked file */
    if (hdr->headers & MSKWAJ_HDR_HASLENGTH) {
	if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	hdr->length = EndGetI32(&buf[0]);
    }

    /* 2 bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN1) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
    }

    /* 2 bytes: length of section, then [length] bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN2) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	if (sys->seek(fh, (off_t)i, MSPACK_SYS_SEEK_CUR)) return MSPACK_ERR_SEEK;
    }
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
	off_t pos = sys->tell(fh);
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
 	/* allocate memory for maximum length filename */
	if (! fn) return MSPACK_ERR_NOMEMORY;
	hdr->filename = fn;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
	    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;
	    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 9) ? i+1 : 9;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
 		return MSPACK_ERR_SEEK;
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
	    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 4) ? i+1 : 4;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
 		return MSPACK_ERR_SEEK;
 	}
 	*fn = '\0';
     }

    /* 2 bytes: extra text length then [length] bytes of extra text data */
    if (hdr->headers & MSKWAJ_HDR_HASEXTRATEXT) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	hdr->extra = (char *) sys->alloc(sys, (size_t)i+1);
	if (! hdr->extra) return MSPACK_ERR_NOMEMORY;
	if (sys->read(fh, hdr->extra, i) != i) return MSPACK_ERR_READ;
	hdr->extra[i] = '\0';
	hdr->extra_length = i;
    }
    return MSPACK_ERR_OK;
}
",C,"	int len;
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
	if (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;
	    /* read and copy up to 9 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 9 bytes with no null terminator, reject it */
	    if (i == 9 && buf[8] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
	    fn--; /* remove the null terminator */
	    /* read and copy up to 4 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 4 bytes with no null terminator, reject it */
	    if (i == 4 && buf[3] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
	    fn--; /* remove the null terminator */
","	off_t pos = sys->tell(fh);
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
	if (! fn) return MSPACK_ERR_NOMEMORY;
	hdr->filename = fn;
	    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;
	    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 9) ? i+1 : 9;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
	    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 4) ? i+1 : 4;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
",,"@@ -198,30 +198,36 @@ static int kwajd_read_headers(struct mspack_system *sys,
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
-	off_t pos = sys->tell(fh);
-	char *fn = (char *) sys->alloc(sys, (size_t) 13);
-
+	int len;
 	/* allocate memory for maximum length filename */
-	if (! fn) return MSPACK_ERR_NOMEMORY;
-	hdr->filename = fn;
+	char *fn = (char *) sys->alloc(sys, (size_t) 13);
+	if (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
-	    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;
-	    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;
-	    pos += (i < 9) ? i+1 : 9;
-	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
+	    /* read and copy up to 9 bytes of a null terminated string */
+	    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;
+	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
+	    /* if string was 9 bytes with no null terminator, reject it */
+	    if (i == 9 && buf[8] != '\0') return MSPACK_ERR_DATAFORMAT;
+	    /* seek to byte after string ended in file */
+	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
+	    fn--; /* remove the null terminator */
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
-	    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
-	    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;
-	    pos += (i < 4) ? i+1 : 4;
-	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
+	    /* read and copy up to 4 bytes of a null terminated string */
+	    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;
+	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
+	    /* if string was 4 bytes with no null terminator, reject it */
+	    if (i == 4 && buf[3] != '\0') return MSPACK_ERR_DATAFORMAT;
+	    /* seek to byte after string ended in file */
+	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
+	    fn--; /* remove the null terminator */
 	}
 	*fn = '\0';
     }",libmspack,0b0ef9344255ff5acfac6b7af09198ac9c9756c8,4c004e9e14bdf711d57e547b95e105a7514330b6,1,"static int kwajd_read_headers(struct mspack_system *sys,
			      struct mspack_file *fh,
			      struct mskwajd_header *hdr)
{
    unsigned char buf[16];
    int i;

    /* read in the header */
    if (sys->read(fh, &buf[0], kwajh_SIZEOF) != kwajh_SIZEOF) {
	return MSPACK_ERR_READ;
    }

    /* check for ""KWAJ"" signature */
    if (((unsigned int) EndGetI32(&buf[kwajh_Signature1]) != 0x4A41574B) ||
	((unsigned int) EndGetI32(&buf[kwajh_Signature2]) != 0xD127F088))
    {
	return MSPACK_ERR_SIGNATURE;
    }

    /* basic header fields */
    hdr->comp_type    = EndGetI16(&buf[kwajh_CompMethod]);
    hdr->data_offset  = EndGetI16(&buf[kwajh_DataOffset]);
    hdr->headers      = EndGetI16(&buf[kwajh_Flags]);
    hdr->length       = 0;
    hdr->filename     = NULL;
    hdr->extra        = NULL;
    hdr->extra_length = 0;

    /* optional headers */

    /* 4 bytes: length of unpacked file */
    if (hdr->headers & MSKWAJ_HDR_HASLENGTH) {
	if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	hdr->length = EndGetI32(&buf[0]);
    }

    /* 2 bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN1) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
    }

    /* 2 bytes: length of section, then [length] bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN2) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	if (sys->seek(fh, (off_t)i, MSPACK_SYS_SEEK_CUR)) return MSPACK_ERR_SEEK;
    }
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
//flaw_line_below:
	off_t pos = sys->tell(fh);
//flaw_line_below:
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
//flaw_line_below:

//fix_flaw_line_below:
//	int len;
 	/* allocate memory for maximum length filename */
//flaw_line_below:
	if (! fn) return MSPACK_ERR_NOMEMORY;
//flaw_line_below:
	hdr->filename = fn;
//fix_flaw_line_below:
//	char *fn = (char *) sys->alloc(sys, (size_t) 13);
//fix_flaw_line_below:
//	if (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
//flaw_line_below:
	    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;
//flaw_line_below:
	    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;
//flaw_line_below:
	    pos += (i < 9) ? i+1 : 9;
//flaw_line_below:
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
//fix_flaw_line_below:
//	    /* read and copy up to 9 bytes of a null terminated string */
//fix_flaw_line_below:
//	    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;
//fix_flaw_line_below:
//	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
//fix_flaw_line_below:
//	    /* if string was 9 bytes with no null terminator, reject it */
//fix_flaw_line_below:
//	    if (i == 9 && buf[8] != '\0') return MSPACK_ERR_DATAFORMAT;
//fix_flaw_line_below:
//	    /* seek to byte after string ended in file */
//fix_flaw_line_below:
//	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
//fix_flaw_line_below:
//	    fn--; /* remove the null terminator */
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
//flaw_line_below:
	    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
//flaw_line_below:
	    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;
//flaw_line_below:
	    pos += (i < 4) ? i+1 : 4;
//flaw_line_below:
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
//fix_flaw_line_below:
//	    /* read and copy up to 4 bytes of a null terminated string */
//fix_flaw_line_below:
//	    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;
//fix_flaw_line_below:
//	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
//fix_flaw_line_below:
//	    /* if string was 4 bytes with no null terminator, reject it */
//fix_flaw_line_below:
//	    if (i == 4 && buf[3] != '\0') return MSPACK_ERR_DATAFORMAT;
//fix_flaw_line_below:
//	    /* seek to byte after string ended in file */
//fix_flaw_line_below:
//	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
//fix_flaw_line_below:
//	    fn--; /* remove the null terminator */
 	}
 	*fn = '\0';
     }

    /* 2 bytes: extra text length then [length] bytes of extra text data */
    if (hdr->headers & MSKWAJ_HDR_HASEXTRATEXT) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	hdr->extra = (char *) sys->alloc(sys, (size_t)i+1);
	if (! hdr->extra) return MSPACK_ERR_NOMEMORY;
	if (sys->read(fh, hdr->extra, i) != i) return MSPACK_ERR_READ;
	hdr->extra[i] = '\0';
	hdr->extra_length = i;
    }
    return MSPACK_ERR_OK;
}
",182283,"static int kwajd_read_headers(struct mspack_system *sys,
			      struct mspack_file *fh,
			      struct mskwajd_header *hdr)
{
    unsigned char buf[16];
    int i;

    /* read in the header */
    if (sys->read(fh, &buf[0], kwajh_SIZEOF) != kwajh_SIZEOF) {
	return MSPACK_ERR_READ;
    }

    /* check for ""KWAJ"" signature */
    if (((unsigned int) EndGetI32(&buf[kwajh_Signature1]) != 0x4A41574B) ||
	((unsigned int) EndGetI32(&buf[kwajh_Signature2]) != 0xD127F088))
    {
	return MSPACK_ERR_SIGNATURE;
    }

    /* basic header fields */
    hdr->comp_type    = EndGetI16(&buf[kwajh_CompMethod]);
    hdr->data_offset  = EndGetI16(&buf[kwajh_DataOffset]);
    hdr->headers      = EndGetI16(&buf[kwajh_Flags]);
    hdr->length       = 0;
    hdr->filename     = NULL;
    hdr->extra        = NULL;
    hdr->extra_length = 0;

    /* optional headers */

    /* 4 bytes: length of unpacked file */
    if (hdr->headers & MSKWAJ_HDR_HASLENGTH) {
	if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	hdr->length = EndGetI32(&buf[0]);
    }

    /* 2 bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN1) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
    }

    /* 2 bytes: length of section, then [length] bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN2) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	if (sys->seek(fh, (off_t)i, MSPACK_SYS_SEEK_CUR)) return MSPACK_ERR_SEEK;
    }
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
	off_t pos = sys->tell(fh);
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
 	/* allocate memory for maximum length filename */
	if (! fn) return MSPACK_ERR_NOMEMORY;
	hdr->filename = fn;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
	    if (sys->read(fh, &buf[0], 9) != 9) return MSPACK_ERR_READ;
	    for (i = 0; i < 9; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 9) ? i+1 : 9;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
 		return MSPACK_ERR_SEEK;
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
	    if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	    for (i = 0; i < 4; i++, fn++) if (!(*fn = buf[i])) break;
	    pos += (i < 4) ? i+1 : 4;
	    if (sys->seek(fh, pos, MSPACK_SYS_SEEK_START))
 		return MSPACK_ERR_SEEK;
 	}
 	*fn = '\0';
     }

    /* 2 bytes: extra text length then [length] bytes of extra text data */
    if (hdr->headers & MSKWAJ_HDR_HASEXTRATEXT) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	hdr->extra = (char *) sys->alloc(sys, (size_t)i+1);
	if (! hdr->extra) return MSPACK_ERR_NOMEMORY;
	if (sys->read(fh, hdr->extra, i) != i) return MSPACK_ERR_READ;
	hdr->extra[i] = '\0';
	hdr->extra_length = i;
    }
    return MSPACK_ERR_OK;
}
","static int kwajd_read_headers(struct mspack_system *sys,
			      struct mspack_file *fh,
			      struct mskwajd_header *hdr)
{
    unsigned char buf[16];
    int i;

    /* read in the header */
    if (sys->read(fh, &buf[0], kwajh_SIZEOF) != kwajh_SIZEOF) {
	return MSPACK_ERR_READ;
    }

    /* check for ""KWAJ"" signature */
    if (((unsigned int) EndGetI32(&buf[kwajh_Signature1]) != 0x4A41574B) ||
	((unsigned int) EndGetI32(&buf[kwajh_Signature2]) != 0xD127F088))
    {
	return MSPACK_ERR_SIGNATURE;
    }

    /* basic header fields */
    hdr->comp_type    = EndGetI16(&buf[kwajh_CompMethod]);
    hdr->data_offset  = EndGetI16(&buf[kwajh_DataOffset]);
    hdr->headers      = EndGetI16(&buf[kwajh_Flags]);
    hdr->length       = 0;
    hdr->filename     = NULL;
    hdr->extra        = NULL;
    hdr->extra_length = 0;

    /* optional headers */

    /* 4 bytes: length of unpacked file */
    if (hdr->headers & MSKWAJ_HDR_HASLENGTH) {
	if (sys->read(fh, &buf[0], 4) != 4) return MSPACK_ERR_READ;
	hdr->length = EndGetI32(&buf[0]);
    }

    /* 2 bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN1) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
    }

    /* 2 bytes: length of section, then [length] bytes: unknown purpose */
    if (hdr->headers & MSKWAJ_HDR_HASUNKNOWN2) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	if (sys->seek(fh, (off_t)i, MSPACK_SYS_SEEK_CUR)) return MSPACK_ERR_SEEK;
    }
 
     /* filename and extension */
     if (hdr->headers & (MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT)) {
	int len;
 	/* allocate memory for maximum length filename */
	char *fn = (char *) sys->alloc(sys, (size_t) 13);
	if (!(hdr->filename = fn)) return MSPACK_ERR_NOMEMORY;
 
 	/* copy filename if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILENAME) {
	    /* read and copy up to 9 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 9)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 9 bytes with no null terminator, reject it */
	    if (i == 9 && buf[8] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
	    fn--; /* remove the null terminator */
 	}
 
 	/* copy extension if present */
 	if (hdr->headers & MSKWAJ_HDR_HASFILEEXT) {
 	    *fn++ = '.';
	    /* read and copy up to 4 bytes of a null terminated string */
	    if ((len = sys->read(fh, &buf[0], 4)) < 2) return MSPACK_ERR_READ;
	    for (i = 0; i < len; i++) if (!(*fn++ = buf[i])) break;
	    /* if string was 4 bytes with no null terminator, reject it */
	    if (i == 4 && buf[3] != '\0') return MSPACK_ERR_DATAFORMAT;
	    /* seek to byte after string ended in file */
	    if (sys->seek(fh, (off_t)(i + 1 - len), MSPACK_SYS_SEEK_CUR))
 		return MSPACK_ERR_SEEK;
	    fn--; /* remove the null terminator */
 	}
 	*fn = '\0';
     }

    /* 2 bytes: extra text length then [length] bytes of extra text data */
    if (hdr->headers & MSKWAJ_HDR_HASEXTRATEXT) {
	if (sys->read(fh, &buf[0], 2) != 2) return MSPACK_ERR_READ;
	i = EndGetI16(&buf[0]);
	hdr->extra = (char *) sys->alloc(sys, (size_t)i+1);
	if (! hdr->extra) return MSPACK_ERR_NOMEMORY;
	if (sys->read(fh, hdr->extra, i) != i) return MSPACK_ERR_READ;
	hdr->extra[i] = '\0';
	hdr->extra_length = i;
    }
    return MSPACK_ERR_OK;
}
","The vulnerability in the original code lies in the handling of filename and extension reading, where it assumes that the strings are always null-terminated. This can lead to buffer overflows or reading beyond allocated memory if the strings are not properly terminated, potentially causing undefined behavior. The fixed code addresses this by checking the length of the read data using the `len` variable and ensuring that if the filename or extension is exactly 9 or 4 bytes long, respectively, it verifies the last byte is a null terminator. If not, it returns `MSPACK_ERR_DATAFORMAT`, thus preventing potential vulnerabilities.","The vulnerability in the original code stems from the assumption that the filename and extension strings are always null-terminated, which can lead to buffer overflows or reading beyond allocated memory if this condition is not met. This oversight could result in undefined behavior or memory corruption. The revised code mitigates this risk by checking the length of the read data and ensuring that if the strings are at their maximum expected lengths, the last character is indeed a null terminator. If the condition is not satisfied, the code returns an error, thereby enhancing the robustness and security of the implementation.",3,5,4,4
28,28,182387,182387,,Remote,Not required,Partial,CVE-2018-11593,https://www.cvedetails.com/cve/CVE-2018-11593/,CWE-787,Medium,Partial,,,2018-05-31,5.8,Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c.,2019-10-02,DoS Overflow ,14,https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018,bed844f109b6c222816740555068de2e101e8018,"remove strncpy usage as it's effectively useless, replace with an assertion since fn is only used internally (fix #1426)",13,src/jslex.c,"{""sha"": ""c3e90d5cb72d78ecd38dcc5200b931357436efd1"", ""filename"": ""src/jslex.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 13, ""changes"": 27, ""blob_url"": ""https://github.com/espruino/Espruino/blob/bed844f109b6c222816740555068de2e101e8018/src/jslex.c"", ""raw_url"": ""https://github.com/espruino/Espruino/raw/bed844f109b6c222816740555068de2e101e8018/src/jslex.c"", ""contents_url"": ""https://api.github.com/repos/espruino/Espruino/contents/src/jslex.c?ref=bed844f109b6c222816740555068de2e101e8018"", ""patch"": ""@@ -713,6 +713,7 @@ void jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {\n }\n \n void jslTokenAsString(int token, char *str, size_t len) {\n+  assert(len>28); // size of largest string\n   // see JS_ERROR_TOKEN_BUF_SIZE\n   if (token>32 && token<128) {\n     assert(len>=4);\n@@ -723,18 +724,19 @@ void jslTokenAsString(int token, char *str, size_t len) {\n     return;\n   }\n \n+\n   switch (token) {\n-  case LEX_EOF : strncpy(str, \""EOF\"", len); return;\n-  case LEX_ID : strncpy(str, \""ID\"", len); return;\n-  case LEX_INT : strncpy(str, \""INT\"", len); return;\n-  case LEX_FLOAT : strncpy(str, \""FLOAT\"", len); return;\n-  case LEX_STR : strncpy(str, \""STRING\"", len); return;\n-  case LEX_UNFINISHED_STR : strncpy(str, \""UNFINISHED STRING\"", len); return;\n-  case LEX_TEMPLATE_LITERAL : strncpy(str, \""TEMPLATE LITERAL\"", len); return;\n-  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \""UNFINISHED TEMPLATE LITERAL\"", len); return;\n-  case LEX_REGEX : strncpy(str, \""REGEX\"", len); return;\n-  case LEX_UNFINISHED_REGEX : strncpy(str, \""UNFINISHED REGEX\"", len); return;\n-  case LEX_UNFINISHED_COMMENT : strncpy(str, \""UNFINISHED COMMENT\"", len); return;\n+  case LEX_EOF : strcpy(str, \""EOF\""); return;\n+  case LEX_ID : strcpy(str, \""ID\""); return;\n+  case LEX_INT : strcpy(str, \""INT\""); return;\n+  case LEX_FLOAT : strcpy(str, \""FLOAT\""); return;\n+  case LEX_STR : strcpy(str, \""STRING\""); return;\n+  case LEX_UNFINISHED_STR : strcpy(str, \""UNFINISHED STRING\""); return;\n+  case LEX_TEMPLATE_LITERAL : strcpy(str, \""TEMPLATE LITERAL\""); return;\n+  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, \""UNFINISHED TEMPLATE LITERAL\""); return;\n+  case LEX_REGEX : strcpy(str, \""REGEX\""); return;\n+  case LEX_UNFINISHED_REGEX : strcpy(str, \""UNFINISHED REGEX\""); return;\n+  case LEX_UNFINISHED_COMMENT : strcpy(str, \""UNFINISHED COMMENT\""); return;\n   }\n   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {\n     const char tokenNames[] =\n@@ -809,11 +811,10 @@ void jslTokenAsString(int token, char *str, size_t len) {\n       n--; // next token\n     }\n     assert(n==0);\n-    strncpy(str, &tokenNames[p], len);\n+    strcpy(str, &tokenNames[p]);\n     return;\n   }\n \n-  assert(len>=10);\n   espruino_snprintf(str, len, \""?[%d]\"", token);\n }\n ""}"," void jslTokenAsString(int token, char *str, size_t len) {
  assert(len>28); // size of largest string
   if (token>32 && token<128) {
     assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
     return;
   }
 

   switch (token) {
  case LEX_EOF : strcpy(str, ""EOF""); return;
  case LEX_ID : strcpy(str, ""ID""); return;
  case LEX_INT : strcpy(str, ""INT""); return;
  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
  case LEX_STR : strcpy(str, ""STRING""); return;
  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
  case LEX_REGEX : strcpy(str, ""REGEX""); return;
  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
       n--; // next token
     }
     assert(n==0);
    strcpy(str, &tokenNames[p]);
     return;
   }
 
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
"," void jslTokenAsString(int token, char *str, size_t len) {
   if (token>32 && token<128) {
     assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
     return;
   }
 
   switch (token) {
  case LEX_EOF : strncpy(str, ""EOF"", len); return;
  case LEX_ID : strncpy(str, ""ID"", len); return;
  case LEX_INT : strncpy(str, ""INT"", len); return;
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
  case LEX_STR : strncpy(str, ""STRING"", len); return;
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
       n--; // next token
     }
     assert(n==0);
    strncpy(str, &tokenNames[p], len);
     return;
   }
 
  assert(len>=10);
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
",C,"  assert(len>28); // size of largest string

  case LEX_EOF : strcpy(str, ""EOF""); return;
  case LEX_ID : strcpy(str, ""ID""); return;
  case LEX_INT : strcpy(str, ""INT""); return;
  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
  case LEX_STR : strcpy(str, ""STRING""); return;
  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
  case LEX_REGEX : strcpy(str, ""REGEX""); return;
  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
    strcpy(str, &tokenNames[p]);
","  case LEX_EOF : strncpy(str, ""EOF"", len); return;
  case LEX_ID : strncpy(str, ""ID"", len); return;
  case LEX_INT : strncpy(str, ""INT"", len); return;
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
  case LEX_STR : strncpy(str, ""STRING"", len); return;
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
    strncpy(str, &tokenNames[p], len);
  assert(len>=10);
",,"@@ -713,6 +713,7 @@ void jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {
 }
 
 void jslTokenAsString(int token, char *str, size_t len) {
+  assert(len>28); // size of largest string
   // see JS_ERROR_TOKEN_BUF_SIZE
   if (token>32 && token<128) {
     assert(len>=4);
@@ -723,18 +724,19 @@ void jslTokenAsString(int token, char *str, size_t len) {
     return;
   }
 
+
   switch (token) {
-  case LEX_EOF : strncpy(str, ""EOF"", len); return;
-  case LEX_ID : strncpy(str, ""ID"", len); return;
-  case LEX_INT : strncpy(str, ""INT"", len); return;
-  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
-  case LEX_STR : strncpy(str, ""STRING"", len); return;
-  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
-  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
-  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
-  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
-  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
-  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
+  case LEX_EOF : strcpy(str, ""EOF""); return;
+  case LEX_ID : strcpy(str, ""ID""); return;
+  case LEX_INT : strcpy(str, ""INT""); return;
+  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
+  case LEX_STR : strcpy(str, ""STRING""); return;
+  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
+  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
+  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
+  case LEX_REGEX : strcpy(str, ""REGEX""); return;
+  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
+  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
@@ -809,11 +811,10 @@ void jslTokenAsString(int token, char *str, size_t len) {
       n--; // next token
     }
     assert(n==0);
-    strncpy(str, &tokenNames[p], len);
+    strcpy(str, &tokenNames[p]);
     return;
   }
 
-  assert(len>=10);
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
 ",Espruino,bed844f109b6c222816740555068de2e101e8018,0a7619875bf79877907205f6bee08465b89ff10b,1," void jslTokenAsString(int token, char *str, size_t len) {
//fix_flaw_line_below:
//  assert(len>28); // size of largest string
   // see JS_ERROR_TOKEN_BUF_SIZE
   if (token>32 && token<128) {
     assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
     return;
   }
 
//fix_flaw_line_below:
//
   switch (token) {
//flaw_line_below:
  case LEX_EOF : strncpy(str, ""EOF"", len); return;
//flaw_line_below:
  case LEX_ID : strncpy(str, ""ID"", len); return;
//flaw_line_below:
  case LEX_INT : strncpy(str, ""INT"", len); return;
//flaw_line_below:
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
//flaw_line_below:
  case LEX_STR : strncpy(str, ""STRING"", len); return;
//flaw_line_below:
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
//flaw_line_below:
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
//flaw_line_below:
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
//flaw_line_below:
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
//flaw_line_below:
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
//flaw_line_below:
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
//fix_flaw_line_below:
//  case LEX_EOF : strcpy(str, ""EOF""); return;
//fix_flaw_line_below:
//  case LEX_ID : strcpy(str, ""ID""); return;
//fix_flaw_line_below:
//  case LEX_INT : strcpy(str, ""INT""); return;
//fix_flaw_line_below:
//  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
//fix_flaw_line_below:
//  case LEX_STR : strcpy(str, ""STRING""); return;
//fix_flaw_line_below:
//  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
//fix_flaw_line_below:
//  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
//fix_flaw_line_below:
//  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
//fix_flaw_line_below:
//  case LEX_REGEX : strcpy(str, ""REGEX""); return;
//fix_flaw_line_below:
//  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
//fix_flaw_line_below:
//  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        // reserved words
        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
       n--; // next token
     }
     assert(n==0);
//flaw_line_below:
    strncpy(str, &tokenNames[p], len);
//fix_flaw_line_below:
//    strcpy(str, &tokenNames[p]);
     return;
   }
 
//flaw_line_below:
  assert(len>=10);
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
",182387,"void jslTokenAsString(int token, char *str, size_t len) {
  // see JS_ERROR_TOKEN_BUF_SIZE
  if (token>32 && token<128) {
    assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
    return;
  }

  switch (token) {
  case LEX_EOF : strncpy(str, ""EOF"", len); return;
  case LEX_ID : strncpy(str, ""ID"", len); return;
  case LEX_INT : strncpy(str, ""INT"", len); return;
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
  case LEX_STR : strncpy(str, ""STRING"", len); return;
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
  }
  if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
    const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        // reserved words
        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
      n--; // next token
    }
    assert(n==0);
    strncpy(str, &tokenNames[p], len);
    return;
  }

  assert(len>=10);
  espruino_snprintf(str, len, ""?[%d]"", token);
}"," void jslTokenAsString(int token, char *str, size_t len) {
  assert(len>28); // size of largest string
   if (token>32 && token<128) {
     assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
     return;
   }
 

   switch (token) {
  case LEX_EOF : strcpy(str, ""EOF""); return;
  case LEX_ID : strcpy(str, ""ID""); return;
  case LEX_INT : strcpy(str, ""INT""); return;
  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
  case LEX_STR : strcpy(str, ""STRING""); return;
  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
  case LEX_REGEX : strcpy(str, ""REGEX""); return;
  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
       n--; // next token
     }
     assert(n==0);
    strcpy(str, &tokenNames[p]);
     return;
   }
 
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
","The vulnerability in the original code lies in the use of `strncpy` without ensuring that the destination buffer `str` is large enough to hold the copied string, potentially leading to buffer overflows. For instance, when handling tokens like `LEX_UNFINISHED_STR`, the function could write more characters than `len` allows. The fix in the updated code replaces `strncpy` with `strcpy`, which simplifies the copying process, but more importantly, it adds an initial assertion `assert(len>28)` to ensure that the buffer is sufficiently large to accommodate the largest string, thus preventing buffer overflow vulnerabilities.","The vulnerability in the original code stems from inadequate checks on the buffer size before copying strings, which can lead to buffer overflows if the destination buffer is not large enough to hold the copied data. This oversight allows for potential memory corruption or crashes, as the function does not ensure that the length of the input string does not exceed the allocated space. The revised code addresses this issue by introducing a check to confirm that the buffer is sufficiently large before any copying occurs, thereby enhancing the safety and stability of the function by preventing overflow scenarios.",4,5,4,4
29,29,182421,182421,,Remote,Not required,Partial,CVE-2018-10540,https://www.cvedetails.com/cve/CVE-2018-10540/,CWE-787,Medium,,,,2018-04-29,4.3,"An issue was discovered in WavPack 5.1.0 and earlier for W64 input. Out-of-bounds writes can occur because ParseWave64HeaderConfig in wave64.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.",2018-06-13,Overflow ,8,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,"issue #33, sanitize size of unknown chunks before malloc()",1,cli/dsdiff.c,"{""sha"": ""fa56bbb686b5b11b3d8e960868e241a2866123a6"", ""filename"": ""cli/dsdiff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/dsdiff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -279,7 +279,14 @@ int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .DFF file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""7bddf634935f9bd51b2c1673fd8fe9eadcf72ac3"", ""filename"": ""cli/riff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/riff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -286,7 +286,14 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .WAV file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""fa928a0d544e6fe6379ac63151cbb43fa5635164"", ""filename"": ""cli/wave64.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/wave64.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -241,7 +241,14 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         }\n         else {          // just copy unknown chunks to output file\n             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .W64 file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif


    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels, chansSpecified, chanMask = 0;
                uint32_t sampleRate;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif


    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels, chansSpecified, chanMask = 0;
                uint32_t sampleRate;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",C,"            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
","            char *buff = malloc (bytes_to_copy);
",,"@@ -279,7 +279,14 @@ int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
-            char *buff = malloc (bytes_to_copy);
+            char *buff;
+
+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
+                error_line (""%s is not a valid .DFF file!"", infilename);
+                return WAVPACK_SOFT_ERROR;
+            }
+
+            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",",WavPack,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,0a72951de8feaaf4c6e1740b5cb5cd0401b00464,1,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif

    // loop through all elements of the DSDIFF header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels, chansSpecified, chanMask = 0;
                uint32_t sampleRate;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
//flaw_line_below:
            char *buff = malloc (bytes_to_copy);
//fix_flaw_line_below:
//            char *buff;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
//fix_flaw_line_below:
//                error_line (""%s is not a valid .DFF file!"", infilename);
//fix_flaw_line_below:
//                return WAVPACK_SOFT_ERROR;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",182421,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif

    // loop through all elements of the DSDIFF header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels, chansSpecified, chanMask = 0;
                uint32_t sampleRate;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
        else {          // just copy unknown chunks to output file

            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t infilesize, total_samples;
    DFFFileHeader dff_file_header;
    DFFChunkHeader dff_chunk_header;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&dff_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||
        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) {
            error_line (""%s is not a valid .DFF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {
            error_line (""%s is not a valid .DFF file (by total size)!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }

    if (debug_logging_mode)
        error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize);

#endif


    while (1) {
        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||
            bcount != sizeof (DFFChunkHeader)) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

        if (debug_logging_mode)
            error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize);

        if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) {
            uint32_t version;

            if (dff_chunk_header.ckDataSize != sizeof (version) ||
                !DoReadFile (infile, &version, sizeof (version), &bcount) ||
                bcount != sizeof (version)) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &version, sizeof (version))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&version, ""L"");

            if (debug_logging_mode)
                error_line (""dsdiff file version = 0x%08x"", version);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                bcount != dff_chunk_header.ckDataSize) {
                    error_line (""%s is not a valid .DFF file!"", infilename);
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
            }

            if (!strncmp (prop_chunk, ""SND "", 4)) {
                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels, chansSpecified, chanMask = 0;
                uint32_t sampleRate;

                while (eptr - cptr >= sizeof (dff_chunk_header)) {
                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
                    cptr += sizeof (dff_chunk_header);
                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);

                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {
                        if (!strncmp (dff_chunk_header.ckID, ""FS  "", 4) && dff_chunk_header.ckDataSize == 4) {
                            memcpy (&sampleRate, cptr, sizeof (sampleRate));
                            WavpackBigEndianToNative (&sampleRate, ""L"");
                            cptr += dff_chunk_header.ckDataSize;

                            if (debug_logging_mode)
                                error_line (""got sample rate of %u Hz"", sampleRate);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) {
                            memcpy (&numChannels, cptr, sizeof (numChannels));
                            WavpackBigEndianToNative (&numChannels, ""S"");
                            cptr += sizeof (numChannels);

                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;

                            while (chansSpecified--) {
                                if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4))
                                    chanMask |= 0x1;
                                else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4))
                                    chanMask |= 0x2;
                                else if (!strncmp (cptr, ""LS  "", 4))
                                    chanMask |= 0x10;
                                else if (!strncmp (cptr, ""RS  "", 4))
                                    chanMask |= 0x20;
                                else if (!strncmp (cptr, ""C   "", 4))
                                    chanMask |= 0x4;
                                else if (!strncmp (cptr, ""LFE "", 4))
                                    chanMask |= 0x8;
                                else
                                    if (debug_logging_mode)
                                        error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]);

                                cptr += 4;
                            }

                            if (debug_logging_mode)
                                error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask);
                        }
                        else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) {
                            if (strncmp (cptr, ""DSD "", 4)) {
                                error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"",
                                    cptr [0], cptr [1], cptr [2], cptr [3]);
                                free (prop_chunk);
                                return WAVPACK_SOFT_ERROR;
                            }

                            cptr += dff_chunk_header.ckDataSize;
                        }
                        else {
                            if (debug_logging_mode)
                                error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0],
                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

                            cptr += dff_chunk_header.ckDataSize;
                        }
                    }
                    else {
                        error_line (""%s is not a valid .DFF file!"", infilename);
                        free (prop_chunk);
                        return WAVPACK_SOFT_ERROR;
                    }
                }

                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                    error_line (""this DSDIFF file already has channel order information!"");
                    free (prop_chunk);
                    return WAVPACK_SOFT_ERROR;
                }
                else if (chanMask)
                    config->channel_mask = chanMask;

                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->num_channels = numChannels;
                config->sample_rate = sampleRate / 8;
                config->qmode |= QMODE_DSD_MSB_FIRST;
            }
            else if (debug_logging_mode)
                error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"",
                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);

            free (prop_chunk);
        }
        else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
            total_samples = dff_chunk_header.ckDataSize / config->num_channels;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],
                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (debug_logging_mode)
        error_line (""setting configuration with %lld samples"", total_samples);

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","The vulnerability in the original code lies in the handling of the `bytes_to_copy` variable when copying unknown chunks. Specifically, the code does not validate the size of `dff_chunk_header.ckDataSize`, which could lead to a negative or excessively large value being assigned to `bytes_to_copy`. This could result in a buffer overflow or memory allocation failure when `malloc` is called. The fixed code addresses this vulnerability by adding a check to ensure that `bytes_to_copy` is non-negative and does not exceed a maximum limit of 4,194,304 bytes, thus preventing potential memory-related issues.","The vulnerability in the original code arises from inadequate validation of the size of data being processed, particularly when reading unknown chunks. This oversight allows for the possibility of negative or excessively large sizes being used, which could lead to buffer overflows or memory allocation failures, potentially causing crashes or security exploits. The revised code mitigates this risk by implementing checks to ensure that the size is non-negative and does not exceed a predefined maximum limit. This enhancement effectively prevents memory-related issues and enhances the overall robustness of the code.",3,5,4,4
30,30,182422,182422,,Remote,Not required,Partial,CVE-2018-10540,https://www.cvedetails.com/cve/CVE-2018-10540/,CWE-787,Medium,,,,2018-04-29,4.3,"An issue was discovered in WavPack 5.1.0 and earlier for W64 input. Out-of-bounds writes can occur because ParseWave64HeaderConfig in wave64.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.",2018-06-13,Overflow ,8,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,"issue #33, sanitize size of unknown chunks before malloc()",1,cli/riff.c,"{""sha"": ""fa56bbb686b5b11b3d8e960868e241a2866123a6"", ""filename"": ""cli/dsdiff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/dsdiff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -279,7 +279,14 @@ int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .DFF file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""7bddf634935f9bd51b2c1673fd8fe9eadcf72ac3"", ""filename"": ""cli/riff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/riff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -286,7 +286,14 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .WAV file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""fa928a0d544e6fe6379ac63151cbb43fa5635164"", ""filename"": ""cli/wave64.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/wave64.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -241,7 +241,14 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         }\n         else {          // just copy unknown chunks to output file\n             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .W64 file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}","int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0;
    int64_t total_samples = 0, infilesize;
    RiffChunkHeader riff_chunk_header;
    ChunkHeader chunk_header;
    WaveHeader WaveHeader;
    DS64Chunk ds64_chunk;
    uint32_t bcount;

    CLEAR (WaveHeader);
    CLEAR (ds64_chunk);
    infilesize = DoGetFileSize (infile);

    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {
        error_line (""can't handle .WAV files larger than 4 GB (non-standard)!"");
        return WAVPACK_SOFT_ERROR;
    }

    memcpy (&riff_chunk_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) {
            error_line (""%s is not a valid .WAV file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||
            bcount != sizeof (ChunkHeader)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);

        if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
            if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            got_ds64 = 1;
            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);

            if (debug_logging_mode)
                error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"",
                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,
                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);

            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            while (ds64_chunk.tableLength--) {
                CS64Chunk cs64_chunk;
                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||
                    bcount != sizeof (CS64Chunk) ||
                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {
                        error_line (""%s"", WavpackGetErrorMessage (wpc));
                        return WAVPACK_SOFT_ERROR;
                }
            }
        }
        else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {     // if it's the format chunk, we want to get some info out of there and
            int supported = TRUE, format;                        // make sure it's a .wav file we can handle

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .WAV format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this WAV file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else if (config->float_norm_exp)
                    error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"",
                        config->float_norm_exp - 126, 150 - config->float_norm_exp);
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!strncmp (chunk_header.ckID, ""data"", 4)) {             // on the data chunk, get size and exit loop

            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?
                ds64_chunk.dataSize64 : chunk_header.ckSize;


            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw ""fmt"" and ""ds64"" chunks (if required)
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {
                error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (config->qmode & QMODE_IGNORE_LENGTH) {
                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                total_samples = data_chunk_size / WaveHeader.BlockAlign;

                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if (!total_samples) {
                    error_line (""this .WAV file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0;
    int64_t total_samples = 0, infilesize;
    RiffChunkHeader riff_chunk_header;
    ChunkHeader chunk_header;
    WaveHeader WaveHeader;
    DS64Chunk ds64_chunk;
    uint32_t bcount;

    CLEAR (WaveHeader);
    CLEAR (ds64_chunk);
    infilesize = DoGetFileSize (infile);

    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {
        error_line (""can't handle .WAV files larger than 4 GB (non-standard)!"");
        return WAVPACK_SOFT_ERROR;
    }

    memcpy (&riff_chunk_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) {
            error_line (""%s is not a valid .WAV file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||
            bcount != sizeof (ChunkHeader)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);

        if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
            if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            got_ds64 = 1;
            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);

            if (debug_logging_mode)
                error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"",
                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,
                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);

            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            while (ds64_chunk.tableLength--) {
                CS64Chunk cs64_chunk;
                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||
                    bcount != sizeof (CS64Chunk) ||
                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {
                        error_line (""%s"", WavpackGetErrorMessage (wpc));
                        return WAVPACK_SOFT_ERROR;
                }
            }
        }
        else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {     // if it's the format chunk, we want to get some info out of there and
            int supported = TRUE, format;                        // make sure it's a .wav file we can handle

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .WAV format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this WAV file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else if (config->float_norm_exp)
                    error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"",
                        config->float_norm_exp - 126, 150 - config->float_norm_exp);
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!strncmp (chunk_header.ckID, ""data"", 4)) {             // on the data chunk, get size and exit loop

            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?
                ds64_chunk.dataSize64 : chunk_header.ckSize;


            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw ""fmt"" and ""ds64"" chunks (if required)
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {
                error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (config->qmode & QMODE_IGNORE_LENGTH) {
                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                total_samples = data_chunk_size / WaveHeader.BlockAlign;

                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if (!total_samples) {
                    error_line (""this .WAV file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
            char *buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",C,"            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
","            char *buff = malloc (bytes_to_copy);
",,"@@ -286,7 +286,14 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
-            char *buff = malloc (bytes_to_copy);
+            char *buff;
+
+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
+                error_line (""%s is not a valid .WAV file!"", infilename);
+                return WAVPACK_SOFT_ERROR;
+            }
+
+            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",",WavPack,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,0a72951de8feaaf4c6e1740b5cb5cd0401b00464,1,"int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0;
    int64_t total_samples = 0, infilesize;
    RiffChunkHeader riff_chunk_header;
    ChunkHeader chunk_header;
    WaveHeader WaveHeader;
    DS64Chunk ds64_chunk;
    uint32_t bcount;

    CLEAR (WaveHeader);
    CLEAR (ds64_chunk);
    infilesize = DoGetFileSize (infile);

    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {
        error_line (""can't handle .WAV files larger than 4 GB (non-standard)!"");
        return WAVPACK_SOFT_ERROR;
    }

    memcpy (&riff_chunk_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) {
            error_line (""%s is not a valid .WAV file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    // loop through all elements of the RIFF wav header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||
            bcount != sizeof (ChunkHeader)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);

        if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
            if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            got_ds64 = 1;
            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);

            if (debug_logging_mode)
                error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"",
                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,
                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);

            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            while (ds64_chunk.tableLength--) {
                CS64Chunk cs64_chunk;
                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||
                    bcount != sizeof (CS64Chunk) ||
                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {
                        error_line (""%s"", WavpackGetErrorMessage (wpc));
                        return WAVPACK_SOFT_ERROR;
                }
            }
        }
        else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {     // if it's the format chunk, we want to get some info out of there and
            int supported = TRUE, format;                        // make sure it's a .wav file we can handle

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .WAV format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this WAV file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else if (config->float_norm_exp)
                    error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"",
                        config->float_norm_exp - 126, 150 - config->float_norm_exp);
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!strncmp (chunk_header.ckID, ""data"", 4)) {             // on the data chunk, get size and exit loop

            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?
                ds64_chunk.dataSize64 : chunk_header.ckSize;


            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw ""fmt"" and ""ds64"" chunks (if required)
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {
                error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (config->qmode & QMODE_IGNORE_LENGTH) {
                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                total_samples = data_chunk_size / WaveHeader.BlockAlign;

                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if (!total_samples) {
                    error_line (""this .WAV file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
//flaw_line_below:
            char *buff = malloc (bytes_to_copy);
//fix_flaw_line_below:
//            char *buff;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
//fix_flaw_line_below:
//                error_line (""%s is not a valid .WAV file!"", infilename);
//fix_flaw_line_below:
//                return WAVPACK_SOFT_ERROR;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",182422,"int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0;
    int64_t total_samples = 0, infilesize;
    RiffChunkHeader riff_chunk_header;
    ChunkHeader chunk_header;
    WaveHeader WaveHeader;
    DS64Chunk ds64_chunk;
    uint32_t bcount;

    CLEAR (WaveHeader);
    CLEAR (ds64_chunk);
    infilesize = DoGetFileSize (infile);

    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {
        error_line (""can't handle .WAV files larger than 4 GB (non-standard)!"");
        return WAVPACK_SOFT_ERROR;
    }

    memcpy (&riff_chunk_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) {
            error_line (""%s is not a valid .WAV file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    // loop through all elements of the RIFF wav header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||
            bcount != sizeof (ChunkHeader)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);

        if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
            if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            got_ds64 = 1;
            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);

            if (debug_logging_mode)
                error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"",
                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,
                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);

            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            while (ds64_chunk.tableLength--) {
                CS64Chunk cs64_chunk;
                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||
                    bcount != sizeof (CS64Chunk) ||
                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {
                        error_line (""%s"", WavpackGetErrorMessage (wpc));
                        return WAVPACK_SOFT_ERROR;
                }
            }
        }
        else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {     // if it's the format chunk, we want to get some info out of there and
            int supported = TRUE, format;                        // make sure it's a .wav file we can handle

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .WAV format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this WAV file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else if (config->float_norm_exp)
                    error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"",
                        config->float_norm_exp - 126, 150 - config->float_norm_exp);
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!strncmp (chunk_header.ckID, ""data"", 4)) {             // on the data chunk, get size and exit loop

            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?
                ds64_chunk.dataSize64 : chunk_header.ckSize;


            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw ""fmt"" and ""ds64"" chunks (if required)
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {
                error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (config->qmode & QMODE_IGNORE_LENGTH) {
                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                total_samples = data_chunk_size / WaveHeader.BlockAlign;

                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if (!total_samples) {
                    error_line (""this .WAV file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file

            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
            char *buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}","int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0;
    int64_t total_samples = 0, infilesize;
    RiffChunkHeader riff_chunk_header;
    ChunkHeader chunk_header;
    WaveHeader WaveHeader;
    DS64Chunk ds64_chunk;
    uint32_t bcount;

    CLEAR (WaveHeader);
    CLEAR (ds64_chunk);
    infilesize = DoGetFileSize (infile);

    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {
        error_line (""can't handle .WAV files larger than 4 GB (non-standard)!"");
        return WAVPACK_SOFT_ERROR;
    }

    memcpy (&riff_chunk_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) {
            error_line (""%s is not a valid .WAV file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||
            bcount != sizeof (ChunkHeader)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);

        if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
            if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            got_ds64 = 1;
            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);

            if (debug_logging_mode)
                error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"",
                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,
                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);

            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            while (ds64_chunk.tableLength--) {
                CS64Chunk cs64_chunk;
                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||
                    bcount != sizeof (CS64Chunk) ||
                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {
                        error_line (""%s"", WavpackGetErrorMessage (wpc));
                        return WAVPACK_SOFT_ERROR;
                }
            }
        }
        else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {     // if it's the format chunk, we want to get some info out of there and
            int supported = TRUE, format;                        // make sure it's a .wav file we can handle

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .WAV format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this WAV file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else if (config->float_norm_exp)
                    error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"",
                        config->float_norm_exp - 126, 150 - config->float_norm_exp);
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!strncmp (chunk_header.ckID, ""data"", 4)) {             // on the data chunk, get size and exit loop

            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?
                ds64_chunk.dataSize64 : chunk_header.ckSize;


            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw ""fmt"" and ""ds64"" chunks (if required)
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {
                error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (config->qmode & QMODE_IGNORE_LENGTH) {
                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                total_samples = data_chunk_size / WaveHeader.BlockAlign;

                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {
                    error_line (""%s is not a valid .WAV file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if (!total_samples) {
                    error_line (""this .WAV file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
         else {          // just copy unknown chunks to output file
 
             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","The vulnerability in the original code lies in the handling of unknown chunks, specifically in the allocation of memory for `buff` without validating the size of `bytes_to_copy`. If `chunk_header.ckSize` is negative or exceeds a certain limit, it could lead to a buffer overflow or memory allocation failure. The fixed code addresses this vulnerability by adding a check for `bytes_to_copy` to ensure it is within a valid range (greater than 0 and less than or equal to 4,194,304). This prevents potential exploitation through malformed WAV files that could cause memory corruption or crashes.","The vulnerability in the original code stems from inadequate validation of the size of data being processed, particularly when handling unknown chunks. This oversight allows for the possibility of buffer overflows or memory allocation failures if the size exceeds expected limits or is negative. The revised code mitigates this risk by implementing a check to ensure that the size is within a safe range before proceeding with memory allocation. This enhancement effectively prevents potential exploitation through malformed input, thereby improving the overall robustness and security of the code.",4,5,4,4
31,31,182423,182423,,Remote,Not required,Partial,CVE-2018-10540,https://www.cvedetails.com/cve/CVE-2018-10540/,CWE-787,Medium,,,,2018-04-29,4.3,"An issue was discovered in WavPack 5.1.0 and earlier for W64 input. Out-of-bounds writes can occur because ParseWave64HeaderConfig in wave64.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.",2018-06-13,Overflow ,8,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,"issue #33, sanitize size of unknown chunks before malloc()",1,cli/wave64.c,"{""sha"": ""fa56bbb686b5b11b3d8e960868e241a2866123a6"", ""filename"": ""cli/dsdiff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/dsdiff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/dsdiff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -279,7 +279,14 @@ int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .DFF file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""7bddf634935f9bd51b2c1673fd8fe9eadcf72ac3"", ""filename"": ""cli/riff.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/riff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/riff.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -286,7 +286,14 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .WAV file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}<_**next**_>{""sha"": ""fa928a0d544e6fe6379ac63151cbb43fa5635164"", ""filename"": ""cli/wave64.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/dbry/WavPack/blob/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d/cli/wave64.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/wave64.c?ref=6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"", ""patch"": ""@@ -241,7 +241,14 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n         }\n         else {          // just copy unknown chunks to output file\n             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n-            char *buff = malloc (bytes_to_copy);\n+            char *buff;\n+\n+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n+                error_line (\""%s is not a valid .W64 file!\"", infilename);\n+                return WAVPACK_SOFT_ERROR;\n+            }\n+\n+            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\""extra unknown chunk \\\""%c%c%c%c\\\"" of %d bytes\"",""}","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
         }
         else {          // just copy unknown chunks to output file
             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
         }
         else {          // just copy unknown chunks to output file
             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",C,"            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
","            char *buff = malloc (bytes_to_copy);
",,"@@ -241,7 +241,14 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
         }
         else {          // just copy unknown chunks to output file
             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
-            char *buff = malloc (bytes_to_copy);
+            char *buff;
+
+            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
+                error_line (""%s is not a valid .W64 file!"", infilename);
+                return WAVPACK_SOFT_ERROR;
+            }
+
+            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",",WavPack,6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,0a72951de8feaaf4c6e1740b5cb5cd0401b00464,1,"int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif

    // loop through all elements of the wave64 header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .wav file we can handle

        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
         }
         else {          // just copy unknown chunks to output file
             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
//flaw_line_below:
            char *buff = malloc (bytes_to_copy);
//fix_flaw_line_below:
//            char *buff;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
//fix_flaw_line_below:
//                error_line (""%s is not a valid .W64 file!"", infilename);
//fix_flaw_line_below:
//                return WAVPACK_SOFT_ERROR;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",182423,"int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif

    // loop through all elements of the wave64 header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .wav file we can handle

        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
         }
         else {          // just copy unknown chunks to output file
             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","The vulnerability in the original code arises from the lack of validation for the `bytes_to_copy` variable when allocating memory for unknown chunks. If `chunk_header.ckSize` is negative or excessively large, it could lead to a buffer overflow or memory allocation failure, potentially causing a crash or exploitation. The fixed code addresses this vulnerability by adding a check for `bytes_to_copy` to ensure it is within a valid range (greater than 0 and less than or equal to 4,194,304 bytes) before proceeding with the `malloc` call. This prevents unsafe memory operations and enhances the overall robustness of the function.","The vulnerability in the original code stems from inadequate validation of the size of data being processed, particularly when allocating memory for unknown chunks. This oversight could lead to buffer overflows or memory allocation failures if the size is negative or excessively large, potentially resulting in crashes or exploitation. The revised code rectifies this issue by implementing a check to ensure that the size is within a safe and acceptable range before proceeding with memory allocation. This enhancement significantly improves the code's safety and stability by preventing unsafe memory operations.",2,5,5,4
32,32,182456,182456,,Remote,Not required,Partial,CVE-2018-8788,https://www.cvedetails.com/cve/CVE-2018-8788/,CWE-787,Low,Partial,Partial,,2018-11-29,7.5,FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.,2019-06-03,Exec Code Mem. Corr. ,18,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,d1112c279bd1a327e8e4d0b5f371458bf2579659,"Fixed CVE-2018-8788

Thanks to Eyal Itkin from Check Point Software Technologies.",1,libfreerdp/codec/nsc.c,"{""sha"": ""cb16570db8dbfdc52d2a113ca85ec07243ce9c70"", ""filename"": ""include/freerdp/codec/nsc.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/d1112c279bd1a327e8e4d0b5f371458bf2579659/include/freerdp/codec/nsc.h"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/d1112c279bd1a327e8e4d0b5f371458bf2579659/include/freerdp/codec/nsc.h"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/include/freerdp/codec/nsc.h?ref=d1112c279bd1a327e8e4d0b5f371458bf2579659"", ""patch"": ""@@ -77,8 +77,8 @@ struct _NSC_CONTEXT\n \t/* color palette allocated by the application */\n \tconst BYTE* palette;\n \n-\tvoid (*decode)(NSC_CONTEXT* context);\n-\tvoid (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n+\tBOOL (*decode)(NSC_CONTEXT* context);\n+\tBOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n \t               UINT32 rowstride);\n \n \tNSC_CONTEXT_PRIV* priv;""}<_**next**_>{""sha"": ""bad0aec1c99d07abfc13fb0a26d0ff3ec5ba3650"", ""filename"": ""libfreerdp/codec/nsc.c"", ""status"": ""modified"", ""additions"": 80, ""deletions"": 14, ""changes"": 94, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/codec/nsc.c?ref=d1112c279bd1a327e8e4d0b5f371458bf2579659"", ""patch"": ""@@ -42,13 +42,24 @@\n #define NSC_INIT_SIMD(_nsc_context) do { } while (0)\n #endif\n \n-static void nsc_decode(NSC_CONTEXT* context)\n+static BOOL nsc_decode(NSC_CONTEXT* context)\n {\n \tUINT16 x;\n \tUINT16 y;\n-\tUINT16 rw = ROUND_UP_TO(context->width, 8);\n-\tBYTE shift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n-\tBYTE* bmpdata = context->BitmapData;\n+\tUINT16 rw;\n+\tBYTE shift;\n+\tBYTE* bmpdata;\n+\tsize_t pos = 0;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n+\trw = ROUND_UP_TO(context->width, 8);\n+\tshift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n+\tbmpdata = context->BitmapData;\n+\n+\tif (!bmpdata)\n+\t\treturn FALSE;\n \n \tfor (y = 0; y < context->height; y++)\n \t{\n@@ -80,6 +91,11 @@ static void nsc_decode(NSC_CONTEXT* context)\n \t\t\tINT16 r_val = y_val + co_val - cg_val;\n \t\t\tINT16 g_val = y_val + cg_val;\n \t\t\tINT16 b_val = y_val - co_val - cg_val;\n+\n+\t\t\tif (pos + 4 > context->BitmapDataLength)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\tpos += 4;\n \t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n \t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n \t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n@@ -90,9 +106,11 @@ static void nsc_decode(NSC_CONTEXT* context)\n \t\t\taplane++;\n \t\t}\n \t}\n+\n+\treturn TRUE;\n }\n \n-static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n+static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n {\n \tUINT32 len;\n \tUINT32 left;\n@@ -105,6 +123,10 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n \n \t\tif (left == 5)\n \t\t{\n+\t\t\tif (outSize < 1)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize--;\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n@@ -124,26 +146,42 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n \t\t\t\tin += 4;\n \t\t\t}\n \n+\t\t\tif (outSize < len)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize -= len;\n \t\t\tFillMemory(out, len, value);\n \t\t\tout += len;\n \t\t\tleft -= len;\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tif (outSize < 1)\n+\t\t\t\treturn FALSE;\n+\n+\t\t\toutSize--;\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n \t}\n \n-\t*((UINT32*)out) = *((UINT32*)in);\n+\tif ((outSize < 4) || (left < 4))\n+\t\treturn FALSE;\n+\n+\tmemcpy(out, in, 4);\n+\treturn TRUE;\n }\n \n-static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n+static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n {\n \tUINT16 i;\n \tBYTE* rle;\n \tUINT32 planeSize;\n \tUINT32 originalSize;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n \trle = context->Planes;\n \n \tfor (i = 0; i < 4; i++)\n@@ -152,14 +190,30 @@ static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n \t\tplaneSize = context->PlaneByteCount[i];\n \n \t\tif (planeSize == 0)\n+\t\t{\n+\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n+\t\t\t\treturn FALSE;\n+\n \t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n+\t\t}\n \t\telse if (planeSize < originalSize)\n-\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n+\t\t{\n+\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,\n+\t\t\t                    originalSize))\n+\t\t\t\treturn FALSE;\n+\t\t}\n \t\telse\n+\t\t{\n+\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n+\t\t\t\treturn FALSE;\n+\n \t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n+\t\t}\n \n \t\trle += planeSize;\n \t}\n+\n+\treturn TRUE;\n }\n \n static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n@@ -396,13 +450,25 @@ BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n \t\treturn FALSE;\n \n \t/* RLE decode */\n-\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n-\tnsc_rle_decompress_data(context);\n-\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n+\t{\n+\t\tBOOL rc;\n+\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n+\t\trc = nsc_rle_decompress_data(context);\n+\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n+\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n+\t}\n \t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n-\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n-\tcontext->decode(context);\n-\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n+\t{\n+\t\tBOOL rc;\n+\t\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n+\t\trc = context->decode(context);\n+\t\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n+\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n+\t}\n \n \tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,\n \t                        width, height, context->BitmapData,""}<_**next**_>{""sha"": ""d2456fb9394ddaba480880aec14f7b84300c53e3"", ""filename"": ""libfreerdp/codec/nsc_encode.c"", ""status"": ""modified"", ""additions"": 44, ""deletions"": 18, ""changes"": 62, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_encode.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_encode.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/codec/nsc_encode.c?ref=d1112c279bd1a327e8e4d0b5f371458bf2579659"", ""patch"": ""@@ -51,6 +51,7 @@ static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n \t\tfor (i = 0; i < 5; i++)\n \t\t{\n \t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n+\n \t\t\tif (!tmp)\n \t\t\t\tgoto fail;\n \n@@ -87,7 +88,7 @@ static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n \treturn FALSE;\n }\n \n-static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n+static BOOL nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n                                       UINT32 scanline)\n {\n \tUINT16 x;\n@@ -104,10 +105,20 @@ static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n \tINT16 b_val;\n \tBYTE a_val;\n \tUINT32 tempWidth;\n+\n+\tif (!context || data || (scanline == 0))\n+\t\treturn FALSE;\n+\n \ttempWidth = ROUND_UP_TO(context->width, 8);\n \trw = (context->ChromaSubsamplingLevel ? tempWidth : context->width);\n \tccl = context->ColorLossLevel;\n \n+\tif (context->priv->PlaneBuffersLength < rw * scanline)\n+\t\treturn FALSE;\n+\n+\tif (rw < scanline * 2)\n+\t\treturn FALSE;\n+\n \tfor (y = 0; y < context->height; y++)\n \t{\n \t\tsrc = data + (context->height - 1 - y) * scanline;\n@@ -242,31 +253,37 @@ static void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n \t\tCopyMemory(coplane, coplane - rw, rw);\n \t\tCopyMemory(cgplane, cgplane - rw, rw);\n \t}\n+\n+\treturn TRUE;\n }\n \n-static void nsc_encode_subsampling(NSC_CONTEXT* context)\n+static BOOL nsc_encode_subsampling(NSC_CONTEXT* context)\n {\n \tUINT16 x;\n \tUINT16 y;\n-\tBYTE* co_dst;\n-\tBYTE* cg_dst;\n-\tINT8* co_src0;\n-\tINT8* co_src1;\n-\tINT8* cg_src0;\n-\tINT8* cg_src1;\n \tUINT32 tempWidth;\n \tUINT32 tempHeight;\n+\n+\tif (!context)\n+\t\treturn FALSE;\n+\n \ttempWidth = ROUND_UP_TO(context->width, 8);\n \ttempHeight = ROUND_UP_TO(context->height, 2);\n \n+\tif (tempHeight == 0)\n+\t\treturn FALSE;\n+\n+\tif (tempWidth > context->priv->PlaneBuffersLength / tempHeight)\n+\t\treturn FALSE;\n+\n \tfor (y = 0; y < tempHeight >> 1; y++)\n \t{\n-\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n-\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n-\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n-\t\tco_src1 = co_src0 + tempWidth;\n-\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n-\t\tcg_src1 = cg_src0 + tempWidth;\n+\t\tBYTE* co_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n+\t\tBYTE* cg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n+\t\tconst INT8* co_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n+\t\tconst INT8* co_src1 = co_src0 + tempWidth;\n+\t\tconst INT8* cg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n+\t\tconst INT8* cg_src1 = cg_src0 + tempWidth;\n \n \t\tfor (x = 0; x < tempWidth >> 1; x++)\n \t\t{\n@@ -280,19 +297,28 @@ static void nsc_encode_subsampling(NSC_CONTEXT* context)\n \t\t\tcg_src1 += 2;\n \t\t}\n \t}\n+\n+\treturn TRUE;\n }\n \n-void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n+BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n {\n-\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n+\tif (!context || !bmpdata || (rowstride == 0))\n+\t\treturn FALSE;\n+\n+\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n+\t\treturn FALSE;\n \n \tif (context->ChromaSubsamplingLevel)\n \t{\n-\t\tnsc_encode_subsampling(context);\n+\t\tif (!nsc_encode_subsampling(context))\n+\t\t\treturn FALSE;\n \t}\n+\n+\treturn TRUE;\n }\n \n-static UINT32 nsc_rle_encode(BYTE* in, BYTE* out, UINT32 originalSize)\n+static UINT32 nsc_rle_encode(const BYTE* in, BYTE* out, UINT32 originalSize)\n {\n \tUINT32 left;\n \tUINT32 runlength = 1;""}<_**next**_>{""sha"": ""784ccb6e358c583a1dfd7014dac88d55640db7a6"", ""filename"": ""libfreerdp/codec/nsc_encode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_encode.h"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_encode.h"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/codec/nsc_encode.h?ref=d1112c279bd1a327e8e4d0b5f371458bf2579659"", ""patch"": ""@@ -24,7 +24,7 @@\n \n #include <freerdp/api.h>\n \n-FREERDP_LOCAL void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n+FREERDP_LOCAL BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n                               UINT32 rowstride);\n \n #endif /* FREERDP_LIB_CODEC_NSC_ENCODE_H */""}<_**next**_>{""sha"": ""966525f16d1b2dca2bf0dfa7a3cf3fbb6b621763"", ""filename"": ""libfreerdp/codec/nsc_sse2.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_sse2.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/d1112c279bd1a327e8e4d0b5f371458bf2579659/libfreerdp/codec/nsc_sse2.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/codec/nsc_sse2.c?ref=d1112c279bd1a327e8e4d0b5f371458bf2579659"", ""patch"": ""@@ -385,7 +385,7 @@ static void nsc_encode_subsampling_sse2(NSC_CONTEXT* context)\n \t}\n }\n \n-static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n+static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                             UINT32 scanline)\n {\n \tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n@@ -394,6 +394,8 @@ static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n \t{\n \t\tnsc_encode_subsampling_sse2(context);\n \t}\n+\n+\treturn TRUE;\n }\n \n void nsc_init_sse2(NSC_CONTEXT* context)""}","static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
			if (outSize < len)
				return FALSE;

			outSize -= len;
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
 	}
 
	if ((outSize < 4) || (left < 4))
		return FALSE;

	memcpy(out, in, 4);
	return TRUE;
 }
","static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
 			*out++ = value;
 			left--;
 		}
 	}
 
	*((UINT32*)out) = *((UINT32*)in);
 }
",C,"static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
			if (outSize < 1)
				return FALSE;

			outSize--;
			if (outSize < len)
				return FALSE;

			outSize -= len;
			if (outSize < 1)
				return FALSE;

			outSize--;
	if ((outSize < 4) || (left < 4))
		return FALSE;

	memcpy(out, in, 4);
	return TRUE;
","	*((UINT32*)out) = *((UINT32*)in);
",,"@@ -42,13 +42,24 @@
 #define NSC_INIT_SIMD(_nsc_context) do { } while (0)
 #endif
 
-static void nsc_decode(NSC_CONTEXT* context)
+static BOOL nsc_decode(NSC_CONTEXT* context)
 {
 	UINT16 x;
 	UINT16 y;
-	UINT16 rw = ROUND_UP_TO(context->width, 8);
-	BYTE shift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */
-	BYTE* bmpdata = context->BitmapData;
+	UINT16 rw;
+	BYTE shift;
+	BYTE* bmpdata;
+	size_t pos = 0;
+
+	if (!context)
+		return FALSE;
+
+	rw = ROUND_UP_TO(context->width, 8);
+	shift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */
+	bmpdata = context->BitmapData;
+
+	if (!bmpdata)
+		return FALSE;
 
 	for (y = 0; y < context->height; y++)
 	{
@@ -80,6 +91,11 @@ static void nsc_decode(NSC_CONTEXT* context)
 			INT16 r_val = y_val + co_val - cg_val;
 			INT16 g_val = y_val + cg_val;
 			INT16 b_val = y_val - co_val - cg_val;
+
+			if (pos + 4 > context->BitmapDataLength)
+				return FALSE;
+
+			pos += 4;
 			*bmpdata++ = MINMAX(b_val, 0, 0xFF);
 			*bmpdata++ = MINMAX(g_val, 0, 0xFF);
 			*bmpdata++ = MINMAX(r_val, 0, 0xFF);
@@ -90,9 +106,11 @@ static void nsc_decode(NSC_CONTEXT* context)
 			aplane++;
 		}
 	}
+
+	return TRUE;
 }
 
-static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
+static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
@@ -105,6 +123,10 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
 
 		if (left == 5)
 		{
+			if (outSize < 1)
+				return FALSE;
+
+			outSize--;
 			*out++ = value;
 			left--;
 		}
@@ -124,26 +146,42 @@ static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
 				in += 4;
 			}
 
+			if (outSize < len)
+				return FALSE;
+
+			outSize -= len;
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
+			if (outSize < 1)
+				return FALSE;
+
+			outSize--;
 			*out++ = value;
 			left--;
 		}
 	}
 
-	*((UINT32*)out) = *((UINT32*)in);
+	if ((outSize < 4) || (left < 4))
+		return FALSE;
+
+	memcpy(out, in, 4);
+	return TRUE;
 }
 
-static void nsc_rle_decompress_data(NSC_CONTEXT* context)
+static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)
 {
 	UINT16 i;
 	BYTE* rle;
 	UINT32 planeSize;
 	UINT32 originalSize;
+
+	if (!context)
+		return FALSE;
+
 	rle = context->Planes;
 
 	for (i = 0; i < 4; i++)
@@ -152,14 +190,30 @@ static void nsc_rle_decompress_data(NSC_CONTEXT* context)
 		planeSize = context->PlaneByteCount[i];
 
 		if (planeSize == 0)
+		{
+			if (context->priv->PlaneBuffersLength < originalSize)
+				return FALSE;
+
 			FillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);
+		}
 		else if (planeSize < originalSize)
-			nsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);
+		{
+			if (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,
+			                    originalSize))
+				return FALSE;
+		}
 		else
+		{
+			if (context->priv->PlaneBuffersLength < originalSize)
+				return FALSE;
+
 			CopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);
+		}
 
 		rle += planeSize;
 	}
+
+	return TRUE;
 }
 
 static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)
@@ -396,13 +450,25 @@ BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,
 		return FALSE;
 
 	/* RLE decode */
-	PROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)
-	nsc_rle_decompress_data(context);
-	PROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)
+	{
+		BOOL rc;
+		PROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)
+		rc = nsc_rle_decompress_data(context);
+		PROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)
+
+		if (!rc)
+			return FALSE;
+	}
 	/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */
-	PROFILER_ENTER(context->priv->prof_nsc_decode)
-	context->decode(context);
-	PROFILER_EXIT(context->priv->prof_nsc_decode)
+	{
+		BOOL rc;
+		PROFILER_ENTER(context->priv->prof_nsc_decode)
+		rc = context->decode(context);
+		PROFILER_EXIT(context->priv->prof_nsc_decode)
+
+		if (!rc)
+			return FALSE;
+	}
 
 	if (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,
 	                        width, height, context->BitmapData,",FreeRDP,d1112c279bd1a327e8e4d0b5f371458bf2579659,09b9d4f1994a674c4ec85b4947aa656eda1aed8a,1,"static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
//fix_flaw_line_below:
//static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
//fix_flaw_line_below:
//			if (outSize < 1)
//fix_flaw_line_below:
//				return FALSE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			outSize--;
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
//fix_flaw_line_below:
//			if (outSize < len)
//fix_flaw_line_below:
//				return FALSE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			outSize -= len;
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
//fix_flaw_line_below:
//			if (outSize < 1)
//fix_flaw_line_below:
//				return FALSE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			outSize--;
 			*out++ = value;
 			left--;
 		}
 	}
 
//flaw_line_below:
	*((UINT32*)out) = *((UINT32*)in);
//fix_flaw_line_below:
//	if ((outSize < 4) || (left < 4))
//fix_flaw_line_below:
//		return FALSE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	memcpy(out, in, 4);
//fix_flaw_line_below:
//	return TRUE;
 }
",182456,"static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
 			*out++ = value;
 			left--;
 		}
 	}
 
	*((UINT32*)out) = *((UINT32*)in);
 }
","static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
			if (outSize < len)
				return FALSE;

			outSize -= len;
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
 	}
 
	if ((outSize < 4) || (left < 4))
		return FALSE;

	memcpy(out, in, 4);
	return TRUE;
 }
","The vulnerability in the original `nsc_rle_decode` function arises from a lack of bounds checking on the `out` buffer, which could lead to buffer overflows if the `originalSize` exceeds the allocated size of `out`. Specifically, the code does not verify if there is enough space in `out` before writing data, particularly in the `FillMemory` call. The fixed code addresses this vulnerability by introducing an `outSize` parameter and performing checks before writing to `out`. It ensures that there is sufficient space available by returning `FALSE` if `outSize` is insufficient, thus preventing potential buffer overflows.","The vulnerability in the original code stems from the absence of checks to ensure that the output buffer has enough space before writing data, which can lead to buffer overflows. This oversight allows the function to potentially write beyond the allocated memory, causing undefined behavior or crashes. The revised code mitigates this risk by introducing a parameter that specifies the size of the output buffer and includes validation checks before any writing occurs. If the available space is insufficient, the function safely returns an error, thereby preventing any overflow and enhancing overall stability and security.",2,5,4,3
33,33,182621,182621,,Remote,Not required,Partial,CVE-2016-5314,https://www.cvedetails.com/cve/CVE-2016-5314/,CWE-787,Medium,Partial,Partial,,2018-03-11,6.8,"Buffer overflow in the PixarLogDecode function in tif_pixarlog.c in LibTIFF 4.0.6 and earlier allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted TIFF image, as demonstrated by overwriting the vgetparent function pointer with rgb2ycbcr.",2018-04-05,DoS Overflow ,6,https://github.com/vadz/libtiff/commit/391e77fcd217e78b2c51342ac3ddb7100ecacdd2,391e77fcd217e78b2c51342ac3ddb7100ecacdd2,"* libtiff/tif_pixarlog.c: fix potential buffer write overrun in
PixarLogDecode() on corrupted/unexpected images (reported by Mathias Svensson)",0,libtiff/tif_pixarlog.c,"{""sha"": ""dee18813f02fbed7b4dbaf179621a32e297fb264"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/vadz/libtiff/blob/391e77fcd217e78b2c51342ac3ddb7100ecacdd2/ChangeLog"", ""raw_url"": ""https://github.com/vadz/libtiff/raw/391e77fcd217e78b2c51342ac3ddb7100ecacdd2/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/vadz/libtiff/contents/ChangeLog?ref=391e77fcd217e78b2c51342ac3ddb7100ecacdd2"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-28  Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff/tif_pixarlog.c: fix potential buffer write overrun in\n+\tPixarLogDecode() on corrupted/unexpected images (reported by Mathias Svensson)\n+\n 2016-06-15  Bob Friesenhahn  <bfriesen@simple.dallas.tx.us>\n \n \t* libtiff/libtiff.def: Added _TIFFMultiply32 and _TIFFMultiply64""}<_**next**_>{""sha"": ""cc486c5472ba4247d7b241aa9a51f4e36dffd97c"", ""filename"": ""libtiff/tif_pixarlog.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/vadz/libtiff/blob/391e77fcd217e78b2c51342ac3ddb7100ecacdd2/libtiff/tif_pixarlog.c"", ""raw_url"": ""https://github.com/vadz/libtiff/raw/391e77fcd217e78b2c51342ac3ddb7100ecacdd2/libtiff/tif_pixarlog.c"", ""contents_url"": ""https://api.github.com/repos/vadz/libtiff/contents/libtiff/tif_pixarlog.c?ref=391e77fcd217e78b2c51342ac3ddb7100ecacdd2"", ""patch"": ""@@ -459,6 +459,7 @@ horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,\n typedef\tstruct {\n \tTIFFPredictorState\tpredict;\n \tz_stream\t\tstream;\n+\ttmsize_t\t\ttbuf_size; /* only set/used on reading for now */\n \tuint16\t\t\t*tbuf; \n \tuint16\t\t\tstride;\n \tint\t\t\tstate;\n@@ -694,6 +695,7 @@ PixarLogSetupDecode(TIFF* tif)\n \tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n \tif (sp->tbuf == NULL)\n \t\treturn (0);\n+\tsp->tbuf_size = tbuf_size;\n \tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n \t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n \tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n@@ -783,6 +785,12 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n \t\tTIFFErrorExt(tif->tif_clientdata, module, \""ZLib cannot deal with buffers this size\"");\n \t\treturn (0);\n \t}\n+\t/* Check that we will not fill more than what was allocated */\n+\tif (sp->stream.avail_out > sp->tbuf_size)\n+\t{\n+\t\tTIFFErrorExt(tif->tif_clientdata, module, \""sp->stream.avail_out > sp->tbuf_size\"");\n+\t\treturn (0);\n+\t}\n \tdo {\n \t\tint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\n \t\tif (state == Z_STREAM_END) {""}","PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = ""PixarLogDecode"";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			""%d bit input not supported in PixarLog"",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
	/* Check that we will not fill more than what was allocated */
	if (sp->stream.avail_out > sp->tbuf_size)
	{
		TIFFErrorExt(tif->tif_clientdata, module, ""sp->stream.avail_out > sp->tbuf_size"");
		return (0);
	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Decoding error at scanline %lu, %s"",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : ""(null)"");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, ""ZLib error: %s"",
			    sp->stream.msg ? sp->stream.msg : ""(null)"");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Not enough data at scanline %lu (short "" TIFF_UINT64_FORMAT "" bytes)"",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			""stride %lu is not a multiple of sample count, ""
			""%lu, data truncated."", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  ""Unsupported bits/sample: %d"",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
","PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = ""PixarLogDecode"";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			""%d bit input not supported in PixarLog"",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Decoding error at scanline %lu, %s"",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : ""(null)"");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, ""ZLib error: %s"",
			    sp->stream.msg ? sp->stream.msg : ""(null)"");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Not enough data at scanline %lu (short "" TIFF_UINT64_FORMAT "" bytes)"",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			""stride %lu is not a multiple of sample count, ""
			""%lu, data truncated."", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  ""Unsupported bits/sample: %d"",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
",C,"	/* Check that we will not fill more than what was allocated */
	if (sp->stream.avail_out > sp->tbuf_size)
	{
		TIFFErrorExt(tif->tif_clientdata, module, ""sp->stream.avail_out > sp->tbuf_size"");
		return (0);
	}
",,,"@@ -459,6 +459,7 @@ horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,
 typedef	struct {
 	TIFFPredictorState	predict;
 	z_stream		stream;
+	tmsize_t		tbuf_size; /* only set/used on reading for now */
 	uint16			*tbuf; 
 	uint16			stride;
 	int			state;
@@ -694,6 +695,7 @@ PixarLogSetupDecode(TIFF* tif)
 	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
 	if (sp->tbuf == NULL)
 		return (0);
+	sp->tbuf_size = tbuf_size;
 	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
 		sp->user_datafmt = PixarLogGuessDataFmt(td);
 	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
@@ -783,6 +785,12 @@ PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
+	/* Check that we will not fill more than what was allocated */
+	if (sp->stream.avail_out > sp->tbuf_size)
+	{
+		TIFFErrorExt(tif->tif_clientdata, module, ""sp->stream.avail_out > sp->tbuf_size"");
+		return (0);
+	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {",libtiff,391e77fcd217e78b2c51342ac3ddb7100ecacdd2,c421b993abe1d6792252833c3bc8b3252b015fb9,1,"PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = ""PixarLogDecode"";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			""%d bit input not supported in PixarLog"",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
//fix_flaw_line_below:
//	/* Check that we will not fill more than what was allocated */
//fix_flaw_line_below:
//	if (sp->stream.avail_out > sp->tbuf_size)
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		TIFFErrorExt(tif->tif_clientdata, module, ""sp->stream.avail_out > sp->tbuf_size"");
//fix_flaw_line_below:
//		return (0);
//fix_flaw_line_below:
//	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Decoding error at scanline %lu, %s"",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : ""(null)"");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, ""ZLib error: %s"",
			    sp->stream.msg ? sp->stream.msg : ""(null)"");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Not enough data at scanline %lu (short "" TIFF_UINT64_FORMAT "" bytes)"",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			""stride %lu is not a multiple of sample count, ""
			""%lu, data truncated."", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  ""Unsupported bits/sample: %d"",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
",182621,"PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = ""PixarLogDecode"";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			""%d bit input not supported in PixarLog"",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Decoding error at scanline %lu, %s"",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : ""(null)"");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, ""ZLib error: %s"",
			    sp->stream.msg ? sp->stream.msg : ""(null)"");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Not enough data at scanline %lu (short "" TIFF_UINT64_FORMAT "" bytes)"",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			""stride %lu is not a multiple of sample count, ""
			""%lu, data truncated."", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  ""Unsupported bits/sample: %d"",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
","PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = ""PixarLogDecode"";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			""%d bit input not supported in PixarLog"",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
 		TIFFErrorExt(tif->tif_clientdata, module, ""ZLib cannot deal with buffers this size"");
 		return (0);
 	}
	/* Check that we will not fill more than what was allocated */
	if (sp->stream.avail_out > sp->tbuf_size)
	{
		TIFFErrorExt(tif->tif_clientdata, module, ""sp->stream.avail_out > sp->tbuf_size"");
		return (0);
	}
 	do {
 		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
 		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    ""Decoding error at scanline %lu, %s"",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : ""(null)"");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, ""ZLib error: %s"",
			    sp->stream.msg ? sp->stream.msg : ""(null)"");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Not enough data at scanline %lu (short "" TIFF_UINT64_FORMAT "" bytes)"",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			""stride %lu is not a multiple of sample count, ""
			""%lu, data truncated."", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  ""Unsupported bits/sample: %d"",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
","The vulnerability in the original `PixarLogDecode` code arises from a lack of bounds checking on the `sp->stream.avail_out` variable, which could exceed the allocated size of `sp->tbuf`, leading to a buffer overflow. This occurs when the code attempts to write more data than the buffer can hold, potentially allowing an attacker to overwrite adjacent memory. The fix in the modified code introduces a check that ensures `sp->stream.avail_out` does not exceed `sp->tbuf_size`. If this condition is violated, an error is reported, and the function returns early, thus preventing the overflow and enhancing the code's security.","The vulnerability in the original code stems from the absence of checks to ensure that the output buffer does not overflow when data is written to it. This oversight could allow an attacker to exploit the code by causing it to write more data than the allocated buffer can handle, leading to potential memory corruption or arbitrary code execution. The revised code addresses this issue by implementing a safeguard that verifies the size of the output buffer before any data is written. If the output size exceeds the buffer's capacity, an error is triggered, preventing the overflow and enhancing overall security.",3,5,4,4
34,34,182716,182716,,Remote,Not required,Partial,CVE-2019-15148,https://www.cvedetails.com/cve/CVE-2019-15148/,CWE-787,Medium,,,,2019-08-18,4.3,GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,2019-08-22,,1,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,341f12cd5b97ab419e53853ca00176457c9f1681,fixed many security issues with the too crude mp4 reader,1,GPMF_parser.c,"{""sha"": ""aacced95030afb75ffa8848a6865df96d58d90e8"", ""filename"": ""GPMF_parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/GPMF_parser.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library\n  *\n- *  @version 1.2.1\n+ *  @version 1.2.2\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -42,7 +42,7 @@ GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not byt\n {\n \tif (ms)\n \t{\n-\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n+\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n \t\tif (nestsize == 0 && ms->nest_level == 0)\n \t\t\tnestsize = ms->buffer_size_longs;\n ""}<_**next**_>{""sha"": ""63a786a31a1ed54333f71bccf805065db4e27599"", ""filename"": ""GPMF_parser.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.h"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.h"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/GPMF_parser.h?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library include\n  * \n- *  @version 1.1.0\n+ *  @version 1.1.1\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -126,7 +126,11 @@ typedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPr\n \tGPMF_KEY_UNITS =\t\t\tMAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \""RPM\"", \""MPH\"", \""km/h\"", etc)\n \tGPMF_KEY_SCALE =\t\t\tMAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.\n \tGPMF_KEY_TYPE =\t\t\t\tMAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures\n-\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TIME_OFFSET =\t\tMAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)\n+\tGPMF_KEY_TIMING_OFFSET =\tMAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO\n+\tGPMF_KEY_TIME_STAMP =\t\tMAKEID('S','T','M','P'),//STMP - Time stamp for the first sample. \n+\tGPMF_KEY_TIME_STAMPS =\t\tMAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.) \n \tGPMF_KEY_TICK =\t\t\t\tMAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. \n \tGPMF_KEY_TOCK =\t\t\t\tMAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. \n \tGPMF_KEY_EMPTY_PAYLOADS =\tMAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)""}<_**next**_>{""sha"": ""dde13b401c9f23ea31cc864439ffc115f10792a0"", ""filename"": ""demo/GPMF_demo.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_demo.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_demo.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_demo.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -46,6 +46,12 @@ int main(int argc, char *argv[])\n \t}\n \n \tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n+\tif (mp4 == 0)\n+\t{\n+\t\tprintf(\""error: %s is an invalid MP4/MOV\\n\"", argv[1]);\n+\t\treturn -1;\n+\t}\n+\n //\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n \n \tmetadatalength = GetDuration(mp4);\n@@ -90,7 +96,7 @@ int main(int argc, char *argv[])\n \t\tfor (index = 0; index < payloads; index++)\n \t\t{\n \t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n-\t\t\tfloat in = 0.0, out = 0.0; //times\n+\t\t\tdouble in = 0.0, out = 0.0; //times\n \t\t\tpayload = GetPayload(mp4, payload, index);\n \t\t\tif (payload == NULL)\n \t\t\t\tgoto cleanup;\n@@ -238,9 +244,10 @@ int main(int argc, char *argv[])\n \t\t{\n \t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n \t\t\t{\n+\t\t\t\tdouble in = 0.0, out = 0.0;\n \t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n-\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n-\t\t\t\tprintf(\""%c%c%c%c sampling rate = %f Hz\\n\"", PRINTF_4CC(fourcc), rate);\n+\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\tprintf(\""%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\"", PRINTF_4CC(fourcc), rate, in, out);\n \t\t\t}\n \t\t}\n #endif""}<_**next**_>{""sha"": ""1b6d25f47837b61f57b4e3e999ae77aa0409924e"", ""filename"": ""demo/GPMF_mp4reader.c"", ""status"": ""modified"", ""additions"": 494, ""deletions"": 333, ""changes"": 827, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_mp4reader.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,15 +2,14 @@\n *\n *  @brief Way Too Crude MP4|MOV reader\n *\n-*  @version 1.2.1\n+*  @version 1.3.1\n *\n-*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n+*  (C) Copyright 2017-2019 GoPro Inc (http://gopro.com/).\n *\n-*  Licensed under the Apache License, Version 2.0 (the \""License\"");\n-*  you may not use this file except in compliance with the License.\n-*  You may obtain a copy of the License at\n-*\n-*      http://www.apache.org/licenses/LICENSE-2.0\n+*  Licensed under either:\n+*  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0\n+*  - MIT license, http://opensource.org/licenses/MIT\n+*  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \""AS IS\"" BASIS,\n@@ -20,21 +19,24 @@\n *\n */\n \n-/* This is not an elegant MP4 parser, only used to help demonstrate extraction of MP4 */\n-\n+/* This is not an elegant MP4 parser, only used to help demonstrate extraction of GPMF */\n \n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdint.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n #include \""GPMF_mp4reader.h\""\n \n #define PRINT_MP4_STRUCTURE\t\t0\n \n #ifdef WIN32\n-#define LONGSEEK  _fseeki64\n+#define LONGSEEK\t_fseeki64\n+#define stat64\t\t_stat64\n #else\n-#define LONGSEEK  fseeko\n+#define LONGSEEK\tfseeko\n #endif\n \n \n@@ -50,7 +52,6 @@ uint32_t GetNumberPayloads(size_t handle)\n \treturn 0;\n }\n \n-\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n@@ -63,31 +64,35 @@ uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n \n \t\tif (MP4buffer)\n \t\t{\n-\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n-\t\t\treturn MP4buffer;\n+\t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])\n+\t\t\t{\n+\t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n+\t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];\n+\t\t\t\treturn MP4buffer;\n+\t\t\t}\n \t\t}\n \t}\n \treturn NULL;\n }\n \n \n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n+void LongSeek(mp4object *mp4, int64_t offset)\n {\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return;\n-\n-\tuint32_t *MP4buffer = NULL;\n-\tif (index < mp4->indexcount && mp4->mediafp && payload)\n+\tif (mp4 && offset)\n \t{\n-\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\tfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\tif (mp4->filepos + offset < mp4->filesize)\n+\t\t{\n+\t\t\tLONGSEEK(mp4->mediafp, offset, SEEK_CUR);\n+\t\t\tmp4->filepos += offset;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tmp4->filepos = mp4->filesize;\n+\t\t}\n \t}\n-\treturn;\n }\n \n-\n-\n void FreePayload(uint32_t *lastpayload)\n {\n \tif (lastpayload)\n@@ -106,6 +111,7 @@ uint32_t GetPayloadSize(size_t handle, uint32_t index)\n \treturn 0;\n }\n \n+\n #define MAX_NEST_LEVEL\t20\n \n size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4\n@@ -115,6 +121,12 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \tmemset(mp4, 0, sizeof(mp4object));\n \n+\tstruct stat64 mp4stat;\n+\tstat64(filename, &mp4stat);\n+\tmp4->filesize = mp4stat.st_size;\n+\n+\tif (mp4->filesize < 64) return 0;\n+\n #ifdef _WINDOWS\n \tfopen_s(&mp4->mediafp, filename, \""rb\"");\n #else\n@@ -129,25 +141,27 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n \n+\n \t\tdo\n \t\t{\n \t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n \t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n-\t\t\tif (len == 8)\n+\t\t\tmp4->filepos += len;\n+\t\t\tif (len == 8 && mp4->filepos < mp4->filesize)\n \t\t\t{\n \t\t\t\tif (!VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n-\n-\t\t\t\t\tNESTSIZE(lastsize - 8);\n-\t\t\t\t\tcontinue;\n+\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n \n \t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n \t\t\t\t{\n-\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tlen = fread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tmp4->filepos += len;\n \t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n \t\t\t\t}\n \t\t\t\telse\n@@ -168,9 +182,10 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||\n-\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a'))\n+\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a') ||\n+\t\t\t\t\tqttag == MAKEID('f', 'r', 'e', 'e'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -187,8 +202,6 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&\n \t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&\n@@ -197,7 +210,7 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&\n \t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t}\n@@ -210,7 +223,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\n \t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -233,7 +248,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -244,10 +261,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n \n-\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's'))\n+\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))\n \t\t\t\t\t\t\ttype = temp;\n \n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over hldr\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -267,10 +285,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\ttype = 0; // MP4\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsd\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -286,32 +305,35 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metastsc_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * 12);\n-\t\t\t\t\t\t\t\tif (mp4->metastsc)\n+\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tuint32_t total_stsc = num;\n-\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n-\n-\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));\n+\t\t\t\t\t\t\t\t\tif (mp4->metastsc)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n-\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n \n-\t\t\t\t\t\t\t\tif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.\n+\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n+\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsx\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -330,33 +352,44 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metasize_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);\n-\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\tif (mp4->metasizes)\n+\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n+\t\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\tif (mp4->metasizes)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsz\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -369,93 +402,121 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n \t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tuint32_t metastco_count = num;\n+\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n+\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++; stsc_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse if (repeat == mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->indexcount)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stco_pos + 1 < metastco_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstsc_pos++;\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -467,60 +528,79 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n+\n+\t\t\t\t\t\t\tif(num == 0)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", 0, (int)fileoffset, 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", 0, (int)fileoffset, 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n@@ -538,10 +618,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -578,10 +659,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -595,6 +677,15 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} while (len > 0);\n+\n+\t\tif (mp4)\n+\t\t{\n+\t\t\tif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)\n+\t\t\t{\n+\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\tmp4 = NULL;\n+\t\t\t}\n+\t\t}\n \t}\n \telse\n \t{\n@@ -631,20 +722,32 @@ void CloseSource(size_t handle)\n }\n \n \n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0;\n+\tif (mp4 == NULL) return GPMF_ERROR_MEMORY;\n \n-\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;\n+\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;\n \n-\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\treturn 0;\n+\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\treturn GPMF_OK;\n }\n \n \n-\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)\n+{\n+    mp4object *mp4 = (mp4object *)handle;\n+    if (mp4 == NULL) return GPMF_ERROR_MEMORY;\n+    \n+    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;\n+\n+\t*in_numerator = (uint32_t)(index * mp4->basemetadataduration);\n+\t*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);\n+\t*denominator = (uint32_t)mp4->meta_clockdemon;\n+    \n+    return GPMF_OK;\n+}\n \n size_t OpenMP4SourceUDTA(char *filename)\n {\n@@ -661,7 +764,8 @@ size_t OpenMP4SourceUDTA(char *filename)\n \n \tif (mp4->mediafp)\n \t{\n-\t\tuint32_t qttag, qtsize32, len;\n+\t\tuint32_t qttag, qtsize32;\n+\t\tsize_t len;\n \t\tint32_t nest = 0;\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n@@ -674,7 +778,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t{\n \t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, lastsize - 8 - 8);\n \n \t\t\t\t\tNESTSIZE(lastsize - 8);\n \t\t\t\t\tcontinue;\n@@ -701,7 +805,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -725,7 +829,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n \t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -740,7 +844,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n }\n \n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n \tif (mp4 == NULL) return 0.0;\n@@ -750,221 +854,278 @@ double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n \tuint32_t testend = mp4->indexcount;\n \tdouble rate = 0.0;\n \n+\tuint32_t *payload;\n+\tuint32_t payloadsize;\n+\tint32_t ret;\n+\n \tif (mp4->indexcount < 1)\n \t\treturn 0.0;\n \n-\tif (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. \n-\t{\n-\t\tteststart++;\n-\t\ttestend--;\n-\t}\n-\n-\tuint32_t *payload = GetPayload(handle, NULL, teststart); // second payload\n-\tuint32_t payloadsize = GetPayloadSize(handle, teststart);\n-\tint32_t ret = GPMF_Init(ms, payload, payloadsize);\n+\tpayload = GetPayload(handle, NULL, teststart); \n+\tpayloadsize = GetPayloadSize(handle, teststart);\n+\tret = GPMF_Init(ms, payload, payloadsize);\n \n \tif (ret != GPMF_OK)\n \t\tgoto cleanup;\n \n \t{\n+\t\tuint64_t minimumtimestamp = 0;\n+\t\tuint64_t starttimestamp = 0;\n+\t\tuint64_t endtimestamp = 0;\n \t\tuint32_t startsamples = 0;\n \t\tuint32_t endsamples = 0;\n-\t\tuint32_t missing_samples = 0;\n+\t\tdouble intercept = 0.0;\n+\n+\n \n-\t\twhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\twhile (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t{\n-\t\t\tmissing_samples = 1;\n \t\t\tteststart++;\n \t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n \t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n \t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \t\t}\n \n-\t\tif (missing_samples)\n-\t\t{\n-\t\t\tteststart++;   //samples after sensor start are statistically the best\n-\t\t\tpayload = GetPayload(handle, payload, teststart);\n-\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n-\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t}\n-\n-\t\tif (ret == GPMF_OK)\n+\t\tif (ret == GPMF_OK && payload)\n \t\t{\n-\t\t\tuint32_t samples = GPMF_Repeat(ms);\n+\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n \t\t\tGPMF_stream find_stream;\n \t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n \n-\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstarttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\tif (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.\n \t\t\t{\n-\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n+\t\t\t\tGPMF_stream any_stream;\n+\t\t\t\tGPMF_Init(&any_stream, payload, payloadsize);\n+\n+\t\t\t\tminimumtimestamp = starttimestamp;\n+\t\t\t\twhile (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))\n+\t\t\t\t{\n+\t\t\t\t\tuint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));\n+\t\t\t\t\tif (timestamp < minimumtimestamp)\n+\t\t\t\t\t\tminimumtimestamp = timestamp;\n+\t\t\t\t}\n+\t\t\t}\n \n-\t\t\t\tpayload = GetPayload(handle, payload, testend); // second last payload\n+\t\t\ttestend = mp4->indexcount;\n+\t\t\tdo\n+\t\t\t{\n+\t\t\t\ttestend--;// last payload with the fourcc needed\n+\t\t\t\tpayload = GetPayload(handle, payload, testend);\n \t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n \t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\tgoto cleanup;\n+\t\t\t} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n-\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n+\t\t\telse // If there is no TSMP we have to count the samples.\n+\t\t\t{\n+\t\t\t\tuint32_t i;\n+\t\t\t\tfor (i = teststart; i <= testend; i++)\n \t\t\t\t{\n-\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n-\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tpayload = GetPayload(handle,payload, i); // second last payload\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, i);\n+\t\t\t\t\tif (GPMF_OK == GPMF_Init(ms, payload, payloadsize))\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\t\t\tendsamples += GPMF_PayloadSampleCount(ms);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (starttimestamp != 0)\n+\t\t\t{\n+\t\t\t\tuint32_t last_samples = GPMF_PayloadSampleCount(ms);\n+\t\t\t\tuint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;\n+\t\t\t\tdouble time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.\n+\n+\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tendtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\t\tif (endtimestamp)\n+\t\t\t\t{\n+\t\t\t\t\tdouble approxrate = 0.0;\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\tapproxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\t\t\t\t\tif (approxrate == 0.0)\n+\t\t\t\t\t\tapproxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\n+\t\t\t\t\twhile (time_stamp_scale >= 1)\n \t\t\t\t\t{\n-\t\t\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\t\trate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);\n+\t\t\t\t\t\tif (rate*0.9 < approxrate && approxrate < rate*1.1)\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\ttime_stamp_scale *= 0.1;\n \t\t\t\t\t}\n+\t\t\t\t\tif (time_stamp_scale < 1.0) rate = 0.0;\n+\t\t\t\t\tintercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;\n \t\t\t\t}\n-\n-\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t}\n-\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n+\n+\t\t\tif (rate == 0.0) //Timestamps didn't help weren't available\n \t\t\t{\n-\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n-\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n-\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n-\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n+\t\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE))\n+\t\t\t\t{\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tsamples = 0;\n+\t\t\t\t\tif (rate == 0.0)\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n+\t\t\t\t\tdouble in, out;\n+\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))\n+\t\t\t\t\t\tintercept = (double)-in * rate;\n+\t\t\t\t}\n+\t\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n \t\t\t\t{\n-\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n-\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n-\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n+\t\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n+\t\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n+\t\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n \n-\t\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\tsamples = 0;\n \n-\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n \t\t\t\t\t{\n-\t\t\t\t\t\tGPMF_stream find_stream2;\n-\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\t\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n+\t\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n+\t\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \n-\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\tif (ret != GPMF_OK)\n+\t\t\t\t\t\t\tgoto cleanup;\n+\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (repeatarray)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\tGPMF_stream find_stream2;\n+\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\n+\t\t\t\t\t\t\tpayloadcount++;\n \n-\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tsamples++;\n-\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\tsamples++;\n+\t\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tuint32_t repeat = GPMF_Repeat(ms);\n-\t\t\t\t\t\t\tsamples += repeat;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\t\tuint32_t repeat = GPMF_PayloadSampleCount(ms);\n+\t\t\t\t\t\t\t\tsamples += repeat;\n+\n+\t\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\trepeatarray[payloadpos] = 0;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n-\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n-\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n-\t\t\t\tif (repeatarray)\n-\t\t\t\t{\n-\t\t\t\t\tmeanY /= (double)payloadcount;\n-\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n+\t\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n+\t\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n+\t\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n+\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t{\n-\t\t\t\t\t\tfloat in, out;\n-\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n+\t\t\t\t\t\tmeanY /= (double)payloadcount;\n+\t\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n-\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n-\t\t\t\t\t}\n+\t\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tdouble in, out;\n+\t\t\t\t\t\t\tif (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n+\t\t\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\trate = slope;\n \n+\t\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tintercept = meanY - slope * meanX;\n #if 0\n-\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tprintf(\""%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);\n+\t\t\t\t\t\tprintf(\""%c%c%c%c first sample at time %.3fms\\n\"", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);\n+#endif\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tdouble intercept;\n-\t\t\t\t\t\tintercept = meanY - slope*meanX;\n-\t\t\t\t\t\tprintf(\""%c%c%c%c start offset = %f (%.3fms)\\n\"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t\t\t}\n-#endif\n-\t\t\t\t\trate = slope;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t}\n-\n-\t\t\t\tfree(repeatarray);\n \n-\t\t\t\tgoto cleanup;\n+\t\t\t\t\tfree(repeatarray);\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t}\n \n-cleanup:\n-\tif (payload) \n-\t{\n-\t\tFreePayload(payload);\n-\t\tpayload = NULL;\n-\t}\n-\n-\treturn rate;\n-}\n+\t\t\tif (firstsampletime && lastsampletime)\n+\t\t\t{\n+\t\t\t\tuint32_t endpayload = mp4->indexcount;\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tendpayload--;// last payload with the fourcc needed\n+\t\t\t\t\tpayload = GetPayload(handle, payload, endpayload);\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, endpayload);\n+\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n+\t\t\t\tif (endpayload > 0 && ret == GPMF_OK)\n+\t\t\t\t{\n+\t\t\t\t\tuint32_t totalsamples = endsamples - startsamples;\n+\t\t\t\t\tfloat timo = 0.0;\n \n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)\n-{\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0.0;\n+\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\t\tGPMF_FormattedData(&find_stream, &timo, 4, 0, 1);\n \n-\tuint32_t key, insamples;\n-\tuint32_t repeat, outsamples;\n-\tGPMF_stream find_stream;\n+\t\t\t\t\tdouble first, last;\n+\t\t\t\t\tfirst = -intercept / rate - timo;\n+\t\t\t\t\tlast = first + (double)totalsamples / rate;\n \n-\tif (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;\n+\t\t\t\t\t//printf(\""%c%c%c%c first sample at time %.3fms, last at %.3fms\\n\"", PRINTF_4CC(fourcc), 1000.0*first, 1000.0*last);\n \n-\tkey = GPMF_Key(gs);\n-\trepeat = GPMF_Repeat(gs);\n-\tif (rate == 0.0)\n-\t\trate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\t\tif (firstsampletime) *firstsampletime = first;\n \n-\tif (rate == 0.0)\n-\t{\n-\t\t*in = *out = 0.0;\n-\t\treturn 0.0;\n+\t\t\t\t\tif (lastsampletime) *lastsampletime = last;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tGPMF_CopyState(gs, &find_stream);\n-\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n-\t{\n-\t\toutsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\tinsamples = outsamples - repeat;\n+cleanup:\n+\tif (payload)\n+\t\tFreePayload(payload);\n+\tpayload = NULL;\n \n-\t\t*in = ((double)insamples / (double)rate);\n-\t\t*out = ((double)outsamples / (double)rate);\n-\t}\n-\telse\n-\t{\n-\t\t// might too costly in some applications read all the samples to determine the clock jitter, here I return the estimate from the MP4 track.\n-\t\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t}\n \treturn rate;\n }\n+""}<_**next**_>{""sha"": ""3556b663386372762d9d5eedfed43736c617e1e4"", ""filename"": ""demo/GPMF_mp4reader.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.h"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.h"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_mp4reader.h?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -64,6 +64,8 @@ typedef struct mp4object\n \tuint32_t meta_clockdemon, meta_clockcount;\n \tdouble basemetadataduration;\n \tFILE *mediafp;\n+\tuint64_t filesize;\n+\tuint64_t filepos;\n } mp4object;\n \n #define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n@@ -101,16 +103,15 @@ void CloseSource(size_t handle);\n float GetDuration(size_t handle);\n uint32_t GetNumberPayloads(size_t handle);\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);\n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index);\n void FreePayload(uint32_t *lastpayload);\n uint32_t GetPayloadSize(size_t handle, uint32_t index);\n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);\n \n #define GPMF_SAMPLE_RATE_FAST\t\t0\n #define GPMF_SAMPLE_RATE_PRECISE\t1\n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);\n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);\n \n #ifdef __cplusplus\n }""}","GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.
 {
 	if (ms)
 	{
		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 
		if (size + 2 <= nestsize) return GPMF_OK;
	}
	return GPMF_ERROR_BAD_STRUCTURE;
}
","GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.
 {
 	if (ms)
 	{
		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 
		if (size + 2 <= nestsize) return GPMF_OK;
	}
	return GPMF_ERROR_BAD_STRUCTURE;
}
",C,"		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
","		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
",,"@@ -2,7 +2,7 @@
  * 
  *  @brief GPMF Parser library
  *
- *  @version 1.2.1
+ *  @version 1.2.2
  * 
  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).
  *	
@@ -42,7 +42,7 @@ GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not byt
 {
 	if (ms)
 	{
-		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
+		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 ",gpmf-parser,341f12cd5b97ab419e53853ca00176457c9f1681,3e7d6eace490c87e7caf7e7e1153fc4879e8e08d,1,"GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.
 {
 	if (ms)
 	{
//flaw_line_below:
		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
//fix_flaw_line_below:
//		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 
		if (size + 2 <= nestsize) return GPMF_OK;
	}
	return GPMF_ERROR_BAD_STRUCTURE;
}
",182716,"GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.
 {
 	if (ms)
 	{
		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 
		if (size + 2 <= nestsize) return GPMF_OK;
	}
	return GPMF_ERROR_BAD_STRUCTURE;
}
","GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.
 {
 	if (ms)
 	{
		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 
		if (size + 2 <= nestsize) return GPMF_OK;
	}
	return GPMF_ERROR_BAD_STRUCTURE;
}
","The vulnerability in the original code arises from the use of an `int32_t` type for the `nestsize` variable, which can lead to incorrect behavior if `ms->nest_size[ms->nest_level]` returns a negative value, potentially causing an underflow when compared to `size + 2`. This could allow for unintended access to memory or incorrect validation of sizes. In the fixed code, `nestsize` is changed to `uint32_t`, ensuring that it can only hold non-negative values, thus preventing underflow and ensuring that the size validation logic operates correctly and safely within expected bounds.","The vulnerability in the original code stems from the use of a signed integer type, which can lead to negative values being processed. This can result in incorrect comparisons and potential underflow issues, allowing for unintended memory access or validation failures. Such behavior could compromise the integrity of the size validation logic, leading to security risks. The fix involved changing the variable type to an unsigned integer, ensuring that only non-negative values are considered. This change effectively prevents underflow and guarantees that the size validation operates within safe and expected limits, enhancing the overall robustness of the code.",2,5,3,2
35,35,182722,182722,,Remote,Not required,Partial,CVE-2019-15148,https://www.cvedetails.com/cve/CVE-2019-15148/,CWE-787,Medium,,,,2019-08-18,4.3,GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,2019-08-22,,236,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,341f12cd5b97ab419e53853ca00176457c9f1681,fixed many security issues with the too crude mp4 reader,139,demo/GPMF_mp4reader.c,"{""sha"": ""aacced95030afb75ffa8848a6865df96d58d90e8"", ""filename"": ""GPMF_parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/GPMF_parser.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library\n  *\n- *  @version 1.2.1\n+ *  @version 1.2.2\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -42,7 +42,7 @@ GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not byt\n {\n \tif (ms)\n \t{\n-\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n+\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n \t\tif (nestsize == 0 && ms->nest_level == 0)\n \t\t\tnestsize = ms->buffer_size_longs;\n ""}<_**next**_>{""sha"": ""63a786a31a1ed54333f71bccf805065db4e27599"", ""filename"": ""GPMF_parser.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.h"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/GPMF_parser.h"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/GPMF_parser.h?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,7 +2,7 @@\n  * \n  *  @brief GPMF Parser library include\n  * \n- *  @version 1.1.0\n+ *  @version 1.1.1\n  * \n  *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n  *\t\n@@ -126,7 +126,11 @@ typedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPr\n \tGPMF_KEY_UNITS =\t\t\tMAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \""RPM\"", \""MPH\"", \""km/h\"", etc)\n \tGPMF_KEY_SCALE =\t\t\tMAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.\n \tGPMF_KEY_TYPE =\t\t\t\tMAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures\n-\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload \t\n+\tGPMF_KEY_TIME_OFFSET =\t\tMAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)\n+\tGPMF_KEY_TIMING_OFFSET =\tMAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO\n+\tGPMF_KEY_TIME_STAMP =\t\tMAKEID('S','T','M','P'),//STMP - Time stamp for the first sample. \n+\tGPMF_KEY_TIME_STAMPS =\t\tMAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.) \n \tGPMF_KEY_TICK =\t\t\t\tMAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. \n \tGPMF_KEY_TOCK =\t\t\t\tMAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. \n \tGPMF_KEY_EMPTY_PAYLOADS =\tMAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)""}<_**next**_>{""sha"": ""dde13b401c9f23ea31cc864439ffc115f10792a0"", ""filename"": ""demo/GPMF_demo.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_demo.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_demo.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_demo.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -46,6 +46,12 @@ int main(int argc, char *argv[])\n \t}\n \n \tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n+\tif (mp4 == 0)\n+\t{\n+\t\tprintf(\""error: %s is an invalid MP4/MOV\\n\"", argv[1]);\n+\t\treturn -1;\n+\t}\n+\n //\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n \n \tmetadatalength = GetDuration(mp4);\n@@ -90,7 +96,7 @@ int main(int argc, char *argv[])\n \t\tfor (index = 0; index < payloads; index++)\n \t\t{\n \t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n-\t\t\tfloat in = 0.0, out = 0.0; //times\n+\t\t\tdouble in = 0.0, out = 0.0; //times\n \t\t\tpayload = GetPayload(mp4, payload, index);\n \t\t\tif (payload == NULL)\n \t\t\t\tgoto cleanup;\n@@ -238,9 +244,10 @@ int main(int argc, char *argv[])\n \t\t{\n \t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n \t\t\t{\n+\t\t\t\tdouble in = 0.0, out = 0.0;\n \t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n-\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n-\t\t\t\tprintf(\""%c%c%c%c sampling rate = %f Hz\\n\"", PRINTF_4CC(fourcc), rate);\n+\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\tprintf(\""%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\"", PRINTF_4CC(fourcc), rate, in, out);\n \t\t\t}\n \t\t}\n #endif""}<_**next**_>{""sha"": ""1b6d25f47837b61f57b4e3e999ae77aa0409924e"", ""filename"": ""demo/GPMF_mp4reader.c"", ""status"": ""modified"", ""additions"": 494, ""deletions"": 333, ""changes"": 827, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.c"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.c"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_mp4reader.c?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -2,15 +2,14 @@\n *\n *  @brief Way Too Crude MP4|MOV reader\n *\n-*  @version 1.2.1\n+*  @version 1.3.1\n *\n-*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n+*  (C) Copyright 2017-2019 GoPro Inc (http://gopro.com/).\n *\n-*  Licensed under the Apache License, Version 2.0 (the \""License\"");\n-*  you may not use this file except in compliance with the License.\n-*  You may obtain a copy of the License at\n-*\n-*      http://www.apache.org/licenses/LICENSE-2.0\n+*  Licensed under either:\n+*  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0\n+*  - MIT license, http://opensource.org/licenses/MIT\n+*  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \""AS IS\"" BASIS,\n@@ -20,21 +19,24 @@\n *\n */\n \n-/* This is not an elegant MP4 parser, only used to help demonstrate extraction of MP4 */\n-\n+/* This is not an elegant MP4 parser, only used to help demonstrate extraction of GPMF */\n \n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdint.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n #include \""GPMF_mp4reader.h\""\n \n #define PRINT_MP4_STRUCTURE\t\t0\n \n #ifdef WIN32\n-#define LONGSEEK  _fseeki64\n+#define LONGSEEK\t_fseeki64\n+#define stat64\t\t_stat64\n #else\n-#define LONGSEEK  fseeko\n+#define LONGSEEK\tfseeko\n #endif\n \n \n@@ -50,7 +52,6 @@ uint32_t GetNumberPayloads(size_t handle)\n \treturn 0;\n }\n \n-\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n@@ -63,31 +64,35 @@ uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n \n \t\tif (MP4buffer)\n \t\t{\n-\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n-\t\t\treturn MP4buffer;\n+\t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])\n+\t\t\t{\n+\t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n+\t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];\n+\t\t\t\treturn MP4buffer;\n+\t\t\t}\n \t\t}\n \t}\n \treturn NULL;\n }\n \n \n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n+void LongSeek(mp4object *mp4, int64_t offset)\n {\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return;\n-\n-\tuint32_t *MP4buffer = NULL;\n-\tif (index < mp4->indexcount && mp4->mediafp && payload)\n+\tif (mp4 && offset)\n \t{\n-\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n-\t\tfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n+\t\tif (mp4->filepos + offset < mp4->filesize)\n+\t\t{\n+\t\t\tLONGSEEK(mp4->mediafp, offset, SEEK_CUR);\n+\t\t\tmp4->filepos += offset;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tmp4->filepos = mp4->filesize;\n+\t\t}\n \t}\n-\treturn;\n }\n \n-\n-\n void FreePayload(uint32_t *lastpayload)\n {\n \tif (lastpayload)\n@@ -106,6 +111,7 @@ uint32_t GetPayloadSize(size_t handle, uint32_t index)\n \treturn 0;\n }\n \n+\n #define MAX_NEST_LEVEL\t20\n \n size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4\n@@ -115,6 +121,12 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \tmemset(mp4, 0, sizeof(mp4object));\n \n+\tstruct stat64 mp4stat;\n+\tstat64(filename, &mp4stat);\n+\tmp4->filesize = mp4stat.st_size;\n+\n+\tif (mp4->filesize < 64) return 0;\n+\n #ifdef _WINDOWS\n \tfopen_s(&mp4->mediafp, filename, \""rb\"");\n #else\n@@ -129,25 +141,27 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n \n+\n \t\tdo\n \t\t{\n \t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n \t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n-\t\t\tif (len == 8)\n+\t\t\tmp4->filepos += len;\n+\t\t\tif (len == 8 && mp4->filepos < mp4->filesize)\n \t\t\t{\n \t\t\t\tif (!VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n-\n-\t\t\t\t\tNESTSIZE(lastsize - 8);\n-\t\t\t\t\tcontinue;\n+\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n \n \t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n \t\t\t\t{\n-\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tlen = fread(&qtsize, 1, 8, mp4->mediafp);\n+\t\t\t\t\tmp4->filepos += len;\n \t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n \t\t\t\t}\n \t\t\t\telse\n@@ -168,9 +182,10 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||\n-\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a'))\n+\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a') ||\n+\t\t\t\t\tqttag == MAKEID('f', 'r', 'e', 'e'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -187,8 +202,6 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&\n \t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n-\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&\n \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&\n@@ -197,7 +210,7 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&\n \t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t}\n@@ -210,7 +223,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\n \t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -233,7 +248,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n+\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -244,10 +261,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n \n-\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's'))\n+\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))\n \t\t\t\t\t\t\ttype = temp;\n \n-\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr\n+\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over hldr\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \n@@ -267,10 +285,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\ttype = 0; // MP4\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsd\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -286,32 +305,35 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metastsc_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * 12);\n-\t\t\t\t\t\t\t\tif (mp4->metastsc)\n+\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tuint32_t total_stsc = num;\n-\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n-\n-\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));\n+\t\t\t\t\t\t\t\t\tif (mp4->metastsc)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n-\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n-\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n \n-\t\t\t\t\t\t\t\tif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.\n+\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n+\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n+\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsx\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -330,33 +352,44 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tmp4->metasize_count = num;\n \t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);\n-\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\tif (mp4->metasizes)\n+\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n+\t\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\tif (mp4->metasizes)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n-\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n-\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n+\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n+\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsz\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -369,93 +402,121 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n \t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tuint32_t metastco_count = num;\n+\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n+\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif(num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n-\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++; stsc_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse if (repeat == mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->indexcount)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stco_pos + 1 < metastco_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstsc_pos++;\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (num > 0)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n+\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -467,60 +528,79 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n \t\t\t\t\t\t\tnum = BYTESWAP32(num);\n+\n+\t\t\t\t\t\t\tif(num == 0)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n-\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n-\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n+\t\t\t\t\t\t\t\t\tif (mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n-\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n-\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n+\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n+\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n \t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n-\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n-\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n+\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n \t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n-\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n-\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n+\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n+\t\t\t\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n+\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", 0, (int)fileoffset, 0);\n+\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", 0, (int)fileoffset, 0);\n \n-\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n-\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n+\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n \t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n+\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n-\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n-\t\t\t\t\t\t\t\t\t\t\t\t//printf(\""%3d:%08x, delta = %08x\\n\"", num, (int)fileoffset, delta);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n \n-\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n+\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n-\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n-\n-\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t//size of null\n+\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n+\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t{\n@@ -538,10 +618,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -578,10 +659,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n+\t\t\t\t\t\t\tmp4->filepos += len;\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse\n-\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \n \t\t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\t}\n@@ -595,6 +677,15 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} while (len > 0);\n+\n+\t\tif (mp4)\n+\t\t{\n+\t\t\tif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)\n+\t\t\t{\n+\t\t\t\tCloseSource((size_t)mp4);\n+\t\t\t\tmp4 = NULL;\n+\t\t\t}\n+\t\t}\n \t}\n \telse\n \t{\n@@ -631,20 +722,32 @@ void CloseSource(size_t handle)\n }\n \n \n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0;\n+\tif (mp4 == NULL) return GPMF_ERROR_MEMORY;\n \n-\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;\n+\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;\n \n-\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\treturn 0;\n+\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n+\treturn GPMF_OK;\n }\n \n \n-\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)\n+{\n+    mp4object *mp4 = (mp4object *)handle;\n+    if (mp4 == NULL) return GPMF_ERROR_MEMORY;\n+    \n+    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;\n+\n+\t*in_numerator = (uint32_t)(index * mp4->basemetadataduration);\n+\t*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);\n+\t*denominator = (uint32_t)mp4->meta_clockdemon;\n+    \n+    return GPMF_OK;\n+}\n \n size_t OpenMP4SourceUDTA(char *filename)\n {\n@@ -661,7 +764,8 @@ size_t OpenMP4SourceUDTA(char *filename)\n \n \tif (mp4->mediafp)\n \t{\n-\t\tuint32_t qttag, qtsize32, len;\n+\t\tuint32_t qttag, qtsize32;\n+\t\tsize_t len;\n \t\tint32_t nest = 0;\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n@@ -674,7 +778,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t{\n \t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, lastsize - 8 - 8);\n \n \t\t\t\t\tNESTSIZE(lastsize - 8);\n \t\t\t\t\tcontinue;\n@@ -701,7 +805,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -725,7 +829,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n \t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n \t\t\t\t{\n-\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n+\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -740,7 +844,7 @@ size_t OpenMP4SourceUDTA(char *filename)\n }\n \n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n \tif (mp4 == NULL) return 0.0;\n@@ -750,221 +854,278 @@ double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n \tuint32_t testend = mp4->indexcount;\n \tdouble rate = 0.0;\n \n+\tuint32_t *payload;\n+\tuint32_t payloadsize;\n+\tint32_t ret;\n+\n \tif (mp4->indexcount < 1)\n \t\treturn 0.0;\n \n-\tif (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. \n-\t{\n-\t\tteststart++;\n-\t\ttestend--;\n-\t}\n-\n-\tuint32_t *payload = GetPayload(handle, NULL, teststart); // second payload\n-\tuint32_t payloadsize = GetPayloadSize(handle, teststart);\n-\tint32_t ret = GPMF_Init(ms, payload, payloadsize);\n+\tpayload = GetPayload(handle, NULL, teststart); \n+\tpayloadsize = GetPayloadSize(handle, teststart);\n+\tret = GPMF_Init(ms, payload, payloadsize);\n \n \tif (ret != GPMF_OK)\n \t\tgoto cleanup;\n \n \t{\n+\t\tuint64_t minimumtimestamp = 0;\n+\t\tuint64_t starttimestamp = 0;\n+\t\tuint64_t endtimestamp = 0;\n \t\tuint32_t startsamples = 0;\n \t\tuint32_t endsamples = 0;\n-\t\tuint32_t missing_samples = 0;\n+\t\tdouble intercept = 0.0;\n+\n+\n \n-\t\twhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\twhile (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t{\n-\t\t\tmissing_samples = 1;\n \t\t\tteststart++;\n \t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n \t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n \t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \t\t}\n \n-\t\tif (missing_samples)\n-\t\t{\n-\t\t\tteststart++;   //samples after sensor start are statistically the best\n-\t\t\tpayload = GetPayload(handle, payload, teststart);\n-\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n-\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t}\n-\n-\t\tif (ret == GPMF_OK)\n+\t\tif (ret == GPMF_OK && payload)\n \t\t{\n-\t\t\tuint32_t samples = GPMF_Repeat(ms);\n+\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n \t\t\tGPMF_stream find_stream;\n \t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n \n-\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\tstarttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\tif (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.\n \t\t\t{\n-\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n+\t\t\t\tGPMF_stream any_stream;\n+\t\t\t\tGPMF_Init(&any_stream, payload, payloadsize);\n+\n+\t\t\t\tminimumtimestamp = starttimestamp;\n+\t\t\t\twhile (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))\n+\t\t\t\t{\n+\t\t\t\t\tuint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));\n+\t\t\t\t\tif (timestamp < minimumtimestamp)\n+\t\t\t\t\t\tminimumtimestamp = timestamp;\n+\t\t\t\t}\n+\t\t\t}\n \n-\t\t\t\tpayload = GetPayload(handle, payload, testend); // second last payload\n+\t\t\ttestend = mp4->indexcount;\n+\t\t\tdo\n+\t\t\t{\n+\t\t\t\ttestend--;// last payload with the fourcc needed\n+\t\t\t\tpayload = GetPayload(handle, payload, testend);\n \t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n \t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n-\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\tgoto cleanup;\n+\t\t\t} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n-\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n+\t\t\telse // If there is no TSMP we have to count the samples.\n+\t\t\t{\n+\t\t\t\tuint32_t i;\n+\t\t\t\tfor (i = teststart; i <= testend; i++)\n \t\t\t\t{\n-\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n-\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tpayload = GetPayload(handle,payload, i); // second last payload\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, i);\n+\t\t\t\t\tif (GPMF_OK == GPMF_Init(ms, payload, payloadsize))\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\t\t\tendsamples += GPMF_PayloadSampleCount(ms);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (starttimestamp != 0)\n+\t\t\t{\n+\t\t\t\tuint32_t last_samples = GPMF_PayloadSampleCount(ms);\n+\t\t\t\tuint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;\n+\t\t\t\tdouble time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.\n+\n+\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\tendtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n+\n+\t\t\t\tif (endtimestamp)\n+\t\t\t\t{\n+\t\t\t\t\tdouble approxrate = 0.0;\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\tapproxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\t\t\t\t\tif (approxrate == 0.0)\n+\t\t\t\t\t\tapproxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n+\n+\n+\t\t\t\t\twhile (time_stamp_scale >= 1)\n \t\t\t\t\t{\n-\t\t\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\t\trate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);\n+\t\t\t\t\t\tif (rate*0.9 < approxrate && approxrate < rate*1.1)\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\ttime_stamp_scale *= 0.1;\n \t\t\t\t\t}\n+\t\t\t\t\tif (time_stamp_scale < 1.0) rate = 0.0;\n+\t\t\t\t\tintercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;\n \t\t\t\t}\n-\n-\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t}\n-\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n+\n+\t\t\tif (rate == 0.0) //Timestamps didn't help weren't available\n \t\t\t{\n-\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n-\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n-\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n-\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n+\t\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE))\n+\t\t\t\t{\n+\t\t\t\t\tif (endsamples > startsamples)\n+\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tsamples = 0;\n+\t\t\t\t\tif (rate == 0.0)\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \n-\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n+\t\t\t\t\tdouble in, out;\n+\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))\n+\t\t\t\t\t\tintercept = (double)-in * rate;\n+\t\t\t\t}\n+\t\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n \t\t\t\t{\n-\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n-\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n-\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n+\t\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n+\t\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n+\t\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n \n-\t\t\t\t\tif (ret != GPMF_OK)\n-\t\t\t\t\t\tgoto cleanup;\n+\t\t\t\t\tsamples = 0;\n \n-\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n+\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n \t\t\t\t\t{\n-\t\t\t\t\t\tGPMF_stream find_stream2;\n-\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\t\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n+\t\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n+\t\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \n-\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\tif (ret != GPMF_OK)\n+\t\t\t\t\t\t\tgoto cleanup;\n+\n+\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (repeatarray)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\tGPMF_stream find_stream2;\n+\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n+\n+\t\t\t\t\t\t\tpayloadcount++;\n \n-\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tsamples++;\n-\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\tdo\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\tsamples++;\n+\t\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tuint32_t repeat = GPMF_Repeat(ms);\n-\t\t\t\t\t\t\tsamples += repeat;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfloat in, out;\n+\t\t\t\t\t\t\t\tuint32_t repeat = GPMF_PayloadSampleCount(ms);\n+\t\t\t\t\t\t\t\tsamples += repeat;\n+\n+\t\t\t\t\t\t\t\tif (repeatarray)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tdouble in, out;\n \n-\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n-\t\t\t\t\t\t\t\tmeanY += (double)samples;\n+\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n+\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n-\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n-\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t\t\t\tmeanX += out;\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\trepeatarray[payloadpos] = 0;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n-\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n-\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n-\t\t\t\tif (repeatarray)\n-\t\t\t\t{\n-\t\t\t\t\tmeanY /= (double)payloadcount;\n-\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n+\t\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n+\t\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n+\t\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n+\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t{\n-\t\t\t\t\t\tfloat in, out;\n-\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n+\t\t\t\t\t\tmeanY /= (double)payloadcount;\n+\t\t\t\t\t\tmeanX /= (double)payloadcount;\n \n-\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n-\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n-\t\t\t\t\t}\n+\t\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tdouble in, out;\n+\t\t\t\t\t\t\tif (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n+\t\t\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\tslope = top / bot;\n+\t\t\t\t\t\trate = slope;\n \n+\t\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tintercept = meanY - slope * meanX;\n #if 0\n-\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n+\t\t\t\t\t\tprintf(\""%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);\n+\t\t\t\t\t\tprintf(\""%c%c%c%c first sample at time %.3fms\\n\"", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);\n+#endif\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tdouble intercept;\n-\t\t\t\t\t\tintercept = meanY - slope*meanX;\n-\t\t\t\t\t\tprintf(\""%c%c%c%c start offset = %f (%.3fms)\\n\"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n+\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t\t\t}\n-#endif\n-\t\t\t\t\trate = slope;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n-\t\t\t\t}\n-\n-\t\t\t\tfree(repeatarray);\n \n-\t\t\t\tgoto cleanup;\n+\t\t\t\t\tfree(repeatarray);\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t}\n \n-cleanup:\n-\tif (payload) \n-\t{\n-\t\tFreePayload(payload);\n-\t\tpayload = NULL;\n-\t}\n-\n-\treturn rate;\n-}\n+\t\t\tif (firstsampletime && lastsampletime)\n+\t\t\t{\n+\t\t\t\tuint32_t endpayload = mp4->indexcount;\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tendpayload--;// last payload with the fourcc needed\n+\t\t\t\t\tpayload = GetPayload(handle, payload, endpayload);\n+\t\t\t\t\tpayloadsize = GetPayloadSize(handle, endpayload);\n+\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n+\t\t\t\t} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n \n+\t\t\t\tif (endpayload > 0 && ret == GPMF_OK)\n+\t\t\t\t{\n+\t\t\t\t\tuint32_t totalsamples = endsamples - startsamples;\n+\t\t\t\t\tfloat timo = 0.0;\n \n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)\n-{\n-\tmp4object *mp4 = (mp4object *)handle;\n-\tif (mp4 == NULL) return 0.0;\n+\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n+\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))\n+\t\t\t\t\t\tGPMF_FormattedData(&find_stream, &timo, 4, 0, 1);\n \n-\tuint32_t key, insamples;\n-\tuint32_t repeat, outsamples;\n-\tGPMF_stream find_stream;\n+\t\t\t\t\tdouble first, last;\n+\t\t\t\t\tfirst = -intercept / rate - timo;\n+\t\t\t\t\tlast = first + (double)totalsamples / rate;\n \n-\tif (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;\n+\t\t\t\t\t//printf(\""%c%c%c%c first sample at time %.3fms, last at %.3fms\\n\"", PRINTF_4CC(fourcc), 1000.0*first, 1000.0*last);\n \n-\tkey = GPMF_Key(gs);\n-\trepeat = GPMF_Repeat(gs);\n-\tif (rate == 0.0)\n-\t\trate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);\n+\t\t\t\t\tif (firstsampletime) *firstsampletime = first;\n \n-\tif (rate == 0.0)\n-\t{\n-\t\t*in = *out = 0.0;\n-\t\treturn 0.0;\n+\t\t\t\t\tif (lastsampletime) *lastsampletime = last;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tGPMF_CopyState(gs, &find_stream);\n-\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n-\t{\n-\t\toutsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n-\t\tinsamples = outsamples - repeat;\n+cleanup:\n+\tif (payload)\n+\t\tFreePayload(payload);\n+\tpayload = NULL;\n \n-\t\t*in = ((double)insamples / (double)rate);\n-\t\t*out = ((double)outsamples / (double)rate);\n-\t}\n-\telse\n-\t{\n-\t\t// might too costly in some applications read all the samples to determine the clock jitter, here I return the estimate from the MP4 track.\n-\t\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n-\t}\n \treturn rate;\n }\n+""}<_**next**_>{""sha"": ""3556b663386372762d9d5eedfed43736c617e1e4"", ""filename"": ""demo/GPMF_mp4reader.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/gopro/gpmf-parser/blob/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.h"", ""raw_url"": ""https://github.com/gopro/gpmf-parser/raw/341f12cd5b97ab419e53853ca00176457c9f1681/demo/GPMF_mp4reader.h"", ""contents_url"": ""https://api.github.com/repos/gopro/gpmf-parser/contents/demo/GPMF_mp4reader.h?ref=341f12cd5b97ab419e53853ca00176457c9f1681"", ""patch"": ""@@ -64,6 +64,8 @@ typedef struct mp4object\n \tuint32_t meta_clockdemon, meta_clockcount;\n \tdouble basemetadataduration;\n \tFILE *mediafp;\n+\tuint64_t filesize;\n+\tuint64_t filepos;\n } mp4object;\n \n #define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n@@ -101,16 +103,15 @@ void CloseSource(size_t handle);\n float GetDuration(size_t handle);\n uint32_t GetNumberPayloads(size_t handle);\n uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);\n-void SavePayload(size_t handle, uint32_t *payload, uint32_t index);\n void FreePayload(uint32_t *lastpayload);\n uint32_t GetPayloadSize(size_t handle, uint32_t index);\n-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload\n+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);\n \n #define GPMF_SAMPLE_RATE_FAST\t\t0\n #define GPMF_SAMPLE_RATE_PRECISE\t1\n \n-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);\n-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed\n+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);\n \n #ifdef __cplusplus\n }""}"," size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
{
	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
	if (mp4 == NULL) return 0;
 
 	memset(mp4, 0, sizeof(mp4object));
 
	struct stat64 mp4stat;
	stat64(filename, &mp4stat);
	mp4->filesize = mp4stat.st_size;

	if (mp4->filesize < 64) return 0;

 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
	mp4->mediafp = fopen(filename, ""rb"");
#endif

	if (mp4->mediafp)
	{
		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
		size_t len;
		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 

 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
			mp4->filepos += len;
			if (len == 8 && mp4->filepos < mp4->filesize)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
					CloseSource((size_t)mp4);
					mp4 = NULL;
					break;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
					len = fread(&qtsize, 1, 8, mp4->mediafp);
					mp4->filepos += len;
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
					qtsize = qtsize32;

				nest++;

				if (qtsize < 8) break;
				if (nest >= MAX_NEST_LEVEL) break;

				nestsize[nest] = qtsize;
				lastsize = qtsize;

#if PRINT_MP4_STRUCTURE	

				for (int i = 1; i < nest; i++) printf(""    "");
				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
					qttag == MAKEID('u', 'd', 't', 'a') ||
					qttag == MAKEID('f', 'r', 'e', 'e'))
 				{
					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 
					continue;
				}
#else
				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
					qttag != MAKEID('m', 'v', 'h', 'd') &&
					qttag != MAKEID('t', 'r', 'a', 'k') &&
					qttag != MAKEID('m', 'd', 'i', 'a') &&
					qttag != MAKEID('m', 'd', 'h', 'd') &&
					qttag != MAKEID('m', 'i', 'n', 'f') &&
					qttag != MAKEID('g', 'm', 'i', 'n') &&
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
					qttag != MAKEID('s', 't', 's', 'z') &&
					qttag != MAKEID('s', 't', 'c', 'o') &&
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 				}
				else
#endif
					if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header
					{
						len = fread(&skip, 1, 4, mp4->mediafp);
						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header
					{
						media_header md;
						len = fread(&md, 1, sizeof(md), mp4->mediafp);
						if (len == sizeof(md))
						{
							md.creation_time = BYTESWAP32(md.creation_time);
							md.modification_time = BYTESWAP32(md.modification_time);
							md.time_scale = BYTESWAP32(md.time_scale);
							md.duration = BYTESWAP32(md.duration);

							mp4->trak_clockdemon = md.time_scale;
							mp4->trak_clockcount = md.duration;

							if (mp4->videolength == 0.0) // Get the video length from the first track
							{
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr
					{
						uint32_t temp;
						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
 							type = temp;
 
						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over hldr
 
 						NESTSIZE(qtsize);
 
					}
					else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata
					{
						if (type == traktype) //like meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
							if (len == 16)
							{
								if (subtype != traksubtype) // MP4 metadata 
								{
 									type = 0; // MP4
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsd
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 12 <= qtsize - 8 - len)
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
								if (num > 0)
 								{
									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
									if (mp4->metastsc)
 									{
										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
 
										do
										{
											num--;
											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
										} while (num > 0);
									}
								}
								else
 								{
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsx
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes
					{
						if (type == traktype) // meta
						{
							uint32_t equalsamplesize;

							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 4 <= qtsize - 8 - len)
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
								if(num > 0)
 								{
									mp4->metasizes = (uint32_t *)malloc(num * 4);
									if (mp4->metasizes)
 									{
										if (equalsamplesize == 0)
 										{
											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
											} while (num > 0);
										}
										else
 										{
											equalsamplesize = BYTESWAP32(equalsamplesize);
											do
											{
												num--;
												mp4->metasizes[num] = equalsamplesize;
											} while (num > 0);
										}
 									}
 								}
								else
								{
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsz
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
								uint32_t metastco_count = num;

 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if(num > 0)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
 										{
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
 											{
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												int repeat = 1;
												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												do
 												{
													num--;
													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);

												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
												num = 1;
												while (num < mp4->indexcount)
 												{
													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
													{
														if ((uint32_t)stco_pos + 1 < metastco_count)
														{
															stco_pos++;
															fileoffset = (uint64_t)metaoffsets32[stco_pos];
														}
														else
														{
															fileoffset += (uint64_t)mp4->metasizes[num - 1];
														}
														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
																stsc_pos++;

														repeat = 1;
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
														repeat++;
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
 												}
 
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
 
												free(metaoffsets32);
 											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if (num > 0)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
 										{
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
 											{
												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												len += readlen;
												do
												{
													num--;
													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);
 
												free(metaoffsets32);
											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}

					else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);

							if(num == 0)
							{
								//size of null
								CloseSource((size_t)mp4);
								mp4 = NULL;
								break;
							}

 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if (mp4->metasize_count)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
										if (mp4->metaoffsets)
 										{
											uint64_t *metaoffsets64 = NULL;
											metaoffsets64 = (uint64_t *)malloc(num * 8);
											if (metaoffsets64)
 											{
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
												do
												{
													num--;
													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
												} while (num > 0);
 
												fileoffset = metaoffsets64[0];
												mp4->metaoffsets[0] = fileoffset;
												//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
 
												num = 1;
												while (num < mp4->metasize_count)
 												{
													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
													{
														stco_pos++;
														fileoffset = (uint64_t)metaoffsets64[stco_pos];
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
 												}
 
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
 
												free(metaoffsets64);
 											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 								else
 								{
									mp4->indexcount = num;
									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
									{
										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
										do
										{
											num--;
											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
										} while (num > 0);
 									}
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples
					{
						if (type == traktype) // meta 
						{
							uint32_t totaldur = 0, samples = 0;
							int32_t entries = 0;
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
							num = BYTESWAP32(num);
							if (num * 8 <= qtsize - 8 - len)
							{
								entries = num;

								mp4->meta_clockdemon = mp4->trak_clockdemon;
								mp4->meta_clockcount = mp4->trak_clockcount;

								while (entries > 0)
								{
									int32_t samplecount;
									int32_t duration;
									len += fread(&samplecount, 1, 4, mp4->mediafp);
									samplecount = BYTESWAP32(samplecount);
									len += fread(&duration, 1, 4, mp4->mediafp);
									duration = BYTESWAP32(duration);

									samples += samplecount;
									entries--;

									totaldur += duration;
									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else
					{
						NESTSIZE(8);
					}
			}
			else
			{
 				break;
 			}
 		} while (len > 0);

		if (mp4)
		{
			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
			{
				CloseSource((size_t)mp4);
				mp4 = NULL;
			}
		}
 	}
 	else
 	{

		free(mp4);
		mp4 = NULL;
	}

	return (size_t)mp4;
}
"," size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
{
	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
	if (mp4 == NULL) return 0;
 
 	memset(mp4, 0, sizeof(mp4object));
 
 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
	mp4->mediafp = fopen(filename, ""rb"");
#endif

	if (mp4->mediafp)
	{
		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
		size_t len;
		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 
 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
			if (len == 8)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
					NESTSIZE(lastsize - 8);
					continue;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
					fread(&qtsize, 1, 8, mp4->mediafp);
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
					qtsize = qtsize32;

				nest++;

				if (qtsize < 8) break;
				if (nest >= MAX_NEST_LEVEL) break;

				nestsize[nest] = qtsize;
				lastsize = qtsize;

#if PRINT_MP4_STRUCTURE	

				for (int i = 1; i < nest; i++) printf(""    "");
				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
					qttag == MAKEID('u', 'd', 't', 'a'))
 				{
					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
 
 					NESTSIZE(qtsize);
 
					continue;
				}
#else
				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
					qttag != MAKEID('m', 'v', 'h', 'd') &&
					qttag != MAKEID('t', 'r', 'a', 'k') &&
					qttag != MAKEID('m', 'd', 'i', 'a') &&
					qttag != MAKEID('m', 'd', 'h', 'd') &&
					qttag != MAKEID('m', 'i', 'n', 'f') &&
					qttag != MAKEID('g', 'm', 'i', 'n') &&
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
					qttag != MAKEID('s', 't', 's', 'z') &&
					qttag != MAKEID('s', 't', 'c', 'o') &&
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 					NESTSIZE(qtsize);
 				}
				else
#endif
					if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header
					{
						len = fread(&skip, 1, 4, mp4->mediafp);
						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header
					{
						media_header md;
						len = fread(&md, 1, sizeof(md), mp4->mediafp);
						if (len == sizeof(md))
						{
							md.creation_time = BYTESWAP32(md.creation_time);
							md.modification_time = BYTESWAP32(md.modification_time);
							md.time_scale = BYTESWAP32(md.time_scale);
							md.duration = BYTESWAP32(md.duration);

							mp4->trak_clockdemon = md.time_scale;
							mp4->trak_clockcount = md.duration;

							if (mp4->videolength == 0.0) // Get the video length from the first track
							{
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr
					{
						uint32_t temp;
						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
						if (temp != MAKEID('a', 'l', 'i', 's'))
 							type = temp;
 
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr
 
 						NESTSIZE(qtsize);
 
					}
					else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata
					{
						if (type == traktype) //like meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
							if (len == 16)
							{
								if (subtype != traksubtype) // MP4 metadata 
								{
 									type = 0; // MP4
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 12 <= qtsize - 8 - len)
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
								if (mp4->metastsc)
 								{
									uint32_t total_stsc = num;
									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
									do
 									{
										num--;
										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
									} while (num > 0);
								}
 
								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.
 								{
									if (mp4->metastsc) free(mp4->metastsc);
									mp4->metastsc = NULL;
									mp4->metastsc_count = 0;
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes
					{
						if (type == traktype) // meta
						{
							uint32_t equalsamplesize;

							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 4 <= qtsize - 8 - len)
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
								mp4->metasizes = (uint32_t *)malloc(num * 4);
								if (mp4->metasizes)
 								{
									if (equalsamplesize == 0)
 									{
										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
										do
 										{
											num--;
											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
										} while (num > 0);
									}
									else
									{
										equalsamplesize = BYTESWAP32(equalsamplesize);
										do
 										{
											num--;
											mp4->metasizes[num] = equalsamplesize;
										} while (num > 0);
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											int repeat = 1;
											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
											num = 1;
											while (num < mp4->metasize_count)
 											{
												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
 												{
													stco_pos++; stsc_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else if (repeat == mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else
 												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
													repeat++;
 												}
 
												mp4->metaoffsets[num] = fileoffset;
 
												num++;
 											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets32);
 										}
 									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
 									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										{
											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											len += readlen;
											do
 											{
												num--;
												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
 
											free(metaoffsets32);
 										}
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}

					else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									{
										uint64_t *metaoffsets64 = NULL;
										metaoffsets64 = (uint64_t *)malloc(num * 8);
										if (metaoffsets64)
 										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
											do
 											{
												num--;
												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
											} while (num > 0);
 
											fileoffset = metaoffsets64[0];
											mp4->metaoffsets[0] = fileoffset;
 
											num = 1;
											while (num < mp4->metasize_count)
											{
												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets64[stco_pos];
												}
												else
 												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
 												}
 
												mp4->metaoffsets[num] = fileoffset;
 
												num++;
 											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets64);
 										}
 									}
 								}
 								else
 								{
									mp4->indexcount = num;
									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
									{
										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
										do
										{
											num--;
											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
										} while (num > 0);
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples
					{
						if (type == traktype) // meta 
						{
							uint32_t totaldur = 0, samples = 0;
							int32_t entries = 0;
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
							num = BYTESWAP32(num);
							if (num * 8 <= qtsize - 8 - len)
							{
								entries = num;

								mp4->meta_clockdemon = mp4->trak_clockdemon;
								mp4->meta_clockcount = mp4->trak_clockcount;

								while (entries > 0)
								{
									int32_t samplecount;
									int32_t duration;
									len += fread(&samplecount, 1, 4, mp4->mediafp);
									samplecount = BYTESWAP32(samplecount);
									len += fread(&duration, 1, 4, mp4->mediafp);
									duration = BYTESWAP32(duration);

									samples += samplecount;
									entries--;

									totaldur += duration;
									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else
					{
						NESTSIZE(8);
					}
			}
			else
			{
 				break;
 			}
 		} while (len > 0);
 	}
 	else
 	{

		free(mp4);
		mp4 = NULL;
	}

	return (size_t)mp4;
}
",C,"	struct stat64 mp4stat;
	stat64(filename, &mp4stat);
	mp4->filesize = mp4stat.st_size;

	if (mp4->filesize < 64) return 0;


			mp4->filepos += len;
			if (len == 8 && mp4->filepos < mp4->filesize)
					CloseSource((size_t)mp4);
					mp4 = NULL;
					break;
					len = fread(&qtsize, 1, 8, mp4->mediafp);
					mp4->filepos += len;
					qttag == MAKEID('u', 'd', 't', 'a') ||
					qttag == MAKEID('f', 'r', 'e', 'e'))
					LongSeek(mp4, qtsize - 8);
					LongSeek(mp4, qtsize - 8);

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over hldr
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsd
							LongSeek(mp4, qtsize - 8);
								if (num > 0)
									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
									if (mp4->metastsc)
										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
										do
										{
											num--;
											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
										} while (num > 0);
									}
								}
								else
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsx
							LongSeek(mp4, qtsize - 8);
								if(num > 0)
									mp4->metasizes = (uint32_t *)malloc(num * 4);
									if (mp4->metasizes)
										if (equalsamplesize == 0)
											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
											} while (num > 0);
										}
										else
											equalsamplesize = BYTESWAP32(equalsamplesize);
											do
											{
												num--;
												mp4->metasizes[num] = equalsamplesize;
											} while (num > 0);
										}
								else
								{
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
								}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsz
							LongSeek(mp4, qtsize - 8);
								uint32_t metastco_count = num;

									mp4->indexcount = num;
									if(num > 0)
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												int repeat = 1;
												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												do
													num--;
													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);

												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
												num = 1;
												while (num < mp4->indexcount)
													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
													{
														if ((uint32_t)stco_pos + 1 < metastco_count)
														{
															stco_pos++;
															fileoffset = (uint64_t)metaoffsets32[stco_pos];
														}
														else
														{
															fileoffset += (uint64_t)mp4->metasizes[num - 1];
														}
														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
																stsc_pos++;

														repeat = 1;
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
														repeat++;
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
												free(metaoffsets32);
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
									if (num > 0)
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												len += readlen;
												do
												{
													num--;
													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);
												free(metaoffsets32);
											}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
							LongSeek(mp4, qtsize - 8);

							if(num == 0)
							{
								//size of null
								CloseSource((size_t)mp4);
								mp4 = NULL;
								break;
							}

									if (mp4->metasize_count)
										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
										if (mp4->metaoffsets)
											uint64_t *metaoffsets64 = NULL;
											metaoffsets64 = (uint64_t *)malloc(num * 8);
											if (metaoffsets64)
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
												do
												{
													num--;
													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
												} while (num > 0);
												fileoffset = metaoffsets64[0];
												mp4->metaoffsets[0] = fileoffset;
												//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
												num = 1;
												while (num < mp4->metasize_count)
													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
													{
														stco_pos++;
														fileoffset = (uint64_t)metaoffsets64[stco_pos];
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
												free(metaoffsets64);
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
							LongSeek(mp4, qtsize - 8);
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
							LongSeek(mp4, qtsize - 8);

		if (mp4)
		{
			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
			{
				CloseSource((size_t)mp4);
				mp4 = NULL;
			}
		}
","			if (len == 8)
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
					NESTSIZE(lastsize - 8);
					continue;
					fread(&qtsize, 1, 8, mp4->mediafp);
					qttag == MAKEID('u', 'd', 't', 'a'))
					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
					qttag != MAKEID('a', 'l', 'i', 's') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
						if (temp != MAKEID('a', 'l', 'i', 's'))
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
								if (mp4->metastsc)
									uint32_t total_stsc = num;
									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
									do
										num--;
										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
									} while (num > 0);
								}
								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.
									if (mp4->metastsc) free(mp4->metastsc);
									mp4->metastsc = NULL;
									mp4->metastsc_count = 0;
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
								mp4->metasizes = (uint32_t *)malloc(num * 4);
								if (mp4->metasizes)
									if (equalsamplesize == 0)
										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
										do
											num--;
											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
										} while (num > 0);
									}
									else
									{
										equalsamplesize = BYTESWAP32(equalsamplesize);
										do
											num--;
											mp4->metasizes[num] = equalsamplesize;
										} while (num > 0);
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
									mp4->indexcount = mp4->metasize_count;
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											int repeat = 1;
											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
											num = 1;
											while (num < mp4->metasize_count)
												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
													stco_pos++; stsc_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else if (repeat == mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
													repeat++;
												mp4->metaoffsets[num] = fileoffset;
												num++;
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets32);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											len += readlen;
											do
												num--;
												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
											free(metaoffsets32);
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
										uint64_t *metaoffsets64 = NULL;
										metaoffsets64 = (uint64_t *)malloc(num * 8);
										if (metaoffsets64)
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
											do
												num--;
												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
											} while (num > 0);
											fileoffset = metaoffsets64[0];
											mp4->metaoffsets[0] = fileoffset;
											num = 1;
											while (num < mp4->metasize_count)
											{
												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets64[stco_pos];
												}
												else
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
												mp4->metaoffsets[num] = fileoffset;
												num++;
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets64);
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
",,"@@ -2,15 +2,14 @@
 *
 *  @brief Way Too Crude MP4|MOV reader
 *
-*  @version 1.2.1
+*  @version 1.3.1
 *
-*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).
+*  (C) Copyright 2017-2019 GoPro Inc (http://gopro.com/).
 *
-*  Licensed under the Apache License, Version 2.0 (the ""License"");
-*  you may not use this file except in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
+*  Licensed under either:
+*  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0
+*  - MIT license, http://opensource.org/licenses/MIT
+*  at your option.
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
@@ -20,21 +19,24 @@
 *
 */
 
-/* This is not an elegant MP4 parser, only used to help demonstrate extraction of MP4 */
-
+/* This is not an elegant MP4 parser, only used to help demonstrate extraction of GPMF */
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
 #include ""GPMF_mp4reader.h""
 
 #define PRINT_MP4_STRUCTURE		0
 
 #ifdef WIN32
-#define LONGSEEK  _fseeki64
+#define LONGSEEK	_fseeki64
+#define stat64		_stat64
 #else
-#define LONGSEEK  fseeko
+#define LONGSEEK	fseeko
 #endif
 
 
@@ -50,7 +52,6 @@ uint32_t GetNumberPayloads(size_t handle)
 	return 0;
 }
 
-
 uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)
 {
 	mp4object *mp4 = (mp4object *)handle;
@@ -63,31 +64,35 @@ uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)
 
 		if (MP4buffer)
 		{
-			LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
-			fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);
-			return MP4buffer;
+			if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])
+			{
+				LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
+				fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);
+				mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];
+				return MP4buffer;
+			}
 		}
 	}
 	return NULL;
 }
 
 
-void SavePayload(size_t handle, uint32_t *payload, uint32_t index)
+void LongSeek(mp4object *mp4, int64_t offset)
 {
-	mp4object *mp4 = (mp4object *)handle;
-	if (mp4 == NULL) return;
-
-	uint32_t *MP4buffer = NULL;
-	if (index < mp4->indexcount && mp4->mediafp && payload)
+	if (mp4 && offset)
 	{
-		LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
-		fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);
+		if (mp4->filepos + offset < mp4->filesize)
+		{
+			LONGSEEK(mp4->mediafp, offset, SEEK_CUR);
+			mp4->filepos += offset;
+		}
+		else
+		{
+			mp4->filepos = mp4->filesize;
+		}
 	}
-	return;
 }
 
-
-
 void FreePayload(uint32_t *lastpayload)
 {
 	if (lastpayload)
@@ -106,6 +111,7 @@ uint32_t GetPayloadSize(size_t handle, uint32_t index)
 	return 0;
 }
 
+
 #define MAX_NEST_LEVEL	20
 
 size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
@@ -115,6 +121,12 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 
 	memset(mp4, 0, sizeof(mp4object));
 
+	struct stat64 mp4stat;
+	stat64(filename, &mp4stat);
+	mp4->filesize = mp4stat.st_size;
+
+	if (mp4->filesize < 64) return 0;
+
 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
@@ -129,25 +141,27 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 
+
 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
-			if (len == 8)
+			mp4->filepos += len;
+			if (len == 8 && mp4->filepos < mp4->filesize)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
-					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
-
-					NESTSIZE(lastsize - 8);
-					continue;
+					CloseSource((size_t)mp4);
+					mp4 = NULL;
+					break;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
-					fread(&qtsize, 1, 8, mp4->mediafp);
+					len = fread(&qtsize, 1, 8, mp4->mediafp);
+					mp4->filepos += len;
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
@@ -168,9 +182,10 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
-					qttag == MAKEID('u', 'd', 't', 'a'))
+					qttag == MAKEID('u', 'd', 't', 'a') ||
+					qttag == MAKEID('f', 'r', 'e', 'e'))
 				{
-					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
+					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 
@@ -187,8 +202,6 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
-					qttag != MAKEID('a', 'l', 'i', 's') &&
-					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
@@ -197,7 +210,7 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
-					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 				}
@@ -210,7 +223,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
-						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
+
+						mp4->filepos += len;
+						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
@@ -233,7 +248,9 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}
-						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
+
+						mp4->filepos += len;
+						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
@@ -244,10 +261,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
-						if (temp != MAKEID('a', 'l', 'i', 's'))
+						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
 							type = temp;
 
-						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr
+						mp4->filepos += len;
+						LongSeek(mp4, qtsize - 8 - len); // skip over hldr
 
 						NESTSIZE(qtsize);
 
@@ -267,10 +285,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 									type = 0; // MP4
 								}
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stsd
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -286,32 +305,35 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
-								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
-								if (mp4->metastsc)
+								if (num > 0)
 								{
-									uint32_t total_stsc = num;
-									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
-
-									do
+									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
+									if (mp4->metastsc)
 									{
-										num--;
-										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
-										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
-										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
-									} while (num > 0);
-								}
+										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
 
-								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.
+										do
+										{
+											num--;
+											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
+											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
+											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
+										} while (num > 0);
+									}
+								}
+								else
 								{
-									if (mp4->metastsc) free(mp4->metastsc);
-									mp4->metastsc = NULL;
-									mp4->metastsc_count = 0;
+									//size of null
+									CloseSource((size_t)mp4);
+									mp4 = NULL;
+									break;
 								}
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stsx
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -330,33 +352,44 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
-								mp4->metasizes = (uint32_t *)malloc(num * 4);
-								if (mp4->metasizes)
+								if(num > 0)
 								{
-									if (equalsamplesize == 0)
+									mp4->metasizes = (uint32_t *)malloc(num * 4);
+									if (mp4->metasizes)
 									{
-										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
-										do
+										if (equalsamplesize == 0)
 										{
-											num--;
-											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
-										} while (num > 0);
-									}
-									else
-									{
-										equalsamplesize = BYTESWAP32(equalsamplesize);
-										do
+											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
+											do
+											{
+												num--;
+												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
+											} while (num > 0);
+										}
+										else
 										{
-											num--;
-											mp4->metasizes[num] = equalsamplesize;
-										} while (num > 0);
+											equalsamplesize = BYTESWAP32(equalsamplesize);
+											do
+											{
+												num--;
+												mp4->metasizes[num] = equalsamplesize;
+											} while (num > 0);
+										}
 									}
 								}
+								else
+								{
+									//size of null
+									CloseSource((size_t)mp4);
+									mp4 = NULL;
+									break;
+								}
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stsz
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -369,93 +402,121 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
+								uint32_t metastco_count = num;
+
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
-									mp4->indexcount = mp4->metasize_count;
+									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
-									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
-									if (mp4->metaoffsets)
+									if(num > 0)
 									{
-										uint32_t *metaoffsets32 = NULL;
-										metaoffsets32 = (uint32_t *)malloc(num * 4);
-										if (metaoffsets32)
+										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
+										if (mp4->metaoffsets)
 										{
-											uint64_t fileoffset = 0;
-											int stsc_pos = 0;
-											int stco_pos = 0;
-											int repeat = 1;
-											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
-											do
-											{
-												num--;
-												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
-											} while (num > 0);
-
-											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
-											num = 1;
-											while (num < mp4->metasize_count)
+											uint32_t *metaoffsets32 = NULL;
+											metaoffsets32 = (uint32_t *)malloc(num * 4);
+											if (metaoffsets32)
 											{
-												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
+												uint64_t fileoffset = 0;
+												int stsc_pos = 0;
+												int stco_pos = 0;
+												int repeat = 1;
+												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
+												do
 												{
-													stco_pos++; stsc_pos++;
-													fileoffset = (uint64_t)metaoffsets32[stco_pos];
-													repeat = 1;
-												}
-												else if (repeat == mp4->metastsc[stsc_pos].samples)
-												{
-													stco_pos++;
-													fileoffset = (uint64_t)metaoffsets32[stco_pos];
-													repeat = 1;
-												}
-												else
+													num--;
+													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
+												} while (num > 0);
+
+												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
+												num = 1;
+												while (num < mp4->indexcount)
 												{
-													fileoffset += (uint64_t)mp4->metasizes[num - 1];
-													repeat++;
+													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
+													{
+														if ((uint32_t)stco_pos + 1 < metastco_count)
+														{
+															stco_pos++;
+															fileoffset = (uint64_t)metaoffsets32[stco_pos];
+														}
+														else
+														{
+															fileoffset += (uint64_t)mp4->metasizes[num - 1];
+														}
+														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
+															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
+																stsc_pos++;
+
+														repeat = 1;
+													}
+													else
+													{
+														fileoffset += (uint64_t)mp4->metasizes[num - 1];
+														repeat++;
+													}
+
+													mp4->metaoffsets[num] = fileoffset;
+													//int delta = metaoffsets[num] - metaoffsets[num - 1];
+													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
+
+													num++;
 												}
 
-												mp4->metaoffsets[num] = fileoffset;
-												//int delta = metaoffsets[num] - metaoffsets[num - 1];
-												//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
+												if (mp4->metastsc) free(mp4->metastsc);
+												mp4->metastsc = NULL;
+												mp4->metastsc_count = 0;
 
-												num++;
+												free(metaoffsets32);
 											}
-
-											if (mp4->metastsc) free(mp4->metastsc);
-											mp4->metastsc = NULL;
-											mp4->metastsc_count = 0;
-
-											free(metaoffsets32);
 										}
 									}
+									else
+									{
+										//size of null
+										CloseSource((size_t)mp4);
+										mp4 = NULL;
+										break;
+									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
-									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
-									if (mp4->metaoffsets)
+									if (num > 0)
 									{
-										uint32_t *metaoffsets32 = NULL;
-										metaoffsets32 = (uint32_t *)malloc(num * 4);
-										if (metaoffsets32)
+										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
+										if (mp4->metaoffsets)
 										{
-											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
-											len += readlen;
-											do
+											uint32_t *metaoffsets32 = NULL;
+											metaoffsets32 = (uint32_t *)malloc(num * 4);
+											if (metaoffsets32)
 											{
-												num--;
-												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
-											} while (num > 0);
+												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
+												len += readlen;
+												do
+												{
+													num--;
+													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
+												} while (num > 0);
 
-											free(metaoffsets32);
+												free(metaoffsets32);
+											}
 										}
 									}
+									else
+									{
+										//size of null
+										CloseSource((size_t)mp4);
+										mp4 = NULL;
+										break;
+									}
 								}
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -467,60 +528,79 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
+
+							if(num == 0)
+							{
+								//size of null
+								CloseSource((size_t)mp4);
+								mp4 = NULL;
+								break;
+							}
+
 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
-									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
-									if (mp4->metaoffsets)
+									if (mp4->metasize_count)
 									{
-										uint64_t *metaoffsets64 = NULL;
-										metaoffsets64 = (uint64_t *)malloc(num * 8);
-										if (metaoffsets64)
+										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
+										if (mp4->metaoffsets)
 										{
-											uint64_t fileoffset = 0;
-											int stsc_pos = 0;
-											int stco_pos = 0;
-											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
-											do
+											uint64_t *metaoffsets64 = NULL;
+											metaoffsets64 = (uint64_t *)malloc(num * 8);
+											if (metaoffsets64)
 											{
-												num--;
-												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
-											} while (num > 0);
+												uint64_t fileoffset = 0;
+												int stsc_pos = 0;
+												int stco_pos = 0;
+												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
+												do
+												{
+													num--;
+													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
+												} while (num > 0);
 
-											fileoffset = metaoffsets64[0];
-											mp4->metaoffsets[0] = fileoffset;
-											//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
+												fileoffset = metaoffsets64[0];
+												mp4->metaoffsets[0] = fileoffset;
+												//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
 
-											num = 1;
-											while (num < mp4->metasize_count)
-											{
-												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
-												{
-													stco_pos++;
-													fileoffset = (uint64_t)metaoffsets64[stco_pos];
-												}
-												else
+												num = 1;
+												while (num < mp4->metasize_count)
 												{
-													fileoffset += (uint64_t)mp4->metasizes[num - 1];
+													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
+													{
+														stco_pos++;
+														fileoffset = (uint64_t)metaoffsets64[stco_pos];
+													}
+													else
+													{
+														fileoffset += (uint64_t)mp4->metasizes[num - 1];
+													}
+
+													mp4->metaoffsets[num] = fileoffset;
+													//int delta = metaoffsets[num] - metaoffsets[num - 1];
+													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
+
+													num++;
 												}
 
-												mp4->metaoffsets[num] = fileoffset;
-												//int delta = metaoffsets[num] - metaoffsets[num - 1];
-												//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
+												if (mp4->metastsc) free(mp4->metastsc);
+												mp4->metastsc = NULL;
+												mp4->metastsc_count = 0;
 
-												num++;
+												free(metaoffsets64);
 											}
-
-											if (mp4->metastsc) free(mp4->metastsc);
-											mp4->metastsc = NULL;
-											mp4->metastsc_count = 0;
-
-											free(metaoffsets64);
 										}
 									}
+									else
+									{
+										//size of null
+										CloseSource((size_t)mp4);
+										mp4 = NULL;
+										break;
+									}
 								}
 								else
 								{
@@ -538,10 +618,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 									}
 								}
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -578,10 +659,11 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
-							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
+							mp4->filepos += len;
+							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
-							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
@@ -595,6 +677,15 @@ size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  /
 				break;
 			}
 		} while (len > 0);
+
+		if (mp4)
+		{
+			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
+			{
+				CloseSource((size_t)mp4);
+				mp4 = NULL;
+			}
+		}
 	}
 	else
 	{
@@ -631,20 +722,32 @@ void CloseSource(size_t handle)
 }
 
 
-uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)
+uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)
 {
 	mp4object *mp4 = (mp4object *)handle;
-	if (mp4 == NULL) return 0;
+	if (mp4 == NULL) return GPMF_ERROR_MEMORY;
 
-	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;
+	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;
 
-	*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
-	*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
-	return 0;
+	*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
+	*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
+	return GPMF_OK;
 }
 
 
-
+uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)
+{
+    mp4object *mp4 = (mp4object *)handle;
+    if (mp4 == NULL) return GPMF_ERROR_MEMORY;
+    
+    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;
+
+	*in_numerator = (uint32_t)(index * mp4->basemetadataduration);
+	*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);
+	*denominator = (uint32_t)mp4->meta_clockdemon;
+    
+    return GPMF_OK;
+}
 
 size_t OpenMP4SourceUDTA(char *filename)
 {
@@ -661,7 +764,8 @@ size_t OpenMP4SourceUDTA(char *filename)
 
 	if (mp4->mediafp)
 	{
-		uint32_t qttag, qtsize32, len;
+		uint32_t qttag, qtsize32;
+		size_t len;
 		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
@@ -674,7 +778,7 @@ size_t OpenMP4SourceUDTA(char *filename)
 			{
 				if (!GPMF_VALID_FOURCC(qttag))
 				{
-					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
+					LongSeek(mp4, lastsize - 8 - 8);
 
 					NESTSIZE(lastsize - 8);
 					continue;
@@ -701,7 +805,7 @@ size_t OpenMP4SourceUDTA(char *filename)
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p'))
 				{
-					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+					LongSeek(mp4, qtsize - 8);
 					NESTSIZE(qtsize);
 					continue;
 				}
@@ -725,7 +829,7 @@ size_t OpenMP4SourceUDTA(char *filename)
 				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
 					qttag != MAKEID('u', 'd', 't', 'a'))
 				{
-					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
+					LongSeek(mp4, qtsize - 8);
 					NESTSIZE(qtsize);
 					continue;
 				}
@@ -740,7 +844,7 @@ size_t OpenMP4SourceUDTA(char *filename)
 }
 
 
-double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)
+double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)
 {
 	mp4object *mp4 = (mp4object *)handle;
 	if (mp4 == NULL) return 0.0;
@@ -750,221 +854,278 @@ double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)
 	uint32_t testend = mp4->indexcount;
 	double rate = 0.0;
 
+	uint32_t *payload;
+	uint32_t payloadsize;
+	int32_t ret;
+
 	if (mp4->indexcount < 1)
 		return 0.0;
 
-	if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. 
-	{
-		teststart++;
-		testend--;
-	}
-
-	uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload
-	uint32_t payloadsize = GetPayloadSize(handle, teststart);
-	int32_t ret = GPMF_Init(ms, payload, payloadsize);
+	payload = GetPayload(handle, NULL, teststart); 
+	payloadsize = GetPayloadSize(handle, teststart);
+	ret = GPMF_Init(ms, payload, payloadsize);
 
 	if (ret != GPMF_OK)
 		goto cleanup;
 
 	{
+		uint64_t minimumtimestamp = 0;
+		uint64_t starttimestamp = 0;
+		uint64_t endtimestamp = 0;
 		uint32_t startsamples = 0;
 		uint32_t endsamples = 0;
-		uint32_t missing_samples = 0;
+		double intercept = 0.0;
+
+
 
-		while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
+		while (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
 		{
-			missing_samples = 1;
 			teststart++;
 			payload = GetPayload(handle, payload, teststart); // second last payload
 			payloadsize = GetPayloadSize(handle, teststart);
 			ret = GPMF_Init(ms, payload, payloadsize);
 		}
 
-		if (missing_samples)
-		{
-			teststart++;   //samples after sensor start are statistically the best
-			payload = GetPayload(handle, payload, teststart);
-			payloadsize = GetPayloadSize(handle, teststart);
-			ret = GPMF_Init(ms, payload, payloadsize);
-		}
-
-		if (ret == GPMF_OK)
+		if (ret == GPMF_OK && payload)
 		{
-			uint32_t samples = GPMF_Repeat(ms);
+			uint32_t samples = GPMF_PayloadSampleCount(ms);
 			GPMF_stream find_stream;
 			GPMF_CopyState(ms, &find_stream);
+			if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
+				startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;
 
-			if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
+			GPMF_CopyState(ms, &find_stream);
+			if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))
+				starttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));
+
+			if (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.
 			{
-				startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;
+				GPMF_stream any_stream;
+				GPMF_Init(&any_stream, payload, payloadsize);
+
+				minimumtimestamp = starttimestamp;
+				while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))
+				{
+					uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));
+					if (timestamp < minimumtimestamp)
+						minimumtimestamp = timestamp;
+				}
+			}
 
-				payload = GetPayload(handle, payload, testend); // second last payload
+			testend = mp4->indexcount;
+			do
+			{
+				testend--;// last payload with the fourcc needed
+				payload = GetPayload(handle, payload, testend);
 				payloadsize = GetPayloadSize(handle, testend);
 				ret = GPMF_Init(ms, payload, payloadsize);
-				if (ret != GPMF_OK)
-					goto cleanup;
+			} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));
 
-				if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
+			GPMF_CopyState(ms, &find_stream);
+			if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
+				endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
+			else // If there is no TSMP we have to count the samples.
+			{
+				uint32_t i;
+				for (i = teststart; i <= testend; i++)
 				{
-					GPMF_CopyState(ms, &find_stream);
-					if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
+					payload = GetPayload(handle,payload, i); // second last payload
+					payloadsize = GetPayloadSize(handle, i);
+					if (GPMF_OK == GPMF_Init(ms, payload, payloadsize))
+						if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
+							endsamples += GPMF_PayloadSampleCount(ms);
+				}
+			}
+
+			if (starttimestamp != 0)
+			{
+				uint32_t last_samples = GPMF_PayloadSampleCount(ms);
+				uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;
+				double time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.
+
+				GPMF_CopyState(ms, &find_stream);
+				if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))
+					endtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));
+
+				if (endtimestamp)
+				{
+					double approxrate = 0.0;
+					if (endsamples > startsamples)
+						approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
+
+					if (approxrate == 0.0)
+						approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
+
+
+					while (time_stamp_scale >= 1)
 					{
-						endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
-						rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
-						goto cleanup;
+						rate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);
+						if (rate*0.9 < approxrate && approxrate < rate*1.1)
+							break;
+
+						time_stamp_scale *= 0.1;
 					}
+					if (time_stamp_scale < 1.0) rate = 0.0;
+					intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;
 				}
-
-				rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
 			}
-			else // for increased precision, for older GPMF streams sometimes missing the total sample count 
+
+			if (rate == 0.0) //Timestamps didn't help weren't available
 			{
-				uint32_t payloadpos = 0, payloadcount = 0;
-				double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;
-				uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);
-				memset(repeatarray, 0, mp4->indexcount * 4 + 4);
+				if (!(flags & GPMF_SAMPLE_RATE_PRECISE))
+				{
+					if (endsamples > startsamples)
+						rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
 
-				samples = 0;
+					if (rate == 0.0)
+						rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
 
-				for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)
+					double in, out;
+					if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))
+						intercept = (double)-in * rate;
+				}
+				else // for increased precision, for older GPMF streams sometimes missing the total sample count 
 				{
-					payload = GetPayload(handle, payload, payloadpos); // second last payload
-					payloadsize = GetPayloadSize(handle, payloadpos);
-					ret = GPMF_Init(ms, payload, payloadsize);
+					uint32_t payloadpos = 0, payloadcount = 0;
+					double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;
+					uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);
+					memset(repeatarray, 0, mp4->indexcount * 4 + 4);
 
-					if (ret != GPMF_OK)
-						goto cleanup;
+					samples = 0;
 
-					if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
+					for (payloadpos = teststart; payloadpos <= testend; payloadpos++)
 					{
-						GPMF_stream find_stream2;
-						GPMF_CopyState(ms, &find_stream2);
+						payload = GetPayload(handle, payload, payloadpos); // second last payload
+						payloadsize = GetPayloadSize(handle, payloadpos);
+						ret = GPMF_Init(ms, payload, payloadsize);
 
-						if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats
+						if (ret != GPMF_OK)
+							goto cleanup;
+
+						if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
 						{
-							if (repeatarray)
-							{
-								float in, out;
+							GPMF_stream find_stream2;
+							GPMF_CopyState(ms, &find_stream2);
+
+							payloadcount++;
 
-								do
+							if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats
+							{
+								if (repeatarray)
 								{
-									samples++;
-								} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));
+									double in, out;
 
-								repeatarray[payloadpos] = samples;
-								meanY += (double)samples;
+									do
+									{
+										samples++;
+									} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));
 
-								GetPayloadTime(handle, payloadpos, &in, &out);
-								meanX += out;
-							}
-						}
-						else
-						{
-							uint32_t repeat = GPMF_Repeat(ms);
-							samples += repeat;
+									repeatarray[payloadpos] = samples;
+									meanY += (double)samples;
 
-							if (repeatarray)
+									if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))
+										meanX += out;
+								}
+							}
+							else
 							{
-								float in, out;
+								uint32_t repeat = GPMF_PayloadSampleCount(ms);
+								samples += repeat;
+
+								if (repeatarray)
+								{
+									double in, out;
 
-								repeatarray[payloadpos] = samples;
-								meanY += (double)samples;
+									repeatarray[payloadpos] = samples;
+									meanY += (double)samples;
 
-								GetPayloadTime(handle, payloadpos, &in, &out);
-								meanX += out;
+									if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))
+										meanX += out;
+								}
 							}
 						}
+						else
+						{
+							repeatarray[payloadpos] = 0;
+						}
 					}
-				}
-
-				// Compute the line of best fit for a jitter removed sample rate.  
-				// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  
-				// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.
-				if (repeatarray)
-				{
-					meanY /= (double)payloadcount;
-					meanX /= (double)payloadcount;
 
-					for (payloadpos = teststart; payloadpos < testend; payloadpos++)
+					// Compute the line of best fit for a jitter removed sample rate.  
+					// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  
+					// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.
+					if (repeatarray)
 					{
-						float in, out;
-						GetPayloadTime(handle, payloadpos, &in, &out);
+						meanY /= (double)payloadcount;
+						meanX /= (double)payloadcount;
 
-						top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);
-						bot += ((double)out - meanX)*((double)out - meanX);
-					}
+						for (payloadpos = teststart; payloadpos <= testend; payloadpos++)
+						{
+							double in, out;
+							if (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))
+							{
+								top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);
+								bot += ((double)out - meanX)*((double)out - meanX);
+							}
+						}
 
-					slope = top / bot;
+						slope = top / bot;
+						rate = slope;
 
+						// This sample code might be useful for compare data latency between channels.
+						intercept = meanY - slope * meanX;
 #if 0
-					// This sample code might be useful for compare data latency between channels.
+						printf(""%c%c%c%c start offset = %f (%.3fms) rate = %f\n"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);
+						printf(""%c%c%c%c first sample at time %.3fms\n"", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);
+#endif
+					}
+					else
 					{
-						double intercept;
-						intercept = meanY - slope*meanX;
-						printf(""%c%c%c%c start offset = %f (%.3fms)\n"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);
+						rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
 					}
-#endif
-					rate = slope;
-				}
-				else
-				{
-					rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
-				}
-
-				free(repeatarray);
 
-				goto cleanup;
+					free(repeatarray);
+				}
 			}
-		}
-	}
 
-cleanup:
-	if (payload) 
-	{
-		FreePayload(payload);
-		payload = NULL;
-	}
-
-	return rate;
-}
+			if (firstsampletime && lastsampletime)
+			{
+				uint32_t endpayload = mp4->indexcount;
+				do
+				{
+					endpayload--;// last payload with the fourcc needed
+					payload = GetPayload(handle, payload, endpayload);
+					payloadsize = GetPayloadSize(handle, endpayload);
+					ret = GPMF_Init(ms, payload, payloadsize);
+				} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));
 
+				if (endpayload > 0 && ret == GPMF_OK)
+				{
+					uint32_t totalsamples = endsamples - startsamples;
+					float timo = 0.0;
 
-double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)
-{
-	mp4object *mp4 = (mp4object *)handle;
-	if (mp4 == NULL) return 0.0;
+					GPMF_CopyState(ms, &find_stream);
+					if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))
+						GPMF_FormattedData(&find_stream, &timo, 4, 0, 1);
 
-	uint32_t key, insamples;
-	uint32_t repeat, outsamples;
-	GPMF_stream find_stream;
+					double first, last;
+					first = -intercept / rate - timo;
+					last = first + (double)totalsamples / rate;
 
-	if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;
+					//printf(""%c%c%c%c first sample at time %.3fms, last at %.3fms\n"", PRINTF_4CC(fourcc), 1000.0*first, 1000.0*last);
 
-	key = GPMF_Key(gs);
-	repeat = GPMF_Repeat(gs);
-	if (rate == 0.0)
-		rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);
+					if (firstsampletime) *firstsampletime = first;
 
-	if (rate == 0.0)
-	{
-		*in = *out = 0.0;
-		return 0.0;
+					if (lastsampletime) *lastsampletime = last;
+				}
+			}
+		}
 	}
 
-	GPMF_CopyState(gs, &find_stream);
-	if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
-	{
-		outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
-		insamples = outsamples - repeat;
+cleanup:
+	if (payload)
+		FreePayload(payload);
+	payload = NULL;
 
-		*in = ((double)insamples / (double)rate);
-		*out = ((double)outsamples / (double)rate);
-	}
-	else
-	{
-		// might too costly in some applications read all the samples to determine the clock jitter, here I return the estimate from the MP4 track.
-		*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
-		*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
-	}
 	return rate;
 }
+",gpmf-parser,341f12cd5b97ab419e53853ca00176457c9f1681,3e7d6eace490c87e7caf7e7e1153fc4879e8e08d,1," size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
{
	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
	if (mp4 == NULL) return 0;
 
 	memset(mp4, 0, sizeof(mp4object));
 
//fix_flaw_line_below:
//	struct stat64 mp4stat;
//fix_flaw_line_below:
//	stat64(filename, &mp4stat);
//fix_flaw_line_below:
//	mp4->filesize = mp4stat.st_size;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (mp4->filesize < 64) return 0;
//fix_flaw_line_below:
//
 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
	mp4->mediafp = fopen(filename, ""rb"");
#endif

	if (mp4->mediafp)
	{
		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
		size_t len;
		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 
//fix_flaw_line_below:
//
 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
//flaw_line_below:
			if (len == 8)
//fix_flaw_line_below:
//			mp4->filepos += len;
//fix_flaw_line_below:
//			if (len == 8 && mp4->filepos < mp4->filesize)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
//flaw_line_below:
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
//flaw_line_below:

//flaw_line_below:
					NESTSIZE(lastsize - 8);
//flaw_line_below:
					continue;
//fix_flaw_line_below:
//					CloseSource((size_t)mp4);
//fix_flaw_line_below:
//					mp4 = NULL;
//fix_flaw_line_below:
//					break;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
//flaw_line_below:
					fread(&qtsize, 1, 8, mp4->mediafp);
//fix_flaw_line_below:
//					len = fread(&qtsize, 1, 8, mp4->mediafp);
//fix_flaw_line_below:
//					mp4->filepos += len;
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
					qtsize = qtsize32;

				nest++;

				if (qtsize < 8) break;
				if (nest >= MAX_NEST_LEVEL) break;

				nestsize[nest] = qtsize;
				lastsize = qtsize;

#if PRINT_MP4_STRUCTURE	

				for (int i = 1; i < nest; i++) printf(""    "");
				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
//flaw_line_below:
					qttag == MAKEID('u', 'd', 't', 'a'))
//fix_flaw_line_below:
//					qttag == MAKEID('u', 'd', 't', 'a') ||
//fix_flaw_line_below:
//					qttag == MAKEID('f', 'r', 'e', 'e'))
 				{
//flaw_line_below:
					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 
					continue;
				}
#else
				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
					qttag != MAKEID('m', 'v', 'h', 'd') &&
					qttag != MAKEID('t', 'r', 'a', 'k') &&
					qttag != MAKEID('m', 'd', 'i', 'a') &&
					qttag != MAKEID('m', 'd', 'h', 'd') &&
					qttag != MAKEID('m', 'i', 'n', 'f') &&
					qttag != MAKEID('g', 'm', 'i', 'n') &&
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
//flaw_line_below:
					qttag != MAKEID('a', 'l', 'i', 's') &&
//flaw_line_below:
					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
					qttag != MAKEID('s', 't', 's', 'z') &&
					qttag != MAKEID('s', 't', 'c', 'o') &&
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
//flaw_line_below:
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 				}
				else
#endif
					if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header
					{
						len = fread(&skip, 1, 4, mp4->mediafp);
						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
//flaw_line_below:
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						mp4->filepos += len;
//fix_flaw_line_below:
//						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header
					{
						media_header md;
						len = fread(&md, 1, sizeof(md), mp4->mediafp);
						if (len == sizeof(md))
						{
							md.creation_time = BYTESWAP32(md.creation_time);
							md.modification_time = BYTESWAP32(md.modification_time);
							md.time_scale = BYTESWAP32(md.time_scale);
							md.duration = BYTESWAP32(md.duration);

							mp4->trak_clockdemon = md.time_scale;
							mp4->trak_clockcount = md.duration;

							if (mp4->videolength == 0.0) // Get the video length from the first track
							{
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}
//flaw_line_below:
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//						mp4->filepos += len;
//fix_flaw_line_below:
//						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr
					{
						uint32_t temp;
						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
//flaw_line_below:
						if (temp != MAKEID('a', 'l', 'i', 's'))
//fix_flaw_line_below:
//						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
 							type = temp;
 
//flaw_line_below:
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr
//fix_flaw_line_below:
//						mp4->filepos += len;
//fix_flaw_line_below:
//						LongSeek(mp4, qtsize - 8 - len); // skip over hldr
 
 						NESTSIZE(qtsize);
 
					}
					else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata
					{
						if (type == traktype) //like meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
							if (len == 16)
							{
								if (subtype != traksubtype) // MP4 metadata 
								{
 									type = 0; // MP4
 								}
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stsd
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 12 <= qtsize - 8 - len)
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
//flaw_line_below:
								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
//flaw_line_below:
								if (mp4->metastsc)
//fix_flaw_line_below:
//								if (num > 0)
 								{
//flaw_line_below:
									uint32_t total_stsc = num;
//flaw_line_below:
									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
//flaw_line_below:

//flaw_line_below:
									do
//fix_flaw_line_below:
//									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
//fix_flaw_line_below:
//									if (mp4->metastsc)
 									{
//flaw_line_below:
										num--;
//flaw_line_below:
										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
//flaw_line_below:
										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
//flaw_line_below:
										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
//flaw_line_below:
									} while (num > 0);
//flaw_line_below:
								}
//fix_flaw_line_below:
//										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
 
//flaw_line_below:
								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.
//fix_flaw_line_below:
//										do
//fix_flaw_line_below:
//										{
//fix_flaw_line_below:
//											num--;
//fix_flaw_line_below:
//											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
//fix_flaw_line_below:
//											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
//fix_flaw_line_below:
//											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
//fix_flaw_line_below:
//										} while (num > 0);
//fix_flaw_line_below:
//									}
//fix_flaw_line_below:
//								}
//fix_flaw_line_below:
//								else
 								{
//flaw_line_below:
									if (mp4->metastsc) free(mp4->metastsc);
//flaw_line_below:
									mp4->metastsc = NULL;
//flaw_line_below:
									mp4->metastsc_count = 0;
//fix_flaw_line_below:
//									//size of null
//fix_flaw_line_below:
//									CloseSource((size_t)mp4);
//fix_flaw_line_below:
//									mp4 = NULL;
//fix_flaw_line_below:
//									break;
 								}
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stsx
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes
					{
						if (type == traktype) // meta
						{
							uint32_t equalsamplesize;

							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 4 <= qtsize - 8 - len)
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
//flaw_line_below:
								mp4->metasizes = (uint32_t *)malloc(num * 4);
//flaw_line_below:
								if (mp4->metasizes)
//fix_flaw_line_below:
//								if(num > 0)
 								{
//flaw_line_below:
									if (equalsamplesize == 0)
//fix_flaw_line_below:
//									mp4->metasizes = (uint32_t *)malloc(num * 4);
//fix_flaw_line_below:
//									if (mp4->metasizes)
 									{
//flaw_line_below:
										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
//flaw_line_below:
										do
//fix_flaw_line_below:
//										if (equalsamplesize == 0)
 										{
//flaw_line_below:
											num--;
//flaw_line_below:
											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
//flaw_line_below:
										} while (num > 0);
//flaw_line_below:
									}
//flaw_line_below:
									else
//flaw_line_below:
									{
//flaw_line_below:
										equalsamplesize = BYTESWAP32(equalsamplesize);
//flaw_line_below:
										do
//fix_flaw_line_below:
//											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
//fix_flaw_line_below:
//											do
//fix_flaw_line_below:
//											{
//fix_flaw_line_below:
//												num--;
//fix_flaw_line_below:
//												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
//fix_flaw_line_below:
//											} while (num > 0);
//fix_flaw_line_below:
//										}
//fix_flaw_line_below:
//										else
 										{
//flaw_line_below:
											num--;
//flaw_line_below:
											mp4->metasizes[num] = equalsamplesize;
//flaw_line_below:
										} while (num > 0);
//fix_flaw_line_below:
//											equalsamplesize = BYTESWAP32(equalsamplesize);
//fix_flaw_line_below:
//											do
//fix_flaw_line_below:
//											{
//fix_flaw_line_below:
//												num--;
//fix_flaw_line_below:
//												mp4->metasizes[num] = equalsamplesize;
//fix_flaw_line_below:
//											} while (num > 0);
//fix_flaw_line_below:
//										}
 									}
 								}
//fix_flaw_line_below:
//								else
//fix_flaw_line_below:
//								{
//fix_flaw_line_below:
//									//size of null
//fix_flaw_line_below:
//									CloseSource((size_t)mp4);
//fix_flaw_line_below:
//									mp4 = NULL;
//fix_flaw_line_below:
//									break;
//fix_flaw_line_below:
//								}
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stsz
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
//fix_flaw_line_below:
//								uint32_t metastco_count = num;
//fix_flaw_line_below:
//
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
//flaw_line_below:
									mp4->indexcount = mp4->metasize_count;
//fix_flaw_line_below:
//									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
//flaw_line_below:
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
//flaw_line_below:
									if (mp4->metaoffsets)
//fix_flaw_line_below:
//									if(num > 0)
 									{
//flaw_line_below:
										uint32_t *metaoffsets32 = NULL;
//flaw_line_below:
										metaoffsets32 = (uint32_t *)malloc(num * 4);
//flaw_line_below:
										if (metaoffsets32)
//fix_flaw_line_below:
//										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
//fix_flaw_line_below:
//										if (mp4->metaoffsets)
 										{
//flaw_line_below:
											uint64_t fileoffset = 0;
//flaw_line_below:
											int stsc_pos = 0;
//flaw_line_below:
											int stco_pos = 0;
//flaw_line_below:
											int repeat = 1;
//flaw_line_below:
											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
//flaw_line_below:
											do
//flaw_line_below:
											{
//flaw_line_below:
												num--;
//flaw_line_below:
												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
//flaw_line_below:
											} while (num > 0);
//flaw_line_below:

//flaw_line_below:
											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
//flaw_line_below:
											num = 1;
//flaw_line_below:
											while (num < mp4->metasize_count)
//fix_flaw_line_below:
//											uint32_t *metaoffsets32 = NULL;
//fix_flaw_line_below:
//											metaoffsets32 = (uint32_t *)malloc(num * 4);
//fix_flaw_line_below:
//											if (metaoffsets32)
 											{
//flaw_line_below:
												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
//fix_flaw_line_below:
//												uint64_t fileoffset = 0;
//fix_flaw_line_below:
//												int stsc_pos = 0;
//fix_flaw_line_below:
//												int stco_pos = 0;
//fix_flaw_line_below:
//												int repeat = 1;
//fix_flaw_line_below:
//												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
//fix_flaw_line_below:
//												do
 												{
//flaw_line_below:
													stco_pos++; stsc_pos++;
//flaw_line_below:
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
//flaw_line_below:
													repeat = 1;
//flaw_line_below:
												}
//flaw_line_below:
												else if (repeat == mp4->metastsc[stsc_pos].samples)
//flaw_line_below:
												{
//flaw_line_below:
													stco_pos++;
//flaw_line_below:
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
//flaw_line_below:
													repeat = 1;
//flaw_line_below:
												}
//flaw_line_below:
												else
//fix_flaw_line_below:
//													num--;
//fix_flaw_line_below:
//													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
//fix_flaw_line_below:
//												} while (num > 0);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
//fix_flaw_line_below:
//												num = 1;
//fix_flaw_line_below:
//												while (num < mp4->indexcount)
 												{
//flaw_line_below:
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
//flaw_line_below:
													repeat++;
//fix_flaw_line_below:
//													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
//fix_flaw_line_below:
//													{
//fix_flaw_line_below:
//														if ((uint32_t)stco_pos + 1 < metastco_count)
//fix_flaw_line_below:
//														{
//fix_flaw_line_below:
//															stco_pos++;
//fix_flaw_line_below:
//															fileoffset = (uint64_t)metaoffsets32[stco_pos];
//fix_flaw_line_below:
//														}
//fix_flaw_line_below:
//														else
//fix_flaw_line_below:
//														{
//fix_flaw_line_below:
//															fileoffset += (uint64_t)mp4->metasizes[num - 1];
//fix_flaw_line_below:
//														}
//fix_flaw_line_below:
//														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
//fix_flaw_line_below:
//															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
//fix_flaw_line_below:
//																stsc_pos++;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//														repeat = 1;
//fix_flaw_line_below:
//													}
//fix_flaw_line_below:
//													else
//fix_flaw_line_below:
//													{
//fix_flaw_line_below:
//														fileoffset += (uint64_t)mp4->metasizes[num - 1];
//fix_flaw_line_below:
//														repeat++;
//fix_flaw_line_below:
//													}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//													mp4->metaoffsets[num] = fileoffset;
//fix_flaw_line_below:
//													//int delta = metaoffsets[num] - metaoffsets[num - 1];
//fix_flaw_line_below:
//													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//													num++;
 												}
 
//flaw_line_below:
												mp4->metaoffsets[num] = fileoffset;
//flaw_line_below:
												//int delta = metaoffsets[num] - metaoffsets[num - 1];
//flaw_line_below:
												//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
//fix_flaw_line_below:
//												if (mp4->metastsc) free(mp4->metastsc);
//fix_flaw_line_below:
//												mp4->metastsc = NULL;
//fix_flaw_line_below:
//												mp4->metastsc_count = 0;
 
//flaw_line_below:
												num++;
//fix_flaw_line_below:
//												free(metaoffsets32);
 											}
//flaw_line_below:

//flaw_line_below:
											if (mp4->metastsc) free(mp4->metastsc);
//flaw_line_below:
											mp4->metastsc = NULL;
//flaw_line_below:
											mp4->metastsc_count = 0;
//flaw_line_below:

//flaw_line_below:
											free(metaoffsets32);
 										}
 									}
//fix_flaw_line_below:
//									else
//fix_flaw_line_below:
//									{
//fix_flaw_line_below:
//										//size of null
//fix_flaw_line_below:
//										CloseSource((size_t)mp4);
//fix_flaw_line_below:
//										mp4 = NULL;
//fix_flaw_line_below:
//										break;
//fix_flaw_line_below:
//									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
//flaw_line_below:
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
//flaw_line_below:
									if (mp4->metaoffsets)
//fix_flaw_line_below:
//									if (num > 0)
 									{
//flaw_line_below:
										uint32_t *metaoffsets32 = NULL;
//flaw_line_below:
										metaoffsets32 = (uint32_t *)malloc(num * 4);
//flaw_line_below:
										if (metaoffsets32)
//fix_flaw_line_below:
//										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
//fix_flaw_line_below:
//										if (mp4->metaoffsets)
 										{
//flaw_line_below:
											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
//flaw_line_below:
											len += readlen;
//flaw_line_below:
											do
//fix_flaw_line_below:
//											uint32_t *metaoffsets32 = NULL;
//fix_flaw_line_below:
//											metaoffsets32 = (uint32_t *)malloc(num * 4);
//fix_flaw_line_below:
//											if (metaoffsets32)
 											{
//flaw_line_below:
												num--;
//flaw_line_below:
												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
//flaw_line_below:
											} while (num > 0);
//fix_flaw_line_below:
//												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
//fix_flaw_line_below:
//												len += readlen;
//fix_flaw_line_below:
//												do
//fix_flaw_line_below:
//												{
//fix_flaw_line_below:
//													num--;
//fix_flaw_line_below:
//													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
//fix_flaw_line_below:
//												} while (num > 0);
 
//flaw_line_below:
											free(metaoffsets32);
//fix_flaw_line_below:
//												free(metaoffsets32);
//fix_flaw_line_below:
//											}
 										}
 									}
//fix_flaw_line_below:
//									else
//fix_flaw_line_below:
//									{
//fix_flaw_line_below:
//										//size of null
//fix_flaw_line_below:
//										CloseSource((size_t)mp4);
//fix_flaw_line_below:
//										mp4 = NULL;
//fix_flaw_line_below:
//										break;
//fix_flaw_line_below:
//									}
 								}
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}

					else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//							if(num == 0)
//fix_flaw_line_below:
//							{
//fix_flaw_line_below:
//								//size of null
//fix_flaw_line_below:
//								CloseSource((size_t)mp4);
//fix_flaw_line_below:
//								mp4 = NULL;
//fix_flaw_line_below:
//								break;
//fix_flaw_line_below:
//							}
//fix_flaw_line_below:
//
 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
//flaw_line_below:
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
//flaw_line_below:
									if (mp4->metaoffsets)
//fix_flaw_line_below:
//									if (mp4->metasize_count)
 									{
//flaw_line_below:
										uint64_t *metaoffsets64 = NULL;
//flaw_line_below:
										metaoffsets64 = (uint64_t *)malloc(num * 8);
//flaw_line_below:
										if (metaoffsets64)
//fix_flaw_line_below:
//										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
//fix_flaw_line_below:
//										if (mp4->metaoffsets)
 										{
//flaw_line_below:
											uint64_t fileoffset = 0;
//flaw_line_below:
											int stsc_pos = 0;
//flaw_line_below:
											int stco_pos = 0;
//flaw_line_below:
											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
//flaw_line_below:
											do
//fix_flaw_line_below:
//											uint64_t *metaoffsets64 = NULL;
//fix_flaw_line_below:
//											metaoffsets64 = (uint64_t *)malloc(num * 8);
//fix_flaw_line_below:
//											if (metaoffsets64)
 											{
//flaw_line_below:
												num--;
//flaw_line_below:
												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
//flaw_line_below:
											} while (num > 0);
//fix_flaw_line_below:
//												uint64_t fileoffset = 0;
//fix_flaw_line_below:
//												int stsc_pos = 0;
//fix_flaw_line_below:
//												int stco_pos = 0;
//fix_flaw_line_below:
//												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
//fix_flaw_line_below:
//												do
//fix_flaw_line_below:
//												{
//fix_flaw_line_below:
//													num--;
//fix_flaw_line_below:
//													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
//fix_flaw_line_below:
//												} while (num > 0);
 
//flaw_line_below:
											fileoffset = metaoffsets64[0];
//flaw_line_below:
											mp4->metaoffsets[0] = fileoffset;
//flaw_line_below:
											//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
//fix_flaw_line_below:
//												fileoffset = metaoffsets64[0];
//fix_flaw_line_below:
//												mp4->metaoffsets[0] = fileoffset;
//fix_flaw_line_below:
//												//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
 
//flaw_line_below:
											num = 1;
//flaw_line_below:
											while (num < mp4->metasize_count)
//flaw_line_below:
											{
//flaw_line_below:
												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
//flaw_line_below:
												{
//flaw_line_below:
													stco_pos++;
//flaw_line_below:
													fileoffset = (uint64_t)metaoffsets64[stco_pos];
//flaw_line_below:
												}
//flaw_line_below:
												else
//fix_flaw_line_below:
//												num = 1;
//fix_flaw_line_below:
//												while (num < mp4->metasize_count)
 												{
//flaw_line_below:
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
//fix_flaw_line_below:
//													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
//fix_flaw_line_below:
//													{
//fix_flaw_line_below:
//														stco_pos++;
//fix_flaw_line_below:
//														fileoffset = (uint64_t)metaoffsets64[stco_pos];
//fix_flaw_line_below:
//													}
//fix_flaw_line_below:
//													else
//fix_flaw_line_below:
//													{
//fix_flaw_line_below:
//														fileoffset += (uint64_t)mp4->metasizes[num - 1];
//fix_flaw_line_below:
//													}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//													mp4->metaoffsets[num] = fileoffset;
//fix_flaw_line_below:
//													//int delta = metaoffsets[num] - metaoffsets[num - 1];
//fix_flaw_line_below:
//													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//													num++;
 												}
 
//flaw_line_below:
												mp4->metaoffsets[num] = fileoffset;
//flaw_line_below:
												//int delta = metaoffsets[num] - metaoffsets[num - 1];
//flaw_line_below:
												//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);
//fix_flaw_line_below:
//												if (mp4->metastsc) free(mp4->metastsc);
//fix_flaw_line_below:
//												mp4->metastsc = NULL;
//fix_flaw_line_below:
//												mp4->metastsc_count = 0;
 
//flaw_line_below:
												num++;
//fix_flaw_line_below:
//												free(metaoffsets64);
 											}
//flaw_line_below:

//flaw_line_below:
											if (mp4->metastsc) free(mp4->metastsc);
//flaw_line_below:
											mp4->metastsc = NULL;
//flaw_line_below:
											mp4->metastsc_count = 0;
//flaw_line_below:

//flaw_line_below:
											free(metaoffsets64);
 										}
 									}
//fix_flaw_line_below:
//									else
//fix_flaw_line_below:
//									{
//fix_flaw_line_below:
//										//size of null
//fix_flaw_line_below:
//										CloseSource((size_t)mp4);
//fix_flaw_line_below:
//										mp4 = NULL;
//fix_flaw_line_below:
//										break;
//fix_flaw_line_below:
//									}
 								}
 								else
 								{
									mp4->indexcount = num;
									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
									{
										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
										do
										{
											num--;
											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
										} while (num > 0);
 									}
 								}
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples
					{
						if (type == traktype) // meta 
						{
							uint32_t totaldur = 0, samples = 0;
							int32_t entries = 0;
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
							num = BYTESWAP32(num);
							if (num * 8 <= qtsize - 8 - len)
							{
								entries = num;

								mp4->meta_clockdemon = mp4->trak_clockdemon;
								mp4->meta_clockcount = mp4->trak_clockcount;

								while (entries > 0)
								{
									int32_t samplecount;
									int32_t duration;
									len += fread(&samplecount, 1, 4, mp4->mediafp);
									samplecount = BYTESWAP32(samplecount);
									len += fread(&duration, 1, 4, mp4->mediafp);
									duration = BYTESWAP32(duration);

									samples += samplecount;
									entries--;

									totaldur += duration;
									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
//fix_flaw_line_below:
//							mp4->filepos += len;
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
//flaw_line_below:
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
//fix_flaw_line_below:
//							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else
					{
						NESTSIZE(8);
					}
			}
			else
			{
 				break;
 			}
 		} while (len > 0);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		if (mp4)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//				CloseSource((size_t)mp4);
//fix_flaw_line_below:
//				mp4 = NULL;
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		}
 	}
 	else
 	{
		//	printf(""Could not open %s for input\n"", filename);
		//	exit(1);

		free(mp4);
		mp4 = NULL;
	}

	return (size_t)mp4;
}
",182722," size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
{
	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
	if (mp4 == NULL) return 0;
 
 	memset(mp4, 0, sizeof(mp4object));
 
 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
	mp4->mediafp = fopen(filename, ""rb"");
#endif

	if (mp4->mediafp)
	{
		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
		size_t len;
		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 
 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
			if (len == 8)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
					NESTSIZE(lastsize - 8);
					continue;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
					fread(&qtsize, 1, 8, mp4->mediafp);
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
					qtsize = qtsize32;

				nest++;

				if (qtsize < 8) break;
				if (nest >= MAX_NEST_LEVEL) break;

				nestsize[nest] = qtsize;
				lastsize = qtsize;

#if PRINT_MP4_STRUCTURE	

				for (int i = 1; i < nest; i++) printf(""    "");
				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
					qttag == MAKEID('u', 'd', 't', 'a'))
 				{
					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
 
 					NESTSIZE(qtsize);
 
					continue;
				}
#else
				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
					qttag != MAKEID('m', 'v', 'h', 'd') &&
					qttag != MAKEID('t', 'r', 'a', 'k') &&
					qttag != MAKEID('m', 'd', 'i', 'a') &&
					qttag != MAKEID('m', 'd', 'h', 'd') &&
					qttag != MAKEID('m', 'i', 'n', 'f') &&
					qttag != MAKEID('g', 'm', 'i', 'n') &&
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
					qttag != MAKEID('s', 't', 's', 'z') &&
					qttag != MAKEID('s', 't', 'c', 'o') &&
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 					NESTSIZE(qtsize);
 				}
				else
#endif
					if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header
					{
						len = fread(&skip, 1, 4, mp4->mediafp);
						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header
					{
						media_header md;
						len = fread(&md, 1, sizeof(md), mp4->mediafp);
						if (len == sizeof(md))
						{
							md.creation_time = BYTESWAP32(md.creation_time);
							md.modification_time = BYTESWAP32(md.modification_time);
							md.time_scale = BYTESWAP32(md.time_scale);
							md.duration = BYTESWAP32(md.duration);

							mp4->trak_clockdemon = md.time_scale;
							mp4->trak_clockcount = md.duration;

							if (mp4->videolength == 0.0) // Get the video length from the first track
							{
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr
					{
						uint32_t temp;
						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
						if (temp != MAKEID('a', 'l', 'i', 's'))
 							type = temp;
 
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr
 
 						NESTSIZE(qtsize);
 
					}
					else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata
					{
						if (type == traktype) //like meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
							if (len == 16)
							{
								if (subtype != traksubtype) // MP4 metadata 
								{
 									type = 0; // MP4
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 12 <= qtsize - 8 - len)
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
								if (mp4->metastsc)
 								{
									uint32_t total_stsc = num;
									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
									do
 									{
										num--;
										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
									} while (num > 0);
								}
 
								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.
 								{
									if (mp4->metastsc) free(mp4->metastsc);
									mp4->metastsc = NULL;
									mp4->metastsc_count = 0;
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes
					{
						if (type == traktype) // meta
						{
							uint32_t equalsamplesize;

							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 4 <= qtsize - 8 - len)
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
								mp4->metasizes = (uint32_t *)malloc(num * 4);
								if (mp4->metasizes)
 								{
									if (equalsamplesize == 0)
 									{
										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
										do
 										{
											num--;
											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
										} while (num > 0);
									}
									else
									{
										equalsamplesize = BYTESWAP32(equalsamplesize);
										do
 										{
											num--;
											mp4->metasizes[num] = equalsamplesize;
										} while (num > 0);
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											int repeat = 1;
											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
											num = 1;
											while (num < mp4->metasize_count)
 											{
												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
 												{
													stco_pos++; stsc_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else if (repeat == mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else
 												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
													repeat++;
 												}
 
												mp4->metaoffsets[num] = fileoffset;
 
												num++;
 											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets32);
 										}
 									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
 									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										{
											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											len += readlen;
											do
 											{
												num--;
												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
 
											free(metaoffsets32);
 										}
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}

					else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									{
										uint64_t *metaoffsets64 = NULL;
										metaoffsets64 = (uint64_t *)malloc(num * 8);
										if (metaoffsets64)
 										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
											do
 											{
												num--;
												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
											} while (num > 0);
 
											fileoffset = metaoffsets64[0];
											mp4->metaoffsets[0] = fileoffset;
 
											num = 1;
											while (num < mp4->metasize_count)
											{
												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets64[stco_pos];
												}
												else
 												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
 												}
 
												mp4->metaoffsets[num] = fileoffset;
 
												num++;
 											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets64);
 										}
 									}
 								}
 								else
 								{
									mp4->indexcount = num;
									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
									{
										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
										do
										{
											num--;
											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
										} while (num > 0);
 									}
 								}
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples
					{
						if (type == traktype) // meta 
						{
							uint32_t totaldur = 0, samples = 0;
							int32_t entries = 0;
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
							num = BYTESWAP32(num);
							if (num * 8 <= qtsize - 8 - len)
							{
								entries = num;

								mp4->meta_clockdemon = mp4->trak_clockdemon;
								mp4->meta_clockcount = mp4->trak_clockcount;

								while (entries > 0)
								{
									int32_t samplecount;
									int32_t duration;
									len += fread(&samplecount, 1, 4, mp4->mediafp);
									samplecount = BYTESWAP32(samplecount);
									len += fread(&duration, 1, 4, mp4->mediafp);
									duration = BYTESWAP32(duration);

									samples += samplecount;
									entries--;

									totaldur += duration;
									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco
 						}
 						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 
 						NESTSIZE(qtsize);
 					}
					else
					{
						NESTSIZE(8);
					}
			}
			else
			{
 				break;
 			}
 		} while (len > 0);
 	}
 	else
 	{

		free(mp4);
		mp4 = NULL;
	}

	return (size_t)mp4;
}
"," size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4
{
	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
	if (mp4 == NULL) return 0;
 
 	memset(mp4, 0, sizeof(mp4object));
 
	struct stat64 mp4stat;
	stat64(filename, &mp4stat);
	mp4->filesize = mp4stat.st_size;

	if (mp4->filesize < 64) return 0;

 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
	mp4->mediafp = fopen(filename, ""rb"");
#endif

	if (mp4->mediafp)
	{
		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
		size_t len;
		int32_t nest = 0;
 		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
 		uint64_t lastsize = 0, qtsize;
 

 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
			mp4->filepos += len;
			if (len == 8 && mp4->filepos < mp4->filesize)
 			{
 				if (!VALID_FOURCC(qttag))
 				{
					CloseSource((size_t)mp4);
					mp4 = NULL;
					break;
 				}
 
 				qtsize32 = BYTESWAP32(qtsize32);
 
 				if (qtsize32 == 1) // 64-bit Atom
 				{
					len = fread(&qtsize, 1, 8, mp4->mediafp);
					mp4->filepos += len;
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
					qtsize = qtsize32;

				nest++;

				if (qtsize < 8) break;
				if (nest >= MAX_NEST_LEVEL) break;

				nestsize[nest] = qtsize;
				lastsize = qtsize;

#if PRINT_MP4_STRUCTURE	

				for (int i = 1; i < nest; i++) printf(""    "");
				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
 
 				if (qttag == MAKEID('m', 'd', 'a', 't') ||
 					qttag == MAKEID('f', 't', 'y', 'p') ||
					qttag == MAKEID('u', 'd', 't', 'a') ||
					qttag == MAKEID('f', 'r', 'e', 'e'))
 				{
					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 
					continue;
				}
#else
				if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms
					qttag != MAKEID('m', 'v', 'h', 'd') &&
					qttag != MAKEID('t', 'r', 'a', 'k') &&
					qttag != MAKEID('m', 'd', 'i', 'a') &&
					qttag != MAKEID('m', 'd', 'h', 'd') &&
					qttag != MAKEID('m', 'i', 'n', 'f') &&
					qttag != MAKEID('g', 'm', 'i', 'n') &&
 					qttag != MAKEID('d', 'i', 'n', 'f') &&
 					qttag != MAKEID('a', 'l', 'i', 's') &&
 					qttag != MAKEID('s', 't', 's', 'd') &&
 					qttag != MAKEID('s', 't', 'b', 'l') &&
 					qttag != MAKEID('s', 't', 't', 's') &&
 					qttag != MAKEID('s', 't', 's', 'c') &&
					qttag != MAKEID('s', 't', 's', 'z') &&
					qttag != MAKEID('s', 't', 'c', 'o') &&
 					qttag != MAKEID('c', 'o', '6', '4') &&
 					qttag != MAKEID('h', 'd', 'l', 'r'))
 				{
					LongSeek(mp4, qtsize - 8);
 
 					NESTSIZE(qtsize);
 				}
				else
#endif
					if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header
					{
						len = fread(&skip, 1, 4, mp4->mediafp);
						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
 						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header
					{
						media_header md;
						len = fread(&md, 1, sizeof(md), mp4->mediafp);
						if (len == sizeof(md))
						{
							md.creation_time = BYTESWAP32(md.creation_time);
							md.modification_time = BYTESWAP32(md.modification_time);
							md.time_scale = BYTESWAP32(md.time_scale);
							md.duration = BYTESWAP32(md.duration);

							mp4->trak_clockdemon = md.time_scale;
							mp4->trak_clockcount = md.duration;

							if (mp4->videolength == 0.0) // Get the video length from the first track
							{
 								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
 							}
 						}

						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over mvhd
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr
					{
						uint32_t temp;
						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
 
						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
 							type = temp;
 
						mp4->filepos += len;
						LongSeek(mp4, qtsize - 8 - len); // skip over hldr
 
 						NESTSIZE(qtsize);
 
					}
					else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata
					{
						if (type == traktype) //like meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.
							if (len == 16)
							{
								if (subtype != traksubtype) // MP4 metadata 
								{
 									type = 0; // MP4
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsd
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 12 <= qtsize - 8 - len)
 							{
 								mp4->metastsc_count = num;
 								if (mp4->metastsc) free(mp4->metastsc);
								if (num > 0)
 								{
									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
									if (mp4->metastsc)
 									{
										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
 
										do
										{
											num--;
											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
										} while (num > 0);
									}
								}
								else
 								{
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsx
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes
					{
						if (type == traktype) // meta
						{
							uint32_t equalsamplesize;

							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);

							num = BYTESWAP32(num);
							if (num * 4 <= qtsize - 8 - len)
 							{
 								mp4->metasize_count = num;
 								if (mp4->metasizes) free(mp4->metasizes);
								if(num > 0)
 								{
									mp4->metasizes = (uint32_t *)malloc(num * 4);
									if (mp4->metasizes)
 									{
										if (equalsamplesize == 0)
 										{
											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
											} while (num > 0);
										}
										else
 										{
											equalsamplesize = BYTESWAP32(equalsamplesize);
											do
											{
												num--;
												mp4->metasizes[num] = equalsamplesize;
											} while (num > 0);
										}
 									}
 								}
								else
								{
									//size of null
									CloseSource((size_t)mp4);
									mp4 = NULL;
									break;
								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stsz
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
 							{
								uint32_t metastco_count = num;

 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if(num > 0)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
 										{
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
 											{
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												int repeat = 1;
												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												do
 												{
													num--;
													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);

												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
												num = 1;
												while (num < mp4->indexcount)
 												{
													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
													{
														if ((uint32_t)stco_pos + 1 < metastco_count)
														{
															stco_pos++;
															fileoffset = (uint64_t)metaoffsets32[stco_pos];
														}
														else
														{
															fileoffset += (uint64_t)mp4->metasizes[num - 1];
														}
														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
																stsc_pos++;

														repeat = 1;
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
														repeat++;
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
 												}
 
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
 
												free(metaoffsets32);
 											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 								else
 								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if (num > 0)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
										if (mp4->metaoffsets)
 										{
											uint32_t *metaoffsets32 = NULL;
											metaoffsets32 = (uint32_t *)malloc(num * 4);
											if (metaoffsets32)
 											{
												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
												len += readlen;
												do
												{
													num--;
													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
												} while (num > 0);
 
												free(metaoffsets32);
											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}

					else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets
					{
						if (type == traktype) // meta
						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);

							if(num == 0)
							{
								//size of null
								CloseSource((size_t)mp4);
								mp4 = NULL;
								break;
							}

 							if (num * 8 <= qtsize - 8 - len)
 							{
 								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
 								{
 									mp4->indexcount = mp4->metasize_count;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
									if (mp4->metasize_count)
 									{
										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
										if (mp4->metaoffsets)
 										{
											uint64_t *metaoffsets64 = NULL;
											metaoffsets64 = (uint64_t *)malloc(num * 8);
											if (metaoffsets64)
 											{
												uint64_t fileoffset = 0;
												int stsc_pos = 0;
												int stco_pos = 0;
												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
												do
												{
													num--;
													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
												} while (num > 0);
 
												fileoffset = metaoffsets64[0];
												mp4->metaoffsets[0] = fileoffset;
												//printf(""%3d:%08x, delta = %08x\n"", 0, (int)fileoffset, 0);
 
												num = 1;
												while (num < mp4->metasize_count)
 												{
													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
													{
														stco_pos++;
														fileoffset = (uint64_t)metaoffsets64[stco_pos];
													}
													else
													{
														fileoffset += (uint64_t)mp4->metasizes[num - 1];
													}

													mp4->metaoffsets[num] = fileoffset;
													//int delta = metaoffsets[num] - metaoffsets[num - 1];
													//printf(""%3d:%08x, delta = %08x\n"", num, (int)fileoffset, delta);

													num++;
 												}
 
												if (mp4->metastsc) free(mp4->metastsc);
												mp4->metastsc = NULL;
												mp4->metastsc_count = 0;
 
												free(metaoffsets64);
 											}
 										}
 									}
									else
									{
										//size of null
										CloseSource((size_t)mp4);
										mp4 = NULL;
										break;
									}
 								}
 								else
 								{
									mp4->indexcount = num;
									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
									{
										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
										do
										{
											num--;
											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
										} while (num > 0);
 									}
 								}
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples
					{
						if (type == traktype) // meta 
						{
							uint32_t totaldur = 0, samples = 0;
							int32_t entries = 0;
							len = fread(&skip, 1, 4, mp4->mediafp);
							len += fread(&num, 1, 4, mp4->mediafp);
							num = BYTESWAP32(num);
							if (num * 8 <= qtsize - 8 - len)
							{
								entries = num;

								mp4->meta_clockdemon = mp4->trak_clockdemon;
								mp4->meta_clockcount = mp4->trak_clockcount;

								while (entries > 0)
								{
									int32_t samplecount;
									int32_t duration;
									len += fread(&samplecount, 1, 4, mp4->mediafp);
									samplecount = BYTESWAP32(samplecount);
									len += fread(&duration, 1, 4, mp4->mediafp);
									duration = BYTESWAP32(duration);

									samples += samplecount;
									entries--;

									totaldur += duration;
									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
 								}
 								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
 							}
							mp4->filepos += len;
							LongSeek(mp4, qtsize - 8 - len); // skip over stco
 						}
 						else
							LongSeek(mp4, qtsize - 8);
 
 						NESTSIZE(qtsize);
 					}
					else
					{
						NESTSIZE(8);
					}
			}
			else
			{
 				break;
 			}
 		} while (len > 0);

		if (mp4)
		{
			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
			{
				CloseSource((size_t)mp4);
				mp4 = NULL;
			}
		}
 	}
 	else
 	{

		free(mp4);
		mp4 = NULL;
	}

	return (size_t)mp4;
}
","The vulnerability in the original code lies in the lack of validation for the file size before processing, which could lead to buffer overflows or reading beyond the allocated memory if the file is smaller than expected. Specifically, the absence of a check for `mp4->filesize` allows the code to proceed with operations that assume a larger file size, potentially causing undefined behavior. In the fixed code, a check is introduced after obtaining the file size using `stat64`, ensuring that the file size is at least 64 bytes before proceeding with further processing, thus preventing potential vulnerabilities related to insufficient file size.","The vulnerability in the original code stems from the lack of validation for the file size before processing, which could lead to buffer overflows or reading beyond allocated memory if the file is smaller than expected. This oversight allows the code to attempt operations on insufficient data, potentially causing crashes or undefined behavior. The fixed code addresses this issue by implementing a check for the file size after retrieving it, ensuring that it meets a minimum threshold before proceeding with any further processing. This validation effectively mitigates the risk of operating on inadequate data.",3,"5

The explanation and repair description is highly relevant to the specific code snippet. It appears to be comparing the original code with a repaired version that improves handling of MP4 file parsing. The key differences between the versions include:

1. Additional file size validation and checks
2. Improved memory allocation and null checks
3. Better handling of MP4 atom structure parsing
4. Fixed memory leaks and buffer overflows
5. Enhanced error handling for invalid MP4 files

The changes made are specifically targeted at the MP4 file parsing functionality and directly address potential issues in the original implementation.",3,4
36,36,182743,182743,,Remote,Not required,Partial,CVE-2019-14934,https://www.cvedetails.com/cve/CVE-2019-14934/,CWE-787,Medium,Partial,Partial,,2019-08-11,6.8,"An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write.",2019-09-06,,1,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,0c4120fffa3dffe97b95c486a120eded82afe8a6,"Zero and sanity check all dynamic allocs.

This addresses the memory issues in Issue #6 expressed in
calloc_some.pdf and malloc_some.pdf",1,pdf.c,"{""sha"": ""bde5388bca1d0646004dc8c5bc0588f33a674162"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 2, ""changes"": 21, ""blob_url"": ""https://github.com/enferex/pdfresurrect/blob/0c4120fffa3dffe97b95c486a120eded82afe8a6/main.c"", ""raw_url"": ""https://github.com/enferex/pdfresurrect/raw/0c4120fffa3dffe97b95c486a120eded82afe8a6/main.c"", ""contents_url"": ""https://api.github.com/repos/enferex/pdfresurrect/contents/main.c?ref=0c4120fffa3dffe97b95c486a120eded82afe8a6"", ""patch"": ""@@ -72,7 +72,7 @@ static void write_version(\n     /* Create file */\n     if ((c = strstr(fname, \"".pdf\"")))\n       *c = '\\0';\n-    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n+    new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);\n     snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n              \""%s/%s-version-%d.pdf\"", dirname, fname, xref->version);\n \n@@ -213,6 +213,23 @@ static pdf_t *init_pdf(FILE *fp, const char *name)\n }\n \n \n+void *safe_calloc(size_t size) {\n+  void *addr;\n+\n+  if (!size)\n+  {\n+    ERR(\""Invalid allocation size.\\n\"");\n+    exit(EXIT_FAILURE);\n+  }\n+  if (!(addr = calloc(1, size)))\n+  {\n+      ERR(\""Failed to allocate requested number of bytes, out of memory?\\n\"");\n+      exit(EXIT_FAILURE);\n+  }\n+  return addr;\n+}\n+\n+\n int main(int argc, char **argv)\n {\n     int         i, n_valid, do_write, do_scrub;\n@@ -295,7 +312,7 @@ int main(int argc, char **argv)\n         if ((c = strrchr(name, '.')))\n           *c = '\\0';\n \n-        dname = malloc(strlen(name) + 16);\n+        dname = safe_calloc(strlen(name) + 16);\n         sprintf(dname, \""%s-versions\"", name);\n         if (!(dir = opendir(dname)))\n           mkdir(dname, S_IRWXU);""}<_**next**_>{""sha"": ""c01f70d3161f2290ef91aec1cd718790c6ea3248"", ""filename"": ""main.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/enferex/pdfresurrect/blob/0c4120fffa3dffe97b95c486a120eded82afe8a6/main.h"", ""raw_url"": ""https://github.com/enferex/pdfresurrect/raw/0c4120fffa3dffe97b95c486a120eded82afe8a6/main.h"", ""contents_url"": ""https://api.github.com/repos/enferex/pdfresurrect/contents/main.h?ref=0c4120fffa3dffe97b95c486a120eded82afe8a6"", ""patch"": ""@@ -40,5 +40,7 @@\n #define TAG \""[pdfresurrect]\""\n #define ERR(...) {fprintf(stderr, TAG\"" -- Error -- \"" __VA_ARGS__);}\n \n+/* Returns a zero'd buffer of 'size' bytes or exits in failure. */\n+extern void *safe_calloc(size_t bytes);\n \n #endif /* MAIN_H_INCLUDE */""}<_**next**_>{""sha"": ""6debe688700f3684e9f2a9ecd51e682c4fbe3cc3"", ""filename"": ""pdf.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 20, ""changes"": 33, ""blob_url"": ""https://github.com/enferex/pdfresurrect/blob/0c4120fffa3dffe97b95c486a120eded82afe8a6/pdf.c"", ""raw_url"": ""https://github.com/enferex/pdfresurrect/raw/0c4120fffa3dffe97b95c486a120eded82afe8a6/pdf.c"", ""contents_url"": ""https://api.github.com/repos/enferex/pdfresurrect/contents/pdf.c?ref=0c4120fffa3dffe97b95c486a120eded82afe8a6"", ""patch"": ""@@ -122,7 +122,7 @@ pdf_t *pdf_new(const char *name)\n     const char *n;\n     pdf_t      *pdf;\n    \n-    pdf = calloc(1, sizeof(pdf_t));\n+    pdf = safe_calloc(sizeof(pdf_t));\n \n     if (name)\n     {\n@@ -132,12 +132,12 @@ pdf_t *pdf_new(const char *name)\n         else\n           n = name;\n \n-        pdf->name = malloc(strlen(n) + 1);\n+        pdf->name = safe_calloc(strlen(n) + 1);\n         strcpy(pdf->name, n);\n     }\n     else /* !name */\n     {\n-        pdf->name = malloc(strlen(\""Unknown\"") + 1);\n+        pdf->name = safe_calloc(strlen(\""Unknown\"") + 1);\n         strcpy(pdf->name, \""Unknown\"");\n     }\n \n@@ -216,7 +216,7 @@ int pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n \n     /* Load in the start/end positions */\n     fseek(fp, 0, SEEK_SET);\n-    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n+    pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);\n     ver = 1;\n     for (i=0; i<pdf->n_xrefs; i++)\n     {\n@@ -314,7 +314,7 @@ void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n \n             /* Get root catalog */\n             sz = pdf->xrefs[i].end - ftell(fp);\n-            buf = malloc(sz + 1);\n+            buf = safe_calloc(sz + 1);\n             SAFE_E(fread(buf, 1, sz, fp), sz, \""Failed to load /Root.\\n\"");\n             buf[sz] = '\\0';\n             if (!(c = strstr(buf, \""/Root\"")))\n@@ -444,7 +444,7 @@ void pdf_summarize(\n \n     if (name)\n     {\n-        dst_name = malloc(strlen(name) * 2 + 16);\n+        dst_name = safe_calloc(strlen(name) * 2 + 16);\n         sprintf(dst_name, \""%s/%s\"", name, name);\n \n         if ((c = strrchr(dst_name, '.')) && (strncmp(c, \"".pdf\"", 4) == 0))\n@@ -643,7 +643,7 @@ static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n \n     SAFE_E(fread(buf, 1, 21, fp), 21, \""Failed to load entry Size string.\\n\"");\n     xref->n_entries = atoi(buf + strlen(\""ize \""));\n-    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n+    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n \n     /* Load entry data */\n     obj_id = 0;\n@@ -810,7 +810,7 @@ static pdf_creator_t *new_creator(int *n_elements)\n         {\""Trapped\"",      \""\""},\n     };\n \n-    daddy = malloc(sizeof(creator_template));\n+    daddy = safe_calloc(sizeof(creator_template));\n     memcpy(daddy, creator_template, sizeof(creator_template));\n \n     if (n_elements)\n@@ -1099,8 +1099,7 @@ static char *get_object(\n     obj_sz = 0;    /* Bytes in object */\n     total_sz = 0;  /* Bytes read in   */\n     n_blks = 1;\n-    data = malloc(blk_sz * n_blks);\n-    memset(data, 0, blk_sz * n_blks);\n+    data = safe_calloc(blk_sz * n_blks);\n \n     /* Suck in data */\n     stream = 0;\n@@ -1266,18 +1265,12 @@ static int get_page(int obj_id, const xref_t *xref)\n \n static char *get_header(FILE *fp)\n {\n-    long start;\n-\n     /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n-    char *header;\n-\n-    header = calloc(1, 1024);\n-    \n-    start = ftell(fp);\n+    char *header = safe_calloc(1024);\n+    long start = ftell(fp);\n     fseek(fp, 0, SEEK_SET);\n     SAFE_E(fread(header, 1, 1023, fp), 1023, \""Failed to load PDF header.\\n\"");\n     fseek(fp, start, SEEK_SET);\n-    \n     return header;\n }\n \n@@ -1292,7 +1285,7 @@ static char *decode_text_string(const char *str, size_t str_len)\n     /* Regular encoding */\n     if (str[0] == '(')\n     {\n-        ascii = malloc(strlen(str) + 1);\n+        ascii = safe_calloc(strlen(str) + 1);\n         strncpy(ascii, str, strlen(str) + 1);\n         return ascii;\n     }\n@@ -1314,7 +1307,7 @@ static char *decode_text_string(const char *str, size_t str_len)\n       return NULL;\n \n     /* Now decode as hex */\n-    ascii = malloc(str_len);\n+    ascii = safe_calloc(str_len);\n     for ( ; idx<str_len; ++idx)\n     {\n         hex_buf[0] = str[idx++];""}","void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
{
    int     i, id, dummy;
    char   *buf, *c;
    long    start, sz;

    start = ftell(fp);

    /* Load all kids for all xref tables (versions) */
    for (i=0; i<pdf->n_xrefs; i++)
    {
        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))
        {
            fseek(fp, pdf->xrefs[i].start, SEEK_SET);
            while (SAFE_F(fp, (fgetc(fp) != 't')))
                ; /* Iterate to trailer */
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
            buf = safe_calloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
            {
                free(buf);
                continue;
            }

            /* Jump to catalog (root) */
            id = atoi(c + strlen(""/Root"") + 1);
            free(buf);
            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);
            if (!buf || !(c = strstr(buf, ""/Pages"")))
            {
                free(buf);
                continue;
            }

            /* Start at the first Pages obj and get kids */
            id = atoi(c + strlen(""/Pages"") + 1);
            load_kids(fp, id, &pdf->xrefs[i]);
            free(buf); 
        }
    }
            
    fseek(fp, start, SEEK_SET);
}
","void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
{
    int     i, id, dummy;
    char   *buf, *c;
    long    start, sz;

    start = ftell(fp);

    /* Load all kids for all xref tables (versions) */
    for (i=0; i<pdf->n_xrefs; i++)
    {
        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))
        {
            fseek(fp, pdf->xrefs[i].start, SEEK_SET);
            while (SAFE_F(fp, (fgetc(fp) != 't')))
                ; /* Iterate to trailer */
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
            buf = malloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
            {
                free(buf);
                continue;
            }

            /* Jump to catalog (root) */
            id = atoi(c + strlen(""/Root"") + 1);
            free(buf);
            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);
            if (!buf || !(c = strstr(buf, ""/Pages"")))
            {
                free(buf);
                continue;
            }

            /* Start at the first Pages obj and get kids */
            id = atoi(c + strlen(""/Pages"") + 1);
            load_kids(fp, id, &pdf->xrefs[i]);
            free(buf); 
        }
    }
            
    fseek(fp, start, SEEK_SET);
}
",C,"            buf = safe_calloc(sz + 1);
","            buf = malloc(sz + 1);
",,"@@ -122,7 +122,7 @@ pdf_t *pdf_new(const char *name)
     const char *n;
     pdf_t      *pdf;
    
-    pdf = calloc(1, sizeof(pdf_t));
+    pdf = safe_calloc(sizeof(pdf_t));
 
     if (name)
     {
@@ -132,12 +132,12 @@ pdf_t *pdf_new(const char *name)
         else
           n = name;
 
-        pdf->name = malloc(strlen(n) + 1);
+        pdf->name = safe_calloc(strlen(n) + 1);
         strcpy(pdf->name, n);
     }
     else /* !name */
     {
-        pdf->name = malloc(strlen(""Unknown"") + 1);
+        pdf->name = safe_calloc(strlen(""Unknown"") + 1);
         strcpy(pdf->name, ""Unknown"");
     }
 
@@ -216,7 +216,7 @@ int pdf_load_xrefs(FILE *fp, pdf_t *pdf)
 
     /* Load in the start/end positions */
     fseek(fp, 0, SEEK_SET);
-    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);
+    pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);
     ver = 1;
     for (i=0; i<pdf->n_xrefs; i++)
     {
@@ -314,7 +314,7 @@ void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
-            buf = malloc(sz + 1);
+            buf = safe_calloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
@@ -444,7 +444,7 @@ void pdf_summarize(
 
     if (name)
     {
-        dst_name = malloc(strlen(name) * 2 + 16);
+        dst_name = safe_calloc(strlen(name) * 2 + 16);
         sprintf(dst_name, ""%s/%s"", name, name);
 
         if ((c = strrchr(dst_name, '.')) && (strncmp(c, "".pdf"", 4) == 0))
@@ -643,7 +643,7 @@ static void load_xref_from_plaintext(FILE *fp, xref_t *xref)
 
     SAFE_E(fread(buf, 1, 21, fp), 21, ""Failed to load entry Size string.\n"");
     xref->n_entries = atoi(buf + strlen(""ize ""));
-    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));
+    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));
 
     /* Load entry data */
     obj_id = 0;
@@ -810,7 +810,7 @@ static pdf_creator_t *new_creator(int *n_elements)
         {""Trapped"",      """"},
     };
 
-    daddy = malloc(sizeof(creator_template));
+    daddy = safe_calloc(sizeof(creator_template));
     memcpy(daddy, creator_template, sizeof(creator_template));
 
     if (n_elements)
@@ -1099,8 +1099,7 @@ static char *get_object(
     obj_sz = 0;    /* Bytes in object */
     total_sz = 0;  /* Bytes read in   */
     n_blks = 1;
-    data = malloc(blk_sz * n_blks);
-    memset(data, 0, blk_sz * n_blks);
+    data = safe_calloc(blk_sz * n_blks);
 
     /* Suck in data */
     stream = 0;
@@ -1266,18 +1265,12 @@ static int get_page(int obj_id, const xref_t *xref)
 
 static char *get_header(FILE *fp)
 {
-    long start;
-
     /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
-    char *header;
-
-    header = calloc(1, 1024);
-    
-    start = ftell(fp);
+    char *header = safe_calloc(1024);
+    long start = ftell(fp);
     fseek(fp, 0, SEEK_SET);
     SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
     fseek(fp, start, SEEK_SET);
-    
     return header;
 }
 
@@ -1292,7 +1285,7 @@ static char *decode_text_string(const char *str, size_t str_len)
     /* Regular encoding */
     if (str[0] == '(')
     {
-        ascii = malloc(strlen(str) + 1);
+        ascii = safe_calloc(strlen(str) + 1);
         strncpy(ascii, str, strlen(str) + 1);
         return ascii;
     }
@@ -1314,7 +1307,7 @@ static char *decode_text_string(const char *str, size_t str_len)
       return NULL;
 
     /* Now decode as hex */
-    ascii = malloc(str_len);
+    ascii = safe_calloc(str_len);
     for ( ; idx<str_len; ++idx)
     {
         hex_buf[0] = str[idx++];",pdfresurrect,0c4120fffa3dffe97b95c486a120eded82afe8a6,43339ca3fd32537c5218e560599252278245f517,1,"void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
{
    int     i, id, dummy;
    char   *buf, *c;
    long    start, sz;

    start = ftell(fp);

    /* Load all kids for all xref tables (versions) */
    for (i=0; i<pdf->n_xrefs; i++)
    {
        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))
        {
            fseek(fp, pdf->xrefs[i].start, SEEK_SET);
            while (SAFE_F(fp, (fgetc(fp) != 't')))
                ; /* Iterate to trailer */
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
//flaw_line_below:
            buf = malloc(sz + 1);
//fix_flaw_line_below:
//            buf = safe_calloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
            {
                free(buf);
                continue;
            }

            /* Jump to catalog (root) */
            id = atoi(c + strlen(""/Root"") + 1);
            free(buf);
            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);
            if (!buf || !(c = strstr(buf, ""/Pages"")))
            {
                free(buf);
                continue;
            }

            /* Start at the first Pages obj and get kids */
            id = atoi(c + strlen(""/Pages"") + 1);
            load_kids(fp, id, &pdf->xrefs[i]);
            free(buf); 
        }
    }
            
    fseek(fp, start, SEEK_SET);
}
",182743,"void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
{
    int     i, id, dummy;
    char   *buf, *c;
    long    start, sz;

    start = ftell(fp);

    /* Load all kids for all xref tables (versions) */
    for (i=0; i<pdf->n_xrefs; i++)
    {
        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))
        {
            fseek(fp, pdf->xrefs[i].start, SEEK_SET);
            while (SAFE_F(fp, (fgetc(fp) != 't')))
                ; /* Iterate to trailer */
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
            buf = malloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
            {
                free(buf);
                continue;
            }

            /* Jump to catalog (root) */
            id = atoi(c + strlen(""/Root"") + 1);
            free(buf);
            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);
            if (!buf || !(c = strstr(buf, ""/Pages"")))
            {
                free(buf);
                continue;
            }

            /* Start at the first Pages obj and get kids */
            id = atoi(c + strlen(""/Pages"") + 1);
            load_kids(fp, id, &pdf->xrefs[i]);
            free(buf); 
        }
    }
            
    fseek(fp, start, SEEK_SET);
}
","void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)
{
    int     i, id, dummy;
    char   *buf, *c;
    long    start, sz;

    start = ftell(fp);

    /* Load all kids for all xref tables (versions) */
    for (i=0; i<pdf->n_xrefs; i++)
    {
        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))
        {
            fseek(fp, pdf->xrefs[i].start, SEEK_SET);
            while (SAFE_F(fp, (fgetc(fp) != 't')))
                ; /* Iterate to trailer */
 
             /* Get root catalog */
             sz = pdf->xrefs[i].end - ftell(fp);
            buf = safe_calloc(sz + 1);
             SAFE_E(fread(buf, 1, sz, fp), sz, ""Failed to load /Root.\n"");
             buf[sz] = '\0';
             if (!(c = strstr(buf, ""/Root"")))
            {
                free(buf);
                continue;
            }

            /* Jump to catalog (root) */
            id = atoi(c + strlen(""/Root"") + 1);
            free(buf);
            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);
            if (!buf || !(c = strstr(buf, ""/Pages"")))
            {
                free(buf);
                continue;
            }

            /* Start at the first Pages obj and get kids */
            id = atoi(c + strlen(""/Pages"") + 1);
            load_kids(fp, id, &pdf->xrefs[i]);
            free(buf); 
        }
    }
            
    fseek(fp, start, SEEK_SET);
}
","The vulnerability in the original code arises from the use of `malloc` to allocate memory for `buf` without ensuring that the allocation was successful, which could lead to a null pointer dereference if memory allocation fails. This is particularly problematic when `fread` is called, as it assumes `buf` is valid. The fixed code addresses this vulnerability by replacing `malloc` with `safe_calloc`, which not only allocates memory but also initializes it to zero, ensuring that any subsequent operations on `buf` are safe. This change enhances the robustness of the code by preventing potential crashes due to null pointer dereferences.","The vulnerability in the original code stems from the lack of proper memory allocation checks, which can lead to null pointer dereferences if memory allocation fails. This oversight can cause the program to crash or behave unpredictably when attempting to read from or write to an uninitialized pointer. The fixed code resolves this issue by implementing a safer memory allocation method that not only allocates the required memory but also ensures that it is initialized correctly. This enhancement prevents potential crashes and improves the overall stability and reliability of the program by safeguarding against null pointer dereferences.",3,5,3,4
37,37,182752,182752,,Remote,Not required,Partial,CVE-2019-14495,https://www.cvedetails.com/cve/CVE-2019-14495/,CWE-787,Low,Partial,Partial,,2019-08-01,7.5,webadmin.c in 3proxy before 0.8.13 has an out-of-bounds write in the admin interface.,2019-10-09,,9,https://github.com/z3APA3A/3proxy/commit/3b67dc844789dc0f00e934270c7b349bcb547865,3b67dc844789dc0f00e934270c7b349bcb547865,Fix: out-of-bounds write and few more bugs in 'admin' configuration upload,9,src/webadmin.c,"{""sha"": ""04915b2ffff8dd28f603d5296002c7b986326684"", ""filename"": ""src/webadmin.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/z3APA3A/3proxy/blob/3b67dc844789dc0f00e934270c7b349bcb547865/src/webadmin.c"", ""raw_url"": ""https://github.com/z3APA3A/3proxy/raw/3b67dc844789dc0f00e934270c7b349bcb547865/src/webadmin.c"", ""contents_url"": ""https://api.github.com/repos/z3APA3A/3proxy/contents/src/webadmin.c?ref=3b67dc844789dc0f00e934270c7b349bcb547865"", ""patch"": ""@@ -10,7 +10,7 @@\n \n #define RETURN(xxx) { param->res = xxx; goto CLEANRET; }\n \n-#define LINESIZE 2048\n+#define LINESIZE 65536\n \n extern FILE *writable;\n FILE * confopen();\n@@ -341,7 +341,7 @@ void * adminchild(struct clientparam* param) {\n  char *sb;\n  char *req = NULL;\n  struct printparam pp;\n- int contentlen = 0;\n+ unsigned contentlen = 0;\n  int isform = 0;\n \n  pp.inbuf = 0;\n@@ -390,7 +390,8 @@ void * adminchild(struct clientparam* param) {\n \telse if(i > 15 && (!strncasecmp(buf, \""content-length:\"", 15))){\n \t\tsb = buf + 15;\n \t\twhile(isspace(*sb))sb++;\n-\t\tcontentlen = atoi(sb);\n+\t\tsscanf(sb, \""%u\"", &contentlen);\n+\t\tif(contentlen > LINESIZE*1024) contentlen = 0;\n \t}\n \telse if(i > 13 && (!strncasecmp(buf, \""content-type:\"", 13))){\n \t\tsb = buf + 13;\n@@ -520,7 +521,7 @@ void * adminchild(struct clientparam* param) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\t\tprintstr(&pp, \""<h3>Please be careful editing config file remotely</h3>\"");\n-\t\t\t\tprintstr(&pp, \""<form method=\\\""POST\\\"" action=\\\""/U\\\""><textarea cols=\\\""80\\\"" rows=\\\""30\\\"" name=\\\""conffile\\\"">\"");\n+\t\t\t\tprintstr(&pp, \""<form method=\\\""POST\\\"" action=\\\""/U\\\"" enctype=\\\""application/x-www-form-urlencoded\\\""><textarea cols=\\\""80\\\"" rows=\\\""30\\\"" name=\\\""conffile\\\"">\"");\n \t\t\t\twhile(fgets(buf, 256, fp)){\n \t\t\t\t\tprintstr(&pp, buf);\n \t\t\t\t}\n@@ -530,24 +531,23 @@ void * adminchild(struct clientparam* param) {\n \t\t}\n \tcase 'U':\n \t\t{\n-\t\t\tint l=0;\n+\t\t\tunsigned l=0;\n \t\t\tint error = 0;\n \n-\t\t\tif(!writable || fseek(writable, 0, 0)){\n+\t\t\tif(!writable || !contentlen || fseek(writable, 0, 0)){\n \t\t\t\terror = 1;\n \t\t\t}\n-\t\t\twhile((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){\n+\t\t\twhile(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){\n \t\t\t\tif(i > (contentlen - l)) i = (contentlen - l);\n-\t\t\t\tbuf[i] = 0;\n \t\t\t\tif(!l){\n-\t\t\t\t\tif(strncasecmp(buf, \""conffile=\"", 9)) error = 1;\n+\t\t\t\t\tif(i<9 || strncasecmp(buf, \""conffile=\"", 9)) error = 1;\n \t\t\t\t}\n \t\t\t\tif(!error){\n+\t\t\t\t\tbuf[i] = 0;\n \t\t\t\t\tdecodeurl((unsigned char *)buf, 1);\n \t\t\t\t\tfprintf(writable, \""%s\"", l? buf : buf + 9);\n \t\t\t\t}\n \t\t\t\tl += i;\n-\t\t\t\tif(l >= contentlen) break;\n \t\t\t}\n \t\t\tif(writable && !error){\n \t\t\t\tfflush(writable);""}","void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
  char *sb;
  char *req = NULL;
  struct printparam pp;
 unsigned contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
		sscanf(sb, ""%u"", &contentlen);
		if(contentlen > LINESIZE*1024) contentlen = 0;
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
 		}
 	case 'U':
 		{
			unsigned l=0;
 			int error = 0;
 
			if(!writable || !contentlen || fseek(writable, 0, 0)){
 				error = 1;
 			}
			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
 				if(!l){
					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
					buf[i] = 0;
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
 			}
 			if(writable && !error){
 				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
","void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
  char *sb;
  char *req = NULL;
  struct printparam pp;
 int contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
		contentlen = atoi(sb);
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
 		}
 	case 'U':
 		{
			int l=0;
 			int error = 0;
 
			if(!writable || fseek(writable, 0, 0)){
 				error = 1;
 			}
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
				buf[i] = 0;
 				if(!l){
					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
				if(l >= contentlen) break;
 			}
 			if(writable && !error){
 				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
",C," unsigned contentlen = 0;
		sscanf(sb, ""%u"", &contentlen);
		if(contentlen > LINESIZE*1024) contentlen = 0;
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
			unsigned l=0;
			if(!writable || !contentlen || fseek(writable, 0, 0)){
			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
					buf[i] = 0;
"," int contentlen = 0;
		contentlen = atoi(sb);
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
			int l=0;
			if(!writable || fseek(writable, 0, 0)){
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
				buf[i] = 0;
					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
				if(l >= contentlen) break;
",,"@@ -10,7 +10,7 @@
 
 #define RETURN(xxx) { param->res = xxx; goto CLEANRET; }
 
-#define LINESIZE 2048
+#define LINESIZE 65536
 
 extern FILE *writable;
 FILE * confopen();
@@ -341,7 +341,7 @@ void * adminchild(struct clientparam* param) {
  char *sb;
  char *req = NULL;
  struct printparam pp;
- int contentlen = 0;
+ unsigned contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
@@ -390,7 +390,8 @@ void * adminchild(struct clientparam* param) {
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
-		contentlen = atoi(sb);
+		sscanf(sb, ""%u"", &contentlen);
+		if(contentlen > LINESIZE*1024) contentlen = 0;
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
@@ -520,7 +521,7 @@ void * adminchild(struct clientparam* param) {
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
-				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
+				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
@@ -530,24 +531,23 @@ void * adminchild(struct clientparam* param) {
 		}
 	case 'U':
 		{
-			int l=0;
+			unsigned l=0;
 			int error = 0;
 
-			if(!writable || fseek(writable, 0, 0)){
+			if(!writable || !contentlen || fseek(writable, 0, 0)){
 				error = 1;
 			}
-			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
+			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
-				buf[i] = 0;
 				if(!l){
-					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
+					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
+					buf[i] = 0;
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
-				if(l >= contentlen) break;
 			}
 			if(writable && !error){
 				fflush(writable);",3proxy,3b67dc844789dc0f00e934270c7b349bcb547865,d07500687c1a42f73ec5d96a4e1e028af985892f,1,"void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
  char *sb;
  char *req = NULL;
  struct printparam pp;
//flaw_line_below:
 int contentlen = 0;
//fix_flaw_line_below:
// unsigned contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
//flaw_line_below:
		contentlen = atoi(sb);
//fix_flaw_line_below:
//		sscanf(sb, ""%u"", &contentlen);
//fix_flaw_line_below:
//		if(contentlen > LINESIZE*1024) contentlen = 0;
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
//flaw_line_below:
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
//fix_flaw_line_below:
//				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
 		}
 	case 'U':
 		{
//flaw_line_below:
			int l=0;
//fix_flaw_line_below:
//			unsigned l=0;
 			int error = 0;
 
//flaw_line_below:
			if(!writable || fseek(writable, 0, 0)){
//fix_flaw_line_below:
//			if(!writable || !contentlen || fseek(writable, 0, 0)){
 				error = 1;
 			}
//flaw_line_below:
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
//fix_flaw_line_below:
//			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
//flaw_line_below:
				buf[i] = 0;
 				if(!l){
//flaw_line_below:
					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
//fix_flaw_line_below:
//					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
//fix_flaw_line_below:
//					buf[i] = 0;
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
//flaw_line_below:
				if(l >= contentlen) break;
 			}
 			if(writable && !error){
 				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
",182752,"void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
  char *sb;
  char *req = NULL;
  struct printparam pp;
 int contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
		contentlen = atoi(sb);
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
 		}
 	case 'U':
 		{
			int l=0;
 			int error = 0;
 
			if(!writable || fseek(writable, 0, 0)){
 				error = 1;
 			}
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
				buf[i] = 0;
 				if(!l){
					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
				if(l >= contentlen) break;
 			}
 			if(writable && !error){
 				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
","void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
  char *sb;
  char *req = NULL;
  struct printparam pp;
 unsigned contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
		sscanf(sb, ""%u"", &contentlen);
		if(contentlen > LINESIZE*1024) contentlen = 0;
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
 		}
 	case 'U':
 		{
			unsigned l=0;
 			int error = 0;
 
			if(!writable || !contentlen || fseek(writable, 0, 0)){
 				error = 1;
 			}
			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
 				if(!l){
					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
					buf[i] = 0;
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
 			}
 			if(writable && !error){
 				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
","The vulnerability in the original code stemmed from the handling of the `contentlen` variable, which was defined as an `int`. This could lead to integer overflow when processing large content lengths, potentially allowing an attacker to manipulate the buffer size and cause a buffer overflow. In the fixed code, `contentlen` was changed to an `unsigned` type, and additional checks were added to ensure that `contentlen` does not exceed a safe limit (specifically, `LINESIZE*1024`). This change mitigates the risk of buffer overflow by preventing excessively large values from being processed, thus enhancing the security of the function.","The vulnerability in the original code was due to the handling of user input, specifically the content length, which could lead to integer overflow and buffer overflow issues. This allowed an attacker to potentially manipulate the input size, leading to memory corruption or unauthorized access. In the revised code, the content length was changed to an unsigned type, and additional checks were implemented to ensure that the length does not exceed a predefined safe limit. These modifications effectively prevent the exploitation of buffer overflow vulnerabilities, thereby enhancing the overall security of the application.",3,5,4,4
38,38,182959,182959,,Remote,Not required,Partial,CVE-2018-20763,https://www.cvedetails.com/cve/CVE-2018-20763/,CWE-787,Medium,Partial,Partial,,2019-02-06,6.8,"In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because of missing szLineConv bounds checking.",2019-04-15,,1,https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,add some boundary checks on gf_text_get_utf8_line (#1188),1,applications/mp4client/main.c,"{""sha"": ""df01947f3c03c0744cd4811250ae59315d754944"", ""filename"": ""applications/mp4client/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/gpac/gpac/blob/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd/applications/mp4client/main.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd/applications/mp4client/main.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/applications/mp4client/main.c?ref=1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd"", ""patch"": ""@@ -1715,7 +1715,7 @@ int mp4client_main(int argc, char **argv)\n \t\t\t\t\te = gf_dm_sess_process(sess);\n \t\t\t\t\tif (!e) {\n \t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n-\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n+\t\t\t\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n \t\t\t\t\t}\n \t\t\t\t\tgf_dm_sess_del(sess);\n \t\t\t\t}""}<_**next**_>{""sha"": ""af92000787b73a9f10f2d16dd69ccae7c6dccc3b"", ""filename"": ""src/media_tools/text_import.c"", ""status"": ""modified"", ""additions"": 52, ""deletions"": 25, ""changes"": 77, ""blob_url"": ""https://github.com/gpac/gpac/blob/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd/src/media_tools/text_import.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd/src/media_tools/text_import.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/media_tools/text_import.c?ref=1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd"", ""patch"": ""@@ -205,49 +205,76 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod\n \tif (unicode_type<=1) {\n \t\tj=0;\n \t\tlen = (u32) strlen(szLine);\n-\t\tfor (i=0; i<len; i++) {\n+\t\tfor (i=0; i<len && j < sizeof(szLineConv) - 1; i++, j++) {\n+\n \t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n \t\t\t\t/*non UTF8 (likely some win-CP)*/\n \t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n-\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n-\t\t\t\t\tj++;\n-\t\t\t\t\tszLine[i] &= 0xbf;\n+\t\t\t\t\tif (j + 1 < sizeof(szLineConv) - 1) {\n+\t\t\t\t\t\tszLineConv[j] = 0xc0 | ((szLine[i] >> 6) & 0x3);\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t\tszLine[i] &= 0xbf;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\t/*UTF8 2 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n+\n+\t\t\t\t\t// don't cut multibyte in the middle in there is no more room in dest\n+\t\t\t\t\tif (j + 1 < sizeof(szLineConv) - 1 && i + 1 < len) {\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t/*UTF8 3 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n+\t\t\t\t\tif (j + 2 < sizeof(szLineConv) - 1 && i + 2 < len) {\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t/*UTF8 4 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n-\t\t\t\t\tszLineConv[j] = szLine[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t\tj++;\n+\t\t\t\t\tif (j + 3 < sizeof(szLineConv) - 1 && i + 3 < len) {\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t\tszLineConv[j] = szLine[i];\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tj++;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\ti+=1;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tszLineConv[j] = szLine[i];\n-\t\t\tj++;\n+\t\t\tif (j < sizeof(szLineConv)-1 && i<len)\n+\t\t\t\tszLineConv[j] = szLine[i];\n+\n \t\t}\n-\t\tszLineConv[j] = 0;\n+\t\tif (j >= sizeof(szLineConv))\n+\t\t\tszLineConv[sizeof(szLineConv) - 1] = 0;\n+\t\telse\n+\t\t\tszLineConv[j] = 0;\n+\n \t\tstrcpy(szLine, szLineConv);\n \t\treturn sOK;\n \t}""}","int mp4client_main(int argc, char **argv)
{
	char c;
	const char *str;
	int ret_val = 0;
	u32 i, times[100], nb_times, dump_mode;
	u32 simulation_time_in_ms = 0;
	u32 initial_service_id = 0;
	Bool auto_exit = GF_FALSE;
	Bool logs_set = GF_FALSE;
	Bool start_fs = GF_FALSE;
	Bool use_rtix = GF_FALSE;
	Bool pause_at_first = GF_FALSE;
	Bool no_cfg_save = GF_FALSE;
	Bool is_cfg_only = GF_FALSE;

	Double play_from = 0;
#ifdef GPAC_MEMORY_TRACKING
    GF_MemTrackerType mem_track = GF_MemTrackerNone;
#endif
	Double fps = GF_IMPORT_DEFAULT_FPS;
	Bool fill_ar, visible, do_uncache, has_command;
	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
	FILE *logfile = NULL;
	Float scale = 1;
#ifndef WIN32
	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
#endif

	/*by default use current dir*/
	strcpy(the_url, ""."");

	memset(&user, 0, sizeof(GF_User));

	dump_mode = DUMP_NONE;
	fill_ar = visible = do_uncache = has_command = GF_FALSE;
	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
	nb_times = 0;
	times[0] = 0;

	/*first locate config file if specified*/
	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];
		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			the_cfg = argv[i+1];
			i++;
		}
		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
#ifdef GPAC_MEMORY_TRACKING
            mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
#else
			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
#endif
		} else if (!strcmp(arg, ""-gui"")) {
			gui_mode = 1;
		} else if (!strcmp(arg, ""-guid"")) {
			gui_mode = 2;
		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
			PrintUsage();
			return 0;
		}
	}

#ifdef GPAC_MEMORY_TRACKING
	gf_sys_init(mem_track);
#else
	gf_sys_init(GF_MemTrackerNone);
#endif
	gf_sys_set_args(argc, (const char **) argv);

	cfg_file = gf_cfg_init(the_cfg, NULL);
	if (!cfg_file) {
		fprintf(stderr, ""Error: Configuration File not found\n"");
		return 1;
	}
	/*if logs are specified, use them*/
	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
		return 1;
	}

	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
		logs_set = GF_TRUE;
	}

	if (!gui_mode) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
	}

	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];

		if (!strcmp(arg, ""-rti"")) {
			rti_file = argv[i+1];
			i++;
		} else if (!strcmp(arg, ""-rtix"")) {
			rti_file = argv[i+1];
			i++;
			use_rtix = GF_TRUE;
		} else if (!stricmp(arg, ""-size"")) {
			/*usage of %ud breaks sscanf on MSVC*/
			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
				forced_width = forced_height = 0;
			}
			i++;
		} else if (!strcmp(arg, ""-quiet"")) {
			be_quiet = 1;
		} else if (!strcmp(arg, ""-strict-error"")) {
			gf_log_set_strict_error(1);
		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
			logfile = gf_fopen(argv[i+1], ""wt"");
			gf_log_set_callback(logfile, on_gpac_log);
			i++;
		} else if (!strcmp(arg, ""-logs"") ) {
			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
				return 1;
			}
			logs_set = GF_TRUE;
			i++;
		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
			log_time_start = 1;
		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
			log_utc_time = 1;
		}
#if defined(__DARWIN__) || defined(__APPLE__)
		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
#else
		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
#endif
		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
		else if (!strcmp(arg, ""-fs"")) start_fs = 1;

		else if (!strcmp(arg, ""-opt"")) {
			set_cfg_option(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-conf"")) {
			set_cfg_option(argv[i+1]);
			is_cfg_only=GF_TRUE;
			i++;
		}
		else if (!strcmp(arg, ""-ifce"")) {
			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
			i++;
		}
		else if (!stricmp(arg, ""-help"")) {
			PrintUsage();
			return 1;
		}
		else if (!stricmp(arg, ""-noprog"")) {
			no_prog=1;
			gf_set_progress_callback(NULL, progress_quiet);
		}
		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"") /*old versions used --n-save ...*/) {
			no_cfg_save=1;
		}
		else if (!stricmp(arg, ""-ntp-shift"")) {
			s32 shift = atoi(argv[i+1]);
			i++;
			gf_net_set_ntp_shift(shift);
		}
		else if (!stricmp(arg, ""-run-for"")) {
			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
			if (!simulation_time_in_ms)
				simulation_time_in_ms = 1; /*1ms*/
			i++;
		}

		else if (!strcmp(arg, ""-out"")) {
			out_arg = argv[i+1];
			i++;
		}
		else if (!stricmp(arg, ""-fps"")) {
			fps = atof(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
			dump_mode &= 0xFFFF0000;

			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
			else dump_mode |= DUMP_AVI;

			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
					return 1;
				}
				i++;
			}
		} else if (!strcmp(arg, ""-rgbds"")) { /*get dump in rgbds pixel format*/
				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
		} else if (!strcmp(arg, ""-rgbd"")) { /*get dump in rgbd pixel format*/
				dump_mode |= DUMP_RGB_DEPTH;
		} else if (!strcmp(arg, ""-depth"")) {
				dump_mode |= DUMP_DEPTH_ONLY;
		} else if (!strcmp(arg, ""-bmp"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_BMP;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-png"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_PNG;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-raw"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_RAW;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!stricmp(arg, ""-scale"")) {
			sscanf(argv[i+1], ""%f"", &scale);
			i++;
		}
		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			/* already parsed */
			i++;
		}

		/*arguments only used in non-gui mode*/
		if (!gui_mode) {
			if (arg[0] != '-') {
				if (url_arg) {
					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
					return 1;
				}
				url_arg = arg;
			}
			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;

			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
			else if (!strcmp(arg, ""-play-from"")) {
				play_from = atof((const char *) argv[i+1]);
				i++;
			}
			else if (!strcmp(arg, ""-speed"")) {
				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
				if (playback_speed <= 0) playback_speed = FIX_ONE;
				i++;
			}
			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
			else if (!strcmp(arg, ""-align"")) {
				if (argv[i+1][0]=='m') align_mode = 1;
				else if (argv[i+1][0]=='b') align_mode = 2;
				align_mode <<= 8;
				if (argv[i+1][1]=='m') align_mode |= 1;
				else if (argv[i+1][1]=='r') align_mode |= 2;
				i++;
			} else if (!strcmp(arg, ""-fill"")) {
				fill_ar = GF_TRUE;
			} else if (!strcmp(arg, ""-show"")) {
				visible = 1;
			} else if (!strcmp(arg, ""-uncache"")) {
				do_uncache = GF_TRUE;
			}
			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
			else if (!stricmp(arg, ""-views"")) {
				views = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-mosaic"")) {
				mosaic = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-com"")) {
				has_command = GF_TRUE;
				i++;
			}
			else if (!stricmp(arg, ""-service"")) {
				initial_service_id = atoi(argv[i+1]);
				i++;
			}
		}
	}
	if (is_cfg_only) {
		gf_cfg_del(cfg_file);
		fprintf(stderr, ""GPAC Config updated\n"");
		return 0;
	}
	if (do_uncache) {
		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
		do_flatten_cache(cache_dir);
		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
		gf_cfg_del(cfg_file);
		return 0;
	}

	if (dump_mode && !url_arg ) {
		FILE *test;
		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
		if (!test) url_arg = NULL;
		else gf_fclose(test);
		
		if (!url_arg) {
			fprintf(stderr, ""Missing argument for dump\n"");
			PrintUsage();
			if (logfile) gf_fclose(logfile);
			return 1;
		}
	}

	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
		gui_mode=1;
	}

#ifdef WIN32
	if (gui_mode==1) {
		const char *opt;
		TCHAR buffer[1024];
		DWORD res = GetCurrentDirectory(1024, buffer);
		buffer[res] = 0;
		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
		if (strstr(opt, buffer)) {
			gui_mode=1;
		} else {
			gui_mode=2;
		}
	}
#endif

	if (gui_mode==1) {
		hide_shell(1);
	}
	if (gui_mode) {
		no_prog=1;
		gf_set_progress_callback(NULL, progress_quiet);
	}

	if (!url_arg && simulation_time_in_ms)
		simulation_time_in_ms += gf_sys_clock();

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_init();
#endif


	if (dump_mode) rti_file = NULL;

	if (!logs_set) {
		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
	}
	if (rti_file || logfile || log_utc_time || log_time_start)
		gf_log_set_callback(NULL, on_gpac_log);

	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);

	{
		GF_SystemRTInfo rti;
		if (gf_sys_get_rti(0, &rti, 0))
			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
	}


	/*setup dumping options*/
	if (dump_mode) {
		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
		if (!visible)
			user.init_flags |= GF_TERM_INIT_HIDE;

		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		no_cfg_save=GF_TRUE;
	} else {
		init_w = forced_width;
		init_h = forced_height;
	}

	user.modules = gf_modules_new(NULL, cfg_file);
	if (user.modules) i = gf_modules_get_count(user.modules);
	if (!i || !user.modules) {
		fprintf(stderr, ""Error: no modules found - exiting\n"");
		if (user.modules) gf_modules_del(user.modules);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Modules Found : %d \n"", i);

	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
		gf_cfg_del_section(cfg_file, ""PluginsCache"");
		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
	}

	user.config = cfg_file;
	user.EventProc = GPAC_EventProc;
	/*dummy in this case (global vars) but MUST be non-NULL*/
	user.opaque = user.modules;
	if (threading_flags) user.init_flags |= threading_flags;
	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;

	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;

	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

	if (bench_mode) {
		gf_cfg_discard_changes(user.config);
		auto_exit = GF_TRUE;
		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		if (bench_mode!=2) {
			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
		} else {
			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
		}
	}

	{
		char dim[50];
		sprintf(dim, ""%d"", forced_width);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
		sprintf(dim, ""%d"", forced_height);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
	}

	fprintf(stderr, ""Loading GPAC Terminal\n"");
	i = gf_sys_clock();
	term = gf_term_new(&user);
	if (!term) {
		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
		list_modules(user.modules);
		gf_modules_del(user.modules);
		gf_cfg_discard_changes(cfg_file);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);

	if (bench_mode) {
		display_rti = 2;
		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
		if (bench_mode==1) bench_mode=2;
	}

	if (dump_mode) {
		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
	} else {
		/*check video output*/
		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
		/*check audio output*/
		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");

		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
	}

	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
	if (str && !strcmp(str, ""yes"")) {
		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
	}

	if (rti_file) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
		if (str) {
			rti_update_time_ms = atoi(str);
		} else {
			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
		}
		UpdateRTInfo(""At GPAC load time\n"");
	}

	Run = 1;

	if (dump_mode) {
		if (!nb_times) {
			times[0] = 0;
			nb_times++;
		}
		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
		Run = 0;
	}
	else if (views) {
	}
	/*connect if requested*/
	else if (!gui_mode && url_arg) {
		char *ext;

		if (strlen(url_arg) >= sizeof(the_url)) {
			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
			strncpy(the_url, url_arg, sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
		}
		else {
			strcpy(the_url, url_arg);
		}
		ext = strrchr(the_url, '.');
		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
			GF_Err e = GF_OK;
			fprintf(stderr, ""Opening Playlist %s\n"", the_url);

			strcpy(pl_path, the_url);
			/*this is not clean, we need to have a plugin handle playlist for ourselves*/
			if (!strncmp(""http:"", the_url, 5)) {
				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
				if (sess) {
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_url) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}
			}

			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
			readonly_playlist = 1;
			if (playlist) {
				request_next_playlist_item = GF_TRUE;
			} else {
				if (e)
					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
				fprintf(stderr, ""Hit 'h' for help\n\n"");
			}
		} else {
			fprintf(stderr, ""Opening URL %s\n"", the_url);
			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
		}
	} else {
		fprintf(stderr, ""Hit 'h' for help\n\n"");
		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		if (str) {
			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
			gf_term_connect(term, str);
			startup_file = 1;
			is_connected = 1;
		}
	}
	if (gui_mode==2) gui_mode=0;

	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

	if (views) {
		char szTemp[4046];
		sprintf(szTemp, ""views://%s"", views);
		gf_term_connect(term, szTemp);
	}
	if (mosaic) {
		char szTemp[4046];
		sprintf(szTemp, ""mosaic://%s"", mosaic);
		gf_term_connect(term, szTemp);
	}
	if (bench_mode) {
		rti_update_time_ms = 500;
		bench_mode_start = gf_sys_clock();
	}


	while (Run) {

		/*we don't want getchar to block*/
		if ((gui_mode==1) || !gf_prompt_has_input()) {
			if (reload) {
				reload = 0;
				gf_term_disconnect(term);
				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
			}
			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				restart = 0;
				gf_term_play_from_time(term, 0, 0);
			}
			if (request_next_playlist_item) {
				c = '\n';
				request_next_playlist_item = 0;
				goto force_input;
			}

			if (has_command && is_connected) {
				has_command = GF_FALSE;
				for (i=0; i<(u32)argc; i++) {
					if (!strcmp(argv[i], ""-com"")) {
						gf_term_scene_update(term, NULL, argv[i+1]);
						i++;
					}
				}
			}
			if (initial_service_id && is_connected) {
				GF_ObjectManager *root_od = gf_term_get_root_object(term);
				if (root_od) {
					gf_term_select_service(term, root_od, initial_service_id);
					initial_service_id = 0;
				}
			}

			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
			if (term_step) {
				gf_term_process_step(term);
			} else {
				gf_sleep(rti_update_time_ms);
			}
			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				Run = GF_FALSE;
			}

			/*sim time*/
			if (simulation_time_in_ms
			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
			   ) {
				Run = GF_FALSE;
			}
			continue;
		}
		c = gf_prompt_get_char();

force_input:
		switch (c) {
		case 'q':
		{
			GF_Event evt;
			memset(&evt, 0, sizeof(GF_Event));
			evt.type = GF_EVENT_QUIT;
			gf_term_send_event(term, &evt);
		}
		break;
		case 'X':
			exit(0);
			break;
		case 'Q':
			break;
		case 'o':
			startup_file = 0;
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
				break;
			}
			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
			gf_term_connect(term, the_url);
			break;
		case 'O':
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
				break;
			}
			playlist = gf_fopen(the_url, ""rt"");
			if (playlist) {
				if (1 >	fscanf(playlist, ""%s"", the_url)) {
					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
					gf_fclose( playlist);
					break;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case '\n':
		case 'N':
			if (playlist) {
				int res;
				gf_term_disconnect(term);

				res = fscanf(playlist, ""%s"", the_url);
				if ((res == EOF) && loop_at_end) {
					fseek(playlist, 0, SEEK_SET);
					res = fscanf(playlist, ""%s"", the_url);
				}
				if (res == EOF) {
					fprintf(stderr, ""No more items - exiting\n"");
					Run = 0;
				} else if (the_url[0] == '#') {
					request_next_playlist_item = GF_TRUE;
				} else {
					fprintf(stderr, ""Opening URL %s\n"", the_url);
					gf_term_connect_with_path(term, the_url, pl_path);
				}
			}
			break;
		case 'P':
			if (playlist) {
				u32 count;
				gf_term_disconnect(term);
				if (1 > scanf(""%u"", &count)) {
					fprintf(stderr, ""Cannot read number, aborting.\n"");
					break;
				}
				while (count) {
					if (fscanf(playlist, ""%s"", the_url)) {
						fprintf(stderr, ""Failed to read line, aborting\n"");
						break;
					}
					count--;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case 'r':
			if (is_connected)
				reload = 1;
			break;

		case 'D':
			if (is_connected) gf_term_disconnect(term);
			break;

		case 'p':
			if (is_connected) {
				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
			}
			break;
		case 's':
			if (is_connected) {
				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
				fprintf(stderr, ""Step time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, ""\n"");
			}
			break;

		case 'z':
		case 'T':
			if (!CanSeek || (Duration<=2000)) {
				fprintf(stderr, ""scene not seekable\n"");
			} else {
				Double res;
				s32 seekTo;
				fprintf(stderr, ""Duration: "");
				PrintTime(Duration);
				res = gf_term_get_time_in_ms(term);
				if (c=='z') {
					res *= 100;
					res /= (s64)Duration;
					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
					if (scanf(""%d"", &seekTo) == 1) {
						if (seekTo > 100) seekTo = 100;
						res = (Double)(s64)Duration;
						res /= 100;
						res *= seekTo;
						gf_term_play_from_time(term, (u64) (s64) res, 0);
					}
				} else {
					u32 r, h, m, s;
					fprintf(stderr, "" - Current Time: "");
					PrintTime((u64) res);
					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
					h = m = s = 0;
					r =scanf(""%d:%d:%d"", &h, &m, &s);
					if (r==2) {
						s = m;
						m = h;
						h = 0;
					}
					else if (r==1) {
						s = h;
						m = h = 0;
					}

					if (r && (r<=3)) {
						u64 time = h*3600 + m*60 + s;
						gf_term_play_from_time(term, time*1000, 0);
					}
				}
			}
			break;

		case 't':
		{
			if (is_connected) {
				fprintf(stderr, ""Current Time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, "" - Duration: "");
				PrintTime(Duration);
				fprintf(stderr, ""\n"");
			}
		}
		break;
		case 'w':
			if (is_connected) PrintWorldInfo(term);
			break;
		case 'v':
			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
			break;
		case 'i':
			if (is_connected) {
				u32 ID;
				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
				fflush(stderr);
				if (scanf(""%ud"", &ID) == 1) {
					ViewOD(term, ID, (u32)-1, NULL);
				} else {
					char str_url[GF_MAX_PATH];
					if (scanf(""%s"", str_url) == 1)
						ViewOD(term, 0, (u32)-1, str_url);
				}
			}
			break;
		case 'j':
			if (is_connected) {
				u32 num;
				do {
					fprintf(stderr, ""Enter OD number (0 for main OD): "");
					fflush(stderr);
				} while( 1 > scanf(""%ud"", &num));
				ViewOD(term, (u32)-1, num, NULL);
			}
			break;
		case 'b':
			if (is_connected) ViewODs(term, 1);
			break;

		case 'm':
			if (is_connected) ViewODs(term, 0);
			break;

		case 'l':
			list_modules(user.modules);
			break;

		case 'n':
			if (is_connected) set_navigation();
			break;
		case 'x':
			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
			break;

		case 'd':
			if (is_connected) {
				GF_ObjectManager *odm = NULL;
				char radname[GF_MAX_PATH], *sExt;
				GF_Err e;
				u32 i, count, odid;
				Bool xml_dump, std_out;
				radname[0] = 0;
				do {
					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
					fflush(stderr);
				} while( 1 >  scanf(""%ud"", &odid));
				if (odid) {
					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
					if (!root_odm) break;
					count = gf_term_get_object_count(term, root_odm);
					for (i=0; i<count; i++) {
						GF_MediaInfo info;
						odm = gf_term_get_object(term, root_odm, i);
						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
							if (info.od->objectDescriptorID==odid) break;
						}
						odm = NULL;
					}
				}
				do {
					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
					fflush(stderr);
				} while( 1 > scanf(""%s"", radname));
				sExt = strrchr(radname, '.');
				xml_dump = 0;
				if (sExt) {
					if (!stricmp(sExt, "".x"")) xml_dump = 1;
					sExt[0] = 0;
				}
				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
			}
			break;

		case 'c':
			PrintGPACConfig();
			break;
		case '3':
		{
			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
			}
		}
		break;
		case 'k':
		{
			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
			opt = !opt;
			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
		}
		break;
		case '4':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
			break;
		case '5':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
			break;
		case '6':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
			break;
		case '7':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
			break;

		case 'C':
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_DISABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
				break;
			case GF_MEDIA_CACHE_ENABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
				continue;
			}
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_ENABLED:
				fprintf(stderr, ""Streaming Cache Enabled\n"");
				break;
			case GF_MEDIA_CACHE_DISABLED:
				fprintf(stderr, ""Streaming Cache Disabled\n"");
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache Running\n"");
				break;
			}
			break;
		case 'S':
		case 'A':
			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
				fprintf(stderr, ""Streaming Cache stopped\n"");
			} else {
				fprintf(stderr, ""Streaming Cache not running\n"");
			}
			break;
		case 'R':
			display_rti = !display_rti;
			ResetCaption();
			break;
		case 'F':
			if (display_rti) display_rti = 0;
			else display_rti = 2;
			ResetCaption();
			break;

		case 'u':
		{
			GF_Err e;
			char szCom[8192];
			fprintf(stderr, ""Enter command to send:\n"");
			fflush(stdin);
			szCom[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szCom)) {
				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, NULL, szCom);
			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
		}
		break;
		case 'e':
		{
			GF_Err e;
			char jsCode[8192];
			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
			fflush(stdin);
			jsCode[0] = 0;
			if (1 > scanf(""%[^\t\n]"", jsCode)) {
				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
		}
		break;

		case 'L':
		{
			char szLog[1024], *cur_logs;
			cur_logs = gf_log_get_tools_levels();
			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
			gf_free(cur_logs);
			if (scanf(""%s"", szLog) < 1) {
				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
				break;
			}
			gf_log_modify_tools_levels(szLog);
		}
		break;

		case 'g':
		{
			GF_SystemRTInfo rti;
			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
		}
		break;
		case 'M':
		{
			u32 size;
			do {
				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
			} while (1 > scanf(""%ud"", &size));
			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
		}
		break;

		case 'H':
		{
			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
			do {
				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
			} while (1 > scanf(""%ud"", &http_bitrate));

			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
		}
		break;

		case 'E':
			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
			break;

		case 'B':
			switch_bench(!bench_mode);
			break;

		case 'Y':
		{
			char szOpt[8192];
			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read option\n"");
				break;
			}
			set_cfg_option(szOpt);
		}
		break;

		/*extract to PNG*/
		case 'Z':
		{
			char szFileName[100];
			u32 nb_pass, nb_views, offscreen_view = 0;
			GF_VideoSurface fb;
			GF_Err e;
			nb_pass = 1;
			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
			if (nb_views>1) {
				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
				if (scanf(""%d"", &offscreen_view) != 1) {
					offscreen_view = 0;
				}
				if (offscreen_view==nb_views+1) {
					offscreen_view = 1;
					nb_pass = nb_views;
				}
				else if (offscreen_view==nb_views+2) {
					offscreen_view = 0;
					nb_pass = nb_views+1;
				}
			}
			while (nb_pass) {
				nb_pass--;
				if (offscreen_view) {
					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
				} else {
					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
					e = gf_term_get_screen_buffer(term, &fb);
				}
				offscreen_view++;
				if (e) {
					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
					nb_pass = 0;
				} else {
#ifndef GPAC_DISABLE_AV_PARSERS
					u32 dst_size = fb.width*fb.height*4;
					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);

					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
					if (e) {
						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
						nb_pass = 0;
					} else {
						FILE *png = gf_fopen(szFileName, ""wb"");
						if (!png) {
							fprintf(stderr, ""Error writing file %s\n"", szFileName);
							nb_pass = 0;
						} else {
							gf_fwrite(dst, dst_size, 1, png);
							gf_fclose(png);
							fprintf(stderr, ""Dump to %s\n"", szFileName);
						}
					}
					if (dst) gf_free(dst);
					gf_term_release_screen_buffer(term, &fb);
#endif //GPAC_DISABLE_AV_PARSERS
				}
			}
			fprintf(stderr, ""Done: %s\n"", szFileName);
		}
		break;

		case 'G':
		{
			GF_ObjectManager *root_od, *odm;
			u32 index;
			char szOpt[8192];
			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read OD ID\n"");
				break;
			}
			index = atoi(szOpt);
			odm = NULL;
			root_od = gf_term_get_root_object(term);
			if (root_od) {
				if ( gf_term_find_service(term, root_od, index)) {
					gf_term_select_service(term, root_od, index);
				} else {
					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
					odm = gf_term_get_object(term, root_od, index);
					if (odm) {
						gf_term_select_object(term, odm);
					} else {
						fprintf(stderr, ""Cannot find object at index %d\n"", index);
					}
				}
			}
		}
		break;

		case 'h':
			PrintHelp();
			break;
		default:
			break;
		}
	}

	if (bench_mode) {
		PrintAVInfo(GF_TRUE);
	}

	/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/
	if (simulation_time_in_ms) {
		gf_log_set_strict_error(0);
	}


	i = gf_sys_clock();
	gf_term_disconnect(term);
	if (rti_file) UpdateRTInfo(""Disconnected\n"");

	fprintf(stderr, ""Deleting terminal... "");
	if (playlist) gf_fclose(playlist);

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_uninit();
#endif

	gf_term_del(term);
	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());

	fprintf(stderr, ""GPAC cleanup ...\n"");
	gf_modules_del(user.modules);

	if (no_cfg_save)
		gf_cfg_discard_changes(cfg_file);

	gf_cfg_del(cfg_file);

	gf_sys_close();

	if (rti_logs) gf_fclose(rti_logs);
	if (logfile) gf_fclose(logfile);

	if (gui_mode) {
		hide_shell(2);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
		gf_memory_print();
		return 2;
	}
#endif

	return ret_val;
}
","int mp4client_main(int argc, char **argv)
{
	char c;
	const char *str;
	int ret_val = 0;
	u32 i, times[100], nb_times, dump_mode;
	u32 simulation_time_in_ms = 0;
	u32 initial_service_id = 0;
	Bool auto_exit = GF_FALSE;
	Bool logs_set = GF_FALSE;
	Bool start_fs = GF_FALSE;
	Bool use_rtix = GF_FALSE;
	Bool pause_at_first = GF_FALSE;
	Bool no_cfg_save = GF_FALSE;
	Bool is_cfg_only = GF_FALSE;

	Double play_from = 0;
#ifdef GPAC_MEMORY_TRACKING
    GF_MemTrackerType mem_track = GF_MemTrackerNone;
#endif
	Double fps = GF_IMPORT_DEFAULT_FPS;
	Bool fill_ar, visible, do_uncache, has_command;
	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
	FILE *logfile = NULL;
	Float scale = 1;
#ifndef WIN32
	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
#endif

	/*by default use current dir*/
	strcpy(the_url, ""."");

	memset(&user, 0, sizeof(GF_User));

	dump_mode = DUMP_NONE;
	fill_ar = visible = do_uncache = has_command = GF_FALSE;
	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
	nb_times = 0;
	times[0] = 0;

	/*first locate config file if specified*/
	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];
		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			the_cfg = argv[i+1];
			i++;
		}
		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
#ifdef GPAC_MEMORY_TRACKING
            mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
#else
			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
#endif
		} else if (!strcmp(arg, ""-gui"")) {
			gui_mode = 1;
		} else if (!strcmp(arg, ""-guid"")) {
			gui_mode = 2;
		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
			PrintUsage();
			return 0;
		}
	}

#ifdef GPAC_MEMORY_TRACKING
	gf_sys_init(mem_track);
#else
	gf_sys_init(GF_MemTrackerNone);
#endif
	gf_sys_set_args(argc, (const char **) argv);

	cfg_file = gf_cfg_init(the_cfg, NULL);
	if (!cfg_file) {
		fprintf(stderr, ""Error: Configuration File not found\n"");
		return 1;
	}
	/*if logs are specified, use them*/
	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
		return 1;
	}

	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
		logs_set = GF_TRUE;
	}

	if (!gui_mode) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
	}

	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];

		if (!strcmp(arg, ""-rti"")) {
			rti_file = argv[i+1];
			i++;
		} else if (!strcmp(arg, ""-rtix"")) {
			rti_file = argv[i+1];
			i++;
			use_rtix = GF_TRUE;
		} else if (!stricmp(arg, ""-size"")) {
			/*usage of %ud breaks sscanf on MSVC*/
			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
				forced_width = forced_height = 0;
			}
			i++;
		} else if (!strcmp(arg, ""-quiet"")) {
			be_quiet = 1;
		} else if (!strcmp(arg, ""-strict-error"")) {
			gf_log_set_strict_error(1);
		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
			logfile = gf_fopen(argv[i+1], ""wt"");
			gf_log_set_callback(logfile, on_gpac_log);
			i++;
		} else if (!strcmp(arg, ""-logs"") ) {
			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
				return 1;
			}
			logs_set = GF_TRUE;
			i++;
		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
			log_time_start = 1;
		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
			log_utc_time = 1;
		}
#if defined(__DARWIN__) || defined(__APPLE__)
		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
#else
		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
#endif
		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
		else if (!strcmp(arg, ""-fs"")) start_fs = 1;

		else if (!strcmp(arg, ""-opt"")) {
			set_cfg_option(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-conf"")) {
			set_cfg_option(argv[i+1]);
			is_cfg_only=GF_TRUE;
			i++;
		}
		else if (!strcmp(arg, ""-ifce"")) {
			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
			i++;
		}
		else if (!stricmp(arg, ""-help"")) {
			PrintUsage();
			return 1;
		}
		else if (!stricmp(arg, ""-noprog"")) {
			no_prog=1;
			gf_set_progress_callback(NULL, progress_quiet);
		}
		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"") /*old versions used --n-save ...*/) {
			no_cfg_save=1;
		}
		else if (!stricmp(arg, ""-ntp-shift"")) {
			s32 shift = atoi(argv[i+1]);
			i++;
			gf_net_set_ntp_shift(shift);
		}
		else if (!stricmp(arg, ""-run-for"")) {
			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
			if (!simulation_time_in_ms)
				simulation_time_in_ms = 1; /*1ms*/
			i++;
		}

		else if (!strcmp(arg, ""-out"")) {
			out_arg = argv[i+1];
			i++;
		}
		else if (!stricmp(arg, ""-fps"")) {
			fps = atof(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
			dump_mode &= 0xFFFF0000;

			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
			else dump_mode |= DUMP_AVI;

			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
					return 1;
				}
				i++;
			}
		} else if (!strcmp(arg, ""-rgbds"")) { /*get dump in rgbds pixel format*/
				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
		} else if (!strcmp(arg, ""-rgbd"")) { /*get dump in rgbd pixel format*/
				dump_mode |= DUMP_RGB_DEPTH;
		} else if (!strcmp(arg, ""-depth"")) {
				dump_mode |= DUMP_DEPTH_ONLY;
		} else if (!strcmp(arg, ""-bmp"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_BMP;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-png"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_PNG;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-raw"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_RAW;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!stricmp(arg, ""-scale"")) {
			sscanf(argv[i+1], ""%f"", &scale);
			i++;
		}
		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			/* already parsed */
			i++;
		}

		/*arguments only used in non-gui mode*/
		if (!gui_mode) {
			if (arg[0] != '-') {
				if (url_arg) {
					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
					return 1;
				}
				url_arg = arg;
			}
			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;

			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
			else if (!strcmp(arg, ""-play-from"")) {
				play_from = atof((const char *) argv[i+1]);
				i++;
			}
			else if (!strcmp(arg, ""-speed"")) {
				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
				if (playback_speed <= 0) playback_speed = FIX_ONE;
				i++;
			}
			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
			else if (!strcmp(arg, ""-align"")) {
				if (argv[i+1][0]=='m') align_mode = 1;
				else if (argv[i+1][0]=='b') align_mode = 2;
				align_mode <<= 8;
				if (argv[i+1][1]=='m') align_mode |= 1;
				else if (argv[i+1][1]=='r') align_mode |= 2;
				i++;
			} else if (!strcmp(arg, ""-fill"")) {
				fill_ar = GF_TRUE;
			} else if (!strcmp(arg, ""-show"")) {
				visible = 1;
			} else if (!strcmp(arg, ""-uncache"")) {
				do_uncache = GF_TRUE;
			}
			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
			else if (!stricmp(arg, ""-views"")) {
				views = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-mosaic"")) {
				mosaic = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-com"")) {
				has_command = GF_TRUE;
				i++;
			}
			else if (!stricmp(arg, ""-service"")) {
				initial_service_id = atoi(argv[i+1]);
				i++;
			}
		}
	}
	if (is_cfg_only) {
		gf_cfg_del(cfg_file);
		fprintf(stderr, ""GPAC Config updated\n"");
		return 0;
	}
	if (do_uncache) {
		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
		do_flatten_cache(cache_dir);
		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
		gf_cfg_del(cfg_file);
		return 0;
	}

	if (dump_mode && !url_arg ) {
		FILE *test;
		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
		if (!test) url_arg = NULL;
		else gf_fclose(test);
		
		if (!url_arg) {
			fprintf(stderr, ""Missing argument for dump\n"");
			PrintUsage();
			if (logfile) gf_fclose(logfile);
			return 1;
		}
	}

	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
		gui_mode=1;
	}

#ifdef WIN32
	if (gui_mode==1) {
		const char *opt;
		TCHAR buffer[1024];
		DWORD res = GetCurrentDirectory(1024, buffer);
		buffer[res] = 0;
		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
		if (strstr(opt, buffer)) {
			gui_mode=1;
		} else {
			gui_mode=2;
		}
	}
#endif

	if (gui_mode==1) {
		hide_shell(1);
	}
	if (gui_mode) {
		no_prog=1;
		gf_set_progress_callback(NULL, progress_quiet);
	}

	if (!url_arg && simulation_time_in_ms)
		simulation_time_in_ms += gf_sys_clock();

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_init();
#endif


	if (dump_mode) rti_file = NULL;

	if (!logs_set) {
		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
	}
	if (rti_file || logfile || log_utc_time || log_time_start)
		gf_log_set_callback(NULL, on_gpac_log);

	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);

	{
		GF_SystemRTInfo rti;
		if (gf_sys_get_rti(0, &rti, 0))
			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
	}


	/*setup dumping options*/
	if (dump_mode) {
		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
		if (!visible)
			user.init_flags |= GF_TERM_INIT_HIDE;

		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		no_cfg_save=GF_TRUE;
	} else {
		init_w = forced_width;
		init_h = forced_height;
	}

	user.modules = gf_modules_new(NULL, cfg_file);
	if (user.modules) i = gf_modules_get_count(user.modules);
	if (!i || !user.modules) {
		fprintf(stderr, ""Error: no modules found - exiting\n"");
		if (user.modules) gf_modules_del(user.modules);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Modules Found : %d \n"", i);

	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
		gf_cfg_del_section(cfg_file, ""PluginsCache"");
		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
	}

	user.config = cfg_file;
	user.EventProc = GPAC_EventProc;
	/*dummy in this case (global vars) but MUST be non-NULL*/
	user.opaque = user.modules;
	if (threading_flags) user.init_flags |= threading_flags;
	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;

	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;

	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

	if (bench_mode) {
		gf_cfg_discard_changes(user.config);
		auto_exit = GF_TRUE;
		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		if (bench_mode!=2) {
			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
		} else {
			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
		}
	}

	{
		char dim[50];
		sprintf(dim, ""%d"", forced_width);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
		sprintf(dim, ""%d"", forced_height);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
	}

	fprintf(stderr, ""Loading GPAC Terminal\n"");
	i = gf_sys_clock();
	term = gf_term_new(&user);
	if (!term) {
		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
		list_modules(user.modules);
		gf_modules_del(user.modules);
		gf_cfg_discard_changes(cfg_file);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);

	if (bench_mode) {
		display_rti = 2;
		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
		if (bench_mode==1) bench_mode=2;
	}

	if (dump_mode) {
		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
	} else {
		/*check video output*/
		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
		/*check audio output*/
		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");

		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
	}

	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
	if (str && !strcmp(str, ""yes"")) {
		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
	}

	if (rti_file) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
		if (str) {
			rti_update_time_ms = atoi(str);
		} else {
			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
		}
		UpdateRTInfo(""At GPAC load time\n"");
	}

	Run = 1;

	if (dump_mode) {
		if (!nb_times) {
			times[0] = 0;
			nb_times++;
		}
		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
		Run = 0;
	}
	else if (views) {
	}
	/*connect if requested*/
	else if (!gui_mode && url_arg) {
		char *ext;

		if (strlen(url_arg) >= sizeof(the_url)) {
			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
			strncpy(the_url, url_arg, sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
		}
		else {
			strcpy(the_url, url_arg);
		}
		ext = strrchr(the_url, '.');
		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
			GF_Err e = GF_OK;
			fprintf(stderr, ""Opening Playlist %s\n"", the_url);

			strcpy(pl_path, the_url);
			/*this is not clean, we need to have a plugin handle playlist for ourselves*/
			if (!strncmp(""http:"", the_url, 5)) {
				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
				if (sess) {
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_cfg) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}
			}

			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
			readonly_playlist = 1;
			if (playlist) {
				request_next_playlist_item = GF_TRUE;
			} else {
				if (e)
					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
				fprintf(stderr, ""Hit 'h' for help\n\n"");
			}
		} else {
			fprintf(stderr, ""Opening URL %s\n"", the_url);
			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
		}
	} else {
		fprintf(stderr, ""Hit 'h' for help\n\n"");
		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		if (str) {
			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
			gf_term_connect(term, str);
			startup_file = 1;
			is_connected = 1;
		}
	}
	if (gui_mode==2) gui_mode=0;

	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

	if (views) {
		char szTemp[4046];
		sprintf(szTemp, ""views://%s"", views);
		gf_term_connect(term, szTemp);
	}
	if (mosaic) {
		char szTemp[4046];
		sprintf(szTemp, ""mosaic://%s"", mosaic);
		gf_term_connect(term, szTemp);
	}
	if (bench_mode) {
		rti_update_time_ms = 500;
		bench_mode_start = gf_sys_clock();
	}


	while (Run) {

		/*we don't want getchar to block*/
		if ((gui_mode==1) || !gf_prompt_has_input()) {
			if (reload) {
				reload = 0;
				gf_term_disconnect(term);
				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
			}
			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				restart = 0;
				gf_term_play_from_time(term, 0, 0);
			}
			if (request_next_playlist_item) {
				c = '\n';
				request_next_playlist_item = 0;
				goto force_input;
			}

			if (has_command && is_connected) {
				has_command = GF_FALSE;
				for (i=0; i<(u32)argc; i++) {
					if (!strcmp(argv[i], ""-com"")) {
						gf_term_scene_update(term, NULL, argv[i+1]);
						i++;
					}
				}
			}
			if (initial_service_id && is_connected) {
				GF_ObjectManager *root_od = gf_term_get_root_object(term);
				if (root_od) {
					gf_term_select_service(term, root_od, initial_service_id);
					initial_service_id = 0;
				}
			}

			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
			if (term_step) {
				gf_term_process_step(term);
			} else {
				gf_sleep(rti_update_time_ms);
			}
			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				Run = GF_FALSE;
			}

			/*sim time*/
			if (simulation_time_in_ms
			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
			   ) {
				Run = GF_FALSE;
			}
			continue;
		}
		c = gf_prompt_get_char();

force_input:
		switch (c) {
		case 'q':
		{
			GF_Event evt;
			memset(&evt, 0, sizeof(GF_Event));
			evt.type = GF_EVENT_QUIT;
			gf_term_send_event(term, &evt);
		}
		break;
		case 'X':
			exit(0);
			break;
		case 'Q':
			break;
		case 'o':
			startup_file = 0;
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
				break;
			}
			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
			gf_term_connect(term, the_url);
			break;
		case 'O':
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
				break;
			}
			playlist = gf_fopen(the_url, ""rt"");
			if (playlist) {
				if (1 >	fscanf(playlist, ""%s"", the_url)) {
					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
					gf_fclose( playlist);
					break;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case '\n':
		case 'N':
			if (playlist) {
				int res;
				gf_term_disconnect(term);

				res = fscanf(playlist, ""%s"", the_url);
				if ((res == EOF) && loop_at_end) {
					fseek(playlist, 0, SEEK_SET);
					res = fscanf(playlist, ""%s"", the_url);
				}
				if (res == EOF) {
					fprintf(stderr, ""No more items - exiting\n"");
					Run = 0;
				} else if (the_url[0] == '#') {
					request_next_playlist_item = GF_TRUE;
				} else {
					fprintf(stderr, ""Opening URL %s\n"", the_url);
					gf_term_connect_with_path(term, the_url, pl_path);
				}
			}
			break;
		case 'P':
			if (playlist) {
				u32 count;
				gf_term_disconnect(term);
				if (1 > scanf(""%u"", &count)) {
					fprintf(stderr, ""Cannot read number, aborting.\n"");
					break;
				}
				while (count) {
					if (fscanf(playlist, ""%s"", the_url)) {
						fprintf(stderr, ""Failed to read line, aborting\n"");
						break;
					}
					count--;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case 'r':
			if (is_connected)
				reload = 1;
			break;

		case 'D':
			if (is_connected) gf_term_disconnect(term);
			break;

		case 'p':
			if (is_connected) {
				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
			}
			break;
		case 's':
			if (is_connected) {
				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
				fprintf(stderr, ""Step time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, ""\n"");
			}
			break;

		case 'z':
		case 'T':
			if (!CanSeek || (Duration<=2000)) {
				fprintf(stderr, ""scene not seekable\n"");
			} else {
				Double res;
				s32 seekTo;
				fprintf(stderr, ""Duration: "");
				PrintTime(Duration);
				res = gf_term_get_time_in_ms(term);
				if (c=='z') {
					res *= 100;
					res /= (s64)Duration;
					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
					if (scanf(""%d"", &seekTo) == 1) {
						if (seekTo > 100) seekTo = 100;
						res = (Double)(s64)Duration;
						res /= 100;
						res *= seekTo;
						gf_term_play_from_time(term, (u64) (s64) res, 0);
					}
				} else {
					u32 r, h, m, s;
					fprintf(stderr, "" - Current Time: "");
					PrintTime((u64) res);
					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
					h = m = s = 0;
					r =scanf(""%d:%d:%d"", &h, &m, &s);
					if (r==2) {
						s = m;
						m = h;
						h = 0;
					}
					else if (r==1) {
						s = h;
						m = h = 0;
					}

					if (r && (r<=3)) {
						u64 time = h*3600 + m*60 + s;
						gf_term_play_from_time(term, time*1000, 0);
					}
				}
			}
			break;

		case 't':
		{
			if (is_connected) {
				fprintf(stderr, ""Current Time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, "" - Duration: "");
				PrintTime(Duration);
				fprintf(stderr, ""\n"");
			}
		}
		break;
		case 'w':
			if (is_connected) PrintWorldInfo(term);
			break;
		case 'v':
			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
			break;
		case 'i':
			if (is_connected) {
				u32 ID;
				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
				fflush(stderr);
				if (scanf(""%ud"", &ID) == 1) {
					ViewOD(term, ID, (u32)-1, NULL);
				} else {
					char str_url[GF_MAX_PATH];
					if (scanf(""%s"", str_url) == 1)
						ViewOD(term, 0, (u32)-1, str_url);
				}
			}
			break;
		case 'j':
			if (is_connected) {
				u32 num;
				do {
					fprintf(stderr, ""Enter OD number (0 for main OD): "");
					fflush(stderr);
				} while( 1 > scanf(""%ud"", &num));
				ViewOD(term, (u32)-1, num, NULL);
			}
			break;
		case 'b':
			if (is_connected) ViewODs(term, 1);
			break;

		case 'm':
			if (is_connected) ViewODs(term, 0);
			break;

		case 'l':
			list_modules(user.modules);
			break;

		case 'n':
			if (is_connected) set_navigation();
			break;
		case 'x':
			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
			break;

		case 'd':
			if (is_connected) {
				GF_ObjectManager *odm = NULL;
				char radname[GF_MAX_PATH], *sExt;
				GF_Err e;
				u32 i, count, odid;
				Bool xml_dump, std_out;
				radname[0] = 0;
				do {
					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
					fflush(stderr);
				} while( 1 >  scanf(""%ud"", &odid));
				if (odid) {
					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
					if (!root_odm) break;
					count = gf_term_get_object_count(term, root_odm);
					for (i=0; i<count; i++) {
						GF_MediaInfo info;
						odm = gf_term_get_object(term, root_odm, i);
						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
							if (info.od->objectDescriptorID==odid) break;
						}
						odm = NULL;
					}
				}
				do {
					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
					fflush(stderr);
				} while( 1 > scanf(""%s"", radname));
				sExt = strrchr(radname, '.');
				xml_dump = 0;
				if (sExt) {
					if (!stricmp(sExt, "".x"")) xml_dump = 1;
					sExt[0] = 0;
				}
				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
			}
			break;

		case 'c':
			PrintGPACConfig();
			break;
		case '3':
		{
			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
			}
		}
		break;
		case 'k':
		{
			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
			opt = !opt;
			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
		}
		break;
		case '4':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
			break;
		case '5':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
			break;
		case '6':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
			break;
		case '7':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
			break;

		case 'C':
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_DISABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
				break;
			case GF_MEDIA_CACHE_ENABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
				continue;
			}
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_ENABLED:
				fprintf(stderr, ""Streaming Cache Enabled\n"");
				break;
			case GF_MEDIA_CACHE_DISABLED:
				fprintf(stderr, ""Streaming Cache Disabled\n"");
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache Running\n"");
				break;
			}
			break;
		case 'S':
		case 'A':
			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
				fprintf(stderr, ""Streaming Cache stopped\n"");
			} else {
				fprintf(stderr, ""Streaming Cache not running\n"");
			}
			break;
		case 'R':
			display_rti = !display_rti;
			ResetCaption();
			break;
		case 'F':
			if (display_rti) display_rti = 0;
			else display_rti = 2;
			ResetCaption();
			break;

		case 'u':
		{
			GF_Err e;
			char szCom[8192];
			fprintf(stderr, ""Enter command to send:\n"");
			fflush(stdin);
			szCom[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szCom)) {
				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, NULL, szCom);
			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
		}
		break;
		case 'e':
		{
			GF_Err e;
			char jsCode[8192];
			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
			fflush(stdin);
			jsCode[0] = 0;
			if (1 > scanf(""%[^\t\n]"", jsCode)) {
				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
		}
		break;

		case 'L':
		{
			char szLog[1024], *cur_logs;
			cur_logs = gf_log_get_tools_levels();
			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
			gf_free(cur_logs);
			if (scanf(""%s"", szLog) < 1) {
				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
				break;
			}
			gf_log_modify_tools_levels(szLog);
		}
		break;

		case 'g':
		{
			GF_SystemRTInfo rti;
			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
		}
		break;
		case 'M':
		{
			u32 size;
			do {
				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
			} while (1 > scanf(""%ud"", &size));
			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
		}
		break;

		case 'H':
		{
			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
			do {
				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
			} while (1 > scanf(""%ud"", &http_bitrate));

			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
		}
		break;

		case 'E':
			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
			break;

		case 'B':
			switch_bench(!bench_mode);
			break;

		case 'Y':
		{
			char szOpt[8192];
			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read option\n"");
				break;
			}
			set_cfg_option(szOpt);
		}
		break;

		/*extract to PNG*/
		case 'Z':
		{
			char szFileName[100];
			u32 nb_pass, nb_views, offscreen_view = 0;
			GF_VideoSurface fb;
			GF_Err e;
			nb_pass = 1;
			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
			if (nb_views>1) {
				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
				if (scanf(""%d"", &offscreen_view) != 1) {
					offscreen_view = 0;
				}
				if (offscreen_view==nb_views+1) {
					offscreen_view = 1;
					nb_pass = nb_views;
				}
				else if (offscreen_view==nb_views+2) {
					offscreen_view = 0;
					nb_pass = nb_views+1;
				}
			}
			while (nb_pass) {
				nb_pass--;
				if (offscreen_view) {
					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
				} else {
					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
					e = gf_term_get_screen_buffer(term, &fb);
				}
				offscreen_view++;
				if (e) {
					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
					nb_pass = 0;
				} else {
#ifndef GPAC_DISABLE_AV_PARSERS
					u32 dst_size = fb.width*fb.height*4;
					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);

					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
					if (e) {
						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
						nb_pass = 0;
					} else {
						FILE *png = gf_fopen(szFileName, ""wb"");
						if (!png) {
							fprintf(stderr, ""Error writing file %s\n"", szFileName);
							nb_pass = 0;
						} else {
							gf_fwrite(dst, dst_size, 1, png);
							gf_fclose(png);
							fprintf(stderr, ""Dump to %s\n"", szFileName);
						}
					}
					if (dst) gf_free(dst);
					gf_term_release_screen_buffer(term, &fb);
#endif //GPAC_DISABLE_AV_PARSERS
				}
			}
			fprintf(stderr, ""Done: %s\n"", szFileName);
		}
		break;

		case 'G':
		{
			GF_ObjectManager *root_od, *odm;
			u32 index;
			char szOpt[8192];
			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read OD ID\n"");
				break;
			}
			index = atoi(szOpt);
			odm = NULL;
			root_od = gf_term_get_root_object(term);
			if (root_od) {
				if ( gf_term_find_service(term, root_od, index)) {
					gf_term_select_service(term, root_od, index);
				} else {
					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
					odm = gf_term_get_object(term, root_od, index);
					if (odm) {
						gf_term_select_object(term, odm);
					} else {
						fprintf(stderr, ""Cannot find object at index %d\n"", index);
					}
				}
			}
		}
		break;

		case 'h':
			PrintHelp();
			break;
		default:
			break;
		}
	}

	if (bench_mode) {
		PrintAVInfo(GF_TRUE);
	}

	/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/
	if (simulation_time_in_ms) {
		gf_log_set_strict_error(0);
	}


	i = gf_sys_clock();
	gf_term_disconnect(term);
	if (rti_file) UpdateRTInfo(""Disconnected\n"");

	fprintf(stderr, ""Deleting terminal... "");
	if (playlist) gf_fclose(playlist);

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_uninit();
#endif

	gf_term_del(term);
	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());

	fprintf(stderr, ""GPAC cleanup ...\n"");
	gf_modules_del(user.modules);

	if (no_cfg_save)
		gf_cfg_discard_changes(cfg_file);

	gf_cfg_del(cfg_file);

	gf_sys_close();

	if (rti_logs) gf_fclose(rti_logs);
	if (logfile) gf_fclose(logfile);

	if (gui_mode) {
		hide_shell(2);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
		gf_memory_print();
		return 2;
	}
#endif

	return ret_val;
}
",C,"						the_url[sizeof(the_url) - 1] = 0;
","						the_url[sizeof(the_cfg) - 1] = 0;
",,"@@ -1715,7 +1715,7 @@ int mp4client_main(int argc, char **argv)
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
-						the_url[sizeof(the_cfg) - 1] = 0;
+						the_url[sizeof(the_url) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}",gpac,1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,35ab4475a7df9b2a4bcab235e379c0c3ec543658,1,"int mp4client_main(int argc, char **argv)
{
	char c;
	const char *str;
	int ret_val = 0;
	u32 i, times[100], nb_times, dump_mode;
	u32 simulation_time_in_ms = 0;
	u32 initial_service_id = 0;
	Bool auto_exit = GF_FALSE;
	Bool logs_set = GF_FALSE;
	Bool start_fs = GF_FALSE;
	Bool use_rtix = GF_FALSE;
	Bool pause_at_first = GF_FALSE;
	Bool no_cfg_save = GF_FALSE;
	Bool is_cfg_only = GF_FALSE;

	Double play_from = 0;
#ifdef GPAC_MEMORY_TRACKING
    GF_MemTrackerType mem_track = GF_MemTrackerNone;
#endif
	Double fps = GF_IMPORT_DEFAULT_FPS;
	Bool fill_ar, visible, do_uncache, has_command;
	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
	FILE *logfile = NULL;
	Float scale = 1;
#ifndef WIN32
	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
#endif

	/*by default use current dir*/
	strcpy(the_url, ""."");

	memset(&user, 0, sizeof(GF_User));

	dump_mode = DUMP_NONE;
	fill_ar = visible = do_uncache = has_command = GF_FALSE;
	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
	nb_times = 0;
	times[0] = 0;

	/*first locate config file if specified*/
	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];
		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			the_cfg = argv[i+1];
			i++;
		}
		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
#ifdef GPAC_MEMORY_TRACKING
            mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
#else
			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
#endif
		} else if (!strcmp(arg, ""-gui"")) {
			gui_mode = 1;
		} else if (!strcmp(arg, ""-guid"")) {
			gui_mode = 2;
		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
			PrintUsage();
			return 0;
		}
	}

#ifdef GPAC_MEMORY_TRACKING
	gf_sys_init(mem_track);
#else
	gf_sys_init(GF_MemTrackerNone);
#endif
	gf_sys_set_args(argc, (const char **) argv);

	cfg_file = gf_cfg_init(the_cfg, NULL);
	if (!cfg_file) {
		fprintf(stderr, ""Error: Configuration File not found\n"");
		return 1;
	}
	/*if logs are specified, use them*/
	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
		return 1;
	}

	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
		logs_set = GF_TRUE;
	}

	if (!gui_mode) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
	}

	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];

		if (!strcmp(arg, ""-rti"")) {
			rti_file = argv[i+1];
			i++;
		} else if (!strcmp(arg, ""-rtix"")) {
			rti_file = argv[i+1];
			i++;
			use_rtix = GF_TRUE;
		} else if (!stricmp(arg, ""-size"")) {
			/*usage of %ud breaks sscanf on MSVC*/
			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
				forced_width = forced_height = 0;
			}
			i++;
		} else if (!strcmp(arg, ""-quiet"")) {
			be_quiet = 1;
		} else if (!strcmp(arg, ""-strict-error"")) {
			gf_log_set_strict_error(1);
		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
			logfile = gf_fopen(argv[i+1], ""wt"");
			gf_log_set_callback(logfile, on_gpac_log);
			i++;
		} else if (!strcmp(arg, ""-logs"") ) {
			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
				return 1;
			}
			logs_set = GF_TRUE;
			i++;
		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
			log_time_start = 1;
		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
			log_utc_time = 1;
		}
#if defined(__DARWIN__) || defined(__APPLE__)
		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
#else
		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
#endif
		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
		else if (!strcmp(arg, ""-fs"")) start_fs = 1;

		else if (!strcmp(arg, ""-opt"")) {
			set_cfg_option(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-conf"")) {
			set_cfg_option(argv[i+1]);
			is_cfg_only=GF_TRUE;
			i++;
		}
		else if (!strcmp(arg, ""-ifce"")) {
			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
			i++;
		}
		else if (!stricmp(arg, ""-help"")) {
			PrintUsage();
			return 1;
		}
		else if (!stricmp(arg, ""-noprog"")) {
			no_prog=1;
			gf_set_progress_callback(NULL, progress_quiet);
		}
		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"") /*old versions used --n-save ...*/) {
			no_cfg_save=1;
		}
		else if (!stricmp(arg, ""-ntp-shift"")) {
			s32 shift = atoi(argv[i+1]);
			i++;
			gf_net_set_ntp_shift(shift);
		}
		else if (!stricmp(arg, ""-run-for"")) {
			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
			if (!simulation_time_in_ms)
				simulation_time_in_ms = 1; /*1ms*/
			i++;
		}

		else if (!strcmp(arg, ""-out"")) {
			out_arg = argv[i+1];
			i++;
		}
		else if (!stricmp(arg, ""-fps"")) {
			fps = atof(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
			dump_mode &= 0xFFFF0000;

			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
			else dump_mode |= DUMP_AVI;

			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
					return 1;
				}
				i++;
			}
		} else if (!strcmp(arg, ""-rgbds"")) { /*get dump in rgbds pixel format*/
				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
		} else if (!strcmp(arg, ""-rgbd"")) { /*get dump in rgbd pixel format*/
				dump_mode |= DUMP_RGB_DEPTH;
		} else if (!strcmp(arg, ""-depth"")) {
				dump_mode |= DUMP_DEPTH_ONLY;
		} else if (!strcmp(arg, ""-bmp"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_BMP;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-png"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_PNG;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-raw"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_RAW;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!stricmp(arg, ""-scale"")) {
			sscanf(argv[i+1], ""%f"", &scale);
			i++;
		}
		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			/* already parsed */
			i++;
		}

		/*arguments only used in non-gui mode*/
		if (!gui_mode) {
			if (arg[0] != '-') {
				if (url_arg) {
					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
					return 1;
				}
				url_arg = arg;
			}
			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;

			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
			else if (!strcmp(arg, ""-play-from"")) {
				play_from = atof((const char *) argv[i+1]);
				i++;
			}
			else if (!strcmp(arg, ""-speed"")) {
				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
				if (playback_speed <= 0) playback_speed = FIX_ONE;
				i++;
			}
			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
			else if (!strcmp(arg, ""-align"")) {
				if (argv[i+1][0]=='m') align_mode = 1;
				else if (argv[i+1][0]=='b') align_mode = 2;
				align_mode <<= 8;
				if (argv[i+1][1]=='m') align_mode |= 1;
				else if (argv[i+1][1]=='r') align_mode |= 2;
				i++;
			} else if (!strcmp(arg, ""-fill"")) {
				fill_ar = GF_TRUE;
			} else if (!strcmp(arg, ""-show"")) {
				visible = 1;
			} else if (!strcmp(arg, ""-uncache"")) {
				do_uncache = GF_TRUE;
			}
			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
			else if (!stricmp(arg, ""-views"")) {
				views = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-mosaic"")) {
				mosaic = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-com"")) {
				has_command = GF_TRUE;
				i++;
			}
			else if (!stricmp(arg, ""-service"")) {
				initial_service_id = atoi(argv[i+1]);
				i++;
			}
		}
	}
	if (is_cfg_only) {
		gf_cfg_del(cfg_file);
		fprintf(stderr, ""GPAC Config updated\n"");
		return 0;
	}
	if (do_uncache) {
		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
		do_flatten_cache(cache_dir);
		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
		gf_cfg_del(cfg_file);
		return 0;
	}

	if (dump_mode && !url_arg ) {
		FILE *test;
		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
		if (!test) url_arg = NULL;
		else gf_fclose(test);
		
		if (!url_arg) {
			fprintf(stderr, ""Missing argument for dump\n"");
			PrintUsage();
			if (logfile) gf_fclose(logfile);
			return 1;
		}
	}

	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
		gui_mode=1;
	}

#ifdef WIN32
	if (gui_mode==1) {
		const char *opt;
		TCHAR buffer[1024];
		DWORD res = GetCurrentDirectory(1024, buffer);
		buffer[res] = 0;
		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
		if (strstr(opt, buffer)) {
			gui_mode=1;
		} else {
			gui_mode=2;
		}
	}
#endif

	if (gui_mode==1) {
		hide_shell(1);
	}
	if (gui_mode) {
		no_prog=1;
		gf_set_progress_callback(NULL, progress_quiet);
	}

	if (!url_arg && simulation_time_in_ms)
		simulation_time_in_ms += gf_sys_clock();

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_init();
#endif


	if (dump_mode) rti_file = NULL;

	if (!logs_set) {
		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
	}
	//only override default log callback when needed
	if (rti_file || logfile || log_utc_time || log_time_start)
		gf_log_set_callback(NULL, on_gpac_log);

	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);

	{
		GF_SystemRTInfo rti;
		if (gf_sys_get_rti(0, &rti, 0))
			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
	}


	/*setup dumping options*/
	if (dump_mode) {
		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
		if (!visible)
			user.init_flags |= GF_TERM_INIT_HIDE;

		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		no_cfg_save=GF_TRUE;
	} else {
		init_w = forced_width;
		init_h = forced_height;
	}

	user.modules = gf_modules_new(NULL, cfg_file);
	if (user.modules) i = gf_modules_get_count(user.modules);
	if (!i || !user.modules) {
		fprintf(stderr, ""Error: no modules found - exiting\n"");
		if (user.modules) gf_modules_del(user.modules);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Modules Found : %d \n"", i);

	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
		gf_cfg_del_section(cfg_file, ""PluginsCache"");
		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
	}

	user.config = cfg_file;
	user.EventProc = GPAC_EventProc;
	/*dummy in this case (global vars) but MUST be non-NULL*/
	user.opaque = user.modules;
	if (threading_flags) user.init_flags |= threading_flags;
	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;

	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;

	//in dump mode we don't want to rely on system clock but on the number of samples being consumed
	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

	if (bench_mode) {
		gf_cfg_discard_changes(user.config);
		auto_exit = GF_TRUE;
		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		if (bench_mode!=2) {
			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
		} else {
			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
		}
	}

	{
		char dim[50];
		sprintf(dim, ""%d"", forced_width);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
		sprintf(dim, ""%d"", forced_height);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
	}

	fprintf(stderr, ""Loading GPAC Terminal\n"");
	i = gf_sys_clock();
	term = gf_term_new(&user);
	if (!term) {
		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
		list_modules(user.modules);
		gf_modules_del(user.modules);
		gf_cfg_discard_changes(cfg_file);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);

	if (bench_mode) {
		display_rti = 2;
		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
		if (bench_mode==1) bench_mode=2;
	}

	if (dump_mode) {
//		gf_term_set_option(term, GF_OPT_VISIBLE, 0);
		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
	} else {
		/*check video output*/
		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
		/*check audio output*/
		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");

		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
	}

	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
	if (str && !strcmp(str, ""yes"")) {
		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
	}

	if (rti_file) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
		if (str) {
			rti_update_time_ms = atoi(str);
		} else {
			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
		}
		UpdateRTInfo(""At GPAC load time\n"");
	}

	Run = 1;

	if (dump_mode) {
		if (!nb_times) {
			times[0] = 0;
			nb_times++;
		}
		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
		Run = 0;
	}
	else if (views) {
	}
	/*connect if requested*/
	else if (!gui_mode && url_arg) {
		char *ext;

		if (strlen(url_arg) >= sizeof(the_url)) {
			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
			strncpy(the_url, url_arg, sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
		}
		else {
			strcpy(the_url, url_arg);
		}
		ext = strrchr(the_url, '.');
		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
			GF_Err e = GF_OK;
			fprintf(stderr, ""Opening Playlist %s\n"", the_url);

			strcpy(pl_path, the_url);
			/*this is not clean, we need to have a plugin handle playlist for ourselves*/
			if (!strncmp(""http:"", the_url, 5)) {
				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
				if (sess) {
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
//flaw_line_below:
						the_url[sizeof(the_cfg) - 1] = 0;
//fix_flaw_line_below:
//						the_url[sizeof(the_url) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}
			}

			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
			readonly_playlist = 1;
			if (playlist) {
				request_next_playlist_item = GF_TRUE;
			} else {
				if (e)
					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
				fprintf(stderr, ""Hit 'h' for help\n\n"");
			}
		} else {
			fprintf(stderr, ""Opening URL %s\n"", the_url);
			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
		}
	} else {
		fprintf(stderr, ""Hit 'h' for help\n\n"");
		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		if (str) {
			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
			gf_term_connect(term, str);
			startup_file = 1;
			is_connected = 1;
		}
	}
	if (gui_mode==2) gui_mode=0;

	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

	if (views) {
		char szTemp[4046];
		sprintf(szTemp, ""views://%s"", views);
		gf_term_connect(term, szTemp);
	}
	if (mosaic) {
		char szTemp[4046];
		sprintf(szTemp, ""mosaic://%s"", mosaic);
		gf_term_connect(term, szTemp);
	}
	if (bench_mode) {
		rti_update_time_ms = 500;
		bench_mode_start = gf_sys_clock();
	}


	while (Run) {

		/*we don't want getchar to block*/
		if ((gui_mode==1) || !gf_prompt_has_input()) {
			if (reload) {
				reload = 0;
				gf_term_disconnect(term);
				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
			}
			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				restart = 0;
				gf_term_play_from_time(term, 0, 0);
			}
			if (request_next_playlist_item) {
				c = '\n';
				request_next_playlist_item = 0;
				goto force_input;
			}

			if (has_command && is_connected) {
				has_command = GF_FALSE;
				for (i=0; i<(u32)argc; i++) {
					if (!strcmp(argv[i], ""-com"")) {
						gf_term_scene_update(term, NULL, argv[i+1]);
						i++;
					}
				}
			}
			if (initial_service_id && is_connected) {
				GF_ObjectManager *root_od = gf_term_get_root_object(term);
				if (root_od) {
					gf_term_select_service(term, root_od, initial_service_id);
					initial_service_id = 0;
				}
			}

			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
			if (term_step) {
				gf_term_process_step(term);
			} else {
				gf_sleep(rti_update_time_ms);
			}
			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				Run = GF_FALSE;
			}

			/*sim time*/
			if (simulation_time_in_ms
			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
			   ) {
				Run = GF_FALSE;
			}
			continue;
		}
		c = gf_prompt_get_char();

force_input:
		switch (c) {
		case 'q':
		{
			GF_Event evt;
			memset(&evt, 0, sizeof(GF_Event));
			evt.type = GF_EVENT_QUIT;
			gf_term_send_event(term, &evt);
		}
//			Run = 0;
		break;
		case 'X':
			exit(0);
			break;
		case 'Q':
			break;
		case 'o':
			startup_file = 0;
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
				break;
			}
			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
			gf_term_connect(term, the_url);
			break;
		case 'O':
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
				break;
			}
			playlist = gf_fopen(the_url, ""rt"");
			if (playlist) {
				if (1 >	fscanf(playlist, ""%s"", the_url)) {
					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
					gf_fclose( playlist);
					break;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case '\n':
		case 'N':
			if (playlist) {
				int res;
				gf_term_disconnect(term);

				res = fscanf(playlist, ""%s"", the_url);
				if ((res == EOF) && loop_at_end) {
					fseek(playlist, 0, SEEK_SET);
					res = fscanf(playlist, ""%s"", the_url);
				}
				if (res == EOF) {
					fprintf(stderr, ""No more items - exiting\n"");
					Run = 0;
				} else if (the_url[0] == '#') {
					request_next_playlist_item = GF_TRUE;
				} else {
					fprintf(stderr, ""Opening URL %s\n"", the_url);
					gf_term_connect_with_path(term, the_url, pl_path);
				}
			}
			break;
		case 'P':
			if (playlist) {
				u32 count;
				gf_term_disconnect(term);
				if (1 > scanf(""%u"", &count)) {
					fprintf(stderr, ""Cannot read number, aborting.\n"");
					break;
				}
				while (count) {
					if (fscanf(playlist, ""%s"", the_url)) {
						fprintf(stderr, ""Failed to read line, aborting\n"");
						break;
					}
					count--;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case 'r':
			if (is_connected)
				reload = 1;
			break;

		case 'D':
			if (is_connected) gf_term_disconnect(term);
			break;

		case 'p':
			if (is_connected) {
				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
			}
			break;
		case 's':
			if (is_connected) {
				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
				fprintf(stderr, ""Step time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, ""\n"");
			}
			break;

		case 'z':
		case 'T':
			if (!CanSeek || (Duration<=2000)) {
				fprintf(stderr, ""scene not seekable\n"");
			} else {
				Double res;
				s32 seekTo;
				fprintf(stderr, ""Duration: "");
				PrintTime(Duration);
				res = gf_term_get_time_in_ms(term);
				if (c=='z') {
					res *= 100;
					res /= (s64)Duration;
					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
					if (scanf(""%d"", &seekTo) == 1) {
						if (seekTo > 100) seekTo = 100;
						res = (Double)(s64)Duration;
						res /= 100;
						res *= seekTo;
						gf_term_play_from_time(term, (u64) (s64) res, 0);
					}
				} else {
					u32 r, h, m, s;
					fprintf(stderr, "" - Current Time: "");
					PrintTime((u64) res);
					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
					h = m = s = 0;
					r =scanf(""%d:%d:%d"", &h, &m, &s);
					if (r==2) {
						s = m;
						m = h;
						h = 0;
					}
					else if (r==1) {
						s = h;
						m = h = 0;
					}

					if (r && (r<=3)) {
						u64 time = h*3600 + m*60 + s;
						gf_term_play_from_time(term, time*1000, 0);
					}
				}
			}
			break;

		case 't':
		{
			if (is_connected) {
				fprintf(stderr, ""Current Time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, "" - Duration: "");
				PrintTime(Duration);
				fprintf(stderr, ""\n"");
			}
		}
		break;
		case 'w':
			if (is_connected) PrintWorldInfo(term);
			break;
		case 'v':
			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
			break;
		case 'i':
			if (is_connected) {
				u32 ID;
				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
				fflush(stderr);
				if (scanf(""%ud"", &ID) == 1) {
					ViewOD(term, ID, (u32)-1, NULL);
				} else {
					char str_url[GF_MAX_PATH];
					if (scanf(""%s"", str_url) == 1)
						ViewOD(term, 0, (u32)-1, str_url);
				}
			}
			break;
		case 'j':
			if (is_connected) {
				u32 num;
				do {
					fprintf(stderr, ""Enter OD number (0 for main OD): "");
					fflush(stderr);
				} while( 1 > scanf(""%ud"", &num));
				ViewOD(term, (u32)-1, num, NULL);
			}
			break;
		case 'b':
			if (is_connected) ViewODs(term, 1);
			break;

		case 'm':
			if (is_connected) ViewODs(term, 0);
			break;

		case 'l':
			list_modules(user.modules);
			break;

		case 'n':
			if (is_connected) set_navigation();
			break;
		case 'x':
			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
			break;

		case 'd':
			if (is_connected) {
				GF_ObjectManager *odm = NULL;
				char radname[GF_MAX_PATH], *sExt;
				GF_Err e;
				u32 i, count, odid;
				Bool xml_dump, std_out;
				radname[0] = 0;
				do {
					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
					fflush(stderr);
				} while( 1 >  scanf(""%ud"", &odid));
				if (odid) {
					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
					if (!root_odm) break;
					count = gf_term_get_object_count(term, root_odm);
					for (i=0; i<count; i++) {
						GF_MediaInfo info;
						odm = gf_term_get_object(term, root_odm, i);
						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
							if (info.od->objectDescriptorID==odid) break;
						}
						odm = NULL;
					}
				}
				do {
					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
					fflush(stderr);
				} while( 1 > scanf(""%s"", radname));
				sExt = strrchr(radname, '.');
				xml_dump = 0;
				if (sExt) {
					if (!stricmp(sExt, "".x"")) xml_dump = 1;
					sExt[0] = 0;
				}
				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
			}
			break;

		case 'c':
			PrintGPACConfig();
			break;
		case '3':
		{
			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
			}
		}
		break;
		case 'k':
		{
			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
			opt = !opt;
			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
		}
		break;
		case '4':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
			break;
		case '5':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
			break;
		case '6':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
			break;
		case '7':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
			break;

		case 'C':
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_DISABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
				break;
			case GF_MEDIA_CACHE_ENABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
				continue;
			}
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_ENABLED:
				fprintf(stderr, ""Streaming Cache Enabled\n"");
				break;
			case GF_MEDIA_CACHE_DISABLED:
				fprintf(stderr, ""Streaming Cache Disabled\n"");
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache Running\n"");
				break;
			}
			break;
		case 'S':
		case 'A':
			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
				fprintf(stderr, ""Streaming Cache stopped\n"");
			} else {
				fprintf(stderr, ""Streaming Cache not running\n"");
			}
			break;
		case 'R':
			display_rti = !display_rti;
			ResetCaption();
			break;
		case 'F':
			if (display_rti) display_rti = 0;
			else display_rti = 2;
			ResetCaption();
			break;

		case 'u':
		{
			GF_Err e;
			char szCom[8192];
			fprintf(stderr, ""Enter command to send:\n"");
			fflush(stdin);
			szCom[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szCom)) {
				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, NULL, szCom);
			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
		}
		break;
		case 'e':
		{
			GF_Err e;
			char jsCode[8192];
			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
			fflush(stdin);
			jsCode[0] = 0;
			if (1 > scanf(""%[^\t\n]"", jsCode)) {
				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
		}
		break;

		case 'L':
		{
			char szLog[1024], *cur_logs;
			cur_logs = gf_log_get_tools_levels();
			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
			gf_free(cur_logs);
			if (scanf(""%s"", szLog) < 1) {
				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
				break;
			}
			gf_log_modify_tools_levels(szLog);
		}
		break;

		case 'g':
		{
			GF_SystemRTInfo rti;
			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
		}
		break;
		case 'M':
		{
			u32 size;
			do {
				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
			} while (1 > scanf(""%ud"", &size));
			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
		}
		break;

		case 'H':
		{
			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
			do {
				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
			} while (1 > scanf(""%ud"", &http_bitrate));

			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
		}
		break;

		case 'E':
			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
			break;

		case 'B':
			switch_bench(!bench_mode);
			break;

		case 'Y':
		{
			char szOpt[8192];
			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read option\n"");
				break;
			}
			set_cfg_option(szOpt);
		}
		break;

		/*extract to PNG*/
		case 'Z':
		{
			char szFileName[100];
			u32 nb_pass, nb_views, offscreen_view = 0;
			GF_VideoSurface fb;
			GF_Err e;
			nb_pass = 1;
			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
			if (nb_views>1) {
				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
				if (scanf(""%d"", &offscreen_view) != 1) {
					offscreen_view = 0;
				}
				if (offscreen_view==nb_views+1) {
					offscreen_view = 1;
					nb_pass = nb_views;
				}
				else if (offscreen_view==nb_views+2) {
					offscreen_view = 0;
					nb_pass = nb_views+1;
				}
			}
			while (nb_pass) {
				nb_pass--;
				if (offscreen_view) {
					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
				} else {
					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
					e = gf_term_get_screen_buffer(term, &fb);
				}
				offscreen_view++;
				if (e) {
					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
					nb_pass = 0;
				} else {
#ifndef GPAC_DISABLE_AV_PARSERS
					u32 dst_size = fb.width*fb.height*4;
					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);

					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
					if (e) {
						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
						nb_pass = 0;
					} else {
						FILE *png = gf_fopen(szFileName, ""wb"");
						if (!png) {
							fprintf(stderr, ""Error writing file %s\n"", szFileName);
							nb_pass = 0;
						} else {
							gf_fwrite(dst, dst_size, 1, png);
							gf_fclose(png);
							fprintf(stderr, ""Dump to %s\n"", szFileName);
						}
					}
					if (dst) gf_free(dst);
					gf_term_release_screen_buffer(term, &fb);
#endif //GPAC_DISABLE_AV_PARSERS
				}
			}
			fprintf(stderr, ""Done: %s\n"", szFileName);
		}
		break;

		case 'G':
		{
			GF_ObjectManager *root_od, *odm;
			u32 index;
			char szOpt[8192];
			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read OD ID\n"");
				break;
			}
			index = atoi(szOpt);
			odm = NULL;
			root_od = gf_term_get_root_object(term);
			if (root_od) {
				if ( gf_term_find_service(term, root_od, index)) {
					gf_term_select_service(term, root_od, index);
				} else {
					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
					odm = gf_term_get_object(term, root_od, index);
					if (odm) {
						gf_term_select_object(term, odm);
					} else {
						fprintf(stderr, ""Cannot find object at index %d\n"", index);
					}
				}
			}
		}
		break;

		case 'h':
			PrintHelp();
			break;
		default:
			break;
		}
	}

	if (bench_mode) {
		PrintAVInfo(GF_TRUE);
	}

	/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/
	if (simulation_time_in_ms) {
		gf_log_set_strict_error(0);
	}


	i = gf_sys_clock();
	gf_term_disconnect(term);
	if (rti_file) UpdateRTInfo(""Disconnected\n"");

	fprintf(stderr, ""Deleting terminal... "");
	if (playlist) gf_fclose(playlist);

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_uninit();
#endif

	gf_term_del(term);
	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());

	fprintf(stderr, ""GPAC cleanup ...\n"");
	gf_modules_del(user.modules);

	if (no_cfg_save)
		gf_cfg_discard_changes(cfg_file);

	gf_cfg_del(cfg_file);

	gf_sys_close();

	if (rti_logs) gf_fclose(rti_logs);
	if (logfile) gf_fclose(logfile);

	if (gui_mode) {
		hide_shell(2);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
		gf_memory_print();
		return 2;
	}
#endif

	return ret_val;
}
",182959,"int mp4client_main(int argc, char **argv)
{
	char c;
	const char *str;
	int ret_val = 0;
	u32 i, times[100], nb_times, dump_mode;
	u32 simulation_time_in_ms = 0;
	u32 initial_service_id = 0;
	Bool auto_exit = GF_FALSE;
	Bool logs_set = GF_FALSE;
	Bool start_fs = GF_FALSE;
	Bool use_rtix = GF_FALSE;
	Bool pause_at_first = GF_FALSE;
	Bool no_cfg_save = GF_FALSE;
	Bool is_cfg_only = GF_FALSE;

	Double play_from = 0;
#ifdef GPAC_MEMORY_TRACKING
    GF_MemTrackerType mem_track = GF_MemTrackerNone;
#endif
	Double fps = GF_IMPORT_DEFAULT_FPS;
	Bool fill_ar, visible, do_uncache, has_command;
	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
	FILE *logfile = NULL;
	Float scale = 1;
#ifndef WIN32
	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
#endif

	/*by default use current dir*/
	strcpy(the_url, ""."");

	memset(&user, 0, sizeof(GF_User));

	dump_mode = DUMP_NONE;
	fill_ar = visible = do_uncache = has_command = GF_FALSE;
	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
	nb_times = 0;
	times[0] = 0;

	/*first locate config file if specified*/
	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];
		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			the_cfg = argv[i+1];
			i++;
		}
		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
#ifdef GPAC_MEMORY_TRACKING
            mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
#else
			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
#endif
		} else if (!strcmp(arg, ""-gui"")) {
			gui_mode = 1;
		} else if (!strcmp(arg, ""-guid"")) {
			gui_mode = 2;
		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
			PrintUsage();
			return 0;
		}
	}

#ifdef GPAC_MEMORY_TRACKING
	gf_sys_init(mem_track);
#else
	gf_sys_init(GF_MemTrackerNone);
#endif
	gf_sys_set_args(argc, (const char **) argv);

	cfg_file = gf_cfg_init(the_cfg, NULL);
	if (!cfg_file) {
		fprintf(stderr, ""Error: Configuration File not found\n"");
		return 1;
	}
	/*if logs are specified, use them*/
	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
		return 1;
	}

	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
		logs_set = GF_TRUE;
	}

	if (!gui_mode) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
	}

	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];

		if (!strcmp(arg, ""-rti"")) {
			rti_file = argv[i+1];
			i++;
		} else if (!strcmp(arg, ""-rtix"")) {
			rti_file = argv[i+1];
			i++;
			use_rtix = GF_TRUE;
		} else if (!stricmp(arg, ""-size"")) {
			/*usage of %ud breaks sscanf on MSVC*/
			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
				forced_width = forced_height = 0;
			}
			i++;
		} else if (!strcmp(arg, ""-quiet"")) {
			be_quiet = 1;
		} else if (!strcmp(arg, ""-strict-error"")) {
			gf_log_set_strict_error(1);
		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
			logfile = gf_fopen(argv[i+1], ""wt"");
			gf_log_set_callback(logfile, on_gpac_log);
			i++;
		} else if (!strcmp(arg, ""-logs"") ) {
			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
				return 1;
			}
			logs_set = GF_TRUE;
			i++;
		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
			log_time_start = 1;
		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
			log_utc_time = 1;
		}
#if defined(__DARWIN__) || defined(__APPLE__)
		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
#else
		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
#endif
		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
		else if (!strcmp(arg, ""-fs"")) start_fs = 1;

		else if (!strcmp(arg, ""-opt"")) {
			set_cfg_option(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-conf"")) {
			set_cfg_option(argv[i+1]);
			is_cfg_only=GF_TRUE;
			i++;
		}
		else if (!strcmp(arg, ""-ifce"")) {
			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
			i++;
		}
		else if (!stricmp(arg, ""-help"")) {
			PrintUsage();
			return 1;
		}
		else if (!stricmp(arg, ""-noprog"")) {
			no_prog=1;
			gf_set_progress_callback(NULL, progress_quiet);
		}
		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"") /*old versions used --n-save ...*/) {
			no_cfg_save=1;
		}
		else if (!stricmp(arg, ""-ntp-shift"")) {
			s32 shift = atoi(argv[i+1]);
			i++;
			gf_net_set_ntp_shift(shift);
		}
		else if (!stricmp(arg, ""-run-for"")) {
			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
			if (!simulation_time_in_ms)
				simulation_time_in_ms = 1; /*1ms*/
			i++;
		}

		else if (!strcmp(arg, ""-out"")) {
			out_arg = argv[i+1];
			i++;
		}
		else if (!stricmp(arg, ""-fps"")) {
			fps = atof(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
			dump_mode &= 0xFFFF0000;

			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
			else dump_mode |= DUMP_AVI;

			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
					return 1;
				}
				i++;
			}
		} else if (!strcmp(arg, ""-rgbds"")) { /*get dump in rgbds pixel format*/
				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
		} else if (!strcmp(arg, ""-rgbd"")) { /*get dump in rgbd pixel format*/
				dump_mode |= DUMP_RGB_DEPTH;
		} else if (!strcmp(arg, ""-depth"")) {
				dump_mode |= DUMP_DEPTH_ONLY;
		} else if (!strcmp(arg, ""-bmp"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_BMP;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-png"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_PNG;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-raw"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_RAW;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!stricmp(arg, ""-scale"")) {
			sscanf(argv[i+1], ""%f"", &scale);
			i++;
		}
		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			/* already parsed */
			i++;
		}

		/*arguments only used in non-gui mode*/
		if (!gui_mode) {
			if (arg[0] != '-') {
				if (url_arg) {
					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
					return 1;
				}
				url_arg = arg;
			}
			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;

			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
			else if (!strcmp(arg, ""-play-from"")) {
				play_from = atof((const char *) argv[i+1]);
				i++;
			}
			else if (!strcmp(arg, ""-speed"")) {
				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
				if (playback_speed <= 0) playback_speed = FIX_ONE;
				i++;
			}
			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
			else if (!strcmp(arg, ""-align"")) {
				if (argv[i+1][0]=='m') align_mode = 1;
				else if (argv[i+1][0]=='b') align_mode = 2;
				align_mode <<= 8;
				if (argv[i+1][1]=='m') align_mode |= 1;
				else if (argv[i+1][1]=='r') align_mode |= 2;
				i++;
			} else if (!strcmp(arg, ""-fill"")) {
				fill_ar = GF_TRUE;
			} else if (!strcmp(arg, ""-show"")) {
				visible = 1;
			} else if (!strcmp(arg, ""-uncache"")) {
				do_uncache = GF_TRUE;
			}
			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
			else if (!stricmp(arg, ""-views"")) {
				views = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-mosaic"")) {
				mosaic = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-com"")) {
				has_command = GF_TRUE;
				i++;
			}
			else if (!stricmp(arg, ""-service"")) {
				initial_service_id = atoi(argv[i+1]);
				i++;
			}
		}
	}
	if (is_cfg_only) {
		gf_cfg_del(cfg_file);
		fprintf(stderr, ""GPAC Config updated\n"");
		return 0;
	}
	if (do_uncache) {
		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
		do_flatten_cache(cache_dir);
		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
		gf_cfg_del(cfg_file);
		return 0;
	}

	if (dump_mode && !url_arg ) {
		FILE *test;
		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
		if (!test) url_arg = NULL;
		else gf_fclose(test);
		
		if (!url_arg) {
			fprintf(stderr, ""Missing argument for dump\n"");
			PrintUsage();
			if (logfile) gf_fclose(logfile);
			return 1;
		}
	}

	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
		gui_mode=1;
	}

#ifdef WIN32
	if (gui_mode==1) {
		const char *opt;
		TCHAR buffer[1024];
		DWORD res = GetCurrentDirectory(1024, buffer);
		buffer[res] = 0;
		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
		if (strstr(opt, buffer)) {
			gui_mode=1;
		} else {
			gui_mode=2;
		}
	}
#endif

	if (gui_mode==1) {
		hide_shell(1);
	}
	if (gui_mode) {
		no_prog=1;
		gf_set_progress_callback(NULL, progress_quiet);
	}

	if (!url_arg && simulation_time_in_ms)
		simulation_time_in_ms += gf_sys_clock();

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_init();
#endif


	if (dump_mode) rti_file = NULL;

	if (!logs_set) {
		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
	}
	if (rti_file || logfile || log_utc_time || log_time_start)
		gf_log_set_callback(NULL, on_gpac_log);

	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);

	{
		GF_SystemRTInfo rti;
		if (gf_sys_get_rti(0, &rti, 0))
			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
	}


	/*setup dumping options*/
	if (dump_mode) {
		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
		if (!visible)
			user.init_flags |= GF_TERM_INIT_HIDE;

		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		no_cfg_save=GF_TRUE;
	} else {
		init_w = forced_width;
		init_h = forced_height;
	}

	user.modules = gf_modules_new(NULL, cfg_file);
	if (user.modules) i = gf_modules_get_count(user.modules);
	if (!i || !user.modules) {
		fprintf(stderr, ""Error: no modules found - exiting\n"");
		if (user.modules) gf_modules_del(user.modules);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Modules Found : %d \n"", i);

	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
		gf_cfg_del_section(cfg_file, ""PluginsCache"");
		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
	}

	user.config = cfg_file;
	user.EventProc = GPAC_EventProc;
	/*dummy in this case (global vars) but MUST be non-NULL*/
	user.opaque = user.modules;
	if (threading_flags) user.init_flags |= threading_flags;
	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;

	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;

	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

	if (bench_mode) {
		gf_cfg_discard_changes(user.config);
		auto_exit = GF_TRUE;
		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		if (bench_mode!=2) {
			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
		} else {
			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
		}
	}

	{
		char dim[50];
		sprintf(dim, ""%d"", forced_width);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
		sprintf(dim, ""%d"", forced_height);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
	}

	fprintf(stderr, ""Loading GPAC Terminal\n"");
	i = gf_sys_clock();
	term = gf_term_new(&user);
	if (!term) {
		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
		list_modules(user.modules);
		gf_modules_del(user.modules);
		gf_cfg_discard_changes(cfg_file);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);

	if (bench_mode) {
		display_rti = 2;
		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
		if (bench_mode==1) bench_mode=2;
	}

	if (dump_mode) {
		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
	} else {
		/*check video output*/
		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
		/*check audio output*/
		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");

		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
	}

	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
	if (str && !strcmp(str, ""yes"")) {
		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
	}

	if (rti_file) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
		if (str) {
			rti_update_time_ms = atoi(str);
		} else {
			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
		}
		UpdateRTInfo(""At GPAC load time\n"");
	}

	Run = 1;

	if (dump_mode) {
		if (!nb_times) {
			times[0] = 0;
			nb_times++;
		}
		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
		Run = 0;
	}
	else if (views) {
	}
	/*connect if requested*/
	else if (!gui_mode && url_arg) {
		char *ext;

		if (strlen(url_arg) >= sizeof(the_url)) {
			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
			strncpy(the_url, url_arg, sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
		}
		else {
			strcpy(the_url, url_arg);
		}
		ext = strrchr(the_url, '.');
		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
			GF_Err e = GF_OK;
			fprintf(stderr, ""Opening Playlist %s\n"", the_url);

			strcpy(pl_path, the_url);
			/*this is not clean, we need to have a plugin handle playlist for ourselves*/
			if (!strncmp(""http:"", the_url, 5)) {
				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
				if (sess) {
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_cfg) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}
			}

			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
			readonly_playlist = 1;
			if (playlist) {
				request_next_playlist_item = GF_TRUE;
			} else {
				if (e)
					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
				fprintf(stderr, ""Hit 'h' for help\n\n"");
			}
		} else {
			fprintf(stderr, ""Opening URL %s\n"", the_url);
			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
		}
	} else {
		fprintf(stderr, ""Hit 'h' for help\n\n"");
		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		if (str) {
			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
			gf_term_connect(term, str);
			startup_file = 1;
			is_connected = 1;
		}
	}
	if (gui_mode==2) gui_mode=0;

	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

	if (views) {
		char szTemp[4046];
		sprintf(szTemp, ""views://%s"", views);
		gf_term_connect(term, szTemp);
	}
	if (mosaic) {
		char szTemp[4046];
		sprintf(szTemp, ""mosaic://%s"", mosaic);
		gf_term_connect(term, szTemp);
	}
	if (bench_mode) {
		rti_update_time_ms = 500;
		bench_mode_start = gf_sys_clock();
	}


	while (Run) {

		/*we don't want getchar to block*/
		if ((gui_mode==1) || !gf_prompt_has_input()) {
			if (reload) {
				reload = 0;
				gf_term_disconnect(term);
				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
			}
			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				restart = 0;
				gf_term_play_from_time(term, 0, 0);
			}
			if (request_next_playlist_item) {
				c = '\n';
				request_next_playlist_item = 0;
				goto force_input;
			}

			if (has_command && is_connected) {
				has_command = GF_FALSE;
				for (i=0; i<(u32)argc; i++) {
					if (!strcmp(argv[i], ""-com"")) {
						gf_term_scene_update(term, NULL, argv[i+1]);
						i++;
					}
				}
			}
			if (initial_service_id && is_connected) {
				GF_ObjectManager *root_od = gf_term_get_root_object(term);
				if (root_od) {
					gf_term_select_service(term, root_od, initial_service_id);
					initial_service_id = 0;
				}
			}

			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
			if (term_step) {
				gf_term_process_step(term);
			} else {
				gf_sleep(rti_update_time_ms);
			}
			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				Run = GF_FALSE;
			}

			/*sim time*/
			if (simulation_time_in_ms
			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
			   ) {
				Run = GF_FALSE;
			}
			continue;
		}
		c = gf_prompt_get_char();

force_input:
		switch (c) {
		case 'q':
		{
			GF_Event evt;
			memset(&evt, 0, sizeof(GF_Event));
			evt.type = GF_EVENT_QUIT;
			gf_term_send_event(term, &evt);
		}
		break;
		case 'X':
			exit(0);
			break;
		case 'Q':
			break;
		case 'o':
			startup_file = 0;
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
				break;
			}
			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
			gf_term_connect(term, the_url);
			break;
		case 'O':
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
				break;
			}
			playlist = gf_fopen(the_url, ""rt"");
			if (playlist) {
				if (1 >	fscanf(playlist, ""%s"", the_url)) {
					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
					gf_fclose( playlist);
					break;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case '\n':
		case 'N':
			if (playlist) {
				int res;
				gf_term_disconnect(term);

				res = fscanf(playlist, ""%s"", the_url);
				if ((res == EOF) && loop_at_end) {
					fseek(playlist, 0, SEEK_SET);
					res = fscanf(playlist, ""%s"", the_url);
				}
				if (res == EOF) {
					fprintf(stderr, ""No more items - exiting\n"");
					Run = 0;
				} else if (the_url[0] == '#') {
					request_next_playlist_item = GF_TRUE;
				} else {
					fprintf(stderr, ""Opening URL %s\n"", the_url);
					gf_term_connect_with_path(term, the_url, pl_path);
				}
			}
			break;
		case 'P':
			if (playlist) {
				u32 count;
				gf_term_disconnect(term);
				if (1 > scanf(""%u"", &count)) {
					fprintf(stderr, ""Cannot read number, aborting.\n"");
					break;
				}
				while (count) {
					if (fscanf(playlist, ""%s"", the_url)) {
						fprintf(stderr, ""Failed to read line, aborting\n"");
						break;
					}
					count--;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case 'r':
			if (is_connected)
				reload = 1;
			break;

		case 'D':
			if (is_connected) gf_term_disconnect(term);
			break;

		case 'p':
			if (is_connected) {
				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
			}
			break;
		case 's':
			if (is_connected) {
				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
				fprintf(stderr, ""Step time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, ""\n"");
			}
			break;

		case 'z':
		case 'T':
			if (!CanSeek || (Duration<=2000)) {
				fprintf(stderr, ""scene not seekable\n"");
			} else {
				Double res;
				s32 seekTo;
				fprintf(stderr, ""Duration: "");
				PrintTime(Duration);
				res = gf_term_get_time_in_ms(term);
				if (c=='z') {
					res *= 100;
					res /= (s64)Duration;
					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
					if (scanf(""%d"", &seekTo) == 1) {
						if (seekTo > 100) seekTo = 100;
						res = (Double)(s64)Duration;
						res /= 100;
						res *= seekTo;
						gf_term_play_from_time(term, (u64) (s64) res, 0);
					}
				} else {
					u32 r, h, m, s;
					fprintf(stderr, "" - Current Time: "");
					PrintTime((u64) res);
					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
					h = m = s = 0;
					r =scanf(""%d:%d:%d"", &h, &m, &s);
					if (r==2) {
						s = m;
						m = h;
						h = 0;
					}
					else if (r==1) {
						s = h;
						m = h = 0;
					}

					if (r && (r<=3)) {
						u64 time = h*3600 + m*60 + s;
						gf_term_play_from_time(term, time*1000, 0);
					}
				}
			}
			break;

		case 't':
		{
			if (is_connected) {
				fprintf(stderr, ""Current Time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, "" - Duration: "");
				PrintTime(Duration);
				fprintf(stderr, ""\n"");
			}
		}
		break;
		case 'w':
			if (is_connected) PrintWorldInfo(term);
			break;
		case 'v':
			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
			break;
		case 'i':
			if (is_connected) {
				u32 ID;
				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
				fflush(stderr);
				if (scanf(""%ud"", &ID) == 1) {
					ViewOD(term, ID, (u32)-1, NULL);
				} else {
					char str_url[GF_MAX_PATH];
					if (scanf(""%s"", str_url) == 1)
						ViewOD(term, 0, (u32)-1, str_url);
				}
			}
			break;
		case 'j':
			if (is_connected) {
				u32 num;
				do {
					fprintf(stderr, ""Enter OD number (0 for main OD): "");
					fflush(stderr);
				} while( 1 > scanf(""%ud"", &num));
				ViewOD(term, (u32)-1, num, NULL);
			}
			break;
		case 'b':
			if (is_connected) ViewODs(term, 1);
			break;

		case 'm':
			if (is_connected) ViewODs(term, 0);
			break;

		case 'l':
			list_modules(user.modules);
			break;

		case 'n':
			if (is_connected) set_navigation();
			break;
		case 'x':
			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
			break;

		case 'd':
			if (is_connected) {
				GF_ObjectManager *odm = NULL;
				char radname[GF_MAX_PATH], *sExt;
				GF_Err e;
				u32 i, count, odid;
				Bool xml_dump, std_out;
				radname[0] = 0;
				do {
					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
					fflush(stderr);
				} while( 1 >  scanf(""%ud"", &odid));
				if (odid) {
					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
					if (!root_odm) break;
					count = gf_term_get_object_count(term, root_odm);
					for (i=0; i<count; i++) {
						GF_MediaInfo info;
						odm = gf_term_get_object(term, root_odm, i);
						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
							if (info.od->objectDescriptorID==odid) break;
						}
						odm = NULL;
					}
				}
				do {
					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
					fflush(stderr);
				} while( 1 > scanf(""%s"", radname));
				sExt = strrchr(radname, '.');
				xml_dump = 0;
				if (sExt) {
					if (!stricmp(sExt, "".x"")) xml_dump = 1;
					sExt[0] = 0;
				}
				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
			}
			break;

		case 'c':
			PrintGPACConfig();
			break;
		case '3':
		{
			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
			}
		}
		break;
		case 'k':
		{
			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
			opt = !opt;
			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
		}
		break;
		case '4':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
			break;
		case '5':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
			break;
		case '6':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
			break;
		case '7':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
			break;

		case 'C':
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_DISABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
				break;
			case GF_MEDIA_CACHE_ENABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
				continue;
			}
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_ENABLED:
				fprintf(stderr, ""Streaming Cache Enabled\n"");
				break;
			case GF_MEDIA_CACHE_DISABLED:
				fprintf(stderr, ""Streaming Cache Disabled\n"");
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache Running\n"");
				break;
			}
			break;
		case 'S':
		case 'A':
			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
				fprintf(stderr, ""Streaming Cache stopped\n"");
			} else {
				fprintf(stderr, ""Streaming Cache not running\n"");
			}
			break;
		case 'R':
			display_rti = !display_rti;
			ResetCaption();
			break;
		case 'F':
			if (display_rti) display_rti = 0;
			else display_rti = 2;
			ResetCaption();
			break;

		case 'u':
		{
			GF_Err e;
			char szCom[8192];
			fprintf(stderr, ""Enter command to send:\n"");
			fflush(stdin);
			szCom[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szCom)) {
				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, NULL, szCom);
			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
		}
		break;
		case 'e':
		{
			GF_Err e;
			char jsCode[8192];
			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
			fflush(stdin);
			jsCode[0] = 0;
			if (1 > scanf(""%[^\t\n]"", jsCode)) {
				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
		}
		break;

		case 'L':
		{
			char szLog[1024], *cur_logs;
			cur_logs = gf_log_get_tools_levels();
			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
			gf_free(cur_logs);
			if (scanf(""%s"", szLog) < 1) {
				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
				break;
			}
			gf_log_modify_tools_levels(szLog);
		}
		break;

		case 'g':
		{
			GF_SystemRTInfo rti;
			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
		}
		break;
		case 'M':
		{
			u32 size;
			do {
				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
			} while (1 > scanf(""%ud"", &size));
			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
		}
		break;

		case 'H':
		{
			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
			do {
				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
			} while (1 > scanf(""%ud"", &http_bitrate));

			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
		}
		break;

		case 'E':
			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
			break;

		case 'B':
			switch_bench(!bench_mode);
			break;

		case 'Y':
		{
			char szOpt[8192];
			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read option\n"");
				break;
			}
			set_cfg_option(szOpt);
		}
		break;

		/*extract to PNG*/
		case 'Z':
		{
			char szFileName[100];
			u32 nb_pass, nb_views, offscreen_view = 0;
			GF_VideoSurface fb;
			GF_Err e;
			nb_pass = 1;
			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
			if (nb_views>1) {
				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
				if (scanf(""%d"", &offscreen_view) != 1) {
					offscreen_view = 0;
				}
				if (offscreen_view==nb_views+1) {
					offscreen_view = 1;
					nb_pass = nb_views;
				}
				else if (offscreen_view==nb_views+2) {
					offscreen_view = 0;
					nb_pass = nb_views+1;
				}
			}
			while (nb_pass) {
				nb_pass--;
				if (offscreen_view) {
					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
				} else {
					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
					e = gf_term_get_screen_buffer(term, &fb);
				}
				offscreen_view++;
				if (e) {
					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
					nb_pass = 0;
				} else {
#ifndef GPAC_DISABLE_AV_PARSERS
					u32 dst_size = fb.width*fb.height*4;
					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);

					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
					if (e) {
						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
						nb_pass = 0;
					} else {
						FILE *png = gf_fopen(szFileName, ""wb"");
						if (!png) {
							fprintf(stderr, ""Error writing file %s\n"", szFileName);
							nb_pass = 0;
						} else {
							gf_fwrite(dst, dst_size, 1, png);
							gf_fclose(png);
							fprintf(stderr, ""Dump to %s\n"", szFileName);
						}
					}
					if (dst) gf_free(dst);
					gf_term_release_screen_buffer(term, &fb);
#endif //GPAC_DISABLE_AV_PARSERS
				}
			}
			fprintf(stderr, ""Done: %s\n"", szFileName);
		}
		break;

		case 'G':
		{
			GF_ObjectManager *root_od, *odm;
			u32 index;
			char szOpt[8192];
			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read OD ID\n"");
				break;
			}
			index = atoi(szOpt);
			odm = NULL;
			root_od = gf_term_get_root_object(term);
			if (root_od) {
				if ( gf_term_find_service(term, root_od, index)) {
					gf_term_select_service(term, root_od, index);
				} else {
					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
					odm = gf_term_get_object(term, root_od, index);
					if (odm) {
						gf_term_select_object(term, odm);
					} else {
						fprintf(stderr, ""Cannot find object at index %d\n"", index);
					}
				}
			}
		}
		break;

		case 'h':
			PrintHelp();
			break;
		default:
			break;
		}
	}

	if (bench_mode) {
		PrintAVInfo(GF_TRUE);
	}

	/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/
	if (simulation_time_in_ms) {
		gf_log_set_strict_error(0);
	}


	i = gf_sys_clock();
	gf_term_disconnect(term);
	if (rti_file) UpdateRTInfo(""Disconnected\n"");

	fprintf(stderr, ""Deleting terminal... "");
	if (playlist) gf_fclose(playlist);

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_uninit();
#endif

	gf_term_del(term);
	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());

	fprintf(stderr, ""GPAC cleanup ...\n"");
	gf_modules_del(user.modules);

	if (no_cfg_save)
		gf_cfg_discard_changes(cfg_file);

	gf_cfg_del(cfg_file);

	gf_sys_close();

	if (rti_logs) gf_fclose(rti_logs);
	if (logfile) gf_fclose(logfile);

	if (gui_mode) {
		hide_shell(2);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
		gf_memory_print();
		return 2;
	}
#endif

	return ret_val;
}
","int mp4client_main(int argc, char **argv)
{
	char c;
	const char *str;
	int ret_val = 0;
	u32 i, times[100], nb_times, dump_mode;
	u32 simulation_time_in_ms = 0;
	u32 initial_service_id = 0;
	Bool auto_exit = GF_FALSE;
	Bool logs_set = GF_FALSE;
	Bool start_fs = GF_FALSE;
	Bool use_rtix = GF_FALSE;
	Bool pause_at_first = GF_FALSE;
	Bool no_cfg_save = GF_FALSE;
	Bool is_cfg_only = GF_FALSE;

	Double play_from = 0;
#ifdef GPAC_MEMORY_TRACKING
    GF_MemTrackerType mem_track = GF_MemTrackerNone;
#endif
	Double fps = GF_IMPORT_DEFAULT_FPS;
	Bool fill_ar, visible, do_uncache, has_command;
	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
	FILE *logfile = NULL;
	Float scale = 1;
#ifndef WIN32
	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
#endif

	/*by default use current dir*/
	strcpy(the_url, ""."");

	memset(&user, 0, sizeof(GF_User));

	dump_mode = DUMP_NONE;
	fill_ar = visible = do_uncache = has_command = GF_FALSE;
	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
	nb_times = 0;
	times[0] = 0;

	/*first locate config file if specified*/
	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];
		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			the_cfg = argv[i+1];
			i++;
		}
		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
#ifdef GPAC_MEMORY_TRACKING
            mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
#else
			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
#endif
		} else if (!strcmp(arg, ""-gui"")) {
			gui_mode = 1;
		} else if (!strcmp(arg, ""-guid"")) {
			gui_mode = 2;
		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
			PrintUsage();
			return 0;
		}
	}

#ifdef GPAC_MEMORY_TRACKING
	gf_sys_init(mem_track);
#else
	gf_sys_init(GF_MemTrackerNone);
#endif
	gf_sys_set_args(argc, (const char **) argv);

	cfg_file = gf_cfg_init(the_cfg, NULL);
	if (!cfg_file) {
		fprintf(stderr, ""Error: Configuration File not found\n"");
		return 1;
	}
	/*if logs are specified, use them*/
	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
		return 1;
	}

	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
		logs_set = GF_TRUE;
	}

	if (!gui_mode) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
	}

	for (i=1; i<(u32) argc; i++) {
		char *arg = argv[i];

		if (!strcmp(arg, ""-rti"")) {
			rti_file = argv[i+1];
			i++;
		} else if (!strcmp(arg, ""-rtix"")) {
			rti_file = argv[i+1];
			i++;
			use_rtix = GF_TRUE;
		} else if (!stricmp(arg, ""-size"")) {
			/*usage of %ud breaks sscanf on MSVC*/
			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
				forced_width = forced_height = 0;
			}
			i++;
		} else if (!strcmp(arg, ""-quiet"")) {
			be_quiet = 1;
		} else if (!strcmp(arg, ""-strict-error"")) {
			gf_log_set_strict_error(1);
		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
			logfile = gf_fopen(argv[i+1], ""wt"");
			gf_log_set_callback(logfile, on_gpac_log);
			i++;
		} else if (!strcmp(arg, ""-logs"") ) {
			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
				return 1;
			}
			logs_set = GF_TRUE;
			i++;
		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
			log_time_start = 1;
		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
			log_utc_time = 1;
		}
#if defined(__DARWIN__) || defined(__APPLE__)
		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
#else
		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
#endif
		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
		else if (!strcmp(arg, ""-fs"")) start_fs = 1;

		else if (!strcmp(arg, ""-opt"")) {
			set_cfg_option(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-conf"")) {
			set_cfg_option(argv[i+1]);
			is_cfg_only=GF_TRUE;
			i++;
		}
		else if (!strcmp(arg, ""-ifce"")) {
			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
			i++;
		}
		else if (!stricmp(arg, ""-help"")) {
			PrintUsage();
			return 1;
		}
		else if (!stricmp(arg, ""-noprog"")) {
			no_prog=1;
			gf_set_progress_callback(NULL, progress_quiet);
		}
		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"") /*old versions used --n-save ...*/) {
			no_cfg_save=1;
		}
		else if (!stricmp(arg, ""-ntp-shift"")) {
			s32 shift = atoi(argv[i+1]);
			i++;
			gf_net_set_ntp_shift(shift);
		}
		else if (!stricmp(arg, ""-run-for"")) {
			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
			if (!simulation_time_in_ms)
				simulation_time_in_ms = 1; /*1ms*/
			i++;
		}

		else if (!strcmp(arg, ""-out"")) {
			out_arg = argv[i+1];
			i++;
		}
		else if (!stricmp(arg, ""-fps"")) {
			fps = atof(argv[i+1]);
			i++;
		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
			dump_mode &= 0xFFFF0000;

			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
			else dump_mode |= DUMP_AVI;

			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
					return 1;
				}
				i++;
			}
		} else if (!strcmp(arg, ""-rgbds"")) { /*get dump in rgbds pixel format*/
				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
		} else if (!strcmp(arg, ""-rgbd"")) { /*get dump in rgbd pixel format*/
				dump_mode |= DUMP_RGB_DEPTH;
		} else if (!strcmp(arg, ""-depth"")) {
				dump_mode |= DUMP_DEPTH_ONLY;
		} else if (!strcmp(arg, ""-bmp"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_BMP;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-png"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_PNG;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!strcmp(arg, ""-raw"")) {
			dump_mode &= 0xFFFF0000;
			dump_mode |= DUMP_RAW;
			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
		} else if (!stricmp(arg, ""-scale"")) {
			sscanf(argv[i+1], ""%f"", &scale);
			i++;
		}
		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
			/* already parsed */
			i++;
		}

		/*arguments only used in non-gui mode*/
		if (!gui_mode) {
			if (arg[0] != '-') {
				if (url_arg) {
					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
					return 1;
				}
				url_arg = arg;
			}
			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;

			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
			else if (!strcmp(arg, ""-play-from"")) {
				play_from = atof((const char *) argv[i+1]);
				i++;
			}
			else if (!strcmp(arg, ""-speed"")) {
				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
				if (playback_speed <= 0) playback_speed = FIX_ONE;
				i++;
			}
			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
			else if (!strcmp(arg, ""-align"")) {
				if (argv[i+1][0]=='m') align_mode = 1;
				else if (argv[i+1][0]=='b') align_mode = 2;
				align_mode <<= 8;
				if (argv[i+1][1]=='m') align_mode |= 1;
				else if (argv[i+1][1]=='r') align_mode |= 2;
				i++;
			} else if (!strcmp(arg, ""-fill"")) {
				fill_ar = GF_TRUE;
			} else if (!strcmp(arg, ""-show"")) {
				visible = 1;
			} else if (!strcmp(arg, ""-uncache"")) {
				do_uncache = GF_TRUE;
			}
			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
			else if (!stricmp(arg, ""-views"")) {
				views = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-mosaic"")) {
				mosaic = argv[i+1];
				i++;
			}
			else if (!stricmp(arg, ""-com"")) {
				has_command = GF_TRUE;
				i++;
			}
			else if (!stricmp(arg, ""-service"")) {
				initial_service_id = atoi(argv[i+1]);
				i++;
			}
		}
	}
	if (is_cfg_only) {
		gf_cfg_del(cfg_file);
		fprintf(stderr, ""GPAC Config updated\n"");
		return 0;
	}
	if (do_uncache) {
		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
		do_flatten_cache(cache_dir);
		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
		gf_cfg_del(cfg_file);
		return 0;
	}

	if (dump_mode && !url_arg ) {
		FILE *test;
		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
		if (!test) url_arg = NULL;
		else gf_fclose(test);
		
		if (!url_arg) {
			fprintf(stderr, ""Missing argument for dump\n"");
			PrintUsage();
			if (logfile) gf_fclose(logfile);
			return 1;
		}
	}

	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
		gui_mode=1;
	}

#ifdef WIN32
	if (gui_mode==1) {
		const char *opt;
		TCHAR buffer[1024];
		DWORD res = GetCurrentDirectory(1024, buffer);
		buffer[res] = 0;
		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
		if (strstr(opt, buffer)) {
			gui_mode=1;
		} else {
			gui_mode=2;
		}
	}
#endif

	if (gui_mode==1) {
		hide_shell(1);
	}
	if (gui_mode) {
		no_prog=1;
		gf_set_progress_callback(NULL, progress_quiet);
	}

	if (!url_arg && simulation_time_in_ms)
		simulation_time_in_ms += gf_sys_clock();

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_init();
#endif


	if (dump_mode) rti_file = NULL;

	if (!logs_set) {
		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
	}
	if (rti_file || logfile || log_utc_time || log_time_start)
		gf_log_set_callback(NULL, on_gpac_log);

	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);

	{
		GF_SystemRTInfo rti;
		if (gf_sys_get_rti(0, &rti, 0))
			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
	}


	/*setup dumping options*/
	if (dump_mode) {
		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
		if (!visible)
			user.init_flags |= GF_TERM_INIT_HIDE;

		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		no_cfg_save=GF_TRUE;
	} else {
		init_w = forced_width;
		init_h = forced_height;
	}

	user.modules = gf_modules_new(NULL, cfg_file);
	if (user.modules) i = gf_modules_get_count(user.modules);
	if (!i || !user.modules) {
		fprintf(stderr, ""Error: no modules found - exiting\n"");
		if (user.modules) gf_modules_del(user.modules);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Modules Found : %d \n"", i);

	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
		gf_cfg_del_section(cfg_file, ""PluginsCache"");
		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
	}

	user.config = cfg_file;
	user.EventProc = GPAC_EventProc;
	/*dummy in this case (global vars) but MUST be non-NULL*/
	user.opaque = user.modules;
	if (threading_flags) user.init_flags |= threading_flags;
	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;

	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;

	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

	if (bench_mode) {
		gf_cfg_discard_changes(user.config);
		auto_exit = GF_TRUE;
		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
		if (bench_mode!=2) {
			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
		} else {
			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
		}
	}

	{
		char dim[50];
		sprintf(dim, ""%d"", forced_width);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
		sprintf(dim, ""%d"", forced_height);
		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
	}

	fprintf(stderr, ""Loading GPAC Terminal\n"");
	i = gf_sys_clock();
	term = gf_term_new(&user);
	if (!term) {
		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
		list_modules(user.modules);
		gf_modules_del(user.modules);
		gf_cfg_discard_changes(cfg_file);
		gf_cfg_del(cfg_file);
		gf_sys_close();
		if (logfile) gf_fclose(logfile);
		return 1;
	}
	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);

	if (bench_mode) {
		display_rti = 2;
		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
		if (bench_mode==1) bench_mode=2;
	}

	if (dump_mode) {
		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
	} else {
		/*check video output*/
		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
		/*check audio output*/
		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");

		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
	}

	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
	if (str && !strcmp(str, ""yes"")) {
		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
	}

	if (rti_file) {
		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
		if (str) {
			rti_update_time_ms = atoi(str);
		} else {
			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
		}
		UpdateRTInfo(""At GPAC load time\n"");
	}

	Run = 1;

	if (dump_mode) {
		if (!nb_times) {
			times[0] = 0;
			nb_times++;
		}
		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
		Run = 0;
	}
	else if (views) {
	}
	/*connect if requested*/
	else if (!gui_mode && url_arg) {
		char *ext;

		if (strlen(url_arg) >= sizeof(the_url)) {
			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
			strncpy(the_url, url_arg, sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
		}
		else {
			strcpy(the_url, url_arg);
		}
		ext = strrchr(the_url, '.');
		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
			GF_Err e = GF_OK;
			fprintf(stderr, ""Opening Playlist %s\n"", the_url);

			strcpy(pl_path, the_url);
			/*this is not clean, we need to have a plugin handle playlist for ourselves*/
			if (!strncmp(""http:"", the_url, 5)) {
				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
				if (sess) {
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_url) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}
			}

			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
			readonly_playlist = 1;
			if (playlist) {
				request_next_playlist_item = GF_TRUE;
			} else {
				if (e)
					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
				fprintf(stderr, ""Hit 'h' for help\n\n"");
			}
		} else {
			fprintf(stderr, ""Opening URL %s\n"", the_url);
			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
		}
	} else {
		fprintf(stderr, ""Hit 'h' for help\n\n"");
		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
		if (str) {
			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
			the_url[sizeof(the_url) - 1] = 0;
			gf_term_connect(term, str);
			startup_file = 1;
			is_connected = 1;
		}
	}
	if (gui_mode==2) gui_mode=0;

	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

	if (views) {
		char szTemp[4046];
		sprintf(szTemp, ""views://%s"", views);
		gf_term_connect(term, szTemp);
	}
	if (mosaic) {
		char szTemp[4046];
		sprintf(szTemp, ""mosaic://%s"", mosaic);
		gf_term_connect(term, szTemp);
	}
	if (bench_mode) {
		rti_update_time_ms = 500;
		bench_mode_start = gf_sys_clock();
	}


	while (Run) {

		/*we don't want getchar to block*/
		if ((gui_mode==1) || !gf_prompt_has_input()) {
			if (reload) {
				reload = 0;
				gf_term_disconnect(term);
				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
			}
			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				restart = 0;
				gf_term_play_from_time(term, 0, 0);
			}
			if (request_next_playlist_item) {
				c = '\n';
				request_next_playlist_item = 0;
				goto force_input;
			}

			if (has_command && is_connected) {
				has_command = GF_FALSE;
				for (i=0; i<(u32)argc; i++) {
					if (!strcmp(argv[i], ""-com"")) {
						gf_term_scene_update(term, NULL, argv[i+1]);
						i++;
					}
				}
			}
			if (initial_service_id && is_connected) {
				GF_ObjectManager *root_od = gf_term_get_root_object(term);
				if (root_od) {
					gf_term_select_service(term, root_od, initial_service_id);
					initial_service_id = 0;
				}
			}

			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
			if (term_step) {
				gf_term_process_step(term);
			} else {
				gf_sleep(rti_update_time_ms);
			}
			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
				Run = GF_FALSE;
			}

			/*sim time*/
			if (simulation_time_in_ms
			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
			   ) {
				Run = GF_FALSE;
			}
			continue;
		}
		c = gf_prompt_get_char();

force_input:
		switch (c) {
		case 'q':
		{
			GF_Event evt;
			memset(&evt, 0, sizeof(GF_Event));
			evt.type = GF_EVENT_QUIT;
			gf_term_send_event(term, &evt);
		}
		break;
		case 'X':
			exit(0);
			break;
		case 'Q':
			break;
		case 'o':
			startup_file = 0;
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
				break;
			}
			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
			gf_term_connect(term, the_url);
			break;
		case 'O':
			gf_term_disconnect(term);
			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
			if (1 > scanf(""%s"", the_url)) {
				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
				break;
			}
			playlist = gf_fopen(the_url, ""rt"");
			if (playlist) {
				if (1 >	fscanf(playlist, ""%s"", the_url)) {
					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
					gf_fclose( playlist);
					break;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case '\n':
		case 'N':
			if (playlist) {
				int res;
				gf_term_disconnect(term);

				res = fscanf(playlist, ""%s"", the_url);
				if ((res == EOF) && loop_at_end) {
					fseek(playlist, 0, SEEK_SET);
					res = fscanf(playlist, ""%s"", the_url);
				}
				if (res == EOF) {
					fprintf(stderr, ""No more items - exiting\n"");
					Run = 0;
				} else if (the_url[0] == '#') {
					request_next_playlist_item = GF_TRUE;
				} else {
					fprintf(stderr, ""Opening URL %s\n"", the_url);
					gf_term_connect_with_path(term, the_url, pl_path);
				}
			}
			break;
		case 'P':
			if (playlist) {
				u32 count;
				gf_term_disconnect(term);
				if (1 > scanf(""%u"", &count)) {
					fprintf(stderr, ""Cannot read number, aborting.\n"");
					break;
				}
				while (count) {
					if (fscanf(playlist, ""%s"", the_url)) {
						fprintf(stderr, ""Failed to read line, aborting\n"");
						break;
					}
					count--;
				}
				fprintf(stderr, ""Opening URL %s\n"", the_url);
				gf_term_connect(term, the_url);
			}
			break;
		case 'r':
			if (is_connected)
				reload = 1;
			break;

		case 'D':
			if (is_connected) gf_term_disconnect(term);
			break;

		case 'p':
			if (is_connected) {
				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
			}
			break;
		case 's':
			if (is_connected) {
				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
				fprintf(stderr, ""Step time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, ""\n"");
			}
			break;

		case 'z':
		case 'T':
			if (!CanSeek || (Duration<=2000)) {
				fprintf(stderr, ""scene not seekable\n"");
			} else {
				Double res;
				s32 seekTo;
				fprintf(stderr, ""Duration: "");
				PrintTime(Duration);
				res = gf_term_get_time_in_ms(term);
				if (c=='z') {
					res *= 100;
					res /= (s64)Duration;
					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
					if (scanf(""%d"", &seekTo) == 1) {
						if (seekTo > 100) seekTo = 100;
						res = (Double)(s64)Duration;
						res /= 100;
						res *= seekTo;
						gf_term_play_from_time(term, (u64) (s64) res, 0);
					}
				} else {
					u32 r, h, m, s;
					fprintf(stderr, "" - Current Time: "");
					PrintTime((u64) res);
					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
					h = m = s = 0;
					r =scanf(""%d:%d:%d"", &h, &m, &s);
					if (r==2) {
						s = m;
						m = h;
						h = 0;
					}
					else if (r==1) {
						s = h;
						m = h = 0;
					}

					if (r && (r<=3)) {
						u64 time = h*3600 + m*60 + s;
						gf_term_play_from_time(term, time*1000, 0);
					}
				}
			}
			break;

		case 't':
		{
			if (is_connected) {
				fprintf(stderr, ""Current Time: "");
				PrintTime(gf_term_get_time_in_ms(term));
				fprintf(stderr, "" - Duration: "");
				PrintTime(Duration);
				fprintf(stderr, ""\n"");
			}
		}
		break;
		case 'w':
			if (is_connected) PrintWorldInfo(term);
			break;
		case 'v':
			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
			break;
		case 'i':
			if (is_connected) {
				u32 ID;
				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
				fflush(stderr);
				if (scanf(""%ud"", &ID) == 1) {
					ViewOD(term, ID, (u32)-1, NULL);
				} else {
					char str_url[GF_MAX_PATH];
					if (scanf(""%s"", str_url) == 1)
						ViewOD(term, 0, (u32)-1, str_url);
				}
			}
			break;
		case 'j':
			if (is_connected) {
				u32 num;
				do {
					fprintf(stderr, ""Enter OD number (0 for main OD): "");
					fflush(stderr);
				} while( 1 > scanf(""%ud"", &num));
				ViewOD(term, (u32)-1, num, NULL);
			}
			break;
		case 'b':
			if (is_connected) ViewODs(term, 1);
			break;

		case 'm':
			if (is_connected) ViewODs(term, 0);
			break;

		case 'l':
			list_modules(user.modules);
			break;

		case 'n':
			if (is_connected) set_navigation();
			break;
		case 'x':
			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
			break;

		case 'd':
			if (is_connected) {
				GF_ObjectManager *odm = NULL;
				char radname[GF_MAX_PATH], *sExt;
				GF_Err e;
				u32 i, count, odid;
				Bool xml_dump, std_out;
				radname[0] = 0;
				do {
					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
					fflush(stderr);
				} while( 1 >  scanf(""%ud"", &odid));
				if (odid) {
					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
					if (!root_odm) break;
					count = gf_term_get_object_count(term, root_odm);
					for (i=0; i<count; i++) {
						GF_MediaInfo info;
						odm = gf_term_get_object(term, root_odm, i);
						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
							if (info.od->objectDescriptorID==odid) break;
						}
						odm = NULL;
					}
				}
				do {
					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
					fflush(stderr);
				} while( 1 > scanf(""%s"", radname));
				sExt = strrchr(radname, '.');
				xml_dump = 0;
				if (sExt) {
					if (!stricmp(sExt, "".x"")) xml_dump = 1;
					sExt[0] = 0;
				}
				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
			}
			break;

		case 'c':
			PrintGPACConfig();
			break;
		case '3':
		{
			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
			}
		}
		break;
		case 'k':
		{
			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
			opt = !opt;
			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
		}
		break;
		case '4':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
			break;
		case '5':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
			break;
		case '6':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
			break;
		case '7':
			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
			break;

		case 'C':
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_DISABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
				break;
			case GF_MEDIA_CACHE_ENABLED:
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
				continue;
			}
			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
			case GF_MEDIA_CACHE_ENABLED:
				fprintf(stderr, ""Streaming Cache Enabled\n"");
				break;
			case GF_MEDIA_CACHE_DISABLED:
				fprintf(stderr, ""Streaming Cache Disabled\n"");
				break;
			case GF_MEDIA_CACHE_RUNNING:
				fprintf(stderr, ""Streaming Cache Running\n"");
				break;
			}
			break;
		case 'S':
		case 'A':
			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
				fprintf(stderr, ""Streaming Cache stopped\n"");
			} else {
				fprintf(stderr, ""Streaming Cache not running\n"");
			}
			break;
		case 'R':
			display_rti = !display_rti;
			ResetCaption();
			break;
		case 'F':
			if (display_rti) display_rti = 0;
			else display_rti = 2;
			ResetCaption();
			break;

		case 'u':
		{
			GF_Err e;
			char szCom[8192];
			fprintf(stderr, ""Enter command to send:\n"");
			fflush(stdin);
			szCom[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szCom)) {
				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, NULL, szCom);
			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
		}
		break;
		case 'e':
		{
			GF_Err e;
			char jsCode[8192];
			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
			fflush(stdin);
			jsCode[0] = 0;
			if (1 > scanf(""%[^\t\n]"", jsCode)) {
				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
				break;
			}
			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
		}
		break;

		case 'L':
		{
			char szLog[1024], *cur_logs;
			cur_logs = gf_log_get_tools_levels();
			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
			gf_free(cur_logs);
			if (scanf(""%s"", szLog) < 1) {
				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
				break;
			}
			gf_log_modify_tools_levels(szLog);
		}
		break;

		case 'g':
		{
			GF_SystemRTInfo rti;
			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
		}
		break;
		case 'M':
		{
			u32 size;
			do {
				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
			} while (1 > scanf(""%ud"", &size));
			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
		}
		break;

		case 'H':
		{
			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
			do {
				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
			} while (1 > scanf(""%ud"", &http_bitrate));

			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
		}
		break;

		case 'E':
			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
			break;

		case 'B':
			switch_bench(!bench_mode);
			break;

		case 'Y':
		{
			char szOpt[8192];
			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read option\n"");
				break;
			}
			set_cfg_option(szOpt);
		}
		break;

		/*extract to PNG*/
		case 'Z':
		{
			char szFileName[100];
			u32 nb_pass, nb_views, offscreen_view = 0;
			GF_VideoSurface fb;
			GF_Err e;
			nb_pass = 1;
			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
			if (nb_views>1) {
				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
				if (scanf(""%d"", &offscreen_view) != 1) {
					offscreen_view = 0;
				}
				if (offscreen_view==nb_views+1) {
					offscreen_view = 1;
					nb_pass = nb_views;
				}
				else if (offscreen_view==nb_views+2) {
					offscreen_view = 0;
					nb_pass = nb_views+1;
				}
			}
			while (nb_pass) {
				nb_pass--;
				if (offscreen_view) {
					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
				} else {
					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
					e = gf_term_get_screen_buffer(term, &fb);
				}
				offscreen_view++;
				if (e) {
					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
					nb_pass = 0;
				} else {
#ifndef GPAC_DISABLE_AV_PARSERS
					u32 dst_size = fb.width*fb.height*4;
					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);

					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
					if (e) {
						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
						nb_pass = 0;
					} else {
						FILE *png = gf_fopen(szFileName, ""wb"");
						if (!png) {
							fprintf(stderr, ""Error writing file %s\n"", szFileName);
							nb_pass = 0;
						} else {
							gf_fwrite(dst, dst_size, 1, png);
							gf_fclose(png);
							fprintf(stderr, ""Dump to %s\n"", szFileName);
						}
					}
					if (dst) gf_free(dst);
					gf_term_release_screen_buffer(term, &fb);
#endif //GPAC_DISABLE_AV_PARSERS
				}
			}
			fprintf(stderr, ""Done: %s\n"", szFileName);
		}
		break;

		case 'G':
		{
			GF_ObjectManager *root_od, *odm;
			u32 index;
			char szOpt[8192];
			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
			fflush(stdin);
			szOpt[0] = 0;
			if (1 > scanf(""%[^\t\n]"", szOpt)) {
				fprintf(stderr, ""Cannot read OD ID\n"");
				break;
			}
			index = atoi(szOpt);
			odm = NULL;
			root_od = gf_term_get_root_object(term);
			if (root_od) {
				if ( gf_term_find_service(term, root_od, index)) {
					gf_term_select_service(term, root_od, index);
				} else {
					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
					odm = gf_term_get_object(term, root_od, index);
					if (odm) {
						gf_term_select_object(term, odm);
					} else {
						fprintf(stderr, ""Cannot find object at index %d\n"", index);
					}
				}
			}
		}
		break;

		case 'h':
			PrintHelp();
			break;
		default:
			break;
		}
	}

	if (bench_mode) {
		PrintAVInfo(GF_TRUE);
	}

	/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/
	if (simulation_time_in_ms) {
		gf_log_set_strict_error(0);
	}


	i = gf_sys_clock();
	gf_term_disconnect(term);
	if (rti_file) UpdateRTInfo(""Disconnected\n"");

	fprintf(stderr, ""Deleting terminal... "");
	if (playlist) gf_fclose(playlist);

#if defined(__DARWIN__) || defined(__APPLE__)
	carbon_uninit();
#endif

	gf_term_del(term);
	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());

	fprintf(stderr, ""GPAC cleanup ...\n"");
	gf_modules_del(user.modules);

	if (no_cfg_save)
		gf_cfg_discard_changes(cfg_file);

	gf_cfg_del(cfg_file);

	gf_sys_close();

	if (rti_logs) gf_fclose(rti_logs);
	if (logfile) gf_fclose(logfile);

	if (gui_mode) {
		hide_shell(2);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
		gf_memory_print();
		return 2;
	}
#endif

	return ret_val;
}
","The vulnerability in the original code arises from the lack of proper validation when handling command-line arguments, particularly when accessing `argv[i+1]` without checking if `i+1` is within bounds. This can lead to out-of-bounds memory access, potentially causing a segmentation fault or allowing an attacker to manipulate memory. For instance, when processing the `-c` or `-cfg` options, if the user does not provide a subsequent argument, `the_cfg` could be assigned an invalid pointer. The fixed code addresses this by ensuring that the index `i+1` is valid before accessing it, thus preventing potential memory access violations.","The vulnerability in the original code stems from inadequate validation of command-line arguments, particularly when accessing subsequent arguments without checking their availability. This oversight can lead to out-of-bounds memory access, resulting in segmentation faults or unintended memory manipulation if the user fails to provide the expected arguments. The revised code rectifies this issue by implementing checks to ensure that any accessed argument is within the valid range, thereby preventing potential crashes and enhancing overall stability and security against malicious input or accidental misuse.",2,"5

The explanation and repair description is directly discussing the code snippet provided and is completely related to its context. It shows the complete function `mp4client_main()` and provides a detailed understanding of its functionality, purpose, and behavior. The text contains all the relevant code and would help with understanding the implementation and any potential repairs needed.",4,2
39,39,186862,186862,,Remote,Not required,Partial,CVE-2018-6063,https://www.cvedetails.com/cve/CVE-2018-6063/,CWE-787,Medium,Partial,Partial,,2018-11-14,6.8,Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.,2018-12-26,,3,https://github.com/chromium/chromium/commit/673ce95d481ea9368c4d4d43ac756ba1d6d9e608,673ce95d481ea9368c4d4d43ac756ba1d6d9e608,"Correct mojo::WrapSharedMemoryHandle usage

Fixes some incorrect uses of mojo::WrapSharedMemoryHandle which
were assuming that the call actually has any control over the memory
protection applied to a handle when mapped.

Where fixing usage is infeasible for this CL, TODOs are added to
annotate follow-up work.

Also updates the API and documentation to (hopefully) improve clarity
and avoid similar mistakes from being made in the future.

BUG=792900

Cq-Include-Trybots: master.tryserver.chromium.android:android_optional_gpu_tests_rel;master.tryserver.chromium.linux:linux_optional_gpu_tests_rel;master.tryserver.chromium.mac:mac_optional_gpu_tests_rel;master.tryserver.chromium.win:win_optional_gpu_tests_rel
Change-Id: I0578aaa9ca3bfcb01aaf2451315d1ede95458477
Reviewed-on: https://chromium-review.googlesource.com/818282
Reviewed-by: Wei Li <weili@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Reviewed-by: John Abd-El-Malek <jam@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Sadrul Chowdhury <sadrul@chromium.org>
Reviewed-by: Yuzhu Shen <yzshen@chromium.org>
Reviewed-by: Robert Sesek <rsesek@chromium.org>
Commit-Queue: Ken Rockot <rockot@chromium.org>
Cr-Commit-Position: refs/heads/master@{#530268}",3,mojo/public/cpp/system/platform_handle.cc,"{""sha"": ""e97180e53af8217df7146a9df44533c161aa33bb"", ""filename"": ""components/discardable_memory/client/client_discardable_shared_memory_manager.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/discardable_memory/client/client_discardable_shared_memory_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/discardable_memory/client/client_discardable_shared_memory_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/discardable_memory/client/client_discardable_shared_memory_manager.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -391,12 +391,10 @@ void ClientDiscardableSharedMemoryManager::AllocateCompletedOnIO(\n     base::SharedMemoryHandle* handle,\n     base::ScopedClosureRunner closure_runner,\n     mojo::ScopedSharedBufferHandle mojo_handle) {\n-  size_t memory_size = 0;\n-  bool read_only = false;\n   if (!mojo_handle.is_valid())\n     return;\n   auto result = mojo::UnwrapSharedMemoryHandle(std::move(mojo_handle), handle,\n-                                               &memory_size, &read_only);\n+                                               nullptr, nullptr);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n }\n ""}<_**next**_>{""sha"": ""620c60e89676fb899eda493abf009c39812ed303"", ""filename"": ""components/discardable_memory/service/discardable_shared_memory_manager.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/discardable_memory/service/discardable_shared_memory_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/discardable_memory/service/discardable_shared_memory_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/discardable_memory/service/discardable_shared_memory_manager.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -74,8 +74,9 @@ class MojoDiscardableSharedMemoryManagerImpl\n     if (manager_) {\n       manager_->AllocateLockedDiscardableSharedMemoryForClient(client_id_, size,\n                                                                id, &handle);\n-      memory =\n-          mojo::WrapSharedMemoryHandle(handle, size, false /* read_only */);\n+      memory = mojo::WrapSharedMemoryHandle(\n+          handle, size,\n+          mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n     }\n     std::move(callback).Run(std::move(memory));\n   }""}<_**next**_>{""sha"": ""99dfa5a1fbdaf81591547382fe616bafa85761ba"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -18,6 +18,8 @@ class PrintCompositeClient\n   explicit PrintCompositeClient(content::WebContents* web_contents);\n   ~PrintCompositeClient() override;\n \n+  // NOTE: |handle| must be a READ-ONLY base::SharedMemoryHandle, i.e. one\n+  // acquired by base::SharedMemory::GetReadOnlyHandle().\n   void DoComposite(base::SharedMemoryHandle handle,\n                    uint32_t data_size,\n                    mojom::PdfCompositor::CompositePdfCallback callback);""}<_**next**_>{""sha"": ""e33c1df924d5bbf281b19f91fd6310a99c580112"", ""filename"": ""components/printing/renderer/DEPS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/renderer/DEPS?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -1,6 +1,7 @@\n include_rules = [\n   \""+components/grit/components_resources.h\"",\n   \""+content/public/renderer\"",\n+  \""+mojo/public\"",\n   \""+net/base\"",\n   \""+services/service_manager/public/cpp\"",\n   \""+third_party/skia\"",""}<_**next**_>{""sha"": ""86c3b7a291e33f711db9dda7094106f6a21b12eb"", ""filename"": ""components/printing/renderer/print_render_frame_helper.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 16, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/renderer/print_render_frame_helper.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -31,6 +31,8 @@\n #include \""content/public/renderer/render_frame.h\""\n #include \""content/public/renderer/render_thread.h\""\n #include \""content/public/renderer/render_view.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""net/base/escape.h\""\n #include \""printing/features/features.h\""\n #include \""printing/metafile_skia_wrapper.h\""\n@@ -1363,9 +1365,9 @@ bool PrintRenderFrameHelper::FinalizePrintReadyDocument() {\n   PdfMetafileSkia* metafile = print_preview_context_.metafile();\n   PrintHostMsg_DidPreviewDocument_Params preview_params;\n \n-  if (!CopyMetafileDataToSharedMem(*metafile,\n-                                   &preview_params.metafile_data_handle)) {\n-    LOG(ERROR) << \""CopyMetafileDataToSharedMem failed\"";\n+  if (!CopyMetafileDataToReadOnlySharedMem(\n+          *metafile, &preview_params.metafile_data_handle)) {\n+    LOG(ERROR) << \""CopyMetafileDataToReadOnlySharedMem failed\"";\n     print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n     return false;\n   }\n@@ -1628,8 +1630,8 @@ bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n \n   metafile.FinishDocument();\n \n-  if (!CopyMetafileDataToSharedMem(metafile,\n-                                   &page_params.metafile_data_handle)) {\n+  if (!CopyMetafileDataToReadOnlySharedMem(metafile,\n+                                           &page_params.metafile_data_handle)) {\n     return false;\n   }\n \n@@ -1949,26 +1951,29 @@ void PrintRenderFrameHelper::PrintPageInternal(\n }\n #endif  // !defined(OS_MACOSX)\n \n-bool PrintRenderFrameHelper::CopyMetafileDataToSharedMem(\n+bool PrintRenderFrameHelper::CopyMetafileDataToReadOnlySharedMem(\n     const PdfMetafileSkia& metafile,\n     base::SharedMemoryHandle* shared_mem_handle) {\n   uint32_t buf_size = metafile.GetDataSize();\n   if (buf_size == 0)\n     return false;\n \n-  std::unique_ptr<base::SharedMemory> shared_buf(\n-      content::RenderThread::Get()->HostAllocateSharedMemoryBuffer(buf_size));\n-  if (!shared_buf)\n+  mojo::ScopedSharedBufferHandle buffer =\n+      mojo::SharedBufferHandle::Create(buf_size);\n+  if (!buffer.is_valid())\n     return false;\n \n-  if (!shared_buf->Map(buf_size))\n+  mojo::ScopedSharedBufferMapping mapping = buffer->Map(buf_size);\n+  if (!mapping)\n     return false;\n \n-  if (!metafile.GetData(shared_buf->memory(), buf_size))\n+  if (!metafile.GetData(mapping.get(), buf_size))\n     return false;\n \n-  *shared_mem_handle =\n-      base::SharedMemory::DuplicateHandle(shared_buf->handle());\n+  MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      buffer->Clone(mojo::SharedBufferHandle::AccessMode::READ_ONLY),\n+      shared_mem_handle, nullptr, nullptr);\n+  DCHECK_EQ(MOJO_RESULT_OK, result);\n   return true;\n }\n \n@@ -2092,9 +2097,9 @@ bool PrintRenderFrameHelper::PreviewPageRendered(int page_number,\n   }\n \n   PrintHostMsg_DidPreviewPage_Params preview_page_params;\n-  if (!CopyMetafileDataToSharedMem(*metafile,\n-                                   &preview_page_params.metafile_data_handle)) {\n-    LOG(ERROR) << \""CopyMetafileDataToSharedMem failed\"";\n+  if (!CopyMetafileDataToReadOnlySharedMem(\n+          *metafile, &preview_page_params.metafile_data_handle)) {\n+    LOG(ERROR) << \""CopyMetafileDataToReadOnlySharedMem failed\"";\n     print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n     return false;\n   }""}<_**next**_>{""sha"": ""b087b9efe6cab6ac35efd82263ff5fc420d86c73"", ""filename"": ""components/printing/renderer/print_render_frame_helper.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/renderer/print_render_frame_helper.h?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -307,8 +307,9 @@ class PrintRenderFrameHelper\n \n   // Helper methods -----------------------------------------------------------\n \n-  bool CopyMetafileDataToSharedMem(const PdfMetafileSkia& metafile,\n-                                   base::SharedMemoryHandle* shared_mem_handle);\n+  bool CopyMetafileDataToReadOnlySharedMem(\n+      const PdfMetafileSkia& metafile,\n+      base::SharedMemoryHandle* read_only_shared_mem_handle);\n \n   // Helper method to get page layout in points and fit to page if needed.\n   static void ComputePageLayoutInPointsForCss(""}<_**next**_>{""sha"": ""4d135484e7d3409381fdf9ffba33e3a7ec376d7f"", ""filename"": ""components/printing/renderer/print_render_frame_helper_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/renderer/print_render_frame_helper_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/renderer/print_render_frame_helper_linux.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -82,8 +82,8 @@ bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n   return true;\n #else\n   PrintHostMsg_DidPrintDocument_Params page_params;\n-  if (!CopyMetafileDataToSharedMem(metafile,\n-                                   &page_params.metafile_data_handle)) {\n+  if (!CopyMetafileDataToReadOnlySharedMem(metafile,\n+                                           &page_params.metafile_data_handle)) {\n     return false;\n   }\n ""}<_**next**_>{""sha"": ""7b2193c903660c2135b3fe0e6c1f3de087552b3e"", ""filename"": ""components/printing/service/pdf_compositor_service_unittest.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/pdf_compositor_service_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/pdf_compositor_service_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/service/pdf_compositor_service_unittest.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -144,16 +144,17 @@ class PdfCompositorServiceTest : public service_manager::test::ServiceTest {\n     base::SharedMemory shared_memory;\n     if (shared_memory.Create(options) && shared_memory.Map(len)) {\n       stream.copyTo(shared_memory.memory());\n-      return base::SharedMemory::DuplicateHandle(shared_memory.handle());\n+      return shared_memory.GetReadOnlyHandle();\n     }\n     return base::SharedMemoryHandle();\n   }\n \n   void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {\n     auto handle = CreateMSKPInSharedMemory();\n     ASSERT_TRUE(handle.IsValid());\n-    mojo::ScopedSharedBufferHandle buffer_handle =\n-        mojo::WrapSharedMemoryHandle(handle, handle.GetSize(), true);\n+    mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n+        handle, handle.GetSize(),\n+        mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n     ASSERT_TRUE(buffer_handle->is_valid());\n     EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);\n     ptr->CompositePdf(std::move(buffer_handle),""}<_**next**_>{""sha"": ""921b068e2e172840eb0103811ebbc946ffcfe3f4"", ""filename"": ""components/printing/service/public/cpp/pdf_compositor_client.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_compositor_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_compositor_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/service/public/cpp/pdf_compositor_client.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -47,8 +47,9 @@ void PdfCompositorClient::Composite(\n   if (!compositor_)\n     Connect(connector);\n \n-  mojo::ScopedSharedBufferHandle buffer_handle =\n-      mojo::WrapSharedMemoryHandle(handle, data_size, true);\n+  mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n+      handle, data_size,\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n \n   compositor_->CompositePdf(\n       std::move(buffer_handle),""}<_**next**_>{""sha"": ""9816848597753c1f571c79a975117d9c0a645505"", ""filename"": ""components/printing/service/public/cpp/pdf_compositor_client.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_compositor_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_compositor_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/service/public/cpp/pdf_compositor_client.h?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -18,6 +18,9 @@ class PdfCompositorClient {\n   ~PdfCompositorClient();\n \n   // Composite the final picture and convert into a PDF file.\n+  //\n+  // NOTE: |handle| must be a READ-ONLY base::SharedMemoryHandle, i.e. one\n+  // acquired by base::SharedMemory::GetReadOnlyHandle().\n   void Composite(service_manager::Connector* connector,\n                  base::SharedMemoryHandle handle,\n                  size_t data_size,""}<_**next**_>{""sha"": ""8e129e1a330977bb0dafe94e045ed33e44b0d1fe"", ""filename"": ""components/printing/service/public/cpp/pdf_service_mojo_utils.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_service_mojo_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/printing/service/public/cpp/pdf_service_mojo_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/service/public/cpp/pdf_service_mojo_utils.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -14,16 +14,18 @@ std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n     mojo::ScopedSharedBufferHandle handle) {\n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n-  bool read_only_flag = false;\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n-      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+      std::move(handle), &memory_handle, &memory_size, &protection);\n   if (result != MOJO_RESULT_OK)\n     return nullptr;\n   DCHECK_GT(memory_size, 0u);\n \n+  const bool read_only =\n+      protection == mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly;\n   std::unique_ptr<base::SharedMemory> shm =\n-      std::make_unique<base::SharedMemory>(memory_handle, read_only_flag);\n+      std::make_unique<base::SharedMemory>(memory_handle, read_only);\n   if (!shm->Map(memory_size)) {\n     DLOG(ERROR) << \""Map shared memory failed.\"";\n     return nullptr;""}<_**next**_>{""sha"": ""e03df4f64be90d31c6e741727e3818bf6cd1eb4a"", ""filename"": ""components/viz/client/client_shared_bitmap_manager.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/viz/client/client_shared_bitmap_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/components/viz/client/client_shared_bitmap_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/client/client_shared_bitmap_manager.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -170,7 +170,8 @@ uint32_t ClientSharedBitmapManager::NotifyAllocatedSharedBitmap(\n   }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n-      handle_to_send, memory->mapped_size(), true /* read_only */);\n+      handle_to_send, memory->mapped_size(),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n \n   {\n     base::AutoLock lock(lock_);""}<_**next**_>{""sha"": ""e09725aa16837b507bbebb22eb15ce641b5a8bf3"", ""filename"": ""content/browser/browser_child_process_host_impl.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/browser/browser_child_process_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/browser/browser_child_process_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/browser_child_process_host_impl.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -532,7 +532,8 @@ void BrowserChildProcessHostImpl::ShareMetricsAllocatorToProcess() {\n         GetHost(),\n         mojo::WrapSharedMemoryHandle(\n             metrics_allocator_->shared_memory()->handle().Duplicate(),\n-            metrics_allocator_->shared_memory()->mapped_size(), false));\n+            metrics_allocator_->shared_memory()->mapped_size(),\n+            mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite));\n   } else {\n     HistogramController::GetInstance()->SetHistogramMemory<ChildProcessHost>(\n         GetHost(), mojo::ScopedSharedBufferHandle());""}<_**next**_>{""sha"": ""eaf94a9dac3e1737030657de0b3fe812e5d3cc11"", ""filename"": ""content/browser/renderer_host/render_process_host_impl.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/browser/renderer_host/render_process_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/browser/renderer_host/render_process_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_process_host_impl.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -3626,7 +3626,8 @@ void RenderProcessHostImpl::CreateSharedRendererHistogramAllocator() {\n   HistogramController::GetInstance()->SetHistogramMemory<RenderProcessHost>(\n       this, mojo::WrapSharedMemoryHandle(\n                 metrics_allocator_->shared_memory()->handle().Duplicate(),\n-                metrics_allocator_->shared_memory()->mapped_size(), false));\n+                metrics_allocator_->shared_memory()->mapped_size(),\n+                mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite));\n }\n \n void RenderProcessHostImpl::ProcessDied(bool already_dead,""}<_**next**_>{""sha"": ""0b381720384c546f0999b4a807f82ed6882b9410"", ""filename"": ""content/renderer/media/mojo_audio_input_ipc.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/mojo_audio_input_ipc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/mojo_audio_input_ipc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/mojo_audio_input_ipc.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -85,11 +85,11 @@ void MojoAudioInputIPC::StreamCreated(\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n \n   base::SharedMemoryHandle memory_handle;\n-  bool read_only = true;\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n   result = mojo::UnwrapSharedMemoryHandle(std::move(shared_memory),\n-                                          &memory_handle, nullptr, &read_only);\n+                                          &memory_handle, nullptr, &protection);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n-  DCHECK(read_only);\n+  DCHECK_EQ(protection, mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n \n   delegate_->OnStreamCreated(memory_handle, socket_handle, initially_muted);\n }""}<_**next**_>{""sha"": ""1852ab9fe6792110b6239350eb02baca81a55c93"", ""filename"": ""content/renderer/media/mojo_audio_output_ipc.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/mojo_audio_output_ipc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/mojo_audio_output_ipc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/mojo_audio_output_ipc.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -205,12 +205,13 @@ void MojoAudioOutputIPC::StreamCreated(\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n \n   base::SharedMemoryHandle memory_handle;\n-  bool read_only = false;\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n   size_t memory_length = 0;\n   result = mojo::UnwrapSharedMemoryHandle(\n-      std::move(shared_memory), &memory_handle, &memory_length, &read_only);\n+      std::move(shared_memory), &memory_handle, &memory_length, &protection);\n   DCHECK_EQ(result, MOJO_RESULT_OK);\n-  DCHECK(!read_only);\n+  DCHECK_EQ(protection,\n+            mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n \n   delegate_->OnStreamCreated(memory_handle, socket_handle);\n }""}<_**next**_>{""sha"": ""ebdadce93e3277cc5046dc08ec935471b7a56e86"", ""filename"": ""content/renderer/media/video_capture_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/video_capture_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/video_capture_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/video_capture_impl.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -242,13 +242,17 @@ void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n-  bool read_only_flag = false;\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n-      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+      std::move(handle), &memory_handle, &memory_size, &protection);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n+  // TODO(https://crbug.com/803136): We should also be able to assert that the\n+  // unwrapped handle was shared for read-only mapping. That condition is not\n+  // currently guaranteed to be met.\n+\n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true /* read_only */));\n   if (!shm->Map(memory_size)) {""}<_**next**_>{""sha"": ""93ff20fdbcc76f92d6bc88a4de2a3f14ea02f54c"", ""filename"": ""content/renderer/media/video_capture_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 6, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/video_capture_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/content/renderer/media/video_capture_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/video_capture_impl_unittest.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -135,11 +135,20 @@ class VideoCaptureImplTest : public ::testing::Test {\n     video_capture_impl_->StopCapture(client_id);\n   }\n \n+  bool CreateAndMapSharedMemory(size_t size, base::SharedMemory* shm) {\n+    base::SharedMemoryCreateOptions options;\n+    options.size = size;\n+    options.share_read_only = true;\n+    if (!shm->Create(options))\n+      return false;\n+    return shm->Map(size);\n+  }\n+\n   void SimulateOnBufferCreated(int buffer_id, const base::SharedMemory& shm) {\n-    auto handle = base::SharedMemory::DuplicateHandle(shm.handle());\n     video_capture_impl_->OnBufferCreated(\n-        buffer_id, mojo::WrapSharedMemoryHandle(handle, shm.mapped_size(),\n-                                                true /* read_only */));\n+        buffer_id, mojo::WrapSharedMemoryHandle(\n+                       shm.GetReadOnlyHandle(), shm.mapped_size(),\n+                       mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly));\n   }\n \n   void SimulateBufferReceived(int buffer_id, const gfx::Size& size) {\n@@ -278,7 +287,7 @@ TEST_F(VideoCaptureImplTest, BufferReceived) {\n   base::SharedMemory shm;\n   const size_t frame_size = media::VideoFrame::AllocationSize(\n       media::PIXEL_FORMAT_I420, params_small_.requested_format.frame_size);\n-  ASSERT_TRUE(shm.CreateAndMapAnonymous(frame_size));\n+  ASSERT_TRUE(CreateAndMapSharedMemory(frame_size, &shm));\n \n   EXPECT_CALL(*this, OnStateUpdate(VIDEO_CAPTURE_STATE_STARTED));\n   EXPECT_CALL(*this, OnStateUpdate(VIDEO_CAPTURE_STATE_STOPPED));\n@@ -303,7 +312,7 @@ TEST_F(VideoCaptureImplTest, BufferReceivedAfterStop) {\n   base::SharedMemory shm;\n   const size_t frame_size = media::VideoFrame::AllocationSize(\n       media::PIXEL_FORMAT_I420, params_large_.requested_format.frame_size);\n-  ASSERT_TRUE(shm.CreateAndMapAnonymous(frame_size));\n+  ASSERT_TRUE(CreateAndMapSharedMemory(frame_size, &shm));\n \n   EXPECT_CALL(*this, OnStateUpdate(VIDEO_CAPTURE_STATE_STARTED));\n   EXPECT_CALL(*this, OnStateUpdate(VIDEO_CAPTURE_STATE_STOPPED));\n@@ -371,7 +380,7 @@ TEST_F(VideoCaptureImplTest, BufferReceivedBeforeOnStarted) {\n   base::SharedMemory shm;\n   const size_t frame_size = media::VideoFrame::AllocationSize(\n       media::PIXEL_FORMAT_I420, params_small_.requested_format.frame_size);\n-  ASSERT_TRUE(shm.CreateAndMapAnonymous(frame_size));\n+  ASSERT_TRUE(CreateAndMapSharedMemory(frame_size, &shm));\n \n   InSequence s;\n   EXPECT_CALL(mock_video_capture_host_, DoStart(_, kSessionId, params_small_))""}<_**next**_>{""sha"": ""e2a273d36153e19f9153641b243e0f1e65cca157"", ""filename"": ""device/gamepad/gamepad_provider.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/device/gamepad/gamepad_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/device/gamepad/gamepad_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/gamepad/gamepad_provider.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -90,10 +90,10 @@ base::SharedMemoryHandle GamepadProvider::DuplicateSharedMemoryHandle() {\n mojo::ScopedSharedBufferHandle GamepadProvider::GetSharedBufferHandle() {\n   // TODO(heke): Use mojo::SharedBuffer rather than base::SharedMemory in\n   // GamepadSharedBuffer. See crbug.com/670655 for details\n-  base::SharedMemoryHandle handle = base::SharedMemory::DuplicateHandle(\n-      gamepad_shared_buffer_->shared_memory()->handle());\n-  return mojo::WrapSharedMemoryHandle(handle, sizeof(GamepadHardwareBuffer),\n-                                      true /* read_only */);\n+  return mojo::WrapSharedMemoryHandle(\n+      gamepad_shared_buffer_->shared_memory()->GetReadOnlyHandle(),\n+      sizeof(GamepadHardwareBuffer),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n }\n \n void GamepadProvider::GetCurrentGamepadData(Gamepads* data) {""}<_**next**_>{""sha"": ""8b2929b1ab38d6d0c5bcf73a8b26516aaf489fae"", ""filename"": ""gpu/ipc/client/command_buffer_proxy_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/gpu/ipc/client/command_buffer_proxy_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/gpu/ipc/client/command_buffer_proxy_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/ipc/client/command_buffer_proxy_impl.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -751,16 +751,18 @@ CommandBufferProxyImpl::AllocateAndMapSharedMemory(size_t size) {\n \n   base::SharedMemoryHandle platform_handle;\n   size_t shared_memory_size;\n-  bool readonly;\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n   MojoResult result = mojo::UnwrapSharedMemoryHandle(\n-      std::move(handle), &platform_handle, &shared_memory_size, &readonly);\n+      std::move(handle), &platform_handle, &shared_memory_size, &protection);\n   if (result != MOJO_RESULT_OK) {\n     DLOG(ERROR) << \""AllocateAndMapSharedMemory: Unwrap failed\"";\n     return nullptr;\n   }\n   DCHECK_EQ(shared_memory_size, size);\n \n-  auto shm = std::make_unique<base::SharedMemory>(platform_handle, readonly);\n+  bool read_only =\n+      protection == mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly;\n+  auto shm = std::make_unique<base::SharedMemory>(platform_handle, read_only);\n   if (!shm->Map(size)) {\n     DLOG(ERROR) << \""AllocateAndMapSharedMemory: Map failed\"";\n     return nullptr;""}<_**next**_>{""sha"": ""72a909337e690e499c4495d1d652ae9f83149844"", ""filename"": ""media/capture/video/shared_memory_handle_provider.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 4, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/capture/video/shared_memory_handle_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/capture/video/shared_memory_handle_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/capture/video/shared_memory_handle_provider.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -52,11 +52,13 @@ bool SharedMemoryHandleProvider::InitFromMojoHandle(\n   DCHECK(!shared_memory_);\n \n   base::SharedMemoryHandle memory_handle;\n-  const MojoResult result =\n-      mojo::UnwrapSharedMemoryHandle(std::move(buffer_handle), &memory_handle,\n-                                     &mapped_size_, &read_only_flag_);\n+  mojo::UnwrappedSharedMemoryHandleProtection protection;\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(buffer_handle), &memory_handle, &mapped_size_, &protection);\n   if (result != MOJO_RESULT_OK)\n     return false;\n+  read_only_flag_ =\n+      protection == mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly;\n   shared_memory_.emplace(memory_handle, read_only_flag_);\n   return true;\n }\n@@ -68,9 +70,17 @@ SharedMemoryHandleProvider::GetHandleForInterProcessTransit(bool read_only) {\n     NOTREACHED();\n     return mojo::ScopedSharedBufferHandle();\n   }\n+  // TODO(https://crbug.com/803136): This does not actually obey |read_only| in\n+  // any capacity because it uses DuplicateHandle. In order to properly obey\n+  // |read_only| (when true), we need to use |SharedMemory::GetReadOnlyHandle()|\n+  // but that is not possible. With the base::SharedMemory API and this\n+  // SharedMemoryHandleProvider API as they are today, it isn't possible to know\n+  // whether |shared_memory_| even supports read-only duplication. Note that\n+  // changing |kReadWrite| to |kReadOnly| does NOT affect the ability to map\n+  // the handle read-write.\n   return mojo::WrapSharedMemoryHandle(\n       base::SharedMemory::DuplicateHandle(shared_memory_->handle()),\n-      mapped_size_, read_only);\n+      mapped_size_, mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n }\n \n base::SharedMemoryHandle""}<_**next**_>{""sha"": ""ac24e22fe1e8d560e59b8de897ccdcbd1e35e1ec"", ""filename"": ""media/capture/video/shared_memory_handle_provider_unittest.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 11, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/capture/video/shared_memory_handle_provider_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/capture/video/shared_memory_handle_provider_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/capture/video/shared_memory_handle_provider_unittest.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -28,18 +28,18 @@ class SharedMemoryHandleProviderTest : public ::testing::Test {\n   SharedMemoryHandleProviderTest() = default;\n   ~SharedMemoryHandleProviderTest() override = default;\n \n-  void UnwrapAndVerifyMojoHandle(mojo::ScopedSharedBufferHandle buffer_handle,\n-                                 size_t expected_size,\n-                                 bool expected_read_only_flag) {\n+  void UnwrapAndVerifyMojoHandle(\n+      mojo::ScopedSharedBufferHandle buffer_handle,\n+      size_t expected_size,\n+      mojo::UnwrappedSharedMemoryHandleProtection expected_protection) {\n     base::SharedMemoryHandle memory_handle;\n     size_t memory_size = 0;\n-    bool read_only_flag = false;\n-    const MojoResult result =\n-        mojo::UnwrapSharedMemoryHandle(std::move(buffer_handle), &memory_handle,\n-                                       &memory_size, &read_only_flag);\n+    mojo::UnwrappedSharedMemoryHandleProtection protection;\n+    const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+        std::move(buffer_handle), &memory_handle, &memory_size, &protection);\n     EXPECT_EQ(MOJO_RESULT_OK, result);\n     EXPECT_EQ(expected_size, memory_size);\n-    EXPECT_EQ(expected_read_only_flag, read_only_flag);\n+    EXPECT_EQ(expected_protection, protection);\n   }\n \n  protected:\n@@ -55,7 +55,13 @@ TEST_F(SharedMemoryHandleProviderTest,\n \n   auto mojo_handle =\n       handle_provider_.GetHandleForInterProcessTransit(true /* read_only */);\n-  UnwrapAndVerifyMojoHandle(std::move(mojo_handle), kMemorySize, true);\n+\n+  // TODO(https://crbug.com/803136): See comment within\n+  // GetHandleForInterProcessTransit() for an explanation of why this\n+  // intentionally read-write even though it ought to be read-only.\n+  UnwrapAndVerifyMojoHandle(\n+      std::move(mojo_handle), kMemorySize,\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n }\n \n TEST_F(SharedMemoryHandleProviderTest,\n@@ -64,7 +70,9 @@ TEST_F(SharedMemoryHandleProviderTest,\n \n   auto mojo_handle =\n       handle_provider_.GetHandleForInterProcessTransit(false /* read_only */);\n-  UnwrapAndVerifyMojoHandle(std::move(mojo_handle), kMemorySize, false);\n+  UnwrapAndVerifyMojoHandle(\n+      std::move(mojo_handle), kMemorySize,\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n }\n \n-};  // namespace media\n+}  // namespace media""}<_**next**_>{""sha"": ""8783eb414075ced33924e23d347ffe9b30214444"", ""filename"": ""media/mojo/clients/mojo_jpeg_decode_accelerator.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/clients/mojo_jpeg_decode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/clients/mojo_jpeg_decode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/clients/mojo_jpeg_decode_accelerator.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -65,8 +65,9 @@ void MojoJpegDecodeAccelerator::Decode(\n   size_t output_buffer_size = VideoFrame::AllocationSize(\n       video_frame->format(), video_frame->coded_size());\n   mojo::ScopedSharedBufferHandle output_frame_handle =\n-      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,\n-                                   false /* read_only */);\n+      mojo::WrapSharedMemoryHandle(\n+          output_handle, output_buffer_size,\n+          mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n \n   // base::Unretained is safe because |this| owns |jpeg_decoder_|.\n   jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),""}<_**next**_>{""sha"": ""da480d132a7bf6e8a58682008b9f1642066130fc"", ""filename"": ""media/mojo/clients/mojo_video_encode_accelerator.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 6, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/clients/mojo_video_encode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/clients/mojo_video_encode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/clients/mojo_video_encode_accelerator.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -142,9 +142,13 @@ void MojoVideoEncodeAccelerator::Encode(const scoped_refptr<VideoFrame>& frame,\n \n   // WrapSharedMemoryHandle() takes ownership of the handle passed to it, but we\n   // don't have ownership of frame->shared_memory_handle(), so Duplicate() it.\n-  mojo::ScopedSharedBufferHandle handle =\n-      mojo::WrapSharedMemoryHandle(frame->shared_memory_handle().Duplicate(),\n-                                   allocation_size, true /* read_only */);\n+  //\n+  // TODO(https://crbug.com/793446): This should be changed to wrap the frame\n+  // buffer handle as read-only, but VideoFrame does not seem to guarantee that\n+  // its shared_memory_handle() is in fact read-only.\n+  mojo::ScopedSharedBufferHandle handle = mojo::WrapSharedMemoryHandle(\n+      frame->shared_memory_handle().Duplicate(), allocation_size,\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n \n   const size_t y_offset = frame->shared_memory_offset();\n   const size_t u_offset = y_offset + frame->data(VideoFrame::kUPlane) -\n@@ -174,11 +178,13 @@ void MojoVideoEncodeAccelerator::UseOutputBitstreamBuffer(\n            << \"" buffer.size()= \"" << buffer.size() << \""B\"";\n   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n \n-  // WrapSharedMemoryHandle() takes ownership of the handle passed to it, but we\n-  // don't have ownership of the |buffer|s underlying handle, so Duplicate() it.\n   DCHECK(buffer.handle().IsValid());\n+\n+  // TODO(https://crbug.com/793446): Only wrap read-only handles here and change\n+  // the protection status to kReadOnly.\n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n-      buffer.handle().Duplicate(), buffer.size(), true /* read_only */);\n+      buffer.handle().Duplicate(), buffer.size(),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n \n   vea_->UseOutputBitstreamBuffer(buffer.id(), std::move(buffer_handle));\n }""}<_**next**_>{""sha"": ""afaec3005bbaed9eab90274d762ecc3c70d08b7e"", ""filename"": ""media/mojo/interfaces/jpeg_decode_accelerator_typemap_traits.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/interfaces/jpeg_decode_accelerator_typemap_traits.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/interfaces/jpeg_decode_accelerator_typemap_traits.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/interfaces/jpeg_decode_accelerator_typemap_traits.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -72,8 +72,13 @@ StructTraits<media::mojom::BitstreamBufferDataView, media::BitstreamBuffer>::\n     DLOG(ERROR) << \""Failed to duplicate handle of BitstreamBuffer\"";\n     return mojo::ScopedSharedBufferHandle();\n   }\n-  return mojo::WrapSharedMemoryHandle(input_handle, input.size(),\n-                                      true /* read_only */);\n+\n+  // TODO(https://crbug.com/793446): Update this to |kReadOnly| protection once\n+  // BitstreamBuffer can guarantee that its handle() field always corresponds to\n+  // a read-only SharedMemoryHandle.\n+  return mojo::WrapSharedMemoryHandle(\n+      input_handle, input.size(),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n }\n \n // static""}<_**next**_>{""sha"": ""8390938ce26a3bae452f2ff8e80d17e147195f6b"", ""filename"": ""media/mojo/interfaces/video_frame_struct_traits.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/interfaces/video_frame_struct_traits.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/interfaces/video_frame_struct_traits.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/interfaces/video_frame_struct_traits.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -26,8 +26,11 @@ media::mojom::VideoFrameDataPtr MakeVideoFrameData(\n     media::MojoSharedBufferVideoFrame* mojo_frame =\n         static_cast<media::MojoSharedBufferVideoFrame*>(input.get());\n \n+    // TODO(https://crbug.com/803136): This should duplicate as READ_ONLY, but\n+    // can't because there is no guarantee that the input handle is sharable as\n+    // read-only.\n     mojo::ScopedSharedBufferHandle dup = mojo_frame->Handle().Clone(\n-        mojo::SharedBufferHandle::AccessMode::READ_ONLY);\n+        mojo::SharedBufferHandle::AccessMode::READ_WRITE);\n     DCHECK(dup.is_valid());\n \n     return media::mojom::VideoFrameData::NewSharedBufferData(""}<_**next**_>{""sha"": ""9dba8609c156d19b864392db6dbeaf6ed700b2c4"", ""filename"": ""media/mojo/services/mojo_audio_input_stream.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_input_stream.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_input_stream.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/services/mojo_audio_input_stream.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -84,7 +84,7 @@ void MojoAudioInputStream::OnStreamCreated(\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n       foreign_memory_handle, shared_memory->requested_size(),\n-      /*read_only*/ true);\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n ""}<_**next**_>{""sha"": ""5f5cc5034c700c0d51256215f312572e2301e26b"", ""filename"": ""media/mojo/services/mojo_audio_input_stream_unittest.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 4, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_input_stream_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_input_stream_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/services/mojo_audio_input_stream_unittest.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -109,13 +109,15 @@ class MockClient : public mojom::AudioInputStreamClient {\n \n     size_t memory_length;\n     base::SharedMemoryHandle shmem_handle;\n-    bool read_only;\n+    mojo::UnwrappedSharedMemoryHandleProtection protection;\n     EXPECT_EQ(\n         mojo::UnwrapSharedMemoryHandle(std::move(shared_buffer), &shmem_handle,\n-                                       &memory_length, &read_only),\n+                                       &memory_length, &protection),\n         MOJO_RESULT_OK);\n-    EXPECT_TRUE(read_only);\n-    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle, read_only);\n+    EXPECT_EQ(protection,\n+              mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n+    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle,\n+                                                   true /* read_only */);\n \n     GotNotification(initially_muted);\n   }""}<_**next**_>{""sha"": ""dc0997295c4b8561dee3e6f673a375f2bf8721c0"", ""filename"": ""media/mojo/services/mojo_audio_output_stream.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_output_stream.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_output_stream.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/services/mojo_audio_output_stream.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -87,7 +87,8 @@ void MojoAudioOutputStream::OnStreamCreated(\n   }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n-      foreign_memory_handle, shared_memory->requested_size(), false);\n+      foreign_memory_handle, shared_memory->requested_size(),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n ""}<_**next**_>{""sha"": ""f91064e27715ee4c7012ce7be1324409ef0f508a"", ""filename"": ""media/mojo/services/mojo_audio_output_stream_unittest.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 4, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_output_stream_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_audio_output_stream_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/services/mojo_audio_output_stream_unittest.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -107,13 +107,15 @@ class MockClient : public mojom::AudioOutputStreamClient {\n \n     size_t memory_length;\n     base::SharedMemoryHandle shmem_handle;\n-    bool read_only;\n+    mojo::UnwrappedSharedMemoryHandleProtection protection;\n     EXPECT_EQ(\n         mojo::UnwrapSharedMemoryHandle(std::move(shared_buffer), &shmem_handle,\n-                                       &memory_length, &read_only),\n+                                       &memory_length, &protection),\n         MOJO_RESULT_OK);\n-    EXPECT_FALSE(read_only);\n-    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle, read_only);\n+    EXPECT_EQ(protection,\n+              mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n+    buffer_ = std::make_unique<base::SharedMemory>(shmem_handle,\n+                                                   false /* read_only */);\n \n     GotNotification();\n   }""}<_**next**_>{""sha"": ""83b959aabacf70c0096c16bab5194e124adb6dd4"", ""filename"": ""media/mojo/services/mojo_video_encode_accelerator_service.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_video_encode_accelerator_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/media/mojo/services/mojo_video_encode_accelerator_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/mojo/services/mojo_video_encode_accelerator_service.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -136,9 +136,8 @@ void MojoVideoEncodeAcceleratorService::UseOutputBitstreamBuffer(\n \n   base::SharedMemoryHandle handle;\n   size_t memory_size = 0;\n-  bool read_only = false;\n   auto result = mojo::UnwrapSharedMemoryHandle(std::move(buffer), &handle,\n-                                               &memory_size, &read_only);\n+                                               &memory_size, nullptr);\n   if (result != MOJO_RESULT_OK || memory_size == 0u) {\n     DLOG(ERROR) << __func__ << \"" mojo::UnwrapSharedMemoryHandle() failed\"";\n     NotifyError(::media::VideoEncodeAccelerator::kPlatformFailureError);""}<_**next**_>{""sha"": ""d99ab85eb6f2352e788b441b316beff7ac2b9367"", ""filename"": ""mojo/edk/system/core.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/edk/system/core.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/edk/system/core.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/mojo/edk/system/core.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -1052,7 +1052,8 @@ MojoResult Core::WrapPlatformSharedBufferHandle(\n \n   base::UnguessableToken token =\n       base::UnguessableToken::Deserialize(guid->high, guid->low);\n-  bool read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n+  const bool read_only =\n+      flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;\n   scoped_refptr<PlatformSharedBuffer> platform_buffer =\n       PlatformSharedBuffer::CreateFromPlatformHandle(size, read_only, token,\n                                                      std::move(handle));\n@@ -1111,7 +1112,7 @@ MojoResult Core::UnwrapPlatformSharedBufferHandle(\n   DCHECK(flags);\n   *flags = MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n   if (platform_shared_buffer->IsReadOnly())\n-    *flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n+    *flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;\n \n   ScopedPlatformHandle handle = platform_shared_buffer->PassPlatformHandle();\n   return ScopedPlatformHandleToMojoPlatformHandle(std::move(handle),""}<_**next**_>{""sha"": ""d160228cc870c278f943ba983e1dca6403fb95bb"", ""filename"": ""mojo/public/c/system/platform_handle.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 15, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/c/system/platform_handle.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/c/system/platform_handle.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/mojo/public/c/system/platform_handle.h?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -79,9 +79,14 @@ struct MOJO_ALIGNAS(8) MojoSharedBufferGuid {\n // |MojoPlatformSharedBufferHandleFlags|: Flags relevant to wrapped platform\n //     shared buffers.\n //\n-//   |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_NONE| - No flags.\n-//   |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_READ_ONLY| - Indicates that the wrapped\n-//       buffer handle may only be mapped for reading.\n+//   |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE| - No flags.\n+//   |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY| - Indicates\n+//       that the handle being wrapped is mappable only to read-only memory.\n+//\n+//       IMPORTANT: THIS DOES NOT CONTROL MEMORY PROTECTION ON THE WRAPPED\n+//       HANDLE. It merely conveys a |MojoWrapPlatformSharedBufferHandle()|\n+//       caller's knowledge about whether or not the handle being wrapped is\n+//       already read-only.\n \n typedef uint32_t MojoPlatformSharedBufferHandleFlags;\n \n@@ -90,12 +95,12 @@ const MojoPlatformSharedBufferHandleFlags\n     MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE = 0;\n \n const MojoPlatformSharedBufferHandleFlags\n-    MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY = 1 << 0;\n+    MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY = 1 << 0;\n #else\n #define MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE \\\n   ((MojoPlatformSharedBufferHandleFlags)0)\n \n-#define MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY \\\n+#define MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY \\\n   ((MojoPlatformSharedBufferHandleFlags)1 << 0)\n #endif\n \n@@ -145,14 +150,7 @@ MojoUnwrapPlatformHandle(MojoHandle mojo_handle,\n //     shared buffer object.\n // |num_bytes|: The size of the shared buffer in bytes.\n // |flags|: Flags which influence the treatment of the shared buffer object. See\n-//     below.\n-//\n-// Flags:\n-//    |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE| indicates default behavior.\n-//        No flags set.\n-//    |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY| indicates that the\n-//        buffer handled to be wrapped may only be mapped as read-only. This\n-//        flag does NOT change the access control of the buffer in any way.\n+//     the |MojoPlatformSharedBufferHandleFlags| definition for details.\n //\n // Returns:\n //     |MOJO_RESULT_OK| if the handle was successfully wrapped. In this case\n@@ -186,8 +184,9 @@ MOJO_SYSTEM_EXPORT MojoResult MojoWrapPlatformSharedBufferHandle(\n //        shared buffer handle.\n //\n // Flags which may be set in |*flags| upon success:\n-//    |MOJO_PLATFORM_SHARED_BUFFER_FLAG_READ_ONLY| is set iff the unwrapped\n-//        shared buffer handle may only be mapped as read-only.\n+//    |MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY| is set iff\n+//        the unwrapped shared buffer handle can only be mapped to a read-only\n+//        memory segment.\n MOJO_SYSTEM_EXPORT MojoResult MojoUnwrapPlatformSharedBufferHandle(\n     MojoHandle mojo_handle,\n     struct MojoPlatformHandle* platform_handle,""}<_**next**_>{""sha"": ""c8e9ef30f4680390f2f7f414de4e9c641112d983"", ""filename"": ""mojo/public/cpp/system/platform_handle.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 9, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/platform_handle.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/platform_handle.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/mojo/public/cpp/system/platform_handle.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -65,7 +65,7 @@ MojoResult UnwrapPlatformFile(ScopedHandle handle, base::PlatformFile* file) {\n ScopedSharedBufferHandle WrapSharedMemoryHandle(\n     const base::SharedMemoryHandle& memory_handle,\n     size_t size,\n-    bool read_only) {\n+    UnwrappedSharedMemoryHandleProtection protection) {\n   if (!memory_handle.IsValid())\n     return ScopedSharedBufferHandle();\n   MojoPlatformHandle platform_handle;\n@@ -81,8 +81,8 @@ ScopedSharedBufferHandle WrapSharedMemoryHandle(\n \n   MojoPlatformSharedBufferHandleFlags flags =\n       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n-  if (read_only)\n-    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n+  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)\n+    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;\n \n   MojoSharedBufferGuid guid;\n   guid.high = memory_handle.GetGUID().GetHighForSerialization();\n@@ -95,10 +95,11 @@ ScopedSharedBufferHandle WrapSharedMemoryHandle(\n   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));\n }\n \n-MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\n-                                    base::SharedMemoryHandle* memory_handle,\n-                                    size_t* size,\n-                                    bool* read_only) {\n+MojoResult UnwrapSharedMemoryHandle(\n+    ScopedSharedBufferHandle handle,\n+    base::SharedMemoryHandle* memory_handle,\n+    size_t* size,\n+    UnwrappedSharedMemoryHandleProtection* protection) {\n   if (!handle.is_valid())\n     return MOJO_RESULT_INVALID_ARGUMENT;\n   MojoPlatformHandle platform_handle;\n@@ -116,8 +117,12 @@ MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\n   if (size)\n     *size = num_bytes;\n \n-  if (read_only)\n-    *read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n+  if (protection) {\n+    *protection =\n+        flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY\n+            ? UnwrappedSharedMemoryHandleProtection::kReadOnly\n+            : UnwrappedSharedMemoryHandleProtection::kReadWrite;\n+  }\n \n   base::UnguessableToken guid =\n       base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);""}<_**next**_>{""sha"": ""1522bf3ea65327340cc8d091abdd9bce768e2a47"", ""filename"": ""mojo/public/cpp/system/platform_handle.h"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 6, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/platform_handle.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/platform_handle.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/mojo/public/cpp/system/platform_handle.h?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -53,6 +53,20 @@ const MojoPlatformHandleType kPlatformSharedBufferHandleType =\n     MOJO_PLATFORM_HANDLE_TYPE_WINDOWS_HANDLE;\n #endif  // defined(OS_POSIX)\n \n+// Used to specify the protection status of a base::SharedMemoryHandle memory\n+// handle wrapped or unwrapped by mojo::WrapSharedMemoryHandle or\n+// mojo::UnwrapSharedMemoryHandle below. See those functions for additional\n+// details.\n+enum class UnwrappedSharedMemoryHandleProtection {\n+  // Indicates that the base::SharedMemoryHandle supports being mapped to\n+  // writable memory regions.\n+  kReadWrite,\n+\n+  // Indicates that the base::SharedMemoryHandle supports being mapped only to\n+  // read-only memory regions.\n+  kReadOnly,\n+};\n+\n // Wraps a PlatformFile as a Mojo handle. Takes ownership of the file object.\n MOJO_CPP_SYSTEM_EXPORT\n ScopedHandle WrapPlatformFile(base::PlatformFile platform_file);\n@@ -62,22 +76,49 @@ MOJO_CPP_SYSTEM_EXPORT\n MojoResult UnwrapPlatformFile(ScopedHandle handle, base::PlatformFile* file);\n \n // Wraps a base::SharedMemoryHandle as a Mojo handle. Takes ownership of the\n-// SharedMemoryHandle. Note that |read_only| is only an indicator of whether\n-// |memory_handle| only supports read-only mapping. It does NOT have any\n-// influence on the access control of the shared buffer object.\n+// SharedMemoryHandle. |size| indicates the size of the underlying\n+// base::SharedMemory object, and |current_protection| indicates whether or\n+// not |memory_handle| supports being mapped to writable memory segments.\n+//\n+// ***** IMPORTANT. PLEASE READ BELOW CAREFULLY. *****\n+//\n+// THIS CALL DOES NOT IN ANY WAY AFFECT THE MEMORY PROTECTION STATUS OF THE\n+// WRAPPED HANDLE.\n+//\n+// The |current_protection| argument is only an indication of the current memory\n+// protection status of |memory_handle| as known by the caller.\n+//\n+// DO NOT wrap a writable |memory_handle| with |current_protection| set to\n+// |UnwrappedSharedMemoryHandleProtection::kReadOnly|, as this will mislead\n+// corresponding callers to |UnwrapSharedMemoryHandle()|: the subsequently\n+// unwrapped SharedMemoryHandle will appear to be read-only on the surface, but\n+// will still be mappable to a writable memory segment.\n+//\n+// Use base::SharedMemory::GetReadOnlyHandle() to acquire a read-only handle to\n+// a shared memory object if you intend to wrap the handle with\n+// |UnwrappedSharedMemoryHandleProtection::kReadOnly|.\n MOJO_CPP_SYSTEM_EXPORT\n ScopedSharedBufferHandle WrapSharedMemoryHandle(\n     const base::SharedMemoryHandle& memory_handle,\n     size_t size,\n-    bool read_only);\n+    UnwrappedSharedMemoryHandleProtection current_protection);\n \n // Unwraps a base::SharedMemoryHandle from a Mojo handle. The caller assumes\n-// responsibility for the lifetime of the SharedMemoryHandle.\n+// responsibility for the lifetime of the SharedMemoryHandle. On success,\n+// |*memory_handle| is set to a valid handle, |*size| is is set to the size of\n+// that handle's underlying base::SharedMemory object, and\n+// |*protection| indicates whether or not the handle may only be mapped\n+// to a read-only memory segment.\n+//\n+// Note that if |*protection| is\n+// |UnwrappedSharedMemoryHandleProtection::kReadOnly| upon return, writable\n+// mapping of |*memory_handle| should not be attempted, and (unless there\n+// is buggy code misusing WrapSharedMemoryHandle above) will always fail.\n MOJO_CPP_SYSTEM_EXPORT MojoResult\n UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\n                          base::SharedMemoryHandle* memory_handle,\n                          size_t* size,\n-                         bool* read_only);\n+                         UnwrappedSharedMemoryHandleProtection* protection);\n \n #if defined(OS_MACOSX) && !defined(OS_IOS)\n // Wraps a mach_port_t as a Mojo handle. This takes a reference to the""}<_**next**_>{""sha"": ""7acc44b1e4ec972d31da645a3d8cb5cb515bd0c3"", ""filename"": ""mojo/public/cpp/system/tests/BUILD.gn"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/tests/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/mojo/public/cpp/system/tests/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/mojo/public/cpp/system/tests/BUILD.gn?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -19,6 +19,7 @@ source_set(\""tests\"") {\n   deps = [\n     \""//base\"",\n     \""//base/test:test_support\"",\n+    \""//mojo/edk/test:test_support\"",\n     \""//mojo/public/c/system/tests\"",\n     \""//mojo/public/cpp/system\"",\n     \""//mojo/public/cpp/test_support:test_utils\"",""}<_**next**_>{""sha"": ""3489eda27b831c2b7afd95d6ea2f778b16f7f8e4"", ""filename"": ""ui/gfx/mojo/buffer_types_struct_traits.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/ui/gfx/mojo/buffer_types_struct_traits.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/673ce95d481ea9368c4d4d43ac756ba1d6d9e608/ui/gfx/mojo/buffer_types_struct_traits.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/gfx/mojo/buffer_types_struct_traits.cc?ref=673ce95d481ea9368c4d4d43ac756ba1d6d9e608"", ""patch"": ""@@ -58,8 +58,9 @@ StructTraits<gfx::mojom::GpuMemoryBufferHandleDataView,\n       handle.type != gfx::DXGI_SHARED_HANDLE &&\n       handle.type != gfx::ANDROID_HARDWARE_BUFFER)\n     return mojo::ScopedSharedBufferHandle();\n-  return mojo::WrapSharedMemoryHandle(handle.handle, handle.handle.GetSize(),\n-                                      false);\n+  return mojo::WrapSharedMemoryHandle(\n+      handle.handle, handle.handle.GetSize(),\n+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);\n }\n \n const gfx::NativePixmapHandle&""}"," ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
    UnwrappedSharedMemoryHandleProtection protection) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
  platform_handle.struct_size = sizeof(MojoPlatformHandle);
  platform_handle.type = kPlatformSharedBufferHandleType;
#if defined(OS_MACOSX) && !defined(OS_IOS)
  platform_handle.value =
      static_cast<uint64_t>(memory_handle.GetMemoryObject());
#else
  platform_handle.value =
      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());
#endif
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
  guid.low = memory_handle.GetGUID().GetLowForSerialization();
  MojoHandle mojo_handle;
  MojoResult result = MojoWrapPlatformSharedBufferHandle(
      &platform_handle, size, &guid, flags, &mojo_handle);
  CHECK_EQ(result, MOJO_RESULT_OK);

   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
"," ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
    bool read_only) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
  platform_handle.struct_size = sizeof(MojoPlatformHandle);
  platform_handle.type = kPlatformSharedBufferHandleType;
#if defined(OS_MACOSX) && !defined(OS_IOS)
  platform_handle.value =
      static_cast<uint64_t>(memory_handle.GetMemoryObject());
#else
  platform_handle.value =
      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());
#endif
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
  if (read_only)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
  guid.low = memory_handle.GetGUID().GetLowForSerialization();
  MojoHandle mojo_handle;
  MojoResult result = MojoWrapPlatformSharedBufferHandle(
      &platform_handle, size, &guid, flags, &mojo_handle);
  CHECK_EQ(result, MOJO_RESULT_OK);

   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
",C,"    UnwrappedSharedMemoryHandleProtection protection) {
  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;
","    bool read_only) {
  if (read_only)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
",,"@@ -65,7 +65,7 @@ MojoResult UnwrapPlatformFile(ScopedHandle handle, base::PlatformFile* file) {
 ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
-    bool read_only) {
+    UnwrappedSharedMemoryHandleProtection protection) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
@@ -81,8 +81,8 @@ ScopedSharedBufferHandle WrapSharedMemoryHandle(
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
-  if (read_only)
-    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
+  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)
+    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
@@ -95,10 +95,11 @@ ScopedSharedBufferHandle WrapSharedMemoryHandle(
   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
 
-MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,
-                                    base::SharedMemoryHandle* memory_handle,
-                                    size_t* size,
-                                    bool* read_only) {
+MojoResult UnwrapSharedMemoryHandle(
+    ScopedSharedBufferHandle handle,
+    base::SharedMemoryHandle* memory_handle,
+    size_t* size,
+    UnwrappedSharedMemoryHandleProtection* protection) {
   if (!handle.is_valid())
     return MOJO_RESULT_INVALID_ARGUMENT;
   MojoPlatformHandle platform_handle;
@@ -116,8 +117,12 @@ MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,
   if (size)
     *size = num_bytes;
 
-  if (read_only)
-    *read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
+  if (protection) {
+    *protection =
+        flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY
+            ? UnwrappedSharedMemoryHandleProtection::kReadOnly
+            : UnwrappedSharedMemoryHandleProtection::kReadWrite;
+  }
 
   base::UnguessableToken guid =
       base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);",Chrome,673ce95d481ea9368c4d4d43ac756ba1d6d9e608,aac47e9fef7b5814bcc65e147fd1da9b132211cd,1," ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
//flaw_line_below:
    bool read_only) {
//fix_flaw_line_below:
//    UnwrappedSharedMemoryHandleProtection protection) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
  platform_handle.struct_size = sizeof(MojoPlatformHandle);
  platform_handle.type = kPlatformSharedBufferHandleType;
#if defined(OS_MACOSX) && !defined(OS_IOS)
  platform_handle.value =
      static_cast<uint64_t>(memory_handle.GetMemoryObject());
#else
  platform_handle.value =
      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());
#endif
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
//flaw_line_below:
  if (read_only)
//flaw_line_below:
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
//fix_flaw_line_below:
//  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)
//fix_flaw_line_below:
//    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
  guid.low = memory_handle.GetGUID().GetLowForSerialization();
  MojoHandle mojo_handle;
  MojoResult result = MojoWrapPlatformSharedBufferHandle(
      &platform_handle, size, &guid, flags, &mojo_handle);
  CHECK_EQ(result, MOJO_RESULT_OK);

   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
",186862," ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
    bool read_only) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
  platform_handle.struct_size = sizeof(MojoPlatformHandle);
  platform_handle.type = kPlatformSharedBufferHandleType;
#if defined(OS_MACOSX) && !defined(OS_IOS)
  platform_handle.value =
      static_cast<uint64_t>(memory_handle.GetMemoryObject());
#else
  platform_handle.value =
      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());
#endif
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
  if (read_only)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
  guid.low = memory_handle.GetGUID().GetLowForSerialization();
  MojoHandle mojo_handle;
  MojoResult result = MojoWrapPlatformSharedBufferHandle(
      &platform_handle, size, &guid, flags, &mojo_handle);
  CHECK_EQ(result, MOJO_RESULT_OK);

   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
"," ScopedSharedBufferHandle WrapSharedMemoryHandle(
     const base::SharedMemoryHandle& memory_handle,
     size_t size,
    UnwrappedSharedMemoryHandleProtection protection) {
   if (!memory_handle.IsValid())
     return ScopedSharedBufferHandle();
   MojoPlatformHandle platform_handle;
  platform_handle.struct_size = sizeof(MojoPlatformHandle);
  platform_handle.type = kPlatformSharedBufferHandleType;
#if defined(OS_MACOSX) && !defined(OS_IOS)
  platform_handle.value =
      static_cast<uint64_t>(memory_handle.GetMemoryObject());
#else
  platform_handle.value =
      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());
#endif
 
   MojoPlatformSharedBufferHandleFlags flags =
       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;
  if (protection == UnwrappedSharedMemoryHandleProtection::kReadOnly)
    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY;
 
   MojoSharedBufferGuid guid;
   guid.high = memory_handle.GetGUID().GetHighForSerialization();
  guid.low = memory_handle.GetGUID().GetLowForSerialization();
  MojoHandle mojo_handle;
  MojoResult result = MojoWrapPlatformSharedBufferHandle(
      &platform_handle, size, &guid, flags, &mojo_handle);
  CHECK_EQ(result, MOJO_RESULT_OK);

   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));
 }
","The vulnerability in the original code stemmed from the use of a boolean `read_only` flag to determine the access level of the shared memory handle, which could lead to improper handling of memory permissions. This could potentially allow unauthorized access to sensitive data if the flag was misused. In the fixed code, the `read_only` boolean was replaced with an `UnwrappedSharedMemoryHandleProtection` enum, which explicitly defines the protection levels. This change enhances clarity and safety by ensuring that only valid protection levels are used, thereby reducing the risk of incorrect memory access permissions.","The vulnerability in the original code arose from the use of a boolean flag to control access permissions for shared memory, which could lead to improper handling and potential unauthorized access to sensitive data. This simplistic approach lacked clarity and could result in misuse, as it did not enforce strict validation of access levels. The fixed code addressed this issue by replacing the boolean flag with an enumeration that explicitly defines the different protection levels. This change enhances the code's robustness by ensuring that only valid and clearly defined access permissions are applied, thereby reducing the risk of security breaches.",2,5,3,4
40,40,186900,186900,,Remote,Not required,Partial,CVE-2017-15407,https://www.cvedetails.com/cve/CVE-2017-15407/,CWE-787,Medium,Partial,Partial,,2018-08-28,6.8,Out-of-bounds Write in the QUIC networking stack in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to gain code execution via a malicious server.,2018-11-20,Exec Code ,6,https://github.com/chromium/chromium/commit/a96567f02a0881561c964e5c11afe9c1af17a5f7,a96567f02a0881561c964e5c11afe9c1af17a5f7,"Fix OOB Write in QuicStreamSequencerBuffer::OnStreamData

BUG=778505

Cq-Include-Trybots: master.tryserver.chromium.android:android_cronet_tester;master.tryserver.chromium.mac:ios-simulator-cronet
Change-Id: I1dfd1d26a2c7ee8fe047f7fe6e4ac2e9b97efa52
Reviewed-on: https://chromium-review.googlesource.com/748282
Commit-Queue: Ryan Hamilton <rch@chromium.org>
Reviewed-by: Zhongyi Shi <zhongyi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#513144}",2,net/quic/core/quic_stream_sequencer_buffer.cc,"{""sha"": ""46defd0605fe926cc7e0d84ff533fe5126f7a66c"", ""filename"": ""net/quic/core/quic_stream_sequencer_buffer.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/a96567f02a0881561c964e5c11afe9c1af17a5f7/net/quic/core/quic_stream_sequencer_buffer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a96567f02a0881561c964e5c11afe9c1af17a5f7/net/quic/core/quic_stream_sequencer_buffer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/quic/core/quic_stream_sequencer_buffer.cc?ref=a96567f02a0881561c964e5c11afe9c1af17a5f7"", ""patch"": ""@@ -102,7 +102,10 @@ QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(\n     ++current_gap;\n   }\n \n-  DCHECK(current_gap != gaps_.end());\n+  if (current_gap == gaps_.end()) {\n+    *error_details = \""Received stream data outside of maximum range.\"";\n+    return QUIC_INTERNAL_ERROR;\n+  }\n \n   // \""duplication\"": might duplicate with data alread filled,but also might\n   // overlap across different QuicStringPiece objects already written.\n@@ -138,7 +141,8 @@ QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(\n   }\n \n   // Write beyond the current range this buffer is covering.\n-  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {\n+  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||\n+      offset + size < offset) {\n     *error_details = \""Received data beyond available range.\"";\n     return QUIC_INTERNAL_ERROR;\n   }""}<_**next**_>{""sha"": ""344ca583d839a78f3b905897072fba37c29204e6"", ""filename"": ""net/quic/core/quic_stream_sequencer_buffer_test.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/a96567f02a0881561c964e5c11afe9c1af17a5f7/net/quic/core/quic_stream_sequencer_buffer_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a96567f02a0881561c964e5c11afe9c1af17a5f7/net/quic/core/quic_stream_sequencer_buffer_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/quic/core/quic_stream_sequencer_buffer_test.cc?ref=a96567f02a0881561c964e5c11afe9c1af17a5f7"", ""patch"": ""@@ -297,6 +297,21 @@ TEST_F(QuicStreamSequencerBufferTest, OnStreamDataBeyondCapacity) {\n                                   clock_.ApproximateNow(), &written,\n                                   &error_details_));\n   EXPECT_TRUE(helper_->CheckBufferInvariants());\n+\n+  // Disallow current_gap != gaps_.end()\n+  EXPECT_EQ(QUIC_INTERNAL_ERROR,\n+            buffer_->OnStreamData(static_cast<QuicStreamOffset>(-1), source,\n+                                  clock_.ApproximateNow(), &written,\n+                                  &error_details_));\n+  EXPECT_TRUE(helper_->CheckBufferInvariants());\n+\n+  // Disallow offset + size overflow\n+  source = \""bbb\"";\n+  EXPECT_EQ(QUIC_INTERNAL_ERROR,\n+            buffer_->OnStreamData(static_cast<QuicStreamOffset>(-2), source,\n+                                  clock_.ApproximateNow(), &written,\n+                                  &error_details_));\n+  EXPECT_TRUE(helper_->CheckBufferInvariants());\n   EXPECT_EQ(0u, buffer_->BytesBuffered());\n }\n ""}","QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
    QuicStreamOffset starting_offset,
    QuicStringPiece data,
    QuicTime timestamp,
    size_t* const bytes_buffered,
    std::string* error_details) {
  CHECK_EQ(destruction_indicator_, 123456) << ""This object has been destructed"";
  *bytes_buffered = 0;
  QuicStreamOffset offset = starting_offset;
  size_t size = data.size();
  if (size == 0) {
    *error_details = ""Received empty stream frame without FIN."";
    return QUIC_EMPTY_STREAM_FRAME_NO_FIN;
  }

  std::list<Gap>::iterator current_gap = gaps_.begin();
  while (current_gap != gaps_.end() && current_gap->end_offset <= offset) {
     ++current_gap;
   }
 
  if (current_gap == gaps_.end()) {
    *error_details = ""Received stream data outside of maximum range."";
    return QUIC_INTERNAL_ERROR;
  }
 
  if (offset < current_gap->begin_offset &&
      offset + size <= current_gap->begin_offset) {
    QUIC_DVLOG(1) << ""Duplicated data at offset: "" << offset
                  << "" length: "" << size;
    return QUIC_NO_ERROR;
  }
  if (offset < current_gap->begin_offset &&
      offset + size > current_gap->begin_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details =
        QuicStrCat(""Beginning of received data overlaps with buffered data.\n"",
                   ""New frame range ["", offset, "", "", offset + size,
                   "") with first 128 bytes: "", prefix, ""\n"",
                   ""Currently received frames: "", GapsDebugString(), ""\n"",
                   ""Current gaps: "", ReceivedFramesDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
  }
  if (offset + size > current_gap->end_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details = QuicStrCat(
        ""End of received data overlaps with buffered data.\nNew frame range ["",
        offset, "", "", offset + size, "") with first 128 bytes: "", prefix, ""\n"",
        ""Currently received frames: "", ReceivedFramesDebugString(), ""\n"",
        ""Current gaps: "", GapsDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
   }
 
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
      offset + size < offset) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }

  if (current_gap->begin_offset != starting_offset &&
      current_gap->end_offset != starting_offset + data.length() &&
      gaps_.size() >= kMaxNumGapsAllowed) {
    *error_details = ""Too many gaps created for this stream."";
    return QUIC_TOO_MANY_FRAME_GAPS;
  }

  size_t total_written = 0;
  size_t source_remaining = size;
  const char* source = data.data();
  while (source_remaining > 0) {
    const size_t write_block_num = GetBlockIndex(offset);
    const size_t write_block_offset = GetInBlockOffset(offset);
    DCHECK_GT(blocks_count_, write_block_num);

    size_t block_capacity = GetBlockCapacity(write_block_num);
    size_t bytes_avail = block_capacity - write_block_offset;

    if (offset + bytes_avail > total_bytes_read_ + max_buffer_capacity_bytes_) {
      bytes_avail = total_bytes_read_ + max_buffer_capacity_bytes_ - offset;
    }

    if (blocks_ == nullptr) {
      blocks_.reset(new BufferBlock*[blocks_count_]());
      for (size_t i = 0; i < blocks_count_; ++i) {
        blocks_[i] = nullptr;
      }
    }

    if (write_block_num >= blocks_count_) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData() exceed array bounds.""
          ""write offset = "",
          offset, "" write_block_num = "", write_block_num,
          "" blocks_count_ = "", blocks_count_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_ == nullptr) {
      *error_details =
          ""QuicStreamSequencerBuffer error: OnStreamData() blocks_ is null"";
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_[write_block_num] == nullptr) {
      blocks_[write_block_num] = new BufferBlock();
    }

    const size_t bytes_to_copy =
        std::min<size_t>(bytes_avail, source_remaining);
    char* dest = blocks_[write_block_num]->buffer + write_block_offset;
    QUIC_DVLOG(1) << ""Write at offset: "" << offset
                  << "" length: "" << bytes_to_copy;

    if (dest == nullptr || source == nullptr) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData()""
          "" dest == nullptr: "",
          (dest == nullptr), "" source == nullptr: "", (source == nullptr),
          "" Writing at offset "", offset, "" Gaps: "", GapsDebugString(),
          "" Remaining frames: "", ReceivedFramesDebugString(),
          "" total_bytes_read_ = "", total_bytes_read_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    memcpy(dest, source, bytes_to_copy);
    source += bytes_to_copy;
    source_remaining -= bytes_to_copy;
    offset += bytes_to_copy;
    total_written += bytes_to_copy;
  }

  DCHECK_GT(total_written, 0u);
  *bytes_buffered = total_written;
  UpdateGapList(current_gap, starting_offset, total_written);

  frame_arrival_time_map_.insert(
      std::make_pair(starting_offset, FrameInfo(size, timestamp)));
  num_bytes_buffered_ += total_written;
  return QUIC_NO_ERROR;
}
","QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
    QuicStreamOffset starting_offset,
    QuicStringPiece data,
    QuicTime timestamp,
    size_t* const bytes_buffered,
    std::string* error_details) {
  CHECK_EQ(destruction_indicator_, 123456) << ""This object has been destructed"";
  *bytes_buffered = 0;
  QuicStreamOffset offset = starting_offset;
  size_t size = data.size();
  if (size == 0) {
    *error_details = ""Received empty stream frame without FIN."";
    return QUIC_EMPTY_STREAM_FRAME_NO_FIN;
  }

  std::list<Gap>::iterator current_gap = gaps_.begin();
  while (current_gap != gaps_.end() && current_gap->end_offset <= offset) {
     ++current_gap;
   }
 
  DCHECK(current_gap != gaps_.end());
 
  if (offset < current_gap->begin_offset &&
      offset + size <= current_gap->begin_offset) {
    QUIC_DVLOG(1) << ""Duplicated data at offset: "" << offset
                  << "" length: "" << size;
    return QUIC_NO_ERROR;
  }
  if (offset < current_gap->begin_offset &&
      offset + size > current_gap->begin_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details =
        QuicStrCat(""Beginning of received data overlaps with buffered data.\n"",
                   ""New frame range ["", offset, "", "", offset + size,
                   "") with first 128 bytes: "", prefix, ""\n"",
                   ""Currently received frames: "", GapsDebugString(), ""\n"",
                   ""Current gaps: "", ReceivedFramesDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
  }
  if (offset + size > current_gap->end_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details = QuicStrCat(
        ""End of received data overlaps with buffered data.\nNew frame range ["",
        offset, "", "", offset + size, "") with first 128 bytes: "", prefix, ""\n"",
        ""Currently received frames: "", ReceivedFramesDebugString(), ""\n"",
        ""Current gaps: "", GapsDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
   }
 
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }

  if (current_gap->begin_offset != starting_offset &&
      current_gap->end_offset != starting_offset + data.length() &&
      gaps_.size() >= kMaxNumGapsAllowed) {
    *error_details = ""Too many gaps created for this stream."";
    return QUIC_TOO_MANY_FRAME_GAPS;
  }

  size_t total_written = 0;
  size_t source_remaining = size;
  const char* source = data.data();
  while (source_remaining > 0) {
    const size_t write_block_num = GetBlockIndex(offset);
    const size_t write_block_offset = GetInBlockOffset(offset);
    DCHECK_GT(blocks_count_, write_block_num);

    size_t block_capacity = GetBlockCapacity(write_block_num);
    size_t bytes_avail = block_capacity - write_block_offset;

    if (offset + bytes_avail > total_bytes_read_ + max_buffer_capacity_bytes_) {
      bytes_avail = total_bytes_read_ + max_buffer_capacity_bytes_ - offset;
    }

    if (blocks_ == nullptr) {
      blocks_.reset(new BufferBlock*[blocks_count_]());
      for (size_t i = 0; i < blocks_count_; ++i) {
        blocks_[i] = nullptr;
      }
    }

    if (write_block_num >= blocks_count_) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData() exceed array bounds.""
          ""write offset = "",
          offset, "" write_block_num = "", write_block_num,
          "" blocks_count_ = "", blocks_count_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_ == nullptr) {
      *error_details =
          ""QuicStreamSequencerBuffer error: OnStreamData() blocks_ is null"";
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_[write_block_num] == nullptr) {
      blocks_[write_block_num] = new BufferBlock();
    }

    const size_t bytes_to_copy =
        std::min<size_t>(bytes_avail, source_remaining);
    char* dest = blocks_[write_block_num]->buffer + write_block_offset;
    QUIC_DVLOG(1) << ""Write at offset: "" << offset
                  << "" length: "" << bytes_to_copy;

    if (dest == nullptr || source == nullptr) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData()""
          "" dest == nullptr: "",
          (dest == nullptr), "" source == nullptr: "", (source == nullptr),
          "" Writing at offset "", offset, "" Gaps: "", GapsDebugString(),
          "" Remaining frames: "", ReceivedFramesDebugString(),
          "" total_bytes_read_ = "", total_bytes_read_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    memcpy(dest, source, bytes_to_copy);
    source += bytes_to_copy;
    source_remaining -= bytes_to_copy;
    offset += bytes_to_copy;
    total_written += bytes_to_copy;
  }

  DCHECK_GT(total_written, 0u);
  *bytes_buffered = total_written;
  UpdateGapList(current_gap, starting_offset, total_written);

  frame_arrival_time_map_.insert(
      std::make_pair(starting_offset, FrameInfo(size, timestamp)));
  num_bytes_buffered_ += total_written;
  return QUIC_NO_ERROR;
}
",C,"  if (current_gap == gaps_.end()) {
    *error_details = ""Received stream data outside of maximum range."";
    return QUIC_INTERNAL_ERROR;
  }
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
      offset + size < offset) {
","  DCHECK(current_gap != gaps_.end());
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {
",,"@@ -102,7 +102,10 @@ QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
     ++current_gap;
   }
 
-  DCHECK(current_gap != gaps_.end());
+  if (current_gap == gaps_.end()) {
+    *error_details = ""Received stream data outside of maximum range."";
+    return QUIC_INTERNAL_ERROR;
+  }
 
   // ""duplication"": might duplicate with data alread filled,but also might
   // overlap across different QuicStringPiece objects already written.
@@ -138,7 +141,8 @@ QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
   }
 
   // Write beyond the current range this buffer is covering.
-  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {
+  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
+      offset + size < offset) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }",Chrome,a96567f02a0881561c964e5c11afe9c1af17a5f7,8b2f970348522c1103faed86cfabb0a1a07b8be6,1,"QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
    QuicStreamOffset starting_offset,
    QuicStringPiece data,
    QuicTime timestamp,
    size_t* const bytes_buffered,
    std::string* error_details) {
  CHECK_EQ(destruction_indicator_, 123456) << ""This object has been destructed"";
  *bytes_buffered = 0;
  QuicStreamOffset offset = starting_offset;
  size_t size = data.size();
  if (size == 0) {
    *error_details = ""Received empty stream frame without FIN."";
    return QUIC_EMPTY_STREAM_FRAME_NO_FIN;
  }

  // Find the first gap not ending before |offset|. This gap maybe the gap to
  // fill if the arriving frame doesn't overlaps with previous ones.
  std::list<Gap>::iterator current_gap = gaps_.begin();
  while (current_gap != gaps_.end() && current_gap->end_offset <= offset) {
     ++current_gap;
   }
 
//flaw_line_below:
  DCHECK(current_gap != gaps_.end());
//fix_flaw_line_below:
//  if (current_gap == gaps_.end()) {
//fix_flaw_line_below:
//    *error_details = ""Received stream data outside of maximum range."";
//fix_flaw_line_below:
//    return QUIC_INTERNAL_ERROR;
//fix_flaw_line_below:
//  }
 
   // ""duplication"": might duplicate with data alread filled,but also might
   // overlap across different QuicStringPiece objects already written.
  // In both cases, don't write the data,
  // and allow the caller of this method to handle the result.
  if (offset < current_gap->begin_offset &&
      offset + size <= current_gap->begin_offset) {
    QUIC_DVLOG(1) << ""Duplicated data at offset: "" << offset
                  << "" length: "" << size;
    return QUIC_NO_ERROR;
  }
  if (offset < current_gap->begin_offset &&
      offset + size > current_gap->begin_offset) {
    // Beginning of new data overlaps data before current gap.
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details =
        QuicStrCat(""Beginning of received data overlaps with buffered data.\n"",
                   ""New frame range ["", offset, "", "", offset + size,
                   "") with first 128 bytes: "", prefix, ""\n"",
                   ""Currently received frames: "", GapsDebugString(), ""\n"",
                   ""Current gaps: "", ReceivedFramesDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
  }
  if (offset + size > current_gap->end_offset) {
    // End of new data overlaps with data after current gap.
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details = QuicStrCat(
        ""End of received data overlaps with buffered data.\nNew frame range ["",
        offset, "", "", offset + size, "") with first 128 bytes: "", prefix, ""\n"",
        ""Currently received frames: "", ReceivedFramesDebugString(), ""\n"",
        ""Current gaps: "", GapsDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
   }
 
   // Write beyond the current range this buffer is covering.
//flaw_line_below:
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {
//fix_flaw_line_below:
//  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
//fix_flaw_line_below:
//      offset + size < offset) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }

  if (current_gap->begin_offset != starting_offset &&
      current_gap->end_offset != starting_offset + data.length() &&
      gaps_.size() >= kMaxNumGapsAllowed) {
    // This frame is going to create one more gap which exceeds max number of
    // gaps allowed. Stop processing.
    *error_details = ""Too many gaps created for this stream."";
    return QUIC_TOO_MANY_FRAME_GAPS;
  }

  size_t total_written = 0;
  size_t source_remaining = size;
  const char* source = data.data();
  // Write data block by block. If corresponding block has not created yet,
  // create it first.
  // Stop when all data are written or reaches the logical end of the buffer.
  while (source_remaining > 0) {
    const size_t write_block_num = GetBlockIndex(offset);
    const size_t write_block_offset = GetInBlockOffset(offset);
    DCHECK_GT(blocks_count_, write_block_num);

    size_t block_capacity = GetBlockCapacity(write_block_num);
    size_t bytes_avail = block_capacity - write_block_offset;

    // If this write meets the upper boundary of the buffer,
    // reduce the available free bytes.
    if (offset + bytes_avail > total_bytes_read_ + max_buffer_capacity_bytes_) {
      bytes_avail = total_bytes_read_ + max_buffer_capacity_bytes_ - offset;
    }

    if (blocks_ == nullptr) {
      blocks_.reset(new BufferBlock*[blocks_count_]());
      for (size_t i = 0; i < blocks_count_; ++i) {
        blocks_[i] = nullptr;
      }
    }

    if (write_block_num >= blocks_count_) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData() exceed array bounds.""
          ""write offset = "",
          offset, "" write_block_num = "", write_block_num,
          "" blocks_count_ = "", blocks_count_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_ == nullptr) {
      *error_details =
          ""QuicStreamSequencerBuffer error: OnStreamData() blocks_ is null"";
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_[write_block_num] == nullptr) {
      // TODO(danzh): Investigate if using a freelist would improve performance.
      // Same as RetireBlock().
      blocks_[write_block_num] = new BufferBlock();
    }

    const size_t bytes_to_copy =
        std::min<size_t>(bytes_avail, source_remaining);
    char* dest = blocks_[write_block_num]->buffer + write_block_offset;
    QUIC_DVLOG(1) << ""Write at offset: "" << offset
                  << "" length: "" << bytes_to_copy;

    if (dest == nullptr || source == nullptr) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData()""
          "" dest == nullptr: "",
          (dest == nullptr), "" source == nullptr: "", (source == nullptr),
          "" Writing at offset "", offset, "" Gaps: "", GapsDebugString(),
          "" Remaining frames: "", ReceivedFramesDebugString(),
          "" total_bytes_read_ = "", total_bytes_read_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    memcpy(dest, source, bytes_to_copy);
    source += bytes_to_copy;
    source_remaining -= bytes_to_copy;
    offset += bytes_to_copy;
    total_written += bytes_to_copy;
  }

  DCHECK_GT(total_written, 0u);
  *bytes_buffered = total_written;
  UpdateGapList(current_gap, starting_offset, total_written);

  frame_arrival_time_map_.insert(
      std::make_pair(starting_offset, FrameInfo(size, timestamp)));
  num_bytes_buffered_ += total_written;
  return QUIC_NO_ERROR;
}
",186900,"QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
    QuicStreamOffset starting_offset,
    QuicStringPiece data,
    QuicTime timestamp,
    size_t* const bytes_buffered,
    std::string* error_details) {
  CHECK_EQ(destruction_indicator_, 123456) << ""This object has been destructed"";
  *bytes_buffered = 0;
  QuicStreamOffset offset = starting_offset;
  size_t size = data.size();
  if (size == 0) {
    *error_details = ""Received empty stream frame without FIN."";
    return QUIC_EMPTY_STREAM_FRAME_NO_FIN;
  }

  std::list<Gap>::iterator current_gap = gaps_.begin();
  while (current_gap != gaps_.end() && current_gap->end_offset <= offset) {
     ++current_gap;
   }
 
  DCHECK(current_gap != gaps_.end());
 
  if (offset < current_gap->begin_offset &&
      offset + size <= current_gap->begin_offset) {
    QUIC_DVLOG(1) << ""Duplicated data at offset: "" << offset
                  << "" length: "" << size;
    return QUIC_NO_ERROR;
  }
  if (offset < current_gap->begin_offset &&
      offset + size > current_gap->begin_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details =
        QuicStrCat(""Beginning of received data overlaps with buffered data.\n"",
                   ""New frame range ["", offset, "", "", offset + size,
                   "") with first 128 bytes: "", prefix, ""\n"",
                   ""Currently received frames: "", GapsDebugString(), ""\n"",
                   ""Current gaps: "", ReceivedFramesDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
  }
  if (offset + size > current_gap->end_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details = QuicStrCat(
        ""End of received data overlaps with buffered data.\nNew frame range ["",
        offset, "", "", offset + size, "") with first 128 bytes: "", prefix, ""\n"",
        ""Currently received frames: "", ReceivedFramesDebugString(), ""\n"",
        ""Current gaps: "", GapsDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
   }
 
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }

  if (current_gap->begin_offset != starting_offset &&
      current_gap->end_offset != starting_offset + data.length() &&
      gaps_.size() >= kMaxNumGapsAllowed) {
    *error_details = ""Too many gaps created for this stream."";
    return QUIC_TOO_MANY_FRAME_GAPS;
  }

  size_t total_written = 0;
  size_t source_remaining = size;
  const char* source = data.data();
  while (source_remaining > 0) {
    const size_t write_block_num = GetBlockIndex(offset);
    const size_t write_block_offset = GetInBlockOffset(offset);
    DCHECK_GT(blocks_count_, write_block_num);

    size_t block_capacity = GetBlockCapacity(write_block_num);
    size_t bytes_avail = block_capacity - write_block_offset;

    if (offset + bytes_avail > total_bytes_read_ + max_buffer_capacity_bytes_) {
      bytes_avail = total_bytes_read_ + max_buffer_capacity_bytes_ - offset;
    }

    if (blocks_ == nullptr) {
      blocks_.reset(new BufferBlock*[blocks_count_]());
      for (size_t i = 0; i < blocks_count_; ++i) {
        blocks_[i] = nullptr;
      }
    }

    if (write_block_num >= blocks_count_) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData() exceed array bounds.""
          ""write offset = "",
          offset, "" write_block_num = "", write_block_num,
          "" blocks_count_ = "", blocks_count_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_ == nullptr) {
      *error_details =
          ""QuicStreamSequencerBuffer error: OnStreamData() blocks_ is null"";
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_[write_block_num] == nullptr) {
      blocks_[write_block_num] = new BufferBlock();
    }

    const size_t bytes_to_copy =
        std::min<size_t>(bytes_avail, source_remaining);
    char* dest = blocks_[write_block_num]->buffer + write_block_offset;
    QUIC_DVLOG(1) << ""Write at offset: "" << offset
                  << "" length: "" << bytes_to_copy;

    if (dest == nullptr || source == nullptr) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData()""
          "" dest == nullptr: "",
          (dest == nullptr), "" source == nullptr: "", (source == nullptr),
          "" Writing at offset "", offset, "" Gaps: "", GapsDebugString(),
          "" Remaining frames: "", ReceivedFramesDebugString(),
          "" total_bytes_read_ = "", total_bytes_read_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    memcpy(dest, source, bytes_to_copy);
    source += bytes_to_copy;
    source_remaining -= bytes_to_copy;
    offset += bytes_to_copy;
    total_written += bytes_to_copy;
  }

  DCHECK_GT(total_written, 0u);
  *bytes_buffered = total_written;
  UpdateGapList(current_gap, starting_offset, total_written);

  frame_arrival_time_map_.insert(
      std::make_pair(starting_offset, FrameInfo(size, timestamp)));
  num_bytes_buffered_ += total_written;
  return QUIC_NO_ERROR;
}
","QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
    QuicStreamOffset starting_offset,
    QuicStringPiece data,
    QuicTime timestamp,
    size_t* const bytes_buffered,
    std::string* error_details) {
  CHECK_EQ(destruction_indicator_, 123456) << ""This object has been destructed"";
  *bytes_buffered = 0;
  QuicStreamOffset offset = starting_offset;
  size_t size = data.size();
  if (size == 0) {
    *error_details = ""Received empty stream frame without FIN."";
    return QUIC_EMPTY_STREAM_FRAME_NO_FIN;
  }

  std::list<Gap>::iterator current_gap = gaps_.begin();
  while (current_gap != gaps_.end() && current_gap->end_offset <= offset) {
     ++current_gap;
   }
 
  if (current_gap == gaps_.end()) {
    *error_details = ""Received stream data outside of maximum range."";
    return QUIC_INTERNAL_ERROR;
  }
 
  if (offset < current_gap->begin_offset &&
      offset + size <= current_gap->begin_offset) {
    QUIC_DVLOG(1) << ""Duplicated data at offset: "" << offset
                  << "" length: "" << size;
    return QUIC_NO_ERROR;
  }
  if (offset < current_gap->begin_offset &&
      offset + size > current_gap->begin_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details =
        QuicStrCat(""Beginning of received data overlaps with buffered data.\n"",
                   ""New frame range ["", offset, "", "", offset + size,
                   "") with first 128 bytes: "", prefix, ""\n"",
                   ""Currently received frames: "", GapsDebugString(), ""\n"",
                   ""Current gaps: "", ReceivedFramesDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
  }
  if (offset + size > current_gap->end_offset) {
    string prefix(data.data(), data.length() < 128 ? data.length() : 128);
    *error_details = QuicStrCat(
        ""End of received data overlaps with buffered data.\nNew frame range ["",
        offset, "", "", offset + size, "") with first 128 bytes: "", prefix, ""\n"",
        ""Currently received frames: "", ReceivedFramesDebugString(), ""\n"",
        ""Current gaps: "", GapsDebugString());
    return QUIC_OVERLAPPING_STREAM_DATA;
   }
 
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
      offset + size < offset) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }

  if (current_gap->begin_offset != starting_offset &&
      current_gap->end_offset != starting_offset + data.length() &&
      gaps_.size() >= kMaxNumGapsAllowed) {
    *error_details = ""Too many gaps created for this stream."";
    return QUIC_TOO_MANY_FRAME_GAPS;
  }

  size_t total_written = 0;
  size_t source_remaining = size;
  const char* source = data.data();
  while (source_remaining > 0) {
    const size_t write_block_num = GetBlockIndex(offset);
    const size_t write_block_offset = GetInBlockOffset(offset);
    DCHECK_GT(blocks_count_, write_block_num);

    size_t block_capacity = GetBlockCapacity(write_block_num);
    size_t bytes_avail = block_capacity - write_block_offset;

    if (offset + bytes_avail > total_bytes_read_ + max_buffer_capacity_bytes_) {
      bytes_avail = total_bytes_read_ + max_buffer_capacity_bytes_ - offset;
    }

    if (blocks_ == nullptr) {
      blocks_.reset(new BufferBlock*[blocks_count_]());
      for (size_t i = 0; i < blocks_count_; ++i) {
        blocks_[i] = nullptr;
      }
    }

    if (write_block_num >= blocks_count_) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData() exceed array bounds.""
          ""write offset = "",
          offset, "" write_block_num = "", write_block_num,
          "" blocks_count_ = "", blocks_count_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_ == nullptr) {
      *error_details =
          ""QuicStreamSequencerBuffer error: OnStreamData() blocks_ is null"";
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    if (blocks_[write_block_num] == nullptr) {
      blocks_[write_block_num] = new BufferBlock();
    }

    const size_t bytes_to_copy =
        std::min<size_t>(bytes_avail, source_remaining);
    char* dest = blocks_[write_block_num]->buffer + write_block_offset;
    QUIC_DVLOG(1) << ""Write at offset: "" << offset
                  << "" length: "" << bytes_to_copy;

    if (dest == nullptr || source == nullptr) {
      *error_details = QuicStrCat(
          ""QuicStreamSequencerBuffer error: OnStreamData()""
          "" dest == nullptr: "",
          (dest == nullptr), "" source == nullptr: "", (source == nullptr),
          "" Writing at offset "", offset, "" Gaps: "", GapsDebugString(),
          "" Remaining frames: "", ReceivedFramesDebugString(),
          "" total_bytes_read_ = "", total_bytes_read_);
      return QUIC_STREAM_SEQUENCER_INVALID_STATE;
    }
    memcpy(dest, source, bytes_to_copy);
    source += bytes_to_copy;
    source_remaining -= bytes_to_copy;
    offset += bytes_to_copy;
    total_written += bytes_to_copy;
  }

  DCHECK_GT(total_written, 0u);
  *bytes_buffered = total_written;
  UpdateGapList(current_gap, starting_offset, total_written);

  frame_arrival_time_map_.insert(
      std::make_pair(starting_offset, FrameInfo(size, timestamp)));
  num_bytes_buffered_ += total_written;
  return QUIC_NO_ERROR;
}
","The vulnerability in the original code lies in the unchecked iterator `current_gap`, which could lead to dereferencing an invalid iterator if `gaps_` is empty, causing undefined behavior. Specifically, the line `DCHECK(current_gap != gaps_.end());` assumes that `current_gap` is valid, but if `gaps_` is empty, this check fails. The fix in the modified code introduces a check to ensure `current_gap` is not at the end of the list before proceeding, returning an appropriate error message if it is, thus preventing potential crashes or memory access violations.","The vulnerability in the original code arises from the potential dereferencing of an invalid iterator, which could occur if the list being accessed is empty. This situation could lead to undefined behavior, including crashes or memory access violations, as the code assumes that there is always a valid element to reference. The fix in the modified code addresses this issue by adding a check to ensure that the iterator is not at the end of the list before proceeding with further operations. This prevents the code from attempting to access an invalid memory location, thereby enhancing stability and safety.",2,4,4,5
41,41,188103,188103,,Local Network,Not required,Complete,CVE-2018-9504,https://www.cvedetails.com/cve/CVE-2018-9504/,CWE-787,Low,Complete,Complete,,2018-10-02,8.3,"In sdp_copy_raw_data of sdp_discovery.cc, there is a possible out of bounds write due to an incorrect bounds check. This could lead to remote code execution over bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-110216176",2018-11-20,Exec Code ,7,https://android.googlesource.com/platform/system/bt/+/11fb7aa03437eccac98d90ca2de1730a02a515e2,11fb7aa03437eccac98d90ca2de1730a02a515e2,"Fix copy length calculation in sdp_copy_raw_data

Test: compilation
Bug: 110216176
Change-Id: Ic4a19c9f0fe8cd592bc6c25dcec7b1da49ff7459
(cherry picked from commit 23aa15743397b345f3d948289fe90efa2a2e2b3e)
",0,stack/sdp/sdp_discovery.cc,"{""filename"": ""stack/sdp/sdp_discovery.cc"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/11fb7aa03437eccac98d90ca2de1730a02a515e2/stack/sdp/sdp_discovery.cc"", ""patch"": ""@@ -357,8 +357,15 @@\n\n     p = &p_ccb->rsp_list[0];\n \n     if (offset) {\n+      cpy_len -= 1;\n       type = *p++;\n+      uint8_t* old_p = p;\n       p = sdpu_get_len_from_type(p, type, &list_len);\n+      if ((int)cpy_len < (p - old_p)) {\n+        SDP_TRACE_WARNING(\""%s: no bytes left for data\"", __func__);\n+        return;\n+      }\n+      cpy_len -= (p - old_p);\n     }\n     if (list_len < cpy_len) {\n       cpy_len = list_len;\n""}","static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
 unsigned int cpy_len, rem_len;
 uint32_t list_len;
 uint8_t* p;
 uint8_t type;

#if (SDP_DEBUG_RAW == TRUE)
 uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
 uint32_t i;

 for (i = 0; i < p_ccb->list_len; i++) {
    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"",
 (uint8_t)(p_ccb->rsp_list[i]));
 }
  SDP_TRACE_WARNING(""result :%s"", num_array);
#endif

 if (p_ccb->p_db->raw_data) {
    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
    list_len = p_ccb->list_len;

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
      cpy_len -= 1;
       type = *p++;
      uint8_t* old_p = p;
       p = sdpu_get_len_from_type(p, type, &list_len);
      if ((int)cpy_len < (p - old_p)) {
        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
        return;
      }
      cpy_len -= (p - old_p);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
 }
    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
 if (cpy_len > rem_len) {
      SDP_TRACE_WARNING(""rem_len :%d less than cpy_len:%d"", rem_len, cpy_len);
      cpy_len = rem_len;
 }
    SDP_TRACE_WARNING(
 ""%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d ""
 ""raw_used:%d raw_data:%p"",
        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
    p_ccb->p_db->raw_used += cpy_len;
 }
}
","static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
 unsigned int cpy_len, rem_len;
 uint32_t list_len;
 uint8_t* p;
 uint8_t type;

#if (SDP_DEBUG_RAW == TRUE)
 uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
 uint32_t i;

 for (i = 0; i < p_ccb->list_len; i++) {
    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"",
 (uint8_t)(p_ccb->rsp_list[i]));
 }
  SDP_TRACE_WARNING(""result :%s"", num_array);
#endif

 if (p_ccb->p_db->raw_data) {
    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
    list_len = p_ccb->list_len;

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
       type = *p++;
       p = sdpu_get_len_from_type(p, type, &list_len);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
 }
    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
 if (cpy_len > rem_len) {
      SDP_TRACE_WARNING(""rem_len :%d less than cpy_len:%d"", rem_len, cpy_len);
      cpy_len = rem_len;
 }
    SDP_TRACE_WARNING(
 ""%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d ""
 ""raw_used:%d raw_data:%p"",
        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
    p_ccb->p_db->raw_used += cpy_len;
 }
}
",C,"      cpy_len -= 1;
      uint8_t* old_p = p;
      if ((int)cpy_len < (p - old_p)) {
        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
        return;
      }
      cpy_len -= (p - old_p);
",,,"@@ -357,8 +357,15 @@

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
+      cpy_len -= 1;
       type = *p++;
+      uint8_t* old_p = p;
       p = sdpu_get_len_from_type(p, type, &list_len);
+      if ((int)cpy_len < (p - old_p)) {
+        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
+        return;
+      }
+      cpy_len -= (p - old_p);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
",Android,https://android.googlesource.com/platform/system/bt/+/11fb7aa03437eccac98d90ca2de1730a02a515e2/,https://android.googlesource.com/platform/system/bt/+/11fb7aa03437eccac98d90ca2de1730a02a515e2%5E/,1,"static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
 unsigned int cpy_len, rem_len;
 uint32_t list_len;
 uint8_t* p;
 uint8_t type;

#if (SDP_DEBUG_RAW == TRUE)
 uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
 uint32_t i;

 for (i = 0; i < p_ccb->list_len; i++) {
    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"",
 (uint8_t)(p_ccb->rsp_list[i]));
 }
  SDP_TRACE_WARNING(""result :%s"", num_array);
#endif

 if (p_ccb->p_db->raw_data) {
    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
    list_len = p_ccb->list_len;

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
//fix_flaw_line_below:
//      cpy_len -= 1;
       type = *p++;
//fix_flaw_line_below:
//      uint8_t* old_p = p;
       p = sdpu_get_len_from_type(p, type, &list_len);
//fix_flaw_line_below:
//      if ((int)cpy_len < (p - old_p)) {
//fix_flaw_line_below:
//        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//      cpy_len -= (p - old_p);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
 }
    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
 if (cpy_len > rem_len) {
      SDP_TRACE_WARNING(""rem_len :%d less than cpy_len:%d"", rem_len, cpy_len);
      cpy_len = rem_len;
 }
    SDP_TRACE_WARNING(
 ""%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d ""
 ""raw_used:%d raw_data:%p"",
        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
    p_ccb->p_db->raw_used += cpy_len;
 }
}
",188103,"static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
 unsigned int cpy_len, rem_len;
 uint32_t list_len;
 uint8_t* p;
 uint8_t type;

#if (SDP_DEBUG_RAW == TRUE)
 uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
 uint32_t i;

 for (i = 0; i < p_ccb->list_len; i++) {
    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"",
 (uint8_t)(p_ccb->rsp_list[i]));
 }
  SDP_TRACE_WARNING(""result :%s"", num_array);
#endif

 if (p_ccb->p_db->raw_data) {
    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
    list_len = p_ccb->list_len;

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
       type = *p++;
       p = sdpu_get_len_from_type(p, type, &list_len);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
 }
    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
 if (cpy_len > rem_len) {
      SDP_TRACE_WARNING(""rem_len :%d less than cpy_len:%d"", rem_len, cpy_len);
      cpy_len = rem_len;
 }
    SDP_TRACE_WARNING(
 ""%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d ""
 ""raw_used:%d raw_data:%p"",
        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
    p_ccb->p_db->raw_used += cpy_len;
 }
}
","static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
 unsigned int cpy_len, rem_len;
 uint32_t list_len;
 uint8_t* p;
 uint8_t type;

#if (SDP_DEBUG_RAW == TRUE)
 uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
 uint32_t i;

 for (i = 0; i < p_ccb->list_len; i++) {
    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"",
 (uint8_t)(p_ccb->rsp_list[i]));
 }
  SDP_TRACE_WARNING(""result :%s"", num_array);
#endif

 if (p_ccb->p_db->raw_data) {
    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
    list_len = p_ccb->list_len;

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
      cpy_len -= 1;
       type = *p++;
      uint8_t* old_p = p;
       p = sdpu_get_len_from_type(p, type, &list_len);
      if ((int)cpy_len < (p - old_p)) {
        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
        return;
      }
      cpy_len -= (p - old_p);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
 }
    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
 if (cpy_len > rem_len) {
      SDP_TRACE_WARNING(""rem_len :%d less than cpy_len:%d"", rem_len, cpy_len);
      cpy_len = rem_len;
 }
    SDP_TRACE_WARNING(
 ""%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d ""
 ""raw_used:%d raw_data:%p"",
        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
    p_ccb->p_db->raw_used += cpy_len;
 }
}
","The vulnerability in the original code arises from insufficient checks on the `cpy_len` variable, which could lead to a buffer overflow when copying data into `p_ccb->p_db->raw_data`. Specifically, if the `offset` is true, the code does not verify whether there are enough bytes left after adjusting `cpy_len`, potentially allowing `memcpy` to exceed the allocated buffer size. The fixed code addresses this by introducing a check after calculating the new `cpy_len`, ensuring that there are enough bytes left for data copying. If not, it logs a warning and exits the function, thus preventing the overflow.","The vulnerability in the original code stems from inadequate validation of the length of data being copied into a buffer, which could lead to a buffer overflow. Specifically, when certain conditions are met, the code does not ensure that the amount of data being copied does not exceed the allocated space, risking memory corruption or crashes. The revised code mitigates this issue by implementing a check to confirm that there is sufficient space available before proceeding with the data copy operation. If the available space is insufficient, it logs a warning and safely exits the function, thereby preventing potential overflow.",3,5,4,4
42,42,188106,188106,,Remote,Not required,Complete,CVE-2018-9498,https://www.cvedetails.com/cve/CVE-2018-9498/,CWE-787,Medium,Complete,Complete,,2018-10-02,9.3,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",2018-11-20,Exec Code Overflow ,2,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,77c955200ddd1761d6ed7a6c1578349fedbb55e4,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",3,src/codec/SkIcoCodec.cpp,"{""filename"": ""include/core/SkTypes.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/include/core/SkTypes.h"", ""patch"": ""@@ -235,6 +235,7 @@\n\n #define SK_MaxU32   0xFFFFFFFF\n #define SK_MinU32   0\n #define SK_NaN32    ((int) (1U << 31))\n+#define SK_MaxSizeT SIZE_MAX\n \n /** Returns true if the value can be represented with signed 16bits\n  */\n""}<_**next**_>{""filename"": ""include/private/SkMalloc.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/include/private/SkMalloc.h"", ""patch"": ""@@ -17,27 +17,53 @@\n\n     memory wrappers to be implemented by the porting layer (platform)\n */\n \n-enum {\n-    SK_MALLOC_TEMP  = 0x01, //!< hint to sk_malloc that the requested memory will be freed in the scope of the stack frame\n-    SK_MALLOC_THROW = 0x02  //!< instructs sk_malloc to call sk_throw if the memory cannot be allocated.\n-};\n-/** Return a block of memory (at least 4-byte aligned) of at least the\n-    specified size. If the requested memory cannot be returned, either\n-    return null (if SK_MALLOC_TEMP bit is clear) or throw an exception\n-    (if SK_MALLOC_TEMP bit is set). To free the memory, call sk_free().\n-*/\n-SK_API extern void* sk_malloc_flags(size_t size, unsigned flags);\n-/** Same as sk_malloc(), but hard coded to pass SK_MALLOC_THROW as the flag\n-*/\n-SK_API extern void* sk_malloc_throw(size_t size);\n-/** Same as standard realloc(), but this one never returns null on failure. It will throw\n-    an exception if it fails.\n-*/\n-SK_API extern void* sk_realloc_throw(void* buffer, size_t size);\n-/** Free memory returned by sk_malloc(). It is safe to pass null.\n-*/\n+\n+/** Free memory returned by sk_malloc(). It is safe to pass null. */\n SK_API extern void sk_free(void*);\n \n+/**\n+ *  Called internally if we run out of memory. The platform implementation must\n+ *  not return, but should either throw an exception or otherwise exit.\n+ */\n+SK_API extern void sk_out_of_memory(void);\n+\n+enum {\n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+    SK_MALLOC_TEMP = 1,\n+#else\n+    /**\n+     *  If this bit is set, the returned buffer must be zero-initialized. If this bit is not set\n+     *  the buffer can be uninitialized.\n+     */\n+    SK_MALLOC_ZERO_INITIALIZE   = 1 << 0,\n+#endif\n+\n+    /**\n+     *  If this bit is set, the implementation must throw/crash/quit if the request cannot\n+     *  be fulfilled. If this bit is not set, then it should return nullptr on failure.\n+     */\n+    SK_MALLOC_THROW             = 1 << 1,\n+};\n+/**\n+ *  Return a block of memory (at least 4-byte aligned) of at least the specified size.\n+ *  If the requested memory cannot be returned, either return nullptr or throw/exit, depending\n+ *  on the SK_MALLOC_THROW bit. If the allocation succeeds, the memory will be zero-initialized\n+ *  if the SK_MALLOC_ZERO_INITIALIZE bit was set.\n+ *\n+ *  To free the memory, call sk_free()\n+ */\n+SK_API extern void* sk_malloc_flags(size_t size, unsigned flags);\n+\n+/** Same as standard realloc(), but this one never returns null on failure. It will throw\n+ *  an exception if it fails.\n+ */\n+SK_API extern void* sk_realloc_throw(void* buffer, size_t size);\n+\n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+\n+/** Same as sk_malloc_flags(), but hard coded to pass SK_MALLOC_THROW as the flag */\n+SK_API extern void* sk_malloc_throw(size_t size);\n+\n /** Much like calloc: returns a pointer to at least size zero bytes, or NULL on failure.\n  */\n SK_API extern void* sk_calloc(size_t size);\n@@ -46,10 +72,36 @@\n\n  */\n SK_API extern void* sk_calloc_throw(size_t size);\n \n-/** Called internally if we run out of memory. The platform implementation must\n-    not return, but should either throw an exception or otherwise exit.\n-*/\n-SK_API extern void sk_out_of_memory(void);\n+#else\n+static inline void* sk_malloc_throw(size_t size) {\n+    return sk_malloc_flags(size, SK_MALLOC_THROW);\n+}\n+\n+static inline void* sk_calloc_throw(size_t size) {\n+    return sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_ZERO_INITIALIZE);\n+}\n+#endif\n+\n+static inline void* sk_calloc_canfail(size_t size) {\n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+    return sk_calloc(size);\n+#else\n+    return sk_malloc_flags(size, SK_MALLOC_ZERO_INITIALIZE);\n+#endif\n+}\n+\n+// Performs a safe multiply count * elemSize, checking for overflow\n+SK_API extern void* sk_calloc_throw(size_t count, size_t elemSize);\n+SK_API extern void* sk_malloc_throw(size_t count, size_t elemSize);\n+SK_API extern void* sk_realloc_throw(void* buffer, size_t count, size_t elemSize);\n+\n+/**\n+ *  These variants return nullptr on failure\n+ */\n+static inline void* sk_malloc_canfail(size_t size) {\n+    return sk_malloc_flags(size, 0);\n+}\n+SK_API extern void* sk_malloc_canfail(size_t count, size_t elemSize);\n \n // bzero is safer than memset, but we can't rely on it, so... sk_bzero()\n static inline void sk_bzero(void* buffer, size_t size) {\n""}<_**next**_>{""filename"": ""include/private/SkTArray.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/include/private/SkTArray.h"", ""patch"": ""@@ -445,7 +445,7 @@\n\n             fReserved = false;\n         } else {\n             fAllocCount = SkTMax(count, SkTMax(kMinHeapAllocCount, reserveCount));\n-            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));\n+            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));\n             fOwnMemory = true;\n             fReserved = reserveCount > 0;\n         }\n@@ -460,7 +460,7 @@\n\n         fReserved = false;\n         if (count > preallocCount) {\n             fAllocCount = SkTMax(count, kMinHeapAllocCount);\n-            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));\n+            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));\n             fOwnMemory = true;\n         } else {\n             fAllocCount = preallocCount;\n@@ -537,7 +537,7 @@\n\n             return;\n         }\n         fAllocCount = newAllocCount;\n-        void* newMemArray = sk_malloc_throw(fAllocCount * sizeof(T));\n+        void* newMemArray = sk_malloc_throw(fAllocCount, sizeof(T));\n         this->move(newMemArray);\n         if (fOwnMemory) {\n             sk_free(fMemArray);\n""}<_**next**_>{""filename"": ""include/private/SkTemplates.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/include/private/SkTemplates.h"", ""patch"": ""@@ -175,12 +175,7 @@\n\n             }\n \n             if (count > kCount) {\n-                const uint64_t size64 = sk_64_mul(count, sizeof(T));\n-                const size_t size = static_cast<size_t>(size64);\n-                if (size != size64) {\n-                    sk_out_of_memory();\n-                }\n-                fArray = (T*) sk_malloc_throw(size);\n+                fArray = (T*) sk_malloc_throw(count, sizeof(T));\n             } else if (count > 0) {\n                 fArray = (T*) fStorage;\n             } else {\n@@ -250,7 +245,7 @@\n\n \n     /** Allocates space for 'count' Ts. */\n     explicit SkAutoTMalloc(size_t count) {\n-        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;\n+        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;\n     }\n \n     SkAutoTMalloc(SkAutoTMalloc<T>&& that) : fPtr(that.release()) {}\n@@ -271,7 +266,7 @@\n\n     /** Resize the memory area pointed to by the current ptr without preserving contents. */\n     T* reset(size_t count = 0) {\n         sk_free(fPtr);\n-        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;\n+        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;\n         return fPtr;\n     }\n \n@@ -322,7 +317,7 @@\n\n \n     SkAutoSTMalloc(size_t count) {\n         if (count > kCount) {\n-            fPtr = (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW | SK_MALLOC_TEMP);\n+            fPtr = (T*)sk_malloc_throw(count, sizeof(T));\n         } else if (count) {\n             fPtr = fTStorage;\n         } else {\n@@ -342,7 +337,7 @@\n\n             sk_free(fPtr);\n         }\n         if (count > kCount) {\n-            fPtr = (T*)sk_malloc_throw(count * sizeof(T));\n+            fPtr = (T*)sk_malloc_throw(count, sizeof(T));\n         } else if (count) {\n             fPtr = fTStorage;\n         } else {\n@@ -373,14 +368,14 @@\n\n     void realloc(size_t count) {\n         if (count > kCount) {\n             if (fPtr == fTStorage) {\n-                fPtr = (T*)sk_malloc_throw(count * sizeof(T));\n+                fPtr = (T*)sk_malloc_throw(count, sizeof(T));\n                 memcpy(fPtr, fTStorage, kCount * sizeof(T));\n             } else {\n-                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));\n+                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));\n             }\n         } else if (count) {\n             if (fPtr != fTStorage) {\n-                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));\n+                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));\n             }\n         } else {\n             this->reset(0);\n""}<_**next**_>{""filename"": ""public.bzl"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/public.bzl"", ""patch"": ""@@ -672,6 +672,7 @@\n\n     \""SK_NO_ANALYTIC_AA\"",\n     # Experiment to diagnose image diffs in Google3\n     \""SK_DISABLE_SSSE3_RUNTIME_CHECK_FOR_LOWP_STAGES\"",\n+    \""SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\"",\n ]\n \n ################################################################################\n""}<_**next**_>{""filename"": ""src/codec/SkIcoCodec.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/codec/SkIcoCodec.cpp"", ""patch"": ""@@ -58,8 +58,7 @@\n\n         uint32_t offset;\n         uint32_t size;\n     };\n-    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,\n-                                              SK_MALLOC_TEMP));\n+    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));\n     if (!dirEntryBuffer) {\n         SkCodecPrintf(\""Error: OOM allocating ICO directory for %i images.\\n\"",\n                       numImages);\n@@ -135,7 +134,7 @@\n\n         bytesRead = offset;\n \n         // Create a new stream for the embedded codec\n-        SkAutoFree buffer(sk_malloc_flags(size, 0));\n+        SkAutoFree buffer(sk_malloc_canfail(size));\n         if (!buffer) {\n             SkCodecPrintf(\""Warning: OOM trying to create embedded stream.\\n\"");\n             break;\n""}<_**next**_>{""filename"": ""src/core/SkAutoMalloc.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkAutoMalloc.h"", ""patch"": ""@@ -144,7 +144,7 @@\n\n                 SkASSERT(fPtr != fStorage); // otherwise we lied when setting didChangeAlloc.\n                 fPtr = fStorage;\n             } else {\n-                fPtr = sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_TEMP);\n+                fPtr = sk_malloc_throw(size);\n             }\n \n             fSize = size;\n""}<_**next**_>{""filename"": ""src/core/SkAutoPixmapStorage.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkAutoPixmapStorage.cpp"", ""patch"": ""@@ -40,7 +40,7 @@\n\n     if (0 == size) {\n         return false;\n     }\n-    void* pixels = sk_malloc_flags(size, 0);\n+    void* pixels = sk_malloc_canfail(size);\n     if (nullptr == pixels) {\n         return false;\n     }\n""}<_**next**_>{""filename"": ""src/core/SkMallocPixelRef.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkMallocPixelRef.cpp"", ""patch"": ""@@ -8,8 +8,27 @@\n\n #include \""SkMallocPixelRef.h\""\n #include \""SkBitmap.h\""\n #include \""SkReadBuffer.h\""\n+#include \""SkSafeMath.h\""\n #include \""SkWriteBuffer.h\""\n \n+void* sk_calloc_throw(size_t count, size_t elemSize) {\n+    return sk_calloc_throw(SkSafeMath::Mul(count, elemSize));\n+}\n+\n+void* sk_malloc_throw(size_t count, size_t elemSize) {\n+    return sk_malloc_throw(SkSafeMath::Mul(count, elemSize));\n+}\n+\n+void* sk_realloc_throw(void* buffer, size_t count, size_t elemSize) {\n+    return sk_realloc_throw(buffer, SkSafeMath::Mul(count, elemSize));\n+}\n+\n+void* sk_malloc_canfail(size_t count, size_t elemSize) {\n+    return sk_malloc_canfail(SkSafeMath::Mul(count, elemSize));\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n // assumes ptr was allocated via sk_malloc\n static void sk_free_releaseproc(void* ptr, void*) {\n     sk_free(ptr);\n@@ -82,7 +101,7 @@\n\n \n sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& info,\n                                                size_t rowBytes) {\n-    return MakeUsing(sk_calloc, info, rowBytes);\n+    return MakeUsing(sk_calloc_canfail, info, rowBytes);\n }\n \n static void sk_data_releaseproc(void*, void* dataPtr) {\n""}<_**next**_>{""filename"": ""src/core/SkMath.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkMath.cpp"", ""patch"": ""@@ -9,6 +9,7 @@\n\n #include \""SkFixed.h\""\n #include \""SkFloatBits.h\""\n #include \""SkFloatingPoint.h\""\n+#include \""SkSafeMath.h\""\n #include \""SkScalar.h\""\n \n #define sub_shift(zeros, x, n)  \\\n@@ -67,8 +68,6 @@\n\n     return root;\n }\n \n-///////////////////////////////////////////////////////////////////////////////\n-\n float SkScalarSinCos(float radians, float* cosValue) {\n     float sinValue = sk_float_sin(radians);\n \n@@ -84,3 +83,17 @@\n\n     }\n     return sinValue;\n }\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+size_t SkSafeMath::Add(size_t x, size_t y) {\n+    SkSafeMath tmp;\n+    size_t sum = tmp.add(x, y);\n+    return tmp.ok() ? sum : SK_MaxSizeT;\n+}\n+\n+size_t SkSafeMath::Mul(size_t x, size_t y) {\n+    SkSafeMath tmp;\n+    size_t prod = tmp.mul(x, y);\n+    return tmp.ok() ? prod : SK_MaxSizeT;\n+}\n""}<_**next**_>{""filename"": ""src/core/SkRegion_path.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkRegion_path.cpp"", ""patch"": ""@@ -144,12 +144,7 @@\n\n     }\n     fStorageCount = sk_64_asS32(count);\n \n-    int64_t size = sk_64_mul(fStorageCount, sizeof(SkRegion::RunType));\n-    if (size < 0 || !sk_64_isS32(size)) {\n-        return false;\n-    }\n-\n-    fStorage = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(size), 0);\n+    fStorage = (SkRegion::RunType*)sk_malloc_canfail(fStorageCount, sizeof(SkRegion::RunType));\n     if (nullptr == fStorage) {\n         return false;\n     }\n""}<_**next**_>{""filename"": ""src/core/SkSafeMath.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/core/SkSafeMath.h"", ""patch"": ""@@ -0,0 +1,106 @@\n\n+/*\n+ * Copyright 2017 Google Inc.\n+ *\n+ * Use of this source code is governed by a BSD-style license that can be\n+ * found in the LICENSE file.\n+ */\n+\n+#ifndef SkSafeMath_DEFINED\n+#define SkSafeMath_DEFINED\n+\n+#include \""SkTypes.h\""\n+\n+// SkSafeMath always check that a series of operations do not overflow.\n+// This must be correct for all platforms, because this is a check for safety at runtime.\n+\n+class SkSafeMath {\n+public:\n+    SkSafeMath() = default;\n+\n+    bool ok() const { return fOK; }\n+    explicit operator bool() const { return fOK; }\n+\n+    size_t mul(size_t x, size_t y) {\n+        return sizeof(size_t) == sizeof(uint64_t) ? mul64(x, y) : mul32(x, y);\n+    }\n+\n+    size_t add(size_t x, size_t y) {\n+        size_t result = x + y;\n+        fOK &= result >= x;\n+        return result;\n+    }\n+\n+    /**\n+     *  Return a + b, unless this result is an overflow/underflow. In those cases, fOK will\n+     *  be set to false, and it is undefined what this returns.\n+     */\n+    int addInt(int a, int b) {\n+        if (b < 0 && a < std::numeric_limits<int>::min() - b) {\n+            fOK = false;\n+            return a;\n+        } else if (b > 0 && a > std::numeric_limits<int>::max() - b) {\n+            fOK = false;\n+            return a;\n+        }\n+        return a + b;\n+    }\n+\n+    size_t alignUp(size_t x, size_t alignment) {\n+        SkASSERT(alignment && !(alignment & (alignment - 1)));\n+        return add(x, alignment - 1) & ~(alignment - 1);\n+    }\n+\n+    template <typename T> T castTo(size_t value) {\n+        if (!SkTFitsIn<T>(value)) {\n+            fOK = false;\n+        }\n+        return static_cast<T>(value);\n+    }\n+\n+    // These saturate to their results\n+    static size_t Add(size_t x, size_t y);\n+    static size_t Mul(size_t x, size_t y);\n+    static size_t Align4(size_t x) {\n+        SkSafeMath safe;\n+        return safe.alignUp(x, 4);\n+    }\n+\n+private:\n+    uint32_t mul32(uint32_t x, uint32_t y) {\n+        uint64_t bx = x;\n+        uint64_t by = y;\n+        uint64_t result = bx * by;\n+        fOK &= result >> 32 == 0;\n+        return result;\n+    }\n+\n+    uint64_t mul64(uint64_t x, uint64_t y) {\n+        if (x <= std::numeric_limits<uint64_t>::max() >> 32\n+            && y <= std::numeric_limits<uint64_t>::max() >> 32) {\n+            return x * y;\n+        } else {\n+            auto hi = [](uint64_t x) { return x >> 32; };\n+            auto lo = [](uint64_t x) { return x & 0xFFFFFFFF; };\n+\n+            uint64_t lx_ly = lo(x) * lo(y);\n+            uint64_t hx_ly = hi(x) * lo(y);\n+            uint64_t lx_hy = lo(x) * hi(y);\n+            uint64_t hx_hy = hi(x) * hi(y);\n+            uint64_t result = 0;\n+            result = this->add(lx_ly, (hx_ly << 32));\n+            result = this->add(result, (lx_hy << 32));\n+            fOK &= (hx_hy + (hx_ly >> 32) + (lx_hy >> 32)) == 0;\n+\n+            #if defined(SK_DEBUG) && defined(__clang__) && defined(__x86_64__)\n+                auto double_check = (unsigned __int128)x * y;\n+                SkASSERT(result == (double_check & 0xFFFFFFFFFFFFFFFF));\n+                SkASSERT(!fOK || (double_check >> 64 == 0));\n+            #endif\n+\n+            return result;\n+        }\n+    }\n+    bool fOK = true;\n+};\n+\n+#endif//SkSafeMath_DEFINED\n""}<_**next**_>{""filename"": ""src/gpu/GrBuffer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/gpu/GrBuffer.cpp"", ""patch"": ""@@ -16,7 +16,7 @@\n\n     if (gpu->caps()->mustClearUploadedBufferData()) {\n         cpuData = sk_calloc_throw(sizeInBytes);\n     } else {\n-        cpuData = sk_malloc_flags(sizeInBytes, SK_MALLOC_THROW);\n+        cpuData = sk_malloc_throw(sizeInBytes);\n     }\n     if (data) {\n         memcpy(cpuData, data, sizeInBytes);\n""}<_**next**_>{""filename"": ""src/ports/SkMemory_malloc.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/ports/SkMemory_malloc.cpp"", ""patch"": ""@@ -55,10 +55,6 @@\n\n #endif\n }\n \n-void* sk_malloc_throw(size_t size) {\n-    return sk_malloc_flags(size, SK_MALLOC_THROW);\n-}\n-\n void* sk_realloc_throw(void* addr, size_t size) {\n     return throw_on_failure(size, realloc(addr, size));\n }\n@@ -70,7 +66,16 @@\n\n }\n \n void* sk_malloc_flags(size_t size, unsigned flags) {\n-    void* p = malloc(size);\n+    void* p;\n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+    p = malloc(size);\n+#else\n+    if (flags & SK_MALLOC_ZERO_INITIALIZE) {\n+        p = calloc(size, 1);\n+    } else {\n+        p = malloc(size);\n+    }\n+#endif\n     if (flags & SK_MALLOC_THROW) {\n         return throw_on_failure(size, p);\n     } else {\n@@ -78,10 +83,15 @@\n\n     }\n }\n \n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+void* sk_malloc_throw(size_t size) {\n+    return sk_malloc_flags(size, SK_MALLOC_THROW);\n+}\n void* sk_calloc(size_t size) {\n     return calloc(size, 1);\n }\n-\n void* sk_calloc_throw(size_t size) {\n     return throw_on_failure(size, sk_calloc(size));\n }\n+#endif\n+\n""}<_**next**_>{""filename"": ""src/ports/SkMemory_mozalloc.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/src/ports/SkMemory_mozalloc.cpp"", ""patch"": ""@@ -22,20 +22,26 @@\n\n     mozalloc_handle_oom(0);\n }\n \n-void* sk_malloc_throw(size_t size) {\n-    return sk_malloc_flags(size, SK_MALLOC_THROW);\n+void sk_free(void* p) {\n+    free(p);\n }\n \n void* sk_realloc_throw(void* addr, size_t size) {\n     return moz_xrealloc(addr, size);\n }\n \n-void sk_free(void* p) {\n-    free(p);\n+void* sk_malloc_flags(size_t size, unsigned flags) {\n+#ifndef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+    if (flags & SK_MALLOC_ZERO_INITIALIZE) {\n+        return (flags & SK_MALLOC_THROW) ? moz_xcalloc(size, 1) : calloc(size, 1);\n+    }\n+#endif\n+    return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);\n }\n \n-void* sk_malloc_flags(size_t size, unsigned flags) {\n-    return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);\n+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n+void* sk_malloc_throw(size_t size) {\n+    return sk_malloc_flags(size, SK_MALLOC_THROW);\n }\n \n void* sk_calloc(size_t size) {\n@@ -45,3 +51,5 @@\n\n void* sk_calloc_throw(size_t size) {\n     return moz_xcalloc(size, 1);\n }\n+#endif\n+\n""}","SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
    std::unique_ptr<SkStream> inputStream(stream);

 static const uint32_t kIcoDirectoryBytes = 6;
 static const uint32_t kIcoDirEntryBytes = 16;

    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
 if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
 SkCodecPrintf(""Error: unable to read ico directory header.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 const uint16_t numImages = get_short(dirBuffer.get(), 4);
 if (0 == numImages) {
 SkCodecPrintf(""Error: No images embedded in ico.\n"");
 *result = kInvalidInput;
 return nullptr;
 }

 struct Entry {

         uint32_t offset;
         uint32_t size;
     };
    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
 *result = kInternalError;
 return nullptr;
 }
 auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

 for (uint32_t i = 0; i < numImages; i++) {
 uint8_t entryBuffer[kIcoDirEntryBytes];
 if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
 SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }


 uint32_t size = get_int(entryBuffer, 8);

 uint32_t offset = get_int(entryBuffer, 12);

        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
 }

 *result = kInvalidInput;

 struct EntryLessThan {
 bool operator() (Entry a, Entry b) const {
 return a.offset < b.offset;
 }
 };
 EntryLessThan lessThan;
 SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

 uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
 new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
 for (uint32_t i = 0; i < numImages; i++) {
 uint32_t offset = directoryEntries[i].offset;
 uint32_t size = directoryEntries[i].size;

 if (offset < bytesRead) {
 SkCodecPrintf(""Warning: invalid ico offset.\n"");
 continue;
 }

 if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
 SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
 break;
 }

         bytesRead = offset;
 
        SkAutoFree buffer(sk_malloc_canfail(size));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
 }

 if (inputStream->read(buffer.get(), size) != size) {
 SkCodecPrintf(""Warning: could not create embedded stream.\n"");
 *result = kIncompleteInput;
 break;
 }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

 SkCodec* codec = nullptr;
 Result dummyResult;
 if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
 } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
 }

 if (nullptr != codec) {
            codecs->push_back().reset(codec);
 }
 }

 if (0 == codecs->count()) {
 SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
 return nullptr;
 }

 size_t maxSize = 0;
 int maxIndex = 0;
 for (int i = 0; i < codecs->count(); i++) {
 SkImageInfo info = codecs->operator[](i)->getInfo();
 size_t size = info.getSafeSize(info.minRowBytes());

 if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
 }
 }
 int width = codecs->operator[](maxIndex)->getInfo().width();
 int height = codecs->operator[](maxIndex)->getInfo().height();
 SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
 SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

 *result = kSuccess;
 return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}
","SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
    std::unique_ptr<SkStream> inputStream(stream);

 static const uint32_t kIcoDirectoryBytes = 6;
 static const uint32_t kIcoDirEntryBytes = 16;

    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
 if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
 SkCodecPrintf(""Error: unable to read ico directory header.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 const uint16_t numImages = get_short(dirBuffer.get(), 4);
 if (0 == numImages) {
 SkCodecPrintf(""Error: No images embedded in ico.\n"");
 *result = kInvalidInput;
 return nullptr;
 }

 struct Entry {

         uint32_t offset;
         uint32_t size;
     };
    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
                                              SK_MALLOC_TEMP));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
 *result = kInternalError;
 return nullptr;
 }
 auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

 for (uint32_t i = 0; i < numImages; i++) {
 uint8_t entryBuffer[kIcoDirEntryBytes];
 if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
 SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }


 uint32_t size = get_int(entryBuffer, 8);

 uint32_t offset = get_int(entryBuffer, 12);

        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
 }

 *result = kInvalidInput;

 struct EntryLessThan {
 bool operator() (Entry a, Entry b) const {
 return a.offset < b.offset;
 }
 };
 EntryLessThan lessThan;
 SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

 uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
 new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
 for (uint32_t i = 0; i < numImages; i++) {
 uint32_t offset = directoryEntries[i].offset;
 uint32_t size = directoryEntries[i].size;

 if (offset < bytesRead) {
 SkCodecPrintf(""Warning: invalid ico offset.\n"");
 continue;
 }

 if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
 SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
 break;
 }

         bytesRead = offset;
 
        SkAutoFree buffer(sk_malloc_flags(size, 0));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
 }

 if (inputStream->read(buffer.get(), size) != size) {
 SkCodecPrintf(""Warning: could not create embedded stream.\n"");
 *result = kIncompleteInput;
 break;
 }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

 SkCodec* codec = nullptr;
 Result dummyResult;
 if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
 } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
 }

 if (nullptr != codec) {
            codecs->push_back().reset(codec);
 }
 }

 if (0 == codecs->count()) {
 SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
 return nullptr;
 }

 size_t maxSize = 0;
 int maxIndex = 0;
 for (int i = 0; i < codecs->count(); i++) {
 SkImageInfo info = codecs->operator[](i)->getInfo();
 size_t size = info.getSafeSize(info.minRowBytes());

 if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
 }
 }
 int width = codecs->operator[](maxIndex)->getInfo().width();
 int height = codecs->operator[](maxIndex)->getInfo().height();
 SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
 SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

 *result = kSuccess;
 return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}
",C,"    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
        SkAutoFree buffer(sk_malloc_canfail(size));
","    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
                                              SK_MALLOC_TEMP));
        SkAutoFree buffer(sk_malloc_flags(size, 0));
",,"@@ -58,8 +58,7 @@

         uint32_t offset;
         uint32_t size;
     };
-    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
-                                              SK_MALLOC_TEMP));
+    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
@@ -135,7 +134,7 @@

         bytesRead = offset;
 
         // Create a new stream for the embedded codec
-        SkAutoFree buffer(sk_malloc_flags(size, 0));
+        SkAutoFree buffer(sk_malloc_canfail(size));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
",Android,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4/,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4%5E/,1,"SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
 // Ensure that we do not leak the input stream
    std::unique_ptr<SkStream> inputStream(stream);

 // Header size constants
 static const uint32_t kIcoDirectoryBytes = 6;
 static const uint32_t kIcoDirEntryBytes = 16;

 // Read the directory header
    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
 if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
 SkCodecPrintf(""Error: unable to read ico directory header.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 // Process the directory header
 const uint16_t numImages = get_short(dirBuffer.get(), 4);
 if (0 == numImages) {
 SkCodecPrintf(""Error: No images embedded in ico.\n"");
 *result = kInvalidInput;
 return nullptr;
 }

 // This structure is used to represent the vital information about entries
 // in the directory header.  We will obtain this information for each
 // directory entry.
 struct Entry {

         uint32_t offset;
         uint32_t size;
     };
//flaw_line_below:
    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
//flaw_line_below:
                                              SK_MALLOC_TEMP));
//fix_flaw_line_below:
//    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
 *result = kInternalError;
 return nullptr;
 }
 auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

 // Iterate over directory entries
 for (uint32_t i = 0; i < numImages; i++) {
 uint8_t entryBuffer[kIcoDirEntryBytes];
 if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
 SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 // The directory entry contains information such as width, height,
 // bits per pixel, and number of colors in the color palette.  We will
 // ignore these fields since they are repeated in the header of the
 // embedded image.  In the event of an inconsistency, we would always
 // defer to the value in the embedded header anyway.

 // Specifies the size of the embedded image, including the header
 uint32_t size = get_int(entryBuffer, 8);

 // Specifies the offset of the embedded image from the start of file.
 // It does not indicate the start of the pixel data, but rather the
 // start of the embedded image header.
 uint32_t offset = get_int(entryBuffer, 12);

 // Save the vital fields
        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
 }

 // Default Result, if no valid embedded codecs are found.
 *result = kInvalidInput;

 // It is ""customary"" that the embedded images will be stored in order of
 // increasing offset.  However, the specification does not indicate that
 // they must be stored in this order, so we will not trust that this is the
 // case.  Here we sort the embedded images by increasing offset.
 struct EntryLessThan {
 bool operator() (Entry a, Entry b) const {
 return a.offset < b.offset;
 }
 };
 EntryLessThan lessThan;
 SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

 // Now will construct a candidate codec for each of the embedded images
 uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
 new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
 for (uint32_t i = 0; i < numImages; i++) {
 uint32_t offset = directoryEntries[i].offset;
 uint32_t size = directoryEntries[i].size;

 // Ensure that the offset is valid
 if (offset < bytesRead) {
 SkCodecPrintf(""Warning: invalid ico offset.\n"");
 continue;
 }

 // If we cannot skip, assume we have reached the end of the stream and
 // stop trying to make codecs
 if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
 SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
 break;
 }

         bytesRead = offset;
 
         // Create a new stream for the embedded codec
//flaw_line_below:
        SkAutoFree buffer(sk_malloc_flags(size, 0));
//fix_flaw_line_below:
//        SkAutoFree buffer(sk_malloc_canfail(size));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
 }

 if (inputStream->read(buffer.get(), size) != size) {
 SkCodecPrintf(""Warning: could not create embedded stream.\n"");
 *result = kIncompleteInput;
 break;
 }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

 // Check if the embedded codec is bmp or png and create the codec
 SkCodec* codec = nullptr;
 Result dummyResult;
 if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
 } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
 }

 // Save a valid codec
 if (nullptr != codec) {
            codecs->push_back().reset(codec);
 }
 }

 // Recognize if there are no valid codecs
 if (0 == codecs->count()) {
 SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
 return nullptr;
 }

 // Use the largest codec as a ""suggestion"" for image info
 size_t maxSize = 0;
 int maxIndex = 0;
 for (int i = 0; i < codecs->count(); i++) {
 SkImageInfo info = codecs->operator[](i)->getInfo();
 size_t size = info.getSafeSize(info.minRowBytes());

 if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
 }
 }
 int width = codecs->operator[](maxIndex)->getInfo().width();
 int height = codecs->operator[](maxIndex)->getInfo().height();
 SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
 SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

 *result = kSuccess;
 // The original stream is no longer needed, because the embedded codecs own their
 // own streams.
 return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}
",188106,"SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
    std::unique_ptr<SkStream> inputStream(stream);

 static const uint32_t kIcoDirectoryBytes = 6;
 static const uint32_t kIcoDirEntryBytes = 16;

    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
 if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
 SkCodecPrintf(""Error: unable to read ico directory header.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 const uint16_t numImages = get_short(dirBuffer.get(), 4);
 if (0 == numImages) {
 SkCodecPrintf(""Error: No images embedded in ico.\n"");
 *result = kInvalidInput;
 return nullptr;
 }

 struct Entry {

         uint32_t offset;
         uint32_t size;
     };
    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
                                              SK_MALLOC_TEMP));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
 *result = kInternalError;
 return nullptr;
 }
 auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

 for (uint32_t i = 0; i < numImages; i++) {
 uint8_t entryBuffer[kIcoDirEntryBytes];
 if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
 SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }


 uint32_t size = get_int(entryBuffer, 8);

 uint32_t offset = get_int(entryBuffer, 12);

        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
 }

 *result = kInvalidInput;

 struct EntryLessThan {
 bool operator() (Entry a, Entry b) const {
 return a.offset < b.offset;
 }
 };
 EntryLessThan lessThan;
 SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

 uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
 new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
 for (uint32_t i = 0; i < numImages; i++) {
 uint32_t offset = directoryEntries[i].offset;
 uint32_t size = directoryEntries[i].size;

 if (offset < bytesRead) {
 SkCodecPrintf(""Warning: invalid ico offset.\n"");
 continue;
 }

 if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
 SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
 break;
 }

         bytesRead = offset;
 
        SkAutoFree buffer(sk_malloc_flags(size, 0));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
 }

 if (inputStream->read(buffer.get(), size) != size) {
 SkCodecPrintf(""Warning: could not create embedded stream.\n"");
 *result = kIncompleteInput;
 break;
 }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

 SkCodec* codec = nullptr;
 Result dummyResult;
 if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
 } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
 }

 if (nullptr != codec) {
            codecs->push_back().reset(codec);
 }
 }

 if (0 == codecs->count()) {
 SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
 return nullptr;
 }

 size_t maxSize = 0;
 int maxIndex = 0;
 for (int i = 0; i < codecs->count(); i++) {
 SkImageInfo info = codecs->operator[](i)->getInfo();
 size_t size = info.getSafeSize(info.minRowBytes());

 if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
 }
 }
 int width = codecs->operator[](maxIndex)->getInfo().width();
 int height = codecs->operator[](maxIndex)->getInfo().height();
 SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
 SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

 *result = kSuccess;
 return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}
","SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
    std::unique_ptr<SkStream> inputStream(stream);

 static const uint32_t kIcoDirectoryBytes = 6;
 static const uint32_t kIcoDirEntryBytes = 16;

    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
 if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
 SkCodecPrintf(""Error: unable to read ico directory header.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }

 const uint16_t numImages = get_short(dirBuffer.get(), 4);
 if (0 == numImages) {
 SkCodecPrintf(""Error: No images embedded in ico.\n"");
 *result = kInvalidInput;
 return nullptr;
 }

 struct Entry {

         uint32_t offset;
         uint32_t size;
     };
    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
 *result = kInternalError;
 return nullptr;
 }
 auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

 for (uint32_t i = 0; i < numImages; i++) {
 uint8_t entryBuffer[kIcoDirEntryBytes];
 if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
 SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
 *result = kIncompleteInput;
 return nullptr;
 }


 uint32_t size = get_int(entryBuffer, 8);

 uint32_t offset = get_int(entryBuffer, 12);

        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
 }

 *result = kInvalidInput;

 struct EntryLessThan {
 bool operator() (Entry a, Entry b) const {
 return a.offset < b.offset;
 }
 };
 EntryLessThan lessThan;
 SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

 uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
 new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
 for (uint32_t i = 0; i < numImages; i++) {
 uint32_t offset = directoryEntries[i].offset;
 uint32_t size = directoryEntries[i].size;

 if (offset < bytesRead) {
 SkCodecPrintf(""Warning: invalid ico offset.\n"");
 continue;
 }

 if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
 SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
 break;
 }

         bytesRead = offset;
 
        SkAutoFree buffer(sk_malloc_canfail(size));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;
 }

 if (inputStream->read(buffer.get(), size) != size) {
 SkCodecPrintf(""Warning: could not create embedded stream.\n"");
 *result = kIncompleteInput;
 break;
 }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

 SkCodec* codec = nullptr;
 Result dummyResult;
 if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
 } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
 }

 if (nullptr != codec) {
            codecs->push_back().reset(codec);
 }
 }

 if (0 == codecs->count()) {
 SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
 return nullptr;
 }

 size_t maxSize = 0;
 int maxIndex = 0;
 for (int i = 0; i < codecs->count(); i++) {
 SkImageInfo info = codecs->operator[](i)->getInfo();
 size_t size = info.getSafeSize(info.minRowBytes());

 if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
 }
 }
 int width = codecs->operator[](maxIndex)->getInfo().width();
 int height = codecs->operator[](maxIndex)->getInfo().height();
 SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
 SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

 *result = kSuccess;
 return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}
","The vulnerability in the original code stemmed from the use of `sk_malloc_flags` for memory allocation, which could lead to out-of-memory (OOM) errors without proper handling, potentially causing crashes or undefined behavior. Specifically, the allocation of `dirEntryBuffer` and `buffer` did not account for allocation failures, allowing the program to proceed with null pointers. The fix implemented in the changed code replaced `sk_malloc_flags` with `sk_malloc_canfail`, which ensures that memory allocation failures are handled gracefully. This change allows the program to check for null pointers and respond appropriately, enhancing stability and security.","The vulnerability in the original code arose from inadequate handling of memory allocation failures, which could lead to crashes or undefined behavior if the program attempted to use null pointers after a failed allocation. Specifically, the code did not check whether memory was successfully allocated before proceeding with operations that relied on that memory. The fix in the updated code involved using a safer memory allocation method that explicitly accounts for potential failures. This change ensures that the program can detect allocation issues and respond appropriately, thereby improving overall stability and security.",4,5,5,5
