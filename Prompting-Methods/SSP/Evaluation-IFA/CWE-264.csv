,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,F1_Clarity_C5,F2_Relevance_C5,F3_Completeness_C5,F4_Actionability_C5,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,0,46443,46443,,Local,Not required,Complete,CVE-2014-7822,https://www.cvedetails.com/cve/CVE-2014-7822/,CWE-264,Low,Complete,Complete,,2015-03-16,7.2,"The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, as demonstrated by use of a file descriptor associated with an ext4 filesystem.",2017-01-02,DoS ,0,https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958,8d0207652cbe27d1f962050737848e5ad4671958,"->splice_write() via ->write_iter()

iter_file_splice_write() - a ->splice_write() instance that gathers the
pipe buffers, builds a bio_vec-based iov_iter covering those and feeds
it to ->write_iter().  A bunch of simple cases coverted to that...

[AV: fixed the braino spotted by Cyrill]

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/xfs/xfs_file.c,"{""sha"": ""e68e150b1b163c15da172cfa60ed832d14841495"", ""filename"": ""fs/block_dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/block_dev.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1583,7 +1583,7 @@ const struct file_operations def_blk_fops = {\n \t.compat_ioctl\t= compat_blkdev_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)""}<_**next**_>{""sha"": ""71bf8e4fb5d427c660e9913a57054dec59f99dfc"", ""filename"": ""fs/exofs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exofs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -77,7 +77,7 @@ const struct file_operations exofs_file_operations = {\n \t.fsync\t\t= exofs_file_fsync,\n \t.flush\t\t= exofs_flush,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations exofs_file_inode_operations = {""}<_**next**_>{""sha"": ""7c87b22a7228c4ce9ed3c915c64283e2aa72a328"", ""filename"": ""fs/ext2/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -75,7 +75,7 @@ const struct file_operations ext2_file_operations = {\n \t.release\t= ext2_release_file,\n \t.fsync\t\t= ext2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n #ifdef CONFIG_EXT2_FS_XIP""}<_**next**_>{""sha"": ""a062fa1e1b113e56e7545bb4c6bac7ac1bf7d741"", ""filename"": ""fs/ext3/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext3/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -63,7 +63,7 @@ const struct file_operations ext3_file_operations = {\n \t.release\t= ext3_release_file,\n \t.fsync\t\t= ext3_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations ext3_file_inode_operations = {""}<_**next**_>{""sha"": ""708aad7681991368262332520f09f5490af848de"", ""filename"": ""fs/ext4/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -599,7 +599,7 @@ const struct file_operations ext4_file_operations = {\n \t.release\t= ext4_release_file,\n \t.fsync\t\t= ext4_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fallocate\t= ext4_fallocate,\n };\n ""}<_**next**_>{""sha"": ""e4ba4b93f96a90e70c173fa309b242c0390ef8cf"", ""filename"": ""fs/f2fs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -692,5 +692,5 @@ const struct file_operations f2fs_file_operations = {\n \t.compat_ioctl\t= f2fs_compat_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };""}<_**next**_>{""sha"": ""01b4c5b1bff8ddd152a6b93ac3b5249d3d0a49a8"", ""filename"": ""fs/gfs2/file.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1068,7 +1068,7 @@ const struct file_operations gfs2_file_fops = {\n \t.lock\t\t= gfs2_lock,\n \t.flock\t\t= gfs2_flock,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= gfs2_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };\n@@ -1098,7 +1098,7 @@ const struct file_operations gfs2_file_fops_nolock = {\n \t.release\t= gfs2_release,\n \t.fsync\t\t= gfs2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= generic_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };""}<_**next**_>{""sha"": ""33aa0cc1f8b863b7b101bec470af4238d0c6eeb1"", ""filename"": ""fs/jfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -157,7 +157,7 @@ const struct file_operations jfs_file_operations = {\n \t.write_iter\t= generic_file_write_iter,\n \t.mmap\t\t= generic_file_mmap,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fsync\t\t= jfs_fsync,\n \t.release\t= jfs_release,\n \t.unlocked_ioctl = jfs_ioctl,""}<_**next**_>{""sha"": ""4f56de822d2f5995b81006e0bc9783d321b1621d"", ""filename"": ""fs/ramfs/file-mmu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-mmu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -38,7 +38,7 @@ const struct file_operations ramfs_file_operations = {\n \t.mmap\t\t= generic_file_mmap,\n \t.fsync\t\t= noop_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.llseek\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""dda012ad4208d3192521c80a082af5ff038f5b3b"", ""filename"": ""fs/ramfs/file-nommu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-nommu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -43,7 +43,7 @@ const struct file_operations ramfs_file_operations = {\n \t.write_iter\t\t= generic_file_write_iter,\n \t.fsync\t\t\t= noop_fsync,\n \t.splice_read\t\t= generic_file_splice_read,\n-\t.splice_write\t\t= generic_file_splice_write,\n+\t.splice_write\t\t= iter_file_splice_write,\n \t.llseek\t\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f070cc827456b68cc3dd3a79bab4009a2c5a2924"", ""filename"": ""fs/reiserfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -248,7 +248,7 @@ const struct file_operations reiserfs_file_operations = {\n \t.read_iter = generic_file_read_iter,\n \t.write_iter = generic_file_write_iter,\n \t.splice_read = generic_file_splice_read,\n-\t.splice_write = generic_file_splice_write,\n+\t.splice_write = iter_file_splice_write,\n \t.llseek = generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f195a9b89fb22ea64ac5e8fda4af03d0ae3f16e3"", ""filename"": ""fs/splice.c"", ""status"": ""modified"", ""additions"": 140, ""deletions"": 0, ""changes"": 140, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/splice.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -32,6 +32,7 @@\n #include <linux/gfp.h>\n #include <linux/socket.h>\n #include <linux/compat.h>\n+#include <linux/aio.h>\n #include \""internal.h\""\n \n /*\n@@ -1052,6 +1053,145 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n \n EXPORT_SYMBOL(generic_file_splice_write);\n \n+/**\n+ * iter_file_splice_write - splice data from a pipe to a file\n+ * @pipe:\tpipe info\n+ * @out:\tfile to write to\n+ * @ppos:\tposition in @out\n+ * @len:\tnumber of bytes to splice\n+ * @flags:\tsplice modifier flags\n+ *\n+ * Description:\n+ *    Will either move or copy pages (determined by @flags options) from\n+ *    the given pipe inode to the given file.\n+ *    This one is ->write_iter-based.\n+ *\n+ */\n+ssize_t\n+iter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n+\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n+{\n+\tstruct splice_desc sd = {\n+\t\t.total_len = len,\n+\t\t.flags = flags,\n+\t\t.pos = *ppos,\n+\t\t.u.file = out,\n+\t};\n+\tint nbufs = pipe->buffers;\n+\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\tssize_t ret;\n+\n+\tif (unlikely(!array))\n+\t\treturn -ENOMEM;\n+\n+\tpipe_lock(pipe);\n+\n+\tsplice_from_pipe_begin(&sd);\n+\twhile (sd.total_len) {\n+\t\tstruct iov_iter from;\n+\t\tstruct kiocb kiocb;\n+\t\tsize_t left;\n+\t\tint n, idx;\n+\n+\t\tret = splice_from_pipe_next(pipe, &sd);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tif (unlikely(nbufs < pipe->buffers)) {\n+\t\t\tkfree(array);\n+\t\t\tnbufs = pipe->buffers;\n+\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\t\t\tif (!array) {\n+\t\t\t\tret = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* build the vector */\n+\t\tleft = sd.total_len;\n+\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n+\t\t\tsize_t this_len = buf->len;\n+\n+\t\t\tif (this_len > left)\n+\t\t\t\tthis_len = left;\n+\n+\t\t\tif (idx == pipe->buffers - 1)\n+\t\t\t\tidx = -1;\n+\n+\t\t\tret = buf->ops->confirm(pipe, buf);\n+\t\t\tif (unlikely(ret)) {\n+\t\t\t\tif (ret == -ENODATA)\n+\t\t\t\t\tret = 0;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tarray[n].bv_page = buf->page;\n+\t\t\tarray[n].bv_len = this_len;\n+\t\t\tarray[n].bv_offset = buf->offset;\n+\t\t\tleft -= this_len;\n+\t\t}\n+\n+\t\t/* ... iov_iter */\n+\t\tfrom.type = ITER_BVEC | WRITE;\n+\t\tfrom.bvec = array;\n+\t\tfrom.nr_segs = n;\n+\t\tfrom.count = sd.total_len - left;\n+\t\tfrom.iov_offset = 0;\n+\n+\t\t/* ... and iocb */\n+\t\tinit_sync_kiocb(&kiocb, out);\n+\t\tkiocb.ki_pos = sd.pos;\n+\t\tkiocb.ki_nbytes = sd.total_len - left;\n+\n+\t\t/* now, send it */\n+\t\tret = out->f_op->write_iter(&kiocb, &from);\n+\t\tif (-EIOCBQUEUED == ret)\n+\t\t\tret = wait_on_sync_kiocb(&kiocb);\n+\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tsd.num_spliced += ret;\n+\t\tsd.total_len -= ret;\n+\t\t*ppos = sd.pos = kiocb.ki_pos;\n+\n+\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n+\t\twhile (ret) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n+\t\t\tif (ret >= buf->len) {\n+\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n+\t\t\t\tret -= buf->len;\n+\t\t\t\tbuf->len = 0;\n+\t\t\t\tbuf->ops = NULL;\n+\t\t\t\tops->release(pipe, buf);\n+\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n+\t\t\t\tpipe->nrbufs--;\n+\t\t\t\tif (pipe->files)\n+\t\t\t\t\tsd.need_wakeup = true;\n+\t\t\t} else {\n+\t\t\t\tbuf->offset += ret;\n+\t\t\t\tbuf->len -= ret;\n+\t\t\t\tret = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tkfree(array);\n+\tsplice_from_pipe_end(pipe, &sd);\n+\n+\tpipe_unlock(pipe);\n+\n+\tif (sd.num_spliced)\n+\t\tret = sd.num_spliced;\n+\n+\treturn ret;\n+}\n+\n+EXPORT_SYMBOL(iter_file_splice_write);\n+\n static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n \t\t\t  struct splice_desc *sd)\n {""}<_**next**_>{""sha"": ""0888502a60415223ba9285447c9e2f4425bc4076"", ""filename"": ""fs/ubifs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ubifs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1585,7 +1585,7 @@ const struct file_operations ubifs_file_operations = {\n \t.fsync          = ubifs_fsync,\n \t.unlocked_ioctl = ubifs_ioctl,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl   = ubifs_compat_ioctl,\n #endif""}<_**next**_>{""sha"": ""b1c489c1fb2e4496e8ca7d61955e32779d16e439"", ""filename"": ""fs/xfs/xfs_file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 42, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -342,47 +342,6 @@ xfs_file_splice_read(\n \treturn ret;\n }\n \n-/*\n- * xfs_file_splice_write() does not use xfs_rw_ilock() because\n- * generic_file_splice_write() takes the i_mutex itself. This, in theory,\n- * couuld cause lock inversions between the aio_write path and the splice path\n- * if someone is doing concurrent splice(2) based writes and write(2) based\n- * writes to the same inode. The only real way to fix this is to re-implement\n- * the generic code here with correct locking orders.\n- */\n-STATIC ssize_t\n-xfs_file_splice_write(\n-\tstruct pipe_inode_info\t*pipe,\n-\tstruct file\t\t*outfilp,\n-\tloff_t\t\t\t*ppos,\n-\tsize_t\t\t\tcount,\n-\tunsigned int\t\tflags)\n-{\n-\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n-\tstruct xfs_inode\t*ip = XFS_I(inode);\n-\tint\t\t\tioflags = 0;\n-\tssize_t\t\t\tret;\n-\n-\tXFS_STATS_INC(xs_write_calls);\n-\n-\tif (outfilp->f_mode & FMODE_NOCMTIME)\n-\t\tioflags |= IO_INVIS;\n-\n-\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n-\t\treturn -EIO;\n-\n-\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n-\n-\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n-\n-\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n-\tif (ret > 0)\n-\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n-\n-\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n-\treturn ret;\n-}\n-\n /*\n  * This routine is called to handle zeroing any space in the last block of the\n  * file that is beyond the EOF.  We do this since the size is being increased\n@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {\n \t.read_iter\t= xfs_file_read_iter,\n \t.write_iter\t= xfs_file_write_iter,\n \t.splice_read\t= xfs_file_splice_read,\n-\t.splice_write\t= xfs_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.unlocked_ioctl\t= xfs_file_ioctl,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl\t= xfs_file_compat_ioctl,""}<_**next**_>{""sha"": ""53182f97cf011e62e4806ce4bf3dbdfc71f00835"", ""filename"": ""fs/xfs/xfs_trace.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_trace.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1060,7 +1060,6 @@ DEFINE_RW_EVENT(xfs_file_read);\n DEFINE_RW_EVENT(xfs_file_buffered_write);\n DEFINE_RW_EVENT(xfs_file_direct_write);\n DEFINE_RW_EVENT(xfs_file_splice_read);\n-DEFINE_RW_EVENT(xfs_file_splice_write);\n \n DECLARE_EVENT_CLASS(xfs_page_class,\n \tTP_PROTO(struct inode *inode, struct page *page, unsigned long off,""}<_**next**_>{""sha"": ""8bd8ed357c7b6204308a49375e5d01af1dbd1726"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -2434,6 +2434,8 @@ extern ssize_t default_file_splice_read(struct file *, loff_t *,\n \t\tstruct pipe_inode_info *, size_t, unsigned int);\n extern ssize_t generic_file_splice_write(struct pipe_inode_info *,\n \t\tstruct file *, loff_t *, size_t, unsigned int);\n+extern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n+\t\tstruct file *, loff_t *, size_t, unsigned int);\n extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n \t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\n ""}","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",C,,,,"@@ -342,47 +342,6 @@ xfs_file_splice_read(
 	return ret;
 }
 
-/*
- * xfs_file_splice_write() does not use xfs_rw_ilock() because
- * generic_file_splice_write() takes the i_mutex itself. This, in theory,
- * couuld cause lock inversions between the aio_write path and the splice path
- * if someone is doing concurrent splice(2) based writes and write(2) based
- * writes to the same inode. The only real way to fix this is to re-implement
- * the generic code here with correct locking orders.
- */
-STATIC ssize_t
-xfs_file_splice_write(
-	struct pipe_inode_info	*pipe,
-	struct file		*outfilp,
-	loff_t			*ppos,
-	size_t			count,
-	unsigned int		flags)
-{
-	struct inode		*inode = outfilp->f_mapping->host;
-	struct xfs_inode	*ip = XFS_I(inode);
-	int			ioflags = 0;
-	ssize_t			ret;
-
-	XFS_STATS_INC(xs_write_calls);
-
-	if (outfilp->f_mode & FMODE_NOCMTIME)
-		ioflags |= IO_INVIS;
-
-	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
-		return -EIO;
-
-	xfs_ilock(ip, XFS_IOLOCK_EXCL);
-
-	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
-
-	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
-	if (ret > 0)
-		XFS_STATS_ADD(xs_write_bytes, ret);
-
-	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
-	return ret;
-}
-
 /*
  * This routine is called to handle zeroing any space in the last block of the
  * file that is beyond the EOF.  We do this since the size is being increased
@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {
 	.read_iter	= xfs_file_read_iter,
 	.write_iter	= xfs_file_write_iter,
 	.splice_read	= xfs_file_splice_read,
-	.splice_write	= xfs_file_splice_write,
+	.splice_write	= iter_file_splice_write,
 	.unlocked_ioctl	= xfs_file_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= xfs_file_compat_ioctl,",linux,8d0207652cbe27d1f962050737848e5ad4671958,62a8067a7f35dba2de501c9cb00e4cf36da90bc0,0,"xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",46443,"xfs_file_splice_write(
	struct pipe_inode_info	*pipe,
	struct file		*outfilp,
	loff_t			*ppos,
	size_t			count,
	unsigned int		flags)
{
	struct inode		*inode = outfilp->f_mapping->host;
	struct xfs_inode	*ip = XFS_I(inode);
	int			ioflags = 0;
	ssize_t			ret;
	XFS_STATS_INC(xs_write_calls);
	if (outfilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;
	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;
	xfs_ilock(ip, XFS_IOLOCK_EXCL);
	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_write_bytes, ret);
	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
	return ret;
}
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","The vulnerability in the original `xfs_file_splice_write` function stemmed from its handling of file operations without proper locking mechanisms, potentially leading to data corruption during concurrent writes. Specifically, it used `xfs_ilock` with exclusive locking, which could cause issues if multiple processes attempted to write simultaneously. The fixed code, `xfs_file_splice_read`, addresses this by implementing `xfs_rw_ilock` with shared locking, allowing multiple readers while preventing write conflicts. Additionally, it changes the function to handle reading instead of writing, ensuring that the operations are appropriately synchronized and reducing the risk of data inconsistency.","The vulnerability in the original code was related to improper handling of concurrent write operations, which could lead to data corruption when multiple processes attempted to write simultaneously. The use of exclusive locking without considering the potential for concurrent access created a risk of inconsistent data states. The revised code mitigates this issue by implementing shared locking, allowing multiple read operations while preventing write conflicts. Additionally, the function's focus was shifted from writing to reading, ensuring that the operations are appropriately synchronized and reducing the likelihood of data inconsistency during concurrent access.",4,4,2,1,"CWE-362,CWE-667,CWE-366,CWE-567,CWE-662,CWE-764,CWE-820,CWE-410,CWE-367,CWE-609",N,-1
1,1,1,177736,177736,,Remote,Single system,Partial,CVE-2015-8467,https://www.cvedetails.com/cve/CVE-2015-8467/,CWE-264,Medium,Partial,Partial,,2015-12-29,6.0,"The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",2016-12-30,Bypass,13,https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,,0,,,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
        const struct uac_to_guid {
                uint32_t uac;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",C,"       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
               uint32_t priv_to_change_from;
               bool admin_required;
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
",,a819d2b440aafa3138d95ff6e8b824da885a70e9,"@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
+               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
+               bool admin_required;
                const char *error_string;
        } map[] = {
                {
@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
+               {
+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
+                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
+               },
+               {
+                       .uac = UF_NORMAL_ACCOUNT,
+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
+               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                return ldb_module_operr(ac->module);
        }
 
-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
+       ret = dsdb_get_sd_from_ldb_message(ldb,
                                           ac, res->msgs[0], &domain_sd);
 
        if (ret != LDB_SUCCESS) {
@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                if (have_priv == false) {
                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                }
-                       } else {
+                       } else if (map[i].priv_to_change_from & user_account_control_old) {
+                               bool is_admin = security_token_has_builtin_administrators(user_token);
+                               if (is_admin == false) {
+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
+                               }
+                       } else if (map[i].guid) {
                                ret = acl_check_extended_right(ac, domain_sd,
                                                               user_token,
                                                               map[i].guid,
                                                               SEC_ADS_CONTROL_ACCESS,
                                                               sid);
+                       } else {
+                               ret = LDB_SUCCESS;
                        }
                        if (ret != LDB_SUCCESS) {
                                break;",samba,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98,1,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
//fix_flaw_line_below:
//       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
//fix_flaw_line_below:
//               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
//fix_flaw_line_below:
//               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",177736,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
	struct security_token *user_token;
	struct security_descriptor *domain_sd;
	struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
	const struct uac_to_guid {
		uint32_t uac;
		const char *oid;
		const char *guid;
		enum sec_privilege privilege;
		bool delete_is_privileged;
		const char *error_string;
	} map[] = {
		{
			.uac = UF_PASSWD_NOTREQD,
			.guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,
			.error_string = ""Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object""
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
			.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface"",
			.delete_is_privileged = true
		},
		{
			.uac = UF_TRUSTED_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		},
		{
			.uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};

	if (dsdb_module_am_system(ac->module)) {
		return LDB_SUCCESS;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		if (user_account_control & map[i].uac) {
			need_acl_check = true;
			break;
		}
	}
	if (need_acl_check == false) {
		return LDB_SUCCESS;
	}

	user_token = acl_user_token(ac->module);
	if (user_token == NULL) {
		return LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
	}

	ret = dsdb_module_search_dn(ac->module, ac, &res,
				    domain_dn,
				    sd_attrs,
				    DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
				    ac->req);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (res->count != 1) {
		return ldb_module_operr(ac->module);
	}

	ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
					   ac, res->msgs[0], &domain_sd);

	if (ret != LDB_SUCCESS) {
		return ret;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		uint32_t this_uac_new = user_account_control & map[i].uac;
		uint32_t this_uac_old = user_account_control_old & map[i].uac;
		if (this_uac_new != this_uac_old) {
			if (this_uac_old != 0) {
				if (map[i].delete_is_privileged == false) {
					continue;
				}
			}
			if (map[i].oid) {
				struct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);
				if (control == NULL) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else if (map[i].privilege != SEC_PRIV_INVALID) {
				bool have_priv = security_token_has_privilege(user_token,
									      map[i].privilege);
				if (have_priv == false) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else {
				ret = acl_check_extended_right(ac, domain_sd,
							       user_token,
							       map[i].guid,
							       SEC_ADS_CONTROL_ACCESS,
							       sid);
			}
			if (ret != LDB_SUCCESS) {
				break;
			}
		}
	}
	if (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {
		switch (ac->req->operation) {
		case LDB_ADD:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to add %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		case LDB_MODIFY:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to modify %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		default:
			return ldb_module_operr(ac->module);
		}
		if (map[i].guid) {
			dsdb_acl_debug(domain_sd, acl_user_token(ac->module),
				       domain_dn,
				       true,
				       10);
		}
	}
	return ret;
}","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","The vulnerability in the original code lies in its insufficient checks for user privileges when modifying user account control flags, particularly for sensitive operations like changing the `UF_WORKSTATION_TRUST_ACCOUNT` and `UF_NORMAL_ACCOUNT` flags. The code did not enforce that the user must be a member of the domain admins group for these changes, potentially allowing unauthorized privilege escalation. In the fixed code, the `map` structure was enhanced to include `priv_to_change_from` and `admin_required` fields, which explicitly require that users must be domain admins to perform these sensitive modifications, thereby mitigating the risk of unauthorized access.","The vulnerability in the original code stems from inadequate privilege checks when modifying user account control flags, particularly for sensitive operations. This oversight could allow unauthorized users to escalate their privileges by changing critical account settings without proper authorization. The fixed code addresses this issue by introducing additional checks that require users to be members of the domain admins group for specific modifications. This enhancement ensures that only authorized personnel can perform sensitive changes, thereby significantly reducing the risk of privilege escalation and improving overall security.",3,5,5,3,"CWE-269, CWE-264, CWE-284, CWE-266, CWE-732, CWE-358, CWE-863, CWE-287, CWE-286, CWE-277",N,-1
2,2,2,177838,177838,,Remote,Not required,,CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,Medium,,Partial,,2015-08-02,4.3,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",2018-10-24,Bypass,7,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,,0,,,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",C,"	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

",,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: channels.c,v 1.346 2015/06/30 05:25:07 djm Exp $ */
+/* $OpenBSD: channels.c,v 1.347 2015/07/01 02:26:31 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -161,6 +161,9 @@ static char *x11_saved_proto = NULL;
 static char *x11_saved_data = NULL;
 static u_int x11_saved_data_len = 0;
 
+/* Deadline after which all X11 connections are refused */
+static u_int x11_refuse_time;
+
 /*
  * Fake X11 authentication data.  This is what the server will be sending us;
  * we should replace any occurrences of this by the real data.
@@ -912,6 +915,13 @@ x11_open_helper(Buffer *b)
 	u_char *ucp;
 	u_int proto_len, data_len;
 
+	/* Is this being called after the refusal deadline? */
+	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
+		verbose(""Rejected X11 connection after ForwardX11Timeout ""
+		    ""expired"");
+		return -1;
+	}
+
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
@@ -1483,6 +1493,12 @@ channel_set_reuseaddr(int fd)
 		error(""setsockopt SO_REUSEADDR fd %d: %s"", fd, strerror(errno));
 }
 
+void
+channel_set_x11_refuse_time(u_int refuse_time)
+{
+	x11_refuse_time = refuse_time;
+}
+
 /*
  * This socket is listening for connections to a forwarded TCP/IP port.
  */",mindrot,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,1,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
//fix_flaw_line_below:
//	/* Is this being called after the refusal deadline? */
//fix_flaw_line_below:
//	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
//fix_flaw_line_below:
//		verbose(""Rejected X11 connection after ForwardX11Timeout ""
//fix_flaw_line_below:
//		    ""expired"");
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",177838,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","The vulnerability in the original code lies in the lack of a check for the `x11_refuse_time` variable, which could allow connections to be accepted even after a specified timeout, potentially leading to unauthorized access. This oversight could expose the system to security risks if an attacker attempts to exploit the X11 protocol. In the fixed code, a condition checks if `x11_refuse_time` is not zero and if the current time, obtained from `monotime()`, exceeds this value. If true, the connection is rejected, thereby enhancing security by preventing late connections after the refusal deadline.","The vulnerability in the original code stems from the absence of a mechanism to prevent connections after a specified timeout, which could allow unauthorized access to the system. This oversight means that even if a connection should be refused due to security policies, the code does not enforce this restriction, potentially exposing the system to exploitation. In the revised code, a check is introduced to determine if the connection attempt occurs after the refusal deadline. If this condition is met, the connection is rejected, thereby strengthening security by ensuring that only timely and authorized connections are accepted.",1,5,1,2,"CWE-287,CWE-284,CWE-306,CWE-613,CWE-384,CWE-841,CWE-668,CWE-749,CWE-288,CWE-665",N,-1
3,3,3,177855,177855,,Remote,Not required,,CVE-2015-5252,https://www.cvedetails.com/cve/CVE-2015-5252/,CWE-264,Low,,Partial,,2015-12-29,5.0,"vfs.c in smbd in Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, when share names with certain substring relationships exist, allows remote attackers to bypass intended file-access restrictions via a symlink that points outside of a share.",2016-12-30,Bypass,1,https://git.samba.org/?p=samba.git;a=commit;h=4278ef25f64d5fdbf432ff1534e275416ec9561e,4278ef25f64d5fdbf432ff1534e275416ec9561e,,0,,,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",C,"       bool matched;
",,5b730ab846a9d4ae44b425094af2934c2f7b2843,"@@ -982,6 +982,7 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
+       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,
@@ -1076,7 +1077,10 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        }
 
        rootdir_len = strlen(conn_rootdir);
-       if (strncmp(conn_rootdir, resolved_name, rootdir_len) != 0) {
+       matched = (strncmp(conn_rootdir, resolved_name, rootdir_len) == 0);
+
+       if (!matched || (resolved_name[rootdir_len] != '/' &&
+                        resolved_name[rootdir_len] != '\0')) {
                DEBUG(2, (""check_reduced_name_with_privilege: Bad access ""
                        ""attempt: %s is a symlink outside the ""
                        ""share path\n"",
@@ -1216,6 +1220,7 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
        if (!allow_widelinks || !allow_symlinks) {
                const char *conn_rootdir;
                size_t rootdir_len;
+               bool matched;
 
                conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
                if (conn_rootdir == NULL) {
@@ -1226,8 +1231,10 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
                }
 
                rootdir_len = strlen(conn_rootdir);
-               if (strncmp(conn_rootdir, resolved_name,
-                               rootdir_len) != 0) {
+               matched = (strncmp(conn_rootdir, resolved_name,
+                               rootdir_len) == 0);
+               if (!matched || (resolved_name[rootdir_len] != '/' &&
+                                resolved_name[rootdir_len] != '\0')) {
                        DEBUG(2, (""check_reduced_name: Bad access ""
                                ""attempt: %s is a symlink outside the ""
                                ""share path\n"", fname));",samba,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=f14ecbef9669dbf71c050a0a5363d262092963d1;hb=f14ecbef9669dbf71c050a0a5363d262092963d1,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0;hb=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0,1,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
//fix_flaw_line_below:
//       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",177855,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","The vulnerability in the original code lies in the lack of validation for the `conn_rootdir` variable, which is derived from `SMB_VFS_CONNECTPATH(conn, fname)`. If this function returns a NULL value, the subsequent checks and operations may lead to unauthorized access or incorrect behavior, as the code does not adequately handle this scenario. In the fixed code, a new boolean variable `matched` is introduced, although its specific implementation is not shown in the provided snippet. This suggests that additional checks or logic may have been added to ensure that the connection path is valid before proceeding, thereby enhancing security and preventing potential access violations.","The vulnerability in the original code stems from inadequate validation of the connection path, which could lead to unauthorized access if the path is NULL or invalid. This oversight allows potential exploitation, as the code does not properly handle scenarios where the connection context is compromised. In the revised code, a new boolean variable is introduced, indicating that additional checks or logic have been implemented to ensure the validity of the connection path before proceeding with further operations. This enhancement improves security by preventing access violations and ensuring that only legitimate paths are processed.",2,4,2,3,"CWE-20, CWE-284, CWE-732, CWE-706, CWE-754, CWE-119, CWE-476, CWE-287, CWE-269, CWE-22",N,-1
4,4,4,177896,177896,,Local,Not required,Complete,CVE-2013-2007,https://www.cvedetails.com/cve/CVE-2013-2007/,CWE-264,Medium,Complete,Complete,,2013-05-21,6.9,"The qemu guest agent in Qemu 1.4.1 and earlier, as used by Xen, when started in daemon mode, uses weak permissions for certain files, which allows local users to read and write to these files.",2017-08-28,,1,https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,,1,,,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",C,"    umask(S_IRWXG | S_IRWXO);
","    umask(0);
",d7108d90100d5bac5965abef5ed73f2602adae14,"@@ -478,7 +478,7 @@ static void become_daemon(const char *pidfile)
         }
     }
 
-    umask(0);
+    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=44a283686bbf870a4a1adaa19a9d78f4c3a31108;hb=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=1841759db270295c96262f215f92b408ac6f472c,1,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
//flaw_line_below:
    umask(0);
//fix_flaw_line_below:
//    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",177896,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","The vulnerability in the original code lies in the use of `umask(0)`, which sets the file mode creation mask to allow all permissions for newly created files, potentially exposing sensitive data. This could lead to security risks if the daemon creates files that are accessible by unauthorized users. In the fixed code, the `umask` function is changed to `umask(S_IRWXG | S_IRWXO)`, which restricts permissions for group and others, thereby enhancing security by ensuring that newly created files are not world-writable, thus mitigating the risk of unauthorized access to sensitive information.","The vulnerability in the original code stems from setting the file mode creation mask to allow all permissions, which can lead to the creation of files that are accessible by unauthorized users, posing a security risk. This lack of restriction can expose sensitive data and allow malicious actors to manipulate or read files created by the daemon. The fixed code addresses this issue by modifying the file mode creation mask to restrict permissions for group and others, thereby enhancing security and ensuring that newly created files are not world-writable, thus protecting sensitive information from unauthorized access.",4,5,4,4,"CWE-732, CWE-276, CWE-264, CWE-266, CWE-281, CWE-279, CWE-669, CWE-263, CWE-280, CWE-284",N,-1
5,5,5,177923,177923,,Remote,Not required,,CVE-2015-2348,https://www.cvedetails.com/cve/CVE-2015-2348/,CWE-264,Low,,Partial,,2015-03-30,5.0,"The move_uploaded_file implementation in ext/standard/basic_functions.c in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 truncates a pathname upon encountering a \x00 character, which allows remote attackers to bypass intended extension restrictions and create files with unexpected names via a crafted second argument.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",2018-10-30,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,,1,,,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
",c8eaca013a3922e8383def6158ece2b63f6ec483,"@@ -5775,7 +5775,7 @@ PHP_FUNCTION(move_uploaded_file)
                RETURN_FALSE;
        }
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=c3e223048afaa30e087036e006adb0849babcccc;hb=c3e223048afaa30e087036e006adb0849babcccc,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=9a9df3094bec559376bacfbb9e6737c28f91dfda;hb=9a9df3094bec559376bacfbb9e6737c28f91dfda,1,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",177923,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","The vulnerability in the original code lies in the use of `zend_parse_parameters` with the format string ""ss"", which allows for string inputs that could lead to buffer overflows or improper handling of file paths. This could potentially allow an attacker to manipulate the `path` or `new_path` variables. The fix was implemented by changing the format string to ""sp"", which ensures that `new_path` is treated as a string pointer, providing better control over the input and reducing the risk of buffer overflow vulnerabilities. This change enhances the security of the `move_uploaded_file` function.","The vulnerability in the original code stems from improper handling of input parameters, which could lead to buffer overflows or allow an attacker to manipulate file paths. This lack of strict type enforcement could result in unexpected behavior or security breaches, as the system may not adequately validate the input. The fix involved changing the parameter parsing method to enforce stricter type checking, ensuring that the input is treated correctly and reducing the risk of exploitation. This adjustment enhances the overall security of the function by preventing potential attacks that exploit input handling weaknesses.",1,4,3,0,"CWE-119, CWE-20, CWE-22, CWE-120, CWE-125, CWE-131, CWE-680, CWE-74, CWE-134, CWE-789",N,-1
6,6,6,178074,178074,,Remote,Not required,Partial,CVE-2014-7815,https://www.cvedetails.com/cve/CVE-2014-7815/,CWE-264,Low,,,,2014-11-14,5.0,The set_pixel_format function in ui/vnc.c in QEMU allows remote attackers to cause a denial of service (crash) via a small bytes_per_pixel value.,2017-12-27,DoS,10,https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829,e6908bfe8e07f2b452e78e677da1b45b1c0f6829,,0,,,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",C,"    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

",,3e9418e160cd8901c83a3c88967158084f5b5c03,"@@ -2026,6 +2026,16 @@ static void set_pixel_format(VncState *vs,
         return;
     }
 
+    switch (bits_per_pixel) {
+    case 8:
+    case 16:
+    case 32:
+        break;
+    default:
+        vnc_client_error(vs);
+        return;
+    }
+
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=8bca59798c84011dd7d7320f013a6997d6b0a4bc;hb=8bca59798c84011dd7d7320f013a6997d6b0a4bc,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=0fe6eff1b8a661d7cb123b37bb49921c72d5df16;hb=0fe6eff1b8a661d7cb123b37bb49921c72d5df16,1,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
//fix_flaw_line_below:
//    switch (bits_per_pixel) {
//fix_flaw_line_below:
//    case 8:
//fix_flaw_line_below:
//    case 16:
//fix_flaw_line_below:
//    case 32:
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//    default:
//fix_flaw_line_below:
//        vnc_client_error(vs);
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",178074,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","The vulnerability in the original code lies in the lack of validation for the `bits_per_pixel` parameter, which could allow arbitrary values, potentially leading to undefined behavior or memory corruption. If an invalid value is passed, the subsequent calculations and assignments, such as `vs->client_pf.bytes_per_pixel = bits_per_pixel / 8`, could result in incorrect memory access. The fixed code addresses this vulnerability by introducing a `switch` statement that explicitly checks if `bits_per_pixel` is either 8, 16, or 32. If it is not, the function calls `vnc_client_error(vs)` and returns, ensuring only valid pixel formats are processed.","The vulnerability in the original code stems from the lack of validation for a critical input parameter, which could allow for arbitrary and potentially harmful values to be processed. This oversight could lead to undefined behavior, memory corruption, or crashes, as the code would proceed with invalid configurations. The revised code mitigates this risk by implementing a validation mechanism that checks the input against a predefined set of acceptable values. If the input does not match these criteria, the function gracefully handles the error and exits, ensuring that only valid configurations are processed and enhancing overall stability and security.",1,4,3,3,"CWE-20,CWE-789,CWE-119,CWE-125,CWE-126,CWE-476,CWE-754,CWE-296,CWE-680,CWE-628",N,-1
7,7,7,178405,178405,,Remote,Not required,,CVE-2011-4328,https://www.cvedetails.com/cve/CVE-2011-4328/,CWE-264,Low,Partial,,,2012-06-15,5.0,"plugin/npapi/plugin.cpp in Gnash before 0.8.10 uses weak permissions (world readable) for cookie files with predictable names in /tmp, which allows local users to obtain sensitive information.",2014-01-07,+Info,1,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=commitdiff;h=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,,0,,,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",CPP,"    chmod (ss.str().c_str(), 0600);
",,3dea0709b06a82ad8085d04daf86c9beff93d742,"@@ -1108,6 +1108,7 @@ nsPluginInstance::setupCookies(const std::string& pageurl)
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
+    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //",savannah,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=04950e6c950249a55b6e70e120ea327456bd3a39;hb=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=e161a1d2d9bfa0e0dfe44933bc373c7b3a9c1819,1,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    // Cookie appear to drop anything past the domain, so we strip
    // that off.
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    // Firefox does not (always) return the cookies that are associated
    // with a domain name through GetValueForURL.
    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
//fix_flaw_line_below:
//    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //
    //
    // Whereas libcurl expects cookies in the following format:
    //
    // Set-Cookie: cookie1=value1;
    // Set-Cookie: cookie2=value2;
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",178405,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","The vulnerability in the original code lies in the lack of proper file permissions when creating the cookie file, which is done using `cookiefile.open()`. This could allow unauthorized access to sensitive cookie data, as the file is created with default permissions. In the fixed code, the vulnerability is addressed by adding the `chmod(ss.str().c_str(), 0600);` line, which sets the file permissions to read and write only for the owner. This change ensures that only the user who created the file can access it, thereby enhancing the security of the stored cookie information.","The vulnerability in the original code stems from the lack of secure file permissions when creating a cookie file, which could expose sensitive cookie data to unauthorized access. This oversight allows other users on the system to read the contents of the file, potentially leading to data leaks or exploitation. The fix implemented in the updated code involves setting the file permissions to restrict access, ensuring that only the owner can read or write to the file. This change significantly enhances the security of the stored cookie information by preventing unauthorized users from accessing it.",3,5,2,3,"CWE-732, CWE-276, CWE-266, CWE-281, CWE-432, CWE-668, CWE-280, CWE-284, CWE-732, CWE-265",N,-1
8,8,8,178455,178455,,Local,Not required,Complete,CVE-2015-8325,https://www.cvedetails.com/cve/CVE-2015-8325/,CWE-264,Low,Complete,Complete,,2016-04-30,7.2,"The do_setup_env function in session.c in sshd in OpenSSH through 7.2p2, when the UseLogin feature is enabled and PAM is configured to read .pam_environment files in user home directories, allows local users to gain privileges by triggering a crafted environment for the /bin/login program, as demonstrated by an LD_PRELOAD environment variable.",2018-06-29,+Priv,1,https://anongit.mindrot.org/openssh.git/commit/?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,85bdcd7c92fe7ff133bbc4e10a65c91810f88755,,1,,,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",C,"	if (options.use_pam && !options.use_login) {
","	if (options.use_pam) {
",dce19bf6e4a2a3d0b13a81224de63fc316461ab9,"@@ -1322,7 +1322,7 @@ do_setup_env(Session *s, const char *shell)
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
-	if (options.use_pam) {
+	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();",mindrot,https://anongit.mindrot.org/openssh.git/tree/session.c?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,https://anongit.mindrot.org/openssh.git/tree/session.c?id=dce19bf6e4a2a3d0b13a81224de63fc316461ab9,1,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
//flaw_line_below:
	if (options.use_pam) {
//fix_flaw_line_below:
//	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",178455,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","The vulnerability in the original code lies in the handling of environment variables, particularly the potential for arbitrary code execution through user-controlled inputs. Specifically, the `custom_environment` linked list is processed without sufficient validation, allowing an attacker to inject malicious environment variables. This could lead to security issues, especially if these variables are used in subprocesses. The fixed code addresses this vulnerability by ensuring that the `custom_environment` is only processed when `options.use_login` is false, thereby limiting the exposure to potentially harmful user inputs and enhancing overall security.","The vulnerability in the original code stems from the lack of proper validation when processing user-controlled environment variables, which could allow an attacker to inject malicious data. This could lead to arbitrary code execution or privilege escalation if the environment variables are used in subprocesses without sanitization. The fixed code mitigates this risk by implementing stricter conditions under which user-defined environment variables are processed, ensuring that they are only handled when certain security options are disabled. This change effectively reduces the attack surface and enhances the overall security of the environment setup process.",3,5,3,3,"CWE-78,CWE-250,CWE-94,CWE-77,CWE-426,CWE-427,CWE-74,CWE-269,CWE-88,CWE-114",N,-1
9,9,9,178533,178533,,Remote,Not required,Partial,CVE-2013-4159,https://www.cvedetails.com/cve/CVE-2013-4159/,CWE-264,Low,Partial,Partial,,2014-08-06,7.5,"ctdb before 2.3 in OpenSUSE 12.3 and 13.1 does not create temporary files securely, which has unspecified impact related to ""several temp file vulnerabilities"" in (1) tcp/tcp_connect.c, (2) server/eventscript.c, (3) tools/ctdb_diagnostics, (4) config/gdb_backtrace, and (5) include/ctdb_private.h.",2018-10-30,,1,https://git.samba.org/?p=ctdb.git;a=commitdiff;h=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,b9b9f6738fba5c32e87cb9c36b358355b444fb9b,,1,,,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",C,"       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
","       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
",6a5469a63547029f4fc704a4d4075543e06c36d1,"@@ -284,7 +284,7 @@ static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
-       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
+       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;",samba,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=9df330009f1428fe72ae33ff8c3a91d0c4b782d9;hb=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=383d72641b222a5083c66f7e6e0bc0edc0318880,1,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
//flaw_line_below:
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
//fix_flaw_line_below:
//       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",178533,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","The vulnerability in the original code stemmed from the use of a hardcoded lock path (`const char *lock_path = ""/tmp/.ctdb_socket_lock"";`), which could lead to potential conflicts or security issues if multiple instances of the application were run simultaneously, as they might interfere with each other's lock files. The fix involved changing the lock path to a more secure and unique location (`const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";`), which helps to prevent such conflicts and enhances the overall security of the socket locking mechanism, ensuring that the application operates correctly in multi-instance environments.","The vulnerability in the original code arose from the use of a hardcoded file path for locking, which could lead to conflicts and security risks if multiple instances of the application were executed simultaneously, potentially allowing unauthorized access or interference. This could compromise the integrity of the socket binding process. The fix involved changing the lock file's location to a more secure and unique directory, reducing the likelihood of conflicts and enhancing security. This adjustment ensures that each instance of the application operates independently without risking interference from others, thereby improving overall stability and security.",3,5,4,5,"CWE-378,CWE-377,CWE-379,CWE-732,CWE-532,CWE-775,CWE-668,CWE-281,CWE-613,CWE-441",N,-1
10,10,10,178685,178685,,Local,Not required,Partial,CVE-2014-1845,https://www.cvedetails.com/cve/CVE-2014-1845/,CWE-264,Low,Partial,Partial,,2018-04-27,4.6,An unspecified setuid root helper in Enlightenment before 0.17.6 allows local users to gain privileges by leveraging failure to properly sanitize the environment.,2018-06-07,+Priv,100,https://git.enlightenment.org/core/enlightenment.git/commit/?id=666df815cd86a50343859bce36c5cf968c5f38b0,666df815cd86a50343859bce36c5cf968c5f38b0,,6,,,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",C,"   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif

   /* pass 3 - set path and ifs to minimal defaults */
","#else
# define NOENV(x)
#endif
   NOENV(""PYTHONPATH"");
     clearenv();
   /* set path and ifs to minimal defaults */
",fc9e8865cfb17a556a8a7efd1983ba211c16e545,"@@ -8,6 +8,9 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef HAVE_ENVIRON
+# define _GNU_SOURCE 1
+#endif
 #include <unistd.h>
 #include <string.h>
 #include <sys/types.h>
@@ -22,6 +25,10 @@
 #endif
 #include <Eina.h>
 
+#ifdef HAVE_ENVIRON
+extern char **environ;
+#endif
+
 double e_sys_l2ping(const char *bluetooth_mac);
 
 /* local subsystem functions */
@@ -166,17 +173,111 @@ main(int argc,
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
-#else
-# define NOENV(x)
-#endif
+   /* pass 1 - just nuke known dangerous env vars brutally if possible via
+    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
+   NOENV(""CDPATH"");
+   NOENV(""LOCALDOMAIN"");
+   NOENV(""RES_OPTIONS"");
+   NOENV(""HOSTALIASES"");
+   NOENV(""NLSPATH"");
+   NOENV(""PATH_LOCALE"");
+   NOENV(""COLORTERM"");
+   NOENV(""LANG"");
+   NOENV(""LANGUAGE"");
+   NOENV(""LINGUAS"");
+   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
-   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
+   NOENV(""SHLIB_PATH"");
+   NOENV(""LIBPATH"");
+   NOENV(""AUTHSTATE"");
+   NOENV(""DYLD_*"");
+   NOENV(""KRB_CONF*"");
+   NOENV(""KRBCONFDIR"");
+   NOENV(""KRBTKFILE"");
+   NOENV(""KRB5_CONFIG*"");
+   NOENV(""KRB5_KTNAME"");
+   NOENV(""VAR_ACE"");
+   NOENV(""USR_ACE"");
+   NOENV(""DLC_ACE"");
+   NOENV(""TERMINFO"");
+   NOENV(""TERMINFO_DIRS"");
+   NOENV(""TERMPATH"");
+   NOENV(""TERMCAP"");
+   NOENV(""ENV"");
+   NOENV(""BASH_ENV"");
+   NOENV(""PS4"");
+   NOENV(""GLOBIGNORE"");
+   NOENV(""SHELLOPTS"");
+   NOENV(""JAVA_TOOL_OPTIONS"");
+   NOENV(""PERLIO_DEBUG"");
+   NOENV(""PERLLIB"");
+   NOENV(""PERL5LIB"");
+   NOENV(""PERL5OPT"");
+   NOENV(""PERL5DB"");
+   NOENV(""FPATH"");
+   NOENV(""NULLCMD"");
+   NOENV(""READNULLCMD"");
+   NOENV(""ZDOTDIR"");
+   NOENV(""TMPPREFIX"");
+   NOENV(""PYTHONPATH"");
+   NOENV(""PYTHONHOME"");
+   NOENV(""PYTHONINSPECT"");
+   NOENV(""RUBYLIB"");
+   NOENV(""RUBYOPT"");
+# ifdef HAVE_ENVIRON
+   if (environ)
+     {
+        int again;
+        char *tmp, *p;
+
+        /* go over environment array again and again... safely */
+        do
+          {
+             again = 0;
+
+             /* walk through and find first entry that we don't like */
+             for (i = 0; environ[i]; i++)
+               {
+                  /* if it begins with any of these, it's possibly nasty */
+                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
+                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
+                      (!strncmp(environ[i], ""LC_"", 3)) ||
+                      (!strncmp(environ[i], ""LDR_"", 3)))
+                    {
+                       /* unset it */
+                       tmp = strdup(environ[i]);
+                       if (!tmp) abort();
+                       p = strchr(tmp, '=');
+                       if (!p) abort();
+                       *p = 0;
+                       NOENV(p);
+                       free(tmp);
+                       /* and mark our do to try again from the start in case
+                        * unsetenv changes environ ptr */
+                       again = 1;
+                       break;
+                    }
+               }
+          }
+        while (again);
+     }
+# endif
+#endif
+
+   /* pass 2 - clear entire environment so it doesn't exist at all. if you
+    * can't do this... you're possibly in trouble... but the worst is still
+    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
-     clearenv();
+   clearenv();
+#else
+# ifdef HAVE_ENVIRON
+   environ = NULL;
+# endif
 #endif
-   /* set path and ifs to minimal defaults */
+
+   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");",enlightment,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=666df815cd86a50343859bce36c5cf968c5f38b0,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=fc9e8865cfb17a556a8a7efd1983ba211c16e545,1,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
//flaw_line_below:
#else
//flaw_line_below:
# define NOENV(x)
//flaw_line_below:
#endif
//fix_flaw_line_below:
//   /* pass 1 - just nuke known dangerous env vars brutally if possible via
//fix_flaw_line_below:
//    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
//fix_flaw_line_below:
//   NOENV(""CDPATH"");
//fix_flaw_line_below:
//   NOENV(""LOCALDOMAIN"");
//fix_flaw_line_below:
//   NOENV(""RES_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""HOSTALIASES"");
//fix_flaw_line_below:
//   NOENV(""NLSPATH"");
//fix_flaw_line_below:
//   NOENV(""PATH_LOCALE"");
//fix_flaw_line_below:
//   NOENV(""COLORTERM"");
//fix_flaw_line_below:
//   NOENV(""LANG"");
//fix_flaw_line_below:
//   NOENV(""LANGUAGE"");
//fix_flaw_line_below:
//   NOENV(""LINGUAS"");
//fix_flaw_line_below:
//   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
//flaw_line_below:
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
//fix_flaw_line_below:
//   NOENV(""SHLIB_PATH"");
//fix_flaw_line_below:
//   NOENV(""LIBPATH"");
//fix_flaw_line_below:
//   NOENV(""AUTHSTATE"");
//fix_flaw_line_below:
//   NOENV(""DYLD_*"");
//fix_flaw_line_below:
//   NOENV(""KRB_CONF*"");
//fix_flaw_line_below:
//   NOENV(""KRBCONFDIR"");
//fix_flaw_line_below:
//   NOENV(""KRBTKFILE"");
//fix_flaw_line_below:
//   NOENV(""KRB5_CONFIG*"");
//fix_flaw_line_below:
//   NOENV(""KRB5_KTNAME"");
//fix_flaw_line_below:
//   NOENV(""VAR_ACE"");
//fix_flaw_line_below:
//   NOENV(""USR_ACE"");
//fix_flaw_line_below:
//   NOENV(""DLC_ACE"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO_DIRS"");
//fix_flaw_line_below:
//   NOENV(""TERMPATH"");
//fix_flaw_line_below:
//   NOENV(""TERMCAP"");
//fix_flaw_line_below:
//   NOENV(""ENV"");
//fix_flaw_line_below:
//   NOENV(""BASH_ENV"");
//fix_flaw_line_below:
//   NOENV(""PS4"");
//fix_flaw_line_below:
//   NOENV(""GLOBIGNORE"");
//fix_flaw_line_below:
//   NOENV(""SHELLOPTS"");
//fix_flaw_line_below:
//   NOENV(""JAVA_TOOL_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""PERLIO_DEBUG"");
//fix_flaw_line_below:
//   NOENV(""PERLLIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5LIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5OPT"");
//fix_flaw_line_below:
//   NOENV(""PERL5DB"");
//fix_flaw_line_below:
//   NOENV(""FPATH"");
//fix_flaw_line_below:
//   NOENV(""NULLCMD"");
//fix_flaw_line_below:
//   NOENV(""READNULLCMD"");
//fix_flaw_line_below:
//   NOENV(""ZDOTDIR"");
//fix_flaw_line_below:
//   NOENV(""TMPPREFIX"");
//fix_flaw_line_below:
//   NOENV(""PYTHONPATH"");
//fix_flaw_line_below:
//   NOENV(""PYTHONHOME"");
//fix_flaw_line_below:
//   NOENV(""PYTHONINSPECT"");
//fix_flaw_line_below:
//   NOENV(""RUBYLIB"");
//fix_flaw_line_below:
//   NOENV(""RUBYOPT"");
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   if (environ)
//fix_flaw_line_below:
//     {
//fix_flaw_line_below:
//        int again;
//fix_flaw_line_below:
//        char *tmp, *p;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* go over environment array again and again... safely */
//fix_flaw_line_below:
//        do
//fix_flaw_line_below:
//          {
//fix_flaw_line_below:
//             again = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//             /* walk through and find first entry that we don't like */
//fix_flaw_line_below:
//             for (i = 0; environ[i]; i++)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                  /* if it begins with any of these, it's possibly nasty */
//fix_flaw_line_below:
//                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LC_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LDR_"", 3)))
//fix_flaw_line_below:
//                    {
//fix_flaw_line_below:
//                       /* unset it */
//fix_flaw_line_below:
//                       tmp = strdup(environ[i]);
//fix_flaw_line_below:
//                       if (!tmp) abort();
//fix_flaw_line_below:
//                       p = strchr(tmp, '=');
//fix_flaw_line_below:
//                       if (!p) abort();
//fix_flaw_line_below:
//                       *p = 0;
//fix_flaw_line_below:
//                       NOENV(p);
//fix_flaw_line_below:
//                       free(tmp);
//fix_flaw_line_below:
//                       /* and mark our do to try again from the start in case
//fix_flaw_line_below:
//                        * unsetenv changes environ ptr */
//fix_flaw_line_below:
//                       again = 1;
//fix_flaw_line_below:
//                       break;
//fix_flaw_line_below:
//                    }
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//          }
//fix_flaw_line_below:
//        while (again);
//fix_flaw_line_below:
//     }
//fix_flaw_line_below:
//# endif
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 2 - clear entire environment so it doesn't exist at all. if you
//fix_flaw_line_below:
//    * can't do this... you're possibly in trouble... but the worst is still
//fix_flaw_line_below:
//    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
//flaw_line_below:
     clearenv();
//fix_flaw_line_below:
//   clearenv();
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   environ = NULL;
//fix_flaw_line_below:
//# endif
 #endif
//flaw_line_below:
   /* set path and ifs to minimal defaults */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",178685,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","The vulnerability in the original code arises from insufficient sanitization of the environment variables, which could allow an attacker to manipulate the execution environment by injecting malicious variables like `LD_PRELOAD` or `PATH`. This could lead to privilege escalation or arbitrary code execution when the program runs with elevated privileges. The fixed code addresses this vulnerability by implementing a more comprehensive sanitization process, including the removal of a wider range of potentially dangerous environment variables (e.g., `CDPATH`, `LOCALDOMAIN`, `LD_LIBRARY_PATH`) and ensuring that the environment is cleared or reset to minimal defaults, thereby enhancing security.","The vulnerability in the original code stems from inadequate sanitization of environment variables, which could allow an attacker to manipulate the execution context and potentially execute arbitrary code with elevated privileges. This lack of thorough checks could lead to privilege escalation or exploitation of the program's functionality. The revised code mitigates this vulnerability by implementing a more robust sanitization process that removes a broader range of potentially harmful environment variables. Additionally, it ensures that the environment is either cleared or reset to minimal defaults, significantly enhancing the security posture of the application against such attacks.",2,5,5,3,"CWE-78, CWE-250, CWE-426, CWE-427, CWE-269, CWE-284, CWE-732, CWE-266, CWE-267, CWE-77",N,-1
11,11,11,178695,178695,,Remote,Not required,Partial,CVE-2010-0011,https://www.cvedetails.com/cve/CVE-2010-0011/,CWE-264,Low,Partial,Partial,,2010-02-25,7.5,"The eval_js function in uzbl-core.c in Uzbl before 2010.01.05 exposes the run method of the Uzbl object, which allows remote attackers to execute arbitrary commands via JavaScript code.",2017-08-16,Exec Code ,0,https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047,1958b52d41cba96956dc1995660de49525ed1047,disable Uzbl javascript object because of security problem.,8,uzbl-core.c,"{""sha"": ""a22e105934e4dbd5360e68f28cdbb7474022d4e5"", ""filename"": ""README"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 20, ""changes"": 21, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/README"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/README"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/README?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -397,7 +397,7 @@ The script specific arguments are this:\n \n Custom, userdefined scripts (`spawn foo bar`) get first the arguments as specified in the config and then the above 7 are added at the end.\n \n-### JAVASCRIPT HELPER OBJECT\n+### JAVASCRIPT HELPER OBJECT DISABLED BECAUSE OF SECURITY LEAK\n \n Javascript code run from uzbl is given a special object in the global namespace which gives special privileges to these scripts. This object is called `Uzbl`, and it is added and removed before and after the script execution so that it is hidden to web javascripts (There is no race condition, since all the javascript code runs in a single thread)\n \n@@ -410,25 +410,6 @@ Currently, the `Uzbl` object provides only one function:\n        * `Uzbl.run(\""spawn insert_bookmark.sh\"")`\n        * `uri = Uzbl.run(\""print @uri\"")` (see variable expansion below)\n \n-### JAVASCRIPT SECURITY\n-\n-Since defined variables and functions are set in the global namespace (`window` object) as default, it is recommended to wrap your scripts like this:\n-\n-    (function(Uzbl) {\n-        ...\n-    })(Uzbl);\n-\n-This way, everything is kept private. It also turns Uzbl into a local variable, which can be accessed from callback functions defined inside. However for some situations, isolating everything isn't an option, for example, with binds. You can define them directly in the script body, and use `var Uzbl = window.Uzbl;` to make the Uzbl variable local, as in the following example:\n-\n-    function f() {\n-        var Uzbl = window.Uzbl;\n-        Uzbl.run(...);\n-        setTimeout(function() {\n-            Uzbl.run(...);\n-        }, 500);\n-    }\n-\n-Copying the Uzbl object and creating public functions should be taken with care to avoid creating security holes. Keep in mind that the \""f\"" function above would be defined in the `window` object, and as such any javascript in the current page can call it.\n \n ### EVENTS ###\n ""}<_**next**_>{""sha"": ""fc3b092ea0dd6a2593c92178eb07049a95160a60"", ""filename"": ""tests/test-command.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/tests/test-command.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -305,11 +305,6 @@ test_js (void) {\n     parse_cmd_line(\""js ('x' + 345).toUpperCase()\"", result);\n     g_assert_cmpstr(\""X345\"", ==, result->str);\n \n-    /* uzbl commands can be run from javascript */\n-    uzbl.net.useragent = \""Test useragent\"";\n-    parse_cmd_line(\""js Uzbl.run('print @useragent').toUpperCase();\"", result);\n-    g_assert_cmpstr(\""TEST USERAGENT\"", ==, result->str);\n-\n     g_string_free(result, TRUE);\n }\n ""}<_**next**_>{""sha"": ""fca293c1f5e8ff116ae4de3e1d3f2ecc51f593f6"", ""filename"": ""uzbl-core.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 10, ""changes"": 10, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/uzbl-core.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n-    JSStringRef var_name;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n-    /* uzbl javascript namespace */\n-    var_name = JSStringCreateWithUTF8CString(\""Uzbl\"");\n-    JSObjectSetProperty(context, globalobject, var_name,\n-                        JSObjectMake(context, uzbl.js.classref, NULL),\n-                        kJSClassAttributeNone, NULL);\n-\n     /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     }\n \n     /* cleanup */\n-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n-\n-    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }\n ""}","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",C,,"    JSStringRef var_name;
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
",,"@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
-    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
-    /* uzbl javascript namespace */
-    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
-    JSObjectSetProperty(context, globalobject, var_name,
-                        JSObjectMake(context, uzbl.js.classref, NULL),
-                        kJSClassAttributeNone, NULL);
-
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     }
 
     /* cleanup */
-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
-
-    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
 ",uzbl,1958b52d41cba96956dc1995660de49525ed1047,49941155e43eb520c43b02b55e0bbced2b657cf6,1,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
//flaw_line_below:
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
//flaw_line_below:
    /* uzbl javascript namespace */
//flaw_line_below:
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
//flaw_line_below:
    JSObjectSetProperty(context, globalobject, var_name,
//flaw_line_below:
                        JSObjectMake(context, uzbl.js.classref, NULL),
//flaw_line_below:
                        kJSClassAttributeNone, NULL);
//flaw_line_below:

     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
//flaw_line_below:
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
//flaw_line_below:

//flaw_line_below:
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",178695,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","The vulnerability in the original code arises from the use of `JSObjectSetProperty` to create a global JavaScript object named ""Uzbl"" without proper validation or sanitization, potentially allowing an attacker to inject malicious scripts. This could lead to arbitrary code execution within the web context. In the fixed code, the line that sets the ""Uzbl"" property has been removed, eliminating the risk of exposing the application to untrusted JavaScript execution. This change ensures that the code no longer introduces a global object that could be manipulated by external scripts, thereby enhancing security.","The vulnerability in the original code stems from the creation of a global JavaScript object without proper validation, which could allow an attacker to inject and execute arbitrary scripts within the application's context. This exposure could lead to severe security risks, including unauthorized access to sensitive data or manipulation of application behavior. In the revised code, the line responsible for creating this global object has been removed, effectively closing the security loophole. This change prevents the application from being susceptible to malicious script execution, thereby enhancing the overall security posture of the application.",3,5,4,2,"CWE-79,CWE-94,CWE-471,CWE-706,CWE-707,CWE-470,CWE-284,CWE-749,CWE-611,CWE-95",N,-1
12,12,12,178773,178773,,Local,Not required,Partial,CVE-2012-2313,https://www.cvedetails.com/cve/CVE-2012-2313/,CWE-264,High,,,,2012-06-13,1.2,"The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call.",2016-09-06,,9,https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,"dl2k: Clean up rio_ioctl

The dl2k driver's rio_ioctl call has a few issues:
- No permissions checking
- Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers
- Has a few ioctls that may have been used for debugging at one point
  but have no place in the kernel proper.

This patch removes all but the MII ioctls, renumbers them to use the
standard ones, and adds the proper permission check for SIOCSMIIREG.

We can also get rid of the dl2k-specific struct mii_data in favor of
the generic struct mii_ioctl_data.

Since we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.

Most of the MII code for the driver could probably be converted to use
the generic MII library but I don't have a device to test the results.

Reported-by: Stephan Mueller <stephan.mueller@atsec.com>
Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",40,drivers/net/ethernet/dlink/dl2k.c,"{""sha"": ""2e09edb9cdf84b3d1cc49d7dad5167a2ce3be75a"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 43, ""changes"": 52, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.c?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n-\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n-\n-\tstruct netdev_desc *desc;\n-\tint i;\n+\tstruct mii_ioctl_data *miidata = if_mii(rq);\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n-\tcase SIOCDEVPRIVATE:\n-\t\tbreak;\n-\n-\tcase SIOCDEVPRIVATE + 1:\n-\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n+\tcase SIOCGMIIPHY:\n+\t\tmiidata->phy_id = phy_addr;\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 2:\n-\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n+\tcase SIOCGMIIREG:\n+\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 3:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 4:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 5:\n-\t\tnetif_stop_queue (dev);\n+\tcase SIOCSMIIREG:\n+\t\tif (!capable(CAP_NET_ADMIN))\n+\t\t\treturn -EPERM;\n+\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 6:\n-\t\tnetif_wake_queue (dev);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 7:\n-\t\tprintk\n-\t\t    (\""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\"",\n-\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n-\t\t     np->old_rx);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 8:\n-\t\tprintk(\""TX ring:\\n\"");\n-\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n-\t\t\tdesc = &np->tx_ring[i];\n-\t\t\tprintk\n-\t\t\t    (\""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\"",\n-\t\t\t     i,\n-\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n-\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n-\t\t\t     (u32)le64_to_cpu(desc->status),\n-\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n-\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n-\t\t\tprintk (\""\\n\"");\n-\t\t}\n-\t\tprintk (\""\\n\"");\n-\t\tbreak;\n-\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}""}<_**next**_>{""sha"": ""30c2da3de548f92ce0ebe794dc9c894af284c010"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.h?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -365,13 +365,6 @@ struct ioctl_data {\n \tchar *data;\n };\n \n-struct mii_data {\n-\t__u16 reserved;\n-\t__u16 reg_num;\n-\t__u16 in_value;\n-\t__u16 out_value;\n-};\n-\n /* The Rx and Tx buffer descriptors. */\n struct netdev_desc {\n \t__le64 next_desc;""}","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",C,"	struct mii_ioctl_data *miidata = if_mii(rq);
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
","	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
",,"@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
-	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
-
-	struct netdev_desc *desc;
-	int i;
+	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
-	case SIOCDEVPRIVATE:
-		break;
-
-	case SIOCDEVPRIVATE + 1:
-		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
+	case SIOCGMIIPHY:
+		miidata->phy_id = phy_addr;
 		break;
-	case SIOCDEVPRIVATE + 2:
-		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
+	case SIOCGMIIREG:
+		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
-	case SIOCDEVPRIVATE + 3:
-		break;
-	case SIOCDEVPRIVATE + 4:
-		break;
-	case SIOCDEVPRIVATE + 5:
-		netif_stop_queue (dev);
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
-	case SIOCDEVPRIVATE + 6:
-		netif_wake_queue (dev);
-		break;
-	case SIOCDEVPRIVATE + 7:
-		printk
-		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
-		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
-		     np->old_rx);
-		break;
-	case SIOCDEVPRIVATE + 8:
-		printk(""TX ring:\n"");
-		for (i = 0; i < TX_RING_SIZE; i++) {
-			desc = &np->tx_ring[i];
-			printk
-			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
-			     i,
-			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
-			     (u32)le64_to_cpu(desc->next_desc),
-			     (u32)le64_to_cpu(desc->status),
-			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
-			     (u32)le64_to_cpu(desc->fraginfo));
-			printk (""\n"");
-		}
-		printk (""\n"");
-		break;
-
 	default:
 		return -EOPNOTSUPP;
 	}",linux,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,768f7c7c121e80f458a9d013b2e8b169e5dfb1e5,1,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
//flaw_line_below:
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
//flaw_line_below:

//flaw_line_below:
	struct netdev_desc *desc;
//flaw_line_below:
	int i;
//fix_flaw_line_below:
//	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
//flaw_line_below:
	case SIOCDEVPRIVATE:
//flaw_line_below:
		break;
//flaw_line_below:

//flaw_line_below:
	case SIOCDEVPRIVATE + 1:
//flaw_line_below:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
//fix_flaw_line_below:
//	case SIOCGMIIPHY:
//fix_flaw_line_below:
//		miidata->phy_id = phy_addr;
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 2:
//flaw_line_below:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
//fix_flaw_line_below:
//	case SIOCGMIIREG:
//fix_flaw_line_below:
//		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 3:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 4:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 5:
//flaw_line_below:
		netif_stop_queue (dev);
//fix_flaw_line_below:
//	case SIOCSMIIREG:
//fix_flaw_line_below:
//		if (!capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//			return -EPERM;
//fix_flaw_line_below:
//		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 6:
//flaw_line_below:
		netif_wake_queue (dev);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 7:
//flaw_line_below:
		printk
//flaw_line_below:
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
//flaw_line_below:
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
//flaw_line_below:
		     np->old_rx);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 8:
//flaw_line_below:
		printk(""TX ring:\n"");
//flaw_line_below:
		for (i = 0; i < TX_RING_SIZE; i++) {
//flaw_line_below:
			desc = &np->tx_ring[i];
//flaw_line_below:
			printk
//flaw_line_below:
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
//flaw_line_below:
			     i,
//flaw_line_below:
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->next_desc),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->status),
//flaw_line_below:
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->fraginfo));
//flaw_line_below:
			printk (""\n"");
//flaw_line_below:
		}
//flaw_line_below:
		printk (""\n"");
//flaw_line_below:
		break;
//flaw_line_below:

 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",178773,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","The vulnerability in the original `rio_ioctl` code stemmed from insufficient access control, allowing any user to execute potentially harmful operations, such as reading and writing to MII registers without proper permissions. Specifically, the `mii_write` function could be called without verifying if the caller had the necessary administrative capabilities, leading to unauthorized access. In the fixed code, this vulnerability was addressed by introducing a permission check using `capable(CAP_NET_ADMIN)` before executing `mii_write`, ensuring that only users with the appropriate network administration privileges can perform sensitive operations, thus enhancing the security of the ioctl interface.","The vulnerability in the original code was due to a lack of access control, allowing any user to perform sensitive operations without proper authorization. This oversight meant that malicious users could potentially manipulate hardware settings or read sensitive data, leading to security risks. The fixed code addressed this issue by implementing a permission check that verifies whether the user has the necessary administrative rights before allowing any write operations. This change ensures that only authorized users can execute critical functions, thereby enhancing the overall security and integrity of the system.",2,1,1,0,"CWE-284,CWE-285,CWE-269,CWE-732,CWE-264,CWE-287,CWE-862,CWE-425,CWE-639,CWE-266",Y,5
13,13,13,178788,178788,,Local,Not required,Complete,CVE-2012-2123,https://www.cvedetails.com/cve/CVE-2012-2123/,CWE-264,Low,Complete,Complete,,2012-05-17,7.2,"The cap_bprm_set_creds function in security/commoncap.c in the Linux kernel before 3.3.3 does not properly handle the use of file system capabilities (aka fcaps) for implementing a privileged executable file, which allows local users to bypass intended personality restrictions via a crafted application, as demonstrated by an attack that uses a parent process to disable ASLR.",2017-12-28,Bypass ,5,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,d52fc5dde171f030170a6cb78034d166b13c9445,"fcaps: clear the same personality flags as suid when fcaps are used

If a process increases permissions using fcaps all of the dangerous
personality flags which are cleared for suid apps should also be cleared.
Thus programs given priviledge with fcaps will continue to have address space
randomization enabled even if the parent tried to disable it to make it
easier to attack.

Signed-off-by: Eric Paris <eparis@redhat.com>
Reviewed-by: Serge Hallyn <serge.hallyn@canonical.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/commoncap.c,"{""sha"": ""0ecf4ba321cbeaa812dadc6524e138bc40b866b3"", ""filename"": ""security/commoncap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/commoncap.c?ref=d52fc5dde171f030170a6cb78034d166b13c9445"", ""patch"": ""@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)\n \t}\n skip:\n \n+\t/* if we have fs caps, clear dangerous personality flags */\n+\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\n+\n \t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n \t * credentials unless they have the appropriate permit\n \t */""}","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",C,"	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


",,,"@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)
 	}
 skip:
 
+	/* if we have fs caps, clear dangerous personality flags */
+	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
+		bprm->per_clear |= PER_CLEAR_ON_SETID;
+
+
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */",linux,d52fc5dde171f030170a6cb78034d166b13c9445,09c79b60960bdd4b00916219402eabfa5e479c5a,1,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
//fix_flaw_line_below:
//	/* if we have fs caps, clear dangerous personality flags */
//fix_flaw_line_below:
//	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
//fix_flaw_line_below:
//		bprm->per_clear |= PER_CLEAR_ON_SETID;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",178788,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","The vulnerability in the original code lies in the handling of file capabilities, particularly when a setuid root binary is executed by a non-root user. The check for `cap_issubset(new->cap_permitted, old->cap_permitted)` was insufficient, potentially allowing unauthorized privilege escalation. The fix introduces a new line: `bprm->per_clear |= PER_CLEAR_ON_SETID;`, which ensures that dangerous personality flags are cleared if file capabilities are present and do not match the old permitted capabilities. This additional check enhances security by preventing unintended privilege inheritance and ensuring stricter control over capability management.","The vulnerability in the original code arises from inadequate checks on file capabilities when executing setuid root binaries by non-root users, potentially allowing privilege escalation. Specifically, the logic did not sufficiently restrict the effective capabilities of a process, which could lead to unauthorized access. The fix addresses this issue by introducing a mechanism to clear dangerous personality flags if the new capabilities do not align with the old ones. This additional safeguard ensures that any potentially harmful capabilities are not inherited, thereby enhancing the overall security of the privilege management system.",3,5,2,3,"CWE-269,CWE-250,CWE-264,CWE-284,CWE-732,CWE-266,CWE-274,CWE-271,CWE-272,CWE-263",Y,3
14,14,14,178817,178817,,Local,Not required,Complete,CVE-2012-1090,https://www.cvedetails.com/cve/CVE-2012-1090/,CWE-264,Low,,,,2012-05-17,4.9,"The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO.",2018-01-17,DoS ,18,https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08,88d7d4e4a439f32acc56a6d860e415ee71d3df08,"cifs: fix dentry refcount leak when opening a FIFO on lookup

commit 5bccda0ebc7c0331b81ac47d39e4b920b198b2cd upstream.

The cifs code will attempt to open files on lookup under certain
circumstances. What happens though if we find that the file we opened
was actually a FIFO or other special file?

Currently, the open filehandle just ends up being leaked leading to
a dentry refcount mismatch and oops on umount. Fix this by having the
code close the filehandle on the server if it turns out not to be a
regular file. While we're at it, change this spaghetti if statement
into a switch too.

Reported-by: CAI Qian <caiqian@redhat.com>
Tested-by: CAI Qian <caiqian@redhat.com>
Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Steve French <smfrench@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",2,fs/cifs/dir.c,"{""sha"": ""bf68b4fc9512f0ad226f9503dffbc50d8818138c"", ""filename"": ""fs/cifs/dir.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 2, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/dir.c?ref=88d7d4e4a439f32acc56a6d860e415ee71d3df08"", ""patch"": ""@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n \t\t\t * If either that or op not supported returned, follow\n \t\t\t * the normal lookup.\n \t\t\t */\n-\t\t\tif ((rc == 0) || (rc == -ENOENT))\n+\t\t\tswitch (rc) {\n+\t\t\tcase 0:\n+\t\t\t\t/*\n+\t\t\t\t * The server may allow us to open things like\n+\t\t\t\t * FIFOs, but the client isn't set up to deal\n+\t\t\t\t * with that. If it's not a regular file, just\n+\t\t\t\t * close it and proceed as if it were a normal\n+\t\t\t\t * lookup.\n+\t\t\t\t */\n+\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n+\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\tcase -ENOENT:\n \t\t\t\tposix_open = true;\n-\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n+\t\t\tcase -EOPNOTSUPP:\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n \t\t\t\tpTcon->broken_posix_open = true;\n+\t\t\t}\n \t\t}\n \t\tif (!posix_open)\n \t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,""}","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",C,"			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
			case -EOPNOTSUPP:
				break;
			default:
			}
","			if ((rc == 0) || (rc == -ENOENT))
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
",,"@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
-			if ((rc == 0) || (rc == -ENOENT))
+			switch (rc) {
+			case 0:
+				/*
+				 * The server may allow us to open things like
+				 * FIFOs, but the client isn't set up to deal
+				 * with that. If it's not a regular file, just
+				 * close it and proceed as if it were a normal
+				 * lookup.
+				 */
+				if (newInode && !S_ISREG(newInode->i_mode)) {
+					CIFSSMBClose(xid, pTcon, fileHandle);
+					break;
+				}
+			case -ENOENT:
 				posix_open = true;
-			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
+			case -EOPNOTSUPP:
+				break;
+			default:
 				pTcon->broken_posix_open = true;
+			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,",linux,88d7d4e4a439f32acc56a6d860e415ee71d3df08,ce6e3def616ad1e22443df7fc8bdaa3384cf0575,1,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
//flaw_line_below:
			if ((rc == 0) || (rc == -ENOENT))
//fix_flaw_line_below:
//			switch (rc) {
//fix_flaw_line_below:
//			case 0:
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * The server may allow us to open things like
//fix_flaw_line_below:
//				 * FIFOs, but the client isn't set up to deal
//fix_flaw_line_below:
//				 * with that. If it's not a regular file, just
//fix_flaw_line_below:
//				 * close it and proceed as if it were a normal
//fix_flaw_line_below:
//				 * lookup.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				if (newInode && !S_ISREG(newInode->i_mode)) {
//fix_flaw_line_below:
//					CIFSSMBClose(xid, pTcon, fileHandle);
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//			case -ENOENT:
 				posix_open = true;
//flaw_line_below:
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
//fix_flaw_line_below:
//			case -EOPNOTSUPP:
//fix_flaw_line_below:
//				break;
//fix_flaw_line_below:
//			default:
 				pTcon->broken_posix_open = true;
//fix_flaw_line_below:
//			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",178817,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","The vulnerability in the original `cifs_lookup` code stemmed from improper handling of the return value from `cifs_posix_open`, which could lead to the use of an invalid file handle if the opened file was not a regular file. Specifically, the code did not check if `newInode` was a regular file after a successful open, potentially allowing operations on non-regular files. The fix introduced a `switch` statement to handle the return value of `cifs_posix_open`, ensuring that if `newInode` is not a regular file, the file handle is closed, thus preventing misuse and enhancing overall stability and security.","The vulnerability in the original code arose from inadequate validation of the file type after attempting to open it, which could lead to operations on non-regular files, potentially causing unexpected behavior or crashes. This oversight allowed the system to proceed with a file handle that might not correspond to a valid file type, compromising stability. The fix implemented a more robust handling mechanism by introducing a conditional check after the open operation. This ensures that if the opened file is not of the expected type, the system will close the file handle and avoid further operations, thereby enhancing security and reliability.",2,4,4,3,"CWE-67, CWE-773, CWE-754, CWE-552, CWE-22, CWE-73, CWE-379, CWE-404, CWE-59, CWE-114",N,-1
15,15,15,179032,179032,,Local,Not required,,CVE-2011-2495,https://www.cvedetails.com/cve/CVE-2011-2495/,CWE-264,Low,Partial,,,2012-06-13,2.1,"fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password.",2013-12-30,,3,https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51,1d1221f375c94ef961ba8574ac4f85c8870ddd51,"proc: restrict access to /proc/PID/io

/proc/PID/io may be used for gathering private information.  E.g.  for
openssh and vsftpd daemons wchars/rchars may be used to learn the
precise password length.  Restrict it to processes being able to ptrace
the target process.

ptrace_may_access() is needed to prevent keeping open file descriptor of
""io"" file, executing setuid binary and gathering io information of the
setuid'ed process.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/proc/base.c,"{""sha"": ""fc5bc27676926cccbc27f3349886e02bbc047211"", ""filename"": ""fs/proc/base.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/base.c?ref=1d1221f375c94ef961ba8574ac4f85c8870ddd51"", ""patch"": ""@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n+\t\treturn -EACCES;\n+\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n \n@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {\n \tREG(\""coredump_filter\"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tgid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tgid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),\n@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {\n \tREG(\""make-it-fail\"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),""}","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",C,"	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

",,,"@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
+	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		return -EACCES;
+
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG(""coredump_filter"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tgid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tgid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),
@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {
 	REG(""make-it-fail"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),",linux,1d1221f375c94ef961ba8574ac4f85c8870ddd51,b0af8dfdd67699e25083478c63eedef2e72ebd85,1,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!ptrace_may_access(task, PTRACE_MODE_READ))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",179032,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","The vulnerability in the original code arises from the lack of access control when reading the `task_io_accounting` data of a specified `task`. Without verifying if the calling process has permission to access the target task's memory, an attacker could exploit this to read sensitive information. The fix introduces a check using `ptrace_may_access(task, PTRACE_MODE_READ)`, which ensures that the calling process has the appropriate permissions before proceeding with the accounting operations. This effectively mitigates unauthorized access, enhancing the security of the `do_io_accounting` function.","The vulnerability in the original code stems from the absence of access control checks, allowing any process to read the accounting data of another process without permission. This could lead to unauthorized exposure of sensitive information, potentially enabling an attacker to exploit the system. The fix addresses this issue by implementing a permission check before accessing the target process's data. This ensures that only processes with the appropriate rights can read the accounting information, thereby preventing unauthorized access and enhancing the overall security of the function.",3,5,2,3,"CWE-732, CWE-284, CWE-269, CWE-285, CWE-264, CWE-426, CWE-668, CWE-266, CWE-862, CWE-281",N,-1
16,16,16,179046,179046,,Local,Not required,,CVE-2011-1833,https://www.cvedetails.com/cve/CVE-2011-1833/,CWE-264,Medium,Partial,Partial,,2012-10-03,3.3,Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.,2014-03-07,Bypass ,11,https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97,764355487ea220fdc2faf128d577d7f679b91f97,"Ecryptfs: Add mount option to check uid of device being mounted = expect uid

Close a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount
source (device) can be raced when the ownership test is done in userspace.
Provide Ecryptfs a means to force the uid check at mount time.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Cc: <stable@kernel.org>
Signed-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>",1,fs/ecryptfs/main.c,"{""sha"": ""b4a6befb12168d6b0aa0bb7411794e062ded8734"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 2, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=764355487ea220fdc2faf128d577d7f679b91f97"", ""patch"": ""@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n+       ecryptfs_opt_check_dev_ruid,\n        ecryptfs_opt_err };\n \n static const match_table_t tokens = {\n@@ -191,6 +192,7 @@ static const match_table_t tokens = {\n \t{ecryptfs_opt_fn_cipher_key_bytes, \""ecryptfs_fn_key_bytes=%u\""},\n \t{ecryptfs_opt_unlink_sigs, \""ecryptfs_unlink_sigs\""},\n \t{ecryptfs_opt_mount_auth_tok_only, \""ecryptfs_mount_auth_tok_only\""},\n+\t{ecryptfs_opt_check_dev_ruid, \""ecryptfs_check_dev_ruid\""},\n \t{ecryptfs_opt_err, NULL}\n };\n \n@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(\n  * ecryptfs_parse_options\n  * @sb: The ecryptfs super block\n  * @options: The options passed to the kernel\n+ * @check_ruid: set to 1 if device uid should be checked against the ruid\n  *\n  * Parse mount options:\n  * debug=N \t   - ecryptfs_verbosity level for debug output\n@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(\n  *\n  * Returns zero on success; non-zero on error\n  */\n-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n+\t\t\t\t  uid_t *check_ruid)\n {\n \tchar *p;\n \tint rc = 0;\n@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n+\t*check_ruid = 0;\n+\n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n+\t\tcase ecryptfs_opt_check_dev_ruid:\n+\t\t\t*check_ruid = 1;\n+\t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \tconst char *err = \""Getting sb failed\"";\n \tstruct inode *inode;\n \tstruct path path;\n+\tuid_t check_ruid;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\tgoto out;\n \t}\n \n-\trc = ecryptfs_parse_options(sbi, raw_data);\n+\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n \tif (rc) {\n \t\terr = \""Error parsing options\"";\n \t\tgoto out;\n@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\t\t\""known incompatibilities\\n\"");\n \t\tgoto out_free;\n \t}\n+\n+\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n+\t\trc = -EPERM;\n+\t\tprintk(KERN_ERR \""Mount of device (uid: %d) not owned by \""\n+\t\t       \""requested user (uid: %d)\\n\"",\n+\t\t       path.dentry->d_inode->i_uid, current_uid());\n+\t\tgoto out_free;\n+\t}\n+\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	uid_t check_ruid;
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

","	rc = ecryptfs_parse_options(sbi, raw_data);
",,"@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
+       ecryptfs_opt_check_dev_ruid,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
@@ -191,6 +192,7 @@ static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, ""ecryptfs_fn_key_bytes=%u""},
 	{ecryptfs_opt_unlink_sigs, ""ecryptfs_unlink_sigs""},
 	{ecryptfs_opt_mount_auth_tok_only, ""ecryptfs_mount_auth_tok_only""},
+	{ecryptfs_opt_check_dev_ruid, ""ecryptfs_check_dev_ruid""},
 	{ecryptfs_opt_err, NULL}
 };
 
@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
+ * @check_ruid: set to 1 if device uid should be checked against the ruid
  *
  * Parse mount options:
  * debug=N 	   - ecryptfs_verbosity level for debug output
@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(
  *
  * Returns zero on success; non-zero on error
  */
-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
+				  uid_t *check_ruid)
 {
 	char *p;
 	int rc = 0;
@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
+	*check_ruid = 0;
+
 	if (!options) {
 		rc = -EINVAL;
 		goto out;
@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 			mount_crypt_stat->flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
+		case ecryptfs_opt_check_dev_ruid:
+			*check_ruid = 1;
+			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
+	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out;
 	}
 
-	rc = ecryptfs_parse_options(sbi, raw_data);
+	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 			""known incompatibilities\n"");
 		goto out_free;
 	}
+
+	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
+		rc = -EPERM;
+		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
+		       ""requested user (uid: %d)\n"",
+		       path.dentry->d_inode->i_uid, current_uid());
+		goto out_free;
+	}
+
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;",linux,764355487ea220fdc2faf128d577d7f679b91f97,99b373ff2d1246f64b97a3d449a2fd6018d504e6,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
//fix_flaw_line_below:
//	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
//flaw_line_below:
	rc = ecryptfs_parse_options(sbi, raw_data);
//fix_flaw_line_below:
//	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
//fix_flaw_line_below:
//		rc = -EPERM;
//fix_flaw_line_below:
//		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
//fix_flaw_line_below:
//		       ""requested user (uid: %d)\n"",
//fix_flaw_line_below:
//		       path.dentry->d_inode->i_uid, current_uid());
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",179046,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The vulnerability in the original code lies in the lack of user ID (UID) checks when mounting a filesystem, allowing any user to mount a device regardless of ownership, which could lead to unauthorized access to sensitive data. Specifically, the code does not verify if the UID of the device being mounted (`path.dentry->d_inode->i_uid`) matches the UID of the current user (`current_uid()`). The fix introduces a `check_ruid` variable and an additional conditional check that ensures the device can only be mounted by its owner, returning an error (`-EPERM`) if the ownership does not match, thus enhancing security.","The vulnerability in the original code stems from the absence of checks to verify the ownership of the device being mounted, allowing any user to mount a filesystem regardless of whether they own it. This oversight could lead to unauthorized access to sensitive data, as users could potentially mount devices that do not belong to them. The fix addresses this issue by introducing a mechanism to check the user ID of the device against the current user's ID. This ensures that only the owner of the device can mount it, thereby enhancing security and preventing unauthorized access.",3,5,5,2,"CWE-284, CWE-287, CWE-266, CWE-269, CWE-732, CWE-285, CWE-264, CWE-639, CWE-282, CWE-863",N,-1
17,17,17,179077,179077,,Local,Not required,,CVE-2011-0006,https://www.cvedetails.com/cve/CVE-2011-0006/,CWE-264,Medium,,Partial,,2012-06-21,1.9,"The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM.",2012-06-26,Bypass ,2,https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9,867c20265459d30a01b021a9c1e81fb4c5832aa9,"ima: fix add LSM rule bug

If security_filter_rule_init() doesn't return a rule, then not everything
is as fine as the return code implies.

This bug only occurs when the LSM (eg. SELinux) is disabled at runtime.

Adding an empty LSM rule causes ima_match_rules() to always succeed,
ignoring any remaining rules.

 default IMA TCB policy:
  # PROC_SUPER_MAGIC
  dont_measure fsmagic=0x9fa0
  # SYSFS_MAGIC
  dont_measure fsmagic=0x62656572
  # DEBUGFS_MAGIC
  dont_measure fsmagic=0x64626720
  # TMPFS_MAGIC
  dont_measure fsmagic=0x01021994
  # SECURITYFS_MAGIC
  dont_measure fsmagic=0x73636673

  < LSM specific rule >
  dont_measure obj_type=var_log_t

  measure func=BPRM_CHECK
  measure func=FILE_MMAP mask=MAY_EXEC
  measure func=FILE_CHECK mask=MAY_READ uid=0

Thus without the patch, with the boot parameters 'tcb selinux=0', adding
the above 'dont_measure obj_type=var_log_t' rule to the default IMA TCB
measurement policy, would result in nothing being measured.  The patch
prevents the default TCB policy from being replaced.

Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
Cc: James Morris <jmorris@namei.org>
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Cc: David Safford <safford@watson.ibm.com>
Cc: <stable@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,security/integrity/ima/ima_policy.c,"{""sha"": ""d661afbe474c2fce8f74907869be0a644c5789c9"", ""filename"": ""security/integrity/ima/ima_policy.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/integrity/ima/ima_policy.c?ref=867c20265459d30a01b021a9c1e81fb4c5832aa9"", ""patch"": ""@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n+\tif (!entry->lsm[lsm_rule].rule)\n+\t\treturn -EINVAL;\n \treturn result;\n }\n ""}","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
",C,"	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
",,,"@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
+	if (!entry->lsm[lsm_rule].rule)
+		return -EINVAL;
 	return result;
 }
 ",linux,867c20265459d30a01b021a9c1e81fb4c5832aa9,03ed6a3aa600c48593c3984812fda2d5945ddb46,1,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
//fix_flaw_line_below:
//	if (!entry->lsm[lsm_rule].rule)
//fix_flaw_line_below:
//		return -EINVAL;
 	return result;
 }
",179077,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","The vulnerability in the original code arises from the lack of validation after the call to `security_filter_rule_init`, which could lead to a situation where `entry->lsm[lsm_rule].rule` remains uninitialized or invalid, potentially causing undefined behavior later in the program. The fixed code addresses this issue by adding a check after the initialization call, ensuring that if `entry->lsm[lsm_rule].rule` is still NULL (or invalid), the function returns -EINVAL. This additional validation step enhances the robustness of the code by preventing the use of an uninitialized rule.","The vulnerability in the original code stems from the absence of a validation check after a critical initialization process, which could result in the use of an uninitialized or invalid state. This oversight may lead to undefined behavior or security issues if the subsequent logic relies on the successful initialization of a specific component. The revised code rectifies this flaw by introducing a validation step that confirms the successful initialization before proceeding. This additional check ensures that the function can safely return an error if the initialization did not complete as expected, thereby enhancing the overall reliability and security of the code.",1,3,4,2,"CWE-665, CWE-456, CWE-457, CWE-824, CWE-909, CWE-908, CWE-252, CWE-476, CWE-393, CWE-573",N,-1
18,18,18,179110,179110,,Local,Not required,Complete,CVE-2013-6431,https://www.cvedetails.com/cve/CVE-2013-6431/,CWE-264,Medium,,,,2013-12-09,4.7,"The fib6_add function in net/ipv6/ip6_fib.c in the Linux kernel before 3.11.5 does not properly implement error-code encoding, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for an IPv6 SIOCADDRT ioctl call.",2014-03-05,DoS ,1,https://github.com/torvalds/linux/commit/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,"net: fib: fib6_add: fix potential NULL pointer dereference

When the kernel is compiled with CONFIG_IPV6_SUBTREES, and we return
with an error in fn = fib6_add_1(), then error codes are encoded into
the return pointer e.g. ERR_PTR(-ENOENT). In such an error case, we
write the error code into err and jump to out, hence enter the if(err)
condition. Now, if CONFIG_IPV6_SUBTREES is enabled, we check for:

  if (pn != fn && pn->leaf == rt)
    ...
  if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO))
    ...

Since pn is NULL and fn is f.e. ERR_PTR(-ENOENT), then pn != fn
evaluates to true and causes a NULL-pointer dereference on further
checks on pn. Fix it, by setting both NULL in error case, so that
pn != fn already evaluates to false and no further dereference
takes place.

This was first correctly implemented in 4a287eba2 (""IPv6 routing,
NLM_F_* flag support: REPLACE and EXCL flags support, warn about
missing CREATE flag""), but the bug got later on introduced by
188c517a0 (""ipv6: return errno pointers consistently for fib6_add_1()"").

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Lin Ming <mlin@ss.pku.edu.cn>
Cc: Matti Vaittinen <matti.vaittinen@nsn.com>
Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Matti Vaittinen <matti.vaittinen@nsn.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv6/ip6_fib.c,"{""sha"": ""5bec666aba61d464fab4e77684eedd4265143cf9"", ""filename"": ""net/ipv6/ip6_fib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_fib.c?ref=ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2"", ""patch"": ""@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n \tfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n \t\t\toffsetof(struct rt6_info, rt6i_dst), allow_create,\n \t\t\treplace_required);\n-\n \tif (IS_ERR(fn)) {\n \t\terr = PTR_ERR(fn);\n+\t\tfn = NULL;\n \t\tgoto out;\n \t}\n ""}","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",C,"		fn = NULL;
",,,"@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
-
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
+		fn = NULL;
 		goto out;
 	}
 ",linux,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,3bf4b5b11d381fed6a94a7e487e01c8b3bc436b9,1,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
//flaw_line_below:

 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
//fix_flaw_line_below:
//		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",179110,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","The vulnerability in the original code lies in the handling of the `fn` pointer after the call to `fib6_add_1`. If `fib6_add_1` fails and returns an error, the `fn` pointer is not explicitly set to `NULL`, which could lead to dereferencing an invalid pointer later in the code. This could cause undefined behavior or crashes. In the fixed code, after checking if `IS_ERR(fn)`, the line `fn = NULL;` was added to ensure that `fn` is explicitly set to `NULL` before proceeding to the `out` label, preventing any potential dereference of an invalid pointer.","The vulnerability in the original code arises from the potential dereferencing of an invalid pointer after a failure in a critical function call. If this function fails, the pointer remains uninitialized, leading to undefined behavior or crashes when accessed later in the code. The fix addresses this issue by explicitly setting the pointer to `NULL` after the failure check. This ensures that any subsequent operations that rely on the pointer will not attempt to dereference an invalid memory location, thereby enhancing the stability and safety of the code.",1,5,3,3,"CWE-476, CWE-824, CWE-690, CWE-119, CWE-465, CWE-822, CWE-825, CWE-416, CWE-456, CWE-457",N,-1
19,19,19,179111,179111,,Local,Not required,Complete,CVE-2013-6383,https://www.cvedetails.com/cve/CVE-2013-6383/,CWE-264,Medium,Complete,Complete,,2013-11-26,6.9,"The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call.",2014-03-26,Bypass ,2,https://github.com/torvalds/linux/commit/f856567b930dfcdbc3323261bf77240ccdde01f5,f856567b930dfcdbc3323261bf77240ccdde01f5,"aacraid: missing capable() check in compat ioctl

In commit d496f94d22d1 ('[SCSI] aacraid: fix security weakness') we
added a check on CAP_SYS_RAWIO to the ioctl.  The compat ioctls need the
check as well.

Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,drivers/scsi/aacraid/linit.c,"{""sha"": ""f0d432c139d0cecedf51295562c858d22a9f44f0"", ""filename"": ""drivers/scsi/aacraid/linit.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/aacraid/linit.c?ref=f856567b930dfcdbc3323261bf77240ccdde01f5"", ""patch"": ""@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long\n static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }\n ""}"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
",,,"@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long
 static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
 ",linux,f856567b930dfcdbc3323261bf77240ccdde01f5,c2c65cd2e14ada6de44cb527e7f1990bede24e15,1," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",179111," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
","The vulnerability in the original code lies in the lack of permission checks before executing the `aac_compat_do_ioctl` function, which could allow unauthorized users to perform sensitive operations on the SCSI device. This oversight could lead to privilege escalation or unauthorized access to device controls. In the fixed code, a permission check using `capable(CAP_SYS_RAWIO)` was introduced before the ioctl operation. This ensures that only processes with the appropriate capabilities can execute the command, thereby mitigating the risk of unauthorized access and enhancing the overall security of the SCSI device operations.","The vulnerability in the original code stems from the absence of permission checks before executing potentially sensitive operations, which could allow unauthorized users to manipulate device controls. This lack of validation poses a significant security risk, as it may lead to privilege escalation or unauthorized access to critical system resources. The fixed code addresses this issue by implementing a permission check that verifies whether the calling process has the necessary capabilities to perform the operation. This additional safeguard ensures that only authorized users can execute the command, thereby enhancing the security and integrity of the system.",4,5,3,1,"CWE-269,CWE-862,CWE-732,CWE-285,CWE-264,CWE-266,CWE-284,CWE-287,CWE-434,CWE-522",Y,5
20,20,20,179158,179158,,Local,Not required,Complete,CVE-2013-4470,https://www.cvedetails.com/cve/CVE-2013-4470/,CWE-264,Medium,Complete,Complete,,2013-11-04,6.9,"The Linux kernel before 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly initialize certain data structures, which allows local users to cause a denial of service (memory corruption and system crash) or possibly gain privileges via a crafted application that uses the UDP_CORK option in a setsockopt system call and sends both short and long packets, related to the ip_ufo_append_data function in net/ipv4/ip_output.c and the ip6_ufo_append_data function in net/ipv6/ip6_output.c.",2018-01-08,DoS +Priv Mem. Corr. ,9,https://github.com/torvalds/linux/commit/e93b7d748be887cd7639b113ba7d7ef792a7efb9,e93b7d748be887cd7639b113ba7d7ef792a7efb9,"ip_output: do skb ufo init for peeked non ufo skb as well

Now, if user application does:
sendto len<mtu flag MSG_MORE
sendto len>mtu flag 0
The skb is not treated as fragmented one because it is not initialized
that way. So move the initialization to fix this.

introduced by:
commit e89e9cf539a28df7d0eb1d0a545368e9920b34ac ""[IPv4/IPv6]: UFO Scatter-gather approach""

Signed-off-by: Jiri Pirko <jiri@resnulli.us>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/ip_output.c,"{""sha"": ""3982eabf61e126060fc7c5b48042bea2f0417135"", ""filename"": ""net/ipv4/ip_output.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 4, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_output.c?ref=e93b7d748be887cd7639b113ba7d7ef792a7efb9"", ""patch"": ""@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,\n \t\t/* initialize protocol header pointer */\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n-\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n-\t\t/* specify the length of each IP datagram fragment */\n-\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n-\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n \t\t__skb_queue_tail(queue, skb);\n+\t} else if (skb_is_gso(skb)) {\n+\t\tgoto append;\n \t}\n \n+\tskb->ip_summed = CHECKSUM_PARTIAL;\n+\t/* specify the length of each IP datagram fragment */\n+\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n+\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n+append:\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }""}","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",C,"
	} else if (skb_is_gso(skb)) {
		goto append;
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
","		skb->ip_summed = CHECKSUM_PARTIAL;
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
",,"@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,
 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
-		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
-		/* specify the length of each IP datagram fragment */
-		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
-		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
 		__skb_queue_tail(queue, skb);
+	} else if (skb_is_gso(skb)) {
+		goto append;
 	}
 
+	skb->ip_summed = CHECKSUM_PARTIAL;
+	/* specify the length of each IP datagram fragment */
+	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
+	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
+append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }",linux,e93b7d748be887cd7639b113ba7d7ef792a7efb9,c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,1,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
//flaw_line_below:
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
//flaw_line_below:
		/* specify the length of each IP datagram fragment */
//flaw_line_below:
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//flaw_line_below:
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
 		__skb_queue_tail(queue, skb);
//fix_flaw_line_below:
//	} else if (skb_is_gso(skb)) {
//fix_flaw_line_below:
//		goto append;
 	}
 
//fix_flaw_line_below:
//	skb->ip_summed = CHECKSUM_PARTIAL;
//fix_flaw_line_below:
//	/* specify the length of each IP datagram fragment */
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",179158,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","The vulnerability in the original code arises from the lack of a check for whether the `skb` (socket buffer) is already a GSO (Generic Segmentation Offload) packet before modifying its properties. This could lead to incorrect handling of packets, potentially causing data corruption or crashes. In the fixed code, an additional check using `skb_is_gso(skb)` is introduced to determine if the existing `skb` is a GSO packet. If it is, the code jumps to the `append` label, preventing unnecessary modifications to the `skb` and ensuring that the `ip_summed` and `gso_size` fields are only set when appropriate, thus enhancing stability and correctness.","The vulnerability in the original code stems from the absence of a check to determine if the existing packet is already configured for segmentation, which could lead to improper handling and potential data corruption. This oversight allows the code to modify packet properties even when they should remain unchanged, risking instability in packet processing. The fix introduces a conditional check to ascertain whether the packet is already set for segmentation. If it is, the code bypasses unnecessary modifications, ensuring that packet properties are only adjusted when appropriate, thereby enhancing the overall reliability and correctness of the packet handling process.",3,5,4,0,"CWE-476, CWE-665, CWE-573, CWE-457, CWE-704, CWE-20, CWE-682, CWE-824, CWE-119, CWE-789",N,-1
21,21,21,179163,179163,,Local,Not required,Complete,CVE-2013-4300,https://www.cvedetails.com/cve/CVE-2013-4300/,CWE-264,Low,Complete,Complete,,2013-09-25,7.2,"The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.11 performs a capability check in an incorrect namespace, which allows local users to gain privileges via PID spoofing.",2013-10-30,+Priv ,1,https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e,d661684cf6820331feae71146c35da83d794467e,"net: Check the correct namespace when spoofing pid over SCM_RIGHTS

This is a security bug.

The follow-up will fix nsproxy to discourage this type of issue from
happening again.

Cc: stable@vger.kernel.org
Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/scm.c,"{""sha"": ""b4da80b1cc07d28eafec50a6185d6d2a2ece61af"", ""filename"": ""net/core/scm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/scm.c?ref=d661684cf6820331feae71146c35da83d794467e"", ""patch"": ""@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n-\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n+\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||""}","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",C,"	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
","	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
",,"@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
-	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
+	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||",linux,d661684cf6820331feae71146c35da83d794467e,dd5746bf6b48bb837e9f5af14b9b241fc4fdc1ef,1,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
//flaw_line_below:
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
//fix_flaw_line_below:
//	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",179163,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","The vulnerability in the original code lies in the use of `current->nsproxy->pid_ns->user_ns` to check for administrative capabilities, which could potentially expose the system to privilege escalation attacks if the namespace is manipulated. This could allow unauthorized processes to gain elevated privileges. The fix replaces this with `task_active_pid_ns(current)->user_ns`, ensuring that the user namespace is correctly associated with the currently active task, thereby enhancing security by preventing unauthorized access to sensitive operations based on incorrect namespace references. This change mitigates the risk of privilege escalation by ensuring proper namespace validation.","The vulnerability in the original code stems from the use of an incorrect reference to the user namespace, which could allow unauthorized processes to exploit privilege escalation vulnerabilities. This misconfiguration could enable a malicious actor to gain elevated privileges by manipulating the namespace context. The fix addresses this issue by ensuring that the user namespace is correctly tied to the currently active task, thereby enforcing proper access controls. This change enhances security by preventing unauthorized access to sensitive operations, ensuring that only legitimate processes can perform actions requiring elevated privileges.",2,5,3,4,"CWE-269, CWE-266, CWE-250, CWE-264, CWE-272, CWE-286, CWE-284, CWE-271, CWE-274, CWE-265",N,-1
22,22,22,179220,179220,,Local,Not required,,CVE-2013-2930,https://www.cvedetails.com/cve/CVE-2013-2930/,CWE-264,Low,Partial,Partial,,2013-12-09,3.6,"The perf_trace_event_perm function in kernel/trace/trace_event_perf.c in the Linux kernel before 3.12.2 does not properly restrict access to the perf subsystem, which allows local users to enable function tracing via a crafted application.",2014-03-05,,1,https://github.com/torvalds/linux/commit/12ae030d54ef250706da5642fc7697cc60ad0df7,12ae030d54ef250706da5642fc7697cc60ad0df7,"perf/ftrace: Fix paranoid level for enabling function tracer

The current default perf paranoid level is ""1"" which has
""perf_paranoid_kernel()"" return false, and giving any operations that
use it, access to normal users. Unfortunately, this includes function
tracing and normal users should not be allowed to enable function
tracing by default.

The proper level is defined at ""-1"" (full perf access), which
""perf_paranoid_tracepoint_raw()"" will only give access to. Use that
check instead for enabling function tracing.

Reported-by: Dave Jones <davej@redhat.com>
Reported-by: Vince Weaver <vincent.weaver@maine.edu>
Tested-by: Vince Weaver <vincent.weaver@maine.edu>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: stable@vger.kernel.org # 3.4+
CVE: CVE-2013-2930
Fixes: ced39002f5ea (""ftrace, perf: Add support to use function tracepoint in perf"")
Signed-off-by: Steven Rostedt <rostedt@goodmis.org>",1,kernel/trace/trace_event_perf.c,"{""sha"": ""78e27e3b52ac2ee0b9e86f544b77a45e12865d95"", ""filename"": ""kernel/trace/trace_event_perf.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/trace/trace_event_perf.c?ref=12ae030d54ef250706da5642fc7697cc60ad0df7"", ""patch"": ""@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n {\n \t/* The ftrace function trace is allowed only for root. */\n \tif (ftrace_event_is_function(tp_event) &&\n-\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n+\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \t/* No tracing, just counting, so no obvious leak */""}","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",C,"	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
","	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
",,"@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
-	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
+	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */",linux,12ae030d54ef250706da5642fc7697cc60ad0df7,5e01dc7b26d9f24f39abace5da98ccbd6a5ceb52,1,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
//flaw_line_below:
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
//fix_flaw_line_below:
//	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",179220,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","The vulnerability in the original code lies in the incorrect condition check for allowing non-root users to trace certain events. Specifically, the check for `perf_paranoid_kernel()` was used, which could potentially allow unauthorized access to sensitive tracing data. In the fixed code, this condition was replaced with `perf_paranoid_tracepoint_raw()`, ensuring that only the appropriate security checks are applied. This change tightens the access control, preventing non-root users from tracing raw data that could lead to severe data leaks, thus enhancing the overall security of the tracing mechanism.","The vulnerability in the original code stemmed from inadequate access control, allowing non-root users to potentially trace sensitive data, which could lead to information leaks. This was due to a condition that did not sufficiently restrict access based on user privileges. In the revised code, the access control checks were strengthened by implementing a more appropriate condition that specifically addresses the risks associated with tracing raw data. This change ensures that only authorized users can access sensitive tracing information, thereby mitigating the risk of data exposure and enhancing the overall security of the system.",2,0,2,1,"CWE-285,CWE-732,CWE-269,CWE-284,CWE-732,CWE-200,CWE-264,CWE-250,CWE-612,CWE-668",Y,7
23,23,23,179221,179221,,Local,Not required,,CVE-2013-2929,https://www.cvedetails.com/cve/CVE-2013-2929/,CWE-264,Medium,Partial,Partial,,2013-12-09,3.3,"The Linux kernel before 3.12.2 does not properly use the get_dumpable function, which allows local users to bypass intended ptrace restrictions or obtain sensitive information from IA64 scratch registers via a crafted application, related to kernel/ptrace.c and arch/ia64/include/asm/processor.h.",2018-04-27,Bypass +Info ,2,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,d049f74f2dbe71354d43d393ac3a188947811348,"exec/ptrace: fix get_dumpable() incorrect tests

The get_dumpable() return value is not boolean.  Most users of the
function actually want to be testing for non-SUID_DUMP_USER(1) rather than
SUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a
protected state.  Almost all places did this correctly, excepting the two
places fixed in this patch.

Wrong logic:
    if (dumpable == SUID_DUMP_DISABLE) { /* be protective */ }
        or
    if (dumpable == 0) { /* be protective */ }
        or
    if (!dumpable) { /* be protective */ }

Correct logic:
    if (dumpable != SUID_DUMP_USER) { /* be protective */ }
        or
    if (dumpable != 1) { /* be protective */ }

Without this patch, if the system had set the sysctl fs/suid_dumpable=2, a
user was able to ptrace attach to processes that had dropped privileges to
that user.  (This may have been partially mitigated if Yama was enabled.)

The macros have been moved into the file that declares get/set_dumpable(),
which means things like the ia64 code can see them too.

CVE-2013-2929

Reported-by: Vasily Kulikov <segoon@openwall.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: ""Luck, Tony"" <tony.luck@intel.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,kernel/ptrace.c,"{""sha"": ""5a84b3a5074158d8b0fe975d5def50689c8c735d"", ""filename"": ""arch/ia64/include/asm/processor.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/ia64/include/asm/processor.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -319,7 +319,7 @@ struct thread_struct {\n \tregs->loadrs = 0;\t\t\t\t\t\t\t\t\t\\\n \tregs->r8 = get_dumpable(current->mm);\t/* set \""don't zap registers\"" flag */\t\t\\\n \tregs->r12 = new_sp - 16;\t/* allocate 16 byte scratch area */\t\t\t\\\n-\tif (unlikely(!get_dumpable(current->mm))) {\t\t\t\t\t\t\t\\\n+\tif (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {\t\\\n \t\t/*\t\t\t\t\t\t\t\t\t\t\\\n \t\t * Zap scratch regs to avoid leaking bits between processes with different\t\\\n \t\t * uid/privileges.\t\t\t\t\t\t\t\t\\""}<_**next**_>{""sha"": ""12120620f0409660555aec739e5c0441abb995ee"", ""filename"": ""fs/exec.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exec.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -1669,6 +1669,12 @@ int __get_dumpable(unsigned long mm_flags)\n \treturn (ret > SUID_DUMP_USER) ? SUID_DUMP_ROOT : ret;\n }\n \n+/*\n+ * This returns the actual value of the suid_dumpable flag. For things\n+ * that are using this for checking for privilege transitions, it must\n+ * test against SUID_DUMP_USER rather than treating it as a boolean\n+ * value.\n+ */\n int get_dumpable(struct mm_struct *mm)\n {\n \treturn __get_dumpable(mm->flags);""}<_**next**_>{""sha"": ""7554fd410bcc35ff1a4d56e1e3ae99c62a78bcad"", ""filename"": ""include/linux/binfmts.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/binfmts.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -99,9 +99,6 @@ extern void setup_new_exec(struct linux_binprm * bprm);\n extern void would_dump(struct linux_binprm *, struct file *);\n \n extern int suid_dumpable;\n-#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n-#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n-#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n \n /* Stack area protections */\n #define EXSTACK_DEFAULT   0\t/* Whatever the arch defaults to */""}<_**next**_>{""sha"": ""f7efc86046522c2722501f5967d65983162fa78e"", ""filename"": ""include/linux/sched.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sched.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -323,6 +323,10 @@ static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}\n extern void set_dumpable(struct mm_struct *mm, int value);\n extern int get_dumpable(struct mm_struct *mm);\n \n+#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n+#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n+#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n+\n /* mm flags */\n /* dumpable bits */\n #define MMF_DUMPABLE      0  /* core dump is permitted */""}<_**next**_>{""sha"": ""1f4bcb3cc21cee5bcfd1b4e13a77eeff2af23a2b"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n-\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n+\tif (dumpable != SUID_DUMP_USER &&\n+\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}""}","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",C,"	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
","	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
",,"@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
-	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
+	if (dumpable != SUID_DUMP_USER &&
+	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}",linux,d049f74f2dbe71354d43d393ac3a188947811348,1c3fc3e5cc8a81d21b199cb739d5d9c51f3688f4,1,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
//flaw_line_below:
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
//fix_flaw_line_below:
//	if (dumpable != SUID_DUMP_USER &&
//fix_flaw_line_below:
//	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",179221,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","The vulnerability in the original code lies in the handling of the `dumpable` variable, which could allow unauthorized access to sensitive information if the memory management structure (`task->mm`) is not properly checked. Specifically, the condition `if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode))` could permit access even when the task's memory is not marked as dumpable. The fix introduces a more stringent check by changing the condition to `if (dumpable != SUID_DUMP_USER && !ptrace_has_cap(__task_cred(task)->user_ns, mode))`, ensuring that only tasks explicitly marked as dumpable can be accessed, thereby enhancing security.","The vulnerability in the original code stems from inadequate checks on the access permissions for certain tasks, potentially allowing unauthorized access to sensitive information. Specifically, the logic could permit access even when a task's memory was not appropriately marked as accessible, leading to security risks. The fix addresses this issue by implementing a stricter condition that ensures only tasks explicitly designated as accessible can be interacted with. This change enhances the overall security by preventing unauthorized introspection and ensuring that access is granted only under the correct circumstances, thereby mitigating the risk of information leakage.",4,5,4,4,"CWE-285,CWE-732,CWE-269,CWE-284,CWE-732,CWE-863,CWE-862,CWE-264,CWE-668,CWE-266",Y,8
24,24,24,179266,179266,,Local,Not required,,CVE-2013-1957,https://www.cvedetails.com/cve/CVE-2013-1957/,CWE-264,Medium,Complete,,,2013-04-24,4.7,"The clone_mnt function in fs/namespace.c in the Linux kernel before 3.8.6 does not properly restrict changes to the MNT_READONLY flag, which allows local users to bypass an intended read-only property of a filesystem by leveraging a separate mount namespace.",2013-04-25,Bypass ,4,https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,"vfs: Carefully propogate mounts across user namespaces

As a matter of policy MNT_READONLY should not be changable if the
original mounter had more privileges than creator of the mount
namespace.

Add the flag CL_UNPRIVILEGED to note when we are copying a mount from
a mount namespace that requires more privileges to a mount namespace
that requires fewer privileges.

When the CL_UNPRIVILEGED flag is set cause clone_mnt to set MNT_NO_REMOUNT
if any of the mnt flags that should never be changed are set.

This protects both mount propagation and the initial creation of a less
privileged mount namespace.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""968d4c5eae03aa18b1326e09371aa5ada795939e"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n \t}\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n+\t/* Don't allow unprivileged users to change mount flags */\n+\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n+\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,\n \t/* First pass: copy the tree topology */\n \tcopy_flags = CL_COPY_ALL | CL_EXPIRE;\n \tif (user_ns != mnt_ns->user_ns)\n-\t\tcopy_flags |= CL_SHARED_TO_SLAVE;\n+\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n \tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n \tif (IS_ERR(new)) {\n \t\tup_write(&namespace_sem);""}<_**next**_>{""sha"": ""8b29d2164da6aef6edb88b9872368c849e658530"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -9,6 +9,7 @@\n #include <linux/mnt_namespace.h>\n #include <linux/mount.h>\n #include <linux/fs.h>\n+#include <linux/nsproxy.h>\n #include \""internal.h\""\n #include \""pnode.h\""\n \n@@ -220,6 +221,7 @@ static struct mount *get_source(struct mount *dest,\n int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \t\t    struct mount *source_mnt, struct list_head *tree_list)\n {\n+\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n \tstruct mount *m, *child;\n \tint ret = 0;\n \tstruct mount *prev_dest_mnt = dest_mnt;\n@@ -237,6 +239,10 @@ int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \n \t\tsource =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);\n \n+\t\t/* Notice when we are propagating across user namespaces */\n+\t\tif (m->mnt_ns->user_ns != user_ns)\n+\t\t\ttype |= CL_UNPRIVILEGED;\n+\n \t\tchild = copy_tree(source, source->mnt.mnt_root, type);\n \t\tif (IS_ERR(child)) {\n \t\t\tret = PTR_ERR(child);""}<_**next**_>{""sha"": ""a0493d5ebfbf52be2eb07a794df459ab2a32cd6a"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -23,6 +23,7 @@\n #define CL_MAKE_SHARED \t\t0x08\n #define CL_PRIVATE \t\t0x10\n #define CL_SHARED_TO_SLAVE\t0x20\n+#define CL_UNPRIVILEGED\t\t0x40\n \n static inline void set_mnt_shared(struct mount *mnt)\n {""}","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",C,"	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

",,,"@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
+	/* Don't allow unprivileged users to change mount flags */
+	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
+		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
+
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,
 	/* First pass: copy the tree topology */
 	copy_flags = CL_COPY_ALL | CL_EXPIRE;
 	if (user_ns != mnt_ns->user_ns)
-		copy_flags |= CL_SHARED_TO_SLAVE;
+		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
 	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
 	if (IS_ERR(new)) {
 		up_write(&namespace_sem);",linux,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,90563b198e4c6674c63672fae1923da467215f45,1,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
//fix_flaw_line_below:
//	/* Don't allow unprivileged users to change mount flags */
//fix_flaw_line_below:
//	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
//fix_flaw_line_below:
//		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
//fix_flaw_line_below:
//
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",179266,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","The vulnerability in the original `clone_mnt` function arises from the lack of checks on mount flags, allowing unprivileged users to modify critical mount properties, such as setting a mount as read-only. Specifically, if the `CL_UNPRIVILEGED` flag is set and the mount is already marked as `MNT_READONLY`, the code did not prevent further modifications, potentially leading to privilege escalation or unauthorized access. The fix introduces a conditional check that ensures if `CL_UNPRIVILEGED` is set, the `MNT_LOCK_READONLY` flag is applied, thereby preventing unprivileged users from altering the mount's read-only status.","The vulnerability in the original code stems from insufficient checks on user privileges when modifying mount properties, particularly allowing unprivileged users to alter critical flags related to mount access. This oversight could lead to unauthorized changes, potentially enabling privilege escalation or access to restricted resources. The fix addresses this issue by introducing a conditional check that restricts modifications to mount flags when certain conditions are met, ensuring that unprivileged users cannot change the mount's read-only status. This enhancement effectively mitigates the risk of unauthorized access and maintains the integrity of the mount system.",1,5,2,1,"CWE-269, CWE-264, CWE-732, CWE-284, CWE-266, CWE-285, CWE-639, CWE-273, CWE-668, CWE-272",N,-1
25,25,25,179269,179269,,Local,Not required,,CVE-2013-1956,https://www.cvedetails.com/cve/CVE-2013-1956/,CWE-264,Low,,Partial,,2013-04-24,2.1,"The create_user_ns function in kernel/user_namespace.c in the Linux kernel before 3.8.6 does not check whether a chroot directory exists that differs from the namespace root directory, which allows local users to bypass intended filesystem restrictions via a crafted clone system call.",2013-05-01,Bypass ,9,https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d,3151527ee007b73a0ebd296010f1c0454a919c7d,"userns:  Don't allow creation if the user is chrooted

Guarantee that the policy of which files may be access that is
established by setting the root directory will not be violated
by user namespaces by verifying that the root directory points
to the root of the mount namespace at the time of user namespace
creation.

Changing the root is a privileged operation, and as a matter of policy
it serves to limit unprivileged processes to files below the current
root directory.

For reasons of simplicity and comprehensibility the privilege to
change the root directory is gated solely on the CAP_SYS_CHROOT
capability in the user namespace.  Therefore when creating a user
namespace we must ensure that the policy of which files may be access
can not be violated by changing the root directory.

Anyone who runs a processes in a chroot and would like to use user
namespace can setup the same view of filesystems with a mount
namespace instead.  With this result that this is not a practical
limitation for using user namespaces.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,kernel/user_namespace.c,"{""sha"": ""a3035223d4218c13ac6db83f8d5444e454346c2f"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -2732,6 +2732,30 @@ bool our_mnt(struct vfsmount *mnt)\n \treturn check_mnt(real_mount(mnt));\n }\n \n+bool current_chrooted(void)\n+{\n+\t/* Does the current process have a non-standard root */\n+\tstruct path ns_root;\n+\tstruct path fs_root;\n+\tbool chrooted;\n+\n+\t/* Find the namespace root */\n+\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n+\tns_root.dentry = ns_root.mnt->mnt_root;\n+\tpath_get(&ns_root);\n+\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n+\t\t;\n+\n+\tget_fs_root(current->fs, &fs_root);\n+\n+\tchrooted = !path_equal(&fs_root, &ns_root);\n+\n+\tpath_put(&fs_root);\n+\tpath_put(&ns_root);\n+\n+\treturn chrooted;\n+}\n+\n static void *mntns_get(struct task_struct *task)\n {\n \tstruct mnt_namespace *ns = NULL;""}<_**next**_>{""sha"": ""2b93a9a5a1e6b8ef4a15a6aaf36ade3b48bd0d98"", ""filename"": ""include/linux/fs_struct.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs_struct.h?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -50,4 +50,6 @@ static inline void get_fs_root_and_pwd(struct fs_struct *fs, struct path *root,\n \tspin_unlock(&fs->lock);\n }\n \n+extern bool current_chrooted(void);\n+\n #endif /* _LINUX_FS_STRUCT_H */""}<_**next**_>{""sha"": ""0f1e42884577c93b891a7da6aa149733ba2d5141"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)\n \tkgid_t group = new->egid;\n \tint ret;\n \n+\t/*\n+\t * Verify that we can not violate the policy of which files\n+\t * may be accessed that is specified by the root directory,\n+\t * by verifing that the root directory is at the root of the\n+\t * mount namespace which allows all files to be accessed.\n+\t */\n+\tif (current_chrooted())\n+\t\treturn -EPERM;\n+\n \t/* The creator needs a mapping in the parent user namespace\n \t * or else we won't be able to reasonably tell userspace who\n \t * created a user_namespace.""}","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",C,"	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

",,,"@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)
 	kgid_t group = new->egid;
 	int ret;
 
+	/*
+	 * Verify that we can not violate the policy of which files
+	 * may be accessed that is specified by the root directory,
+	 * by verifing that the root directory is at the root of the
+	 * mount namespace which allows all files to be accessed.
+	 */
+	if (current_chrooted())
+		return -EPERM;
+
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.",linux,3151527ee007b73a0ebd296010f1c0454a919c7d,eddc0a3abff273842a94784d2d022bbc36dc9015,1,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Verify that we can not violate the policy of which files
//fix_flaw_line_below:
//	 * may be accessed that is specified by the root directory,
//fix_flaw_line_below:
//	 * by verifing that the root directory is at the root of the
//fix_flaw_line_below:
//	 * mount namespace which allows all files to be accessed.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (current_chrooted())
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",179269,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","The vulnerability in the original code stemmed from the lack of verification regarding the current process's chroot environment, which could allow unauthorized access to files outside the intended namespace. Specifically, the absence of a check for `current_chrooted()` meant that a user could potentially create a user namespace without proper restrictions, leading to privilege escalation. The fixed code addresses this vulnerability by introducing a check for `current_chrooted()`, returning `-EPERM` if the process is chrooted, thereby enforcing a policy that prevents the creation of user namespaces in potentially unsafe contexts.","The vulnerability in the original code allowed the creation of user namespaces without verifying whether the process was operating within a chroot environment, potentially enabling unauthorized access to files and resources outside the intended scope. This oversight could lead to privilege escalation, as users could manipulate namespaces without proper restrictions. The fixed code addresses this issue by introducing a check to determine if the process is chrooted, returning an error if it is. This additional verification ensures that the creation of user namespaces adheres to security policies, thereby preventing unauthorized access and maintaining system integrity.",3,5,3,4,"CWE-269,CWE-250,CWE-273,CWE-653,CWE-265,CWE-264,CWE-266,CWE-284,CWE-732,CWE-268",Y,6
26,26,26,179294,179294,,Local,Not required,Complete,CVE-2013-1774,https://www.cvedetails.com/cve/CVE-2013-1774/,CWE-264,High,,,,2013-02-28,4.0,The chase_port function in drivers/usb/serial/io_ti.c in the Linux kernel before 3.7.4 allows local users to cause a denial of service (NULL pointer dereference and system crash) via an attempted /dev/ttyUSB read or write operation on a disconnected Edgeport USB serial converter.,2019-04-22,DoS ,3,https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811,1ee0a224bc9aad1de496c795f96bc6ba2c394811,"USB: io_ti: Fix NULL dereference in chase_port()

The tty is NULL when the port is hanging up.
chase_port() needs to check for this.

This patch is intended for stable series.
The behavior was observed and tested in Linux 3.2 and 3.7.1.

Johan Hovold submitted a more elaborate patch for the mainline kernel.

[   56.277883] usb 1-1: edge_bulk_in_callback - nonzero read bulk status received: -84
[   56.278811] usb 1-1: USB disconnect, device number 3
[   56.278856] usb 1-1: edge_bulk_in_callback - stopping read!
[   56.279562] BUG: unable to handle kernel NULL pointer dereference at 00000000000001c8
[   56.280536] IP: [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.281212] PGD 1dc1b067 PUD 1e0f7067 PMD 0
[   56.282085] Oops: 0002 [#1] SMP
[   56.282744] Modules linked in:
[   56.283512] CPU 1
[   56.283512] Pid: 25, comm: khubd Not tainted 3.7.1 #1 innotek GmbH VirtualBox/VirtualBox
[   56.283512] RIP: 0010:[<ffffffff8144e62a>]  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512] RSP: 0018:ffff88001fa99ab0  EFLAGS: 00010046
[   56.283512] RAX: 0000000000000046 RBX: 00000000000001c8 RCX: 0000000000640064
[   56.283512] RDX: 0000000000010000 RSI: ffff88001fa99b20 RDI: 00000000000001c8
[   56.283512] RBP: ffff88001fa99b20 R08: 0000000000000000 R09: 0000000000000000
[   56.283512] R10: 0000000000000000 R11: ffffffff812fcb4c R12: ffff88001ddf53c0
[   56.283512] R13: 0000000000000000 R14: 00000000000001c8 R15: ffff88001e19b9f4
[   56.283512] FS:  0000000000000000(0000) GS:ffff88001fd00000(0000) knlGS:0000000000000000
[   56.283512] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[   56.283512] CR2: 00000000000001c8 CR3: 000000001dc51000 CR4: 00000000000006e0
[   56.283512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   56.283512] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[   56.283512] Process khubd (pid: 25, threadinfo ffff88001fa98000, task ffff88001fa94f80)
[   56.283512] Stack:
[   56.283512]  0000000000000046 00000000000001c8 ffffffff810578ec ffffffff812fcb4c
[   56.283512]  ffff88001e19b980 0000000000002710 ffffffff812ffe81 0000000000000001
[   56.283512]  ffff88001fa94f80 0000000000000202 ffffffff00000001 0000000000000296
[   56.283512] Call Trace:
[   56.283512]  [<ffffffff810578ec>] ? add_wait_queue+0x12/0x3c
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff812ffe81>] ? chase_port+0x84/0x2d6
[   56.283512]  [<ffffffff81063f27>] ? try_to_wake_up+0x199/0x199
[   56.283512]  [<ffffffff81263a5c>] ? tty_ldisc_hangup+0x222/0x298
[   56.283512]  [<ffffffff81300171>] ? edge_close+0x64/0x129
[   56.283512]  [<ffffffff810612f7>] ? __wake_up+0x35/0x46
[   56.283512]  [<ffffffff8106135b>] ? should_resched+0x5/0x23
[   56.283512]  [<ffffffff81264916>] ? tty_port_shutdown+0x39/0x44
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff8125d38c>] ? __tty_hangup+0x307/0x351
[   56.283512]  [<ffffffff812e6ddc>] ? usb_hcd_flush_endpoint+0xde/0xed
[   56.283512]  [<ffffffff8144e625>] ? _raw_spin_lock_irqsave+0x14/0x35
[   56.283512]  [<ffffffff812fd361>] ? usb_serial_disconnect+0x57/0xc2
[   56.283512]  [<ffffffff812ea99b>] ? usb_unbind_interface+0x5c/0x131
[   56.283512]  [<ffffffff8128d738>] ? __device_release_driver+0x7f/0xd5
[   56.283512]  [<ffffffff8128d9cd>] ? device_release_driver+0x1a/0x25
[   56.283512]  [<ffffffff8128d393>] ? bus_remove_device+0xd2/0xe7
[   56.283512]  [<ffffffff8128b7a3>] ? device_del+0x119/0x167
[   56.283512]  [<ffffffff812e8d9d>] ? usb_disable_device+0x6a/0x180
[   56.283512]  [<ffffffff812e2ae0>] ? usb_disconnect+0x81/0xe6
[   56.283512]  [<ffffffff812e4435>] ? hub_thread+0x577/0xe82
[   56.283512]  [<ffffffff8144daa7>] ? __schedule+0x490/0x4be
[   56.283512]  [<ffffffff8105798f>] ? abort_exclusive_wait+0x79/0x79
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff810570b4>] ? kthread+0x81/0x89
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512]  [<ffffffff8145387c>] ? ret_from_fork+0x7c/0xb0
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512] Code: 8b 7c 24 08 e8 17 0b c3 ff 48 8b 04 24 48 83 c4 10 c3 53 48 89 fb 41 50 e8 e0 0a c3 ff 48 89 04 24 e8 e7 0a c3 ff ba 00 00 01 00
<f0> 0f c1 13 48 8b 04 24 89 d1 c1 ea 10 66 39 d1 74 07 f3 90 66
[   56.283512] RIP  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512]  RSP <ffff88001fa99ab0>
[   56.283512] CR2: 00000000000001c8
[   56.283512] ---[ end trace 49714df27e1679ce ]---

Signed-off-by: Wolfgang Frisch <wfpub@roembden.net>
Cc: Johan Hovold <jhovold@gmail.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/usb/serial/io_ti.c,"{""sha"": ""82afc4d6a327d6bdbebc4707507684c966f11f9f"", ""filename"": ""drivers/usb/serial/io_ti.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/io_ti.c?ref=1ee0a224bc9aad1de496c795f96bc6ba2c394811"", ""patch"": ""@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,\n \twait_queue_t wait;\n \tunsigned long flags;\n \n+\tif (!tty)\n+\t\treturn;\n+\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n ""}","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",C,"	if (!tty)
		return;

",,,"@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,
 	wait_queue_t wait;
 	unsigned long flags;
 
+	if (!tty)
+		return;
+
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 ",linux,1ee0a224bc9aad1de496c795f96bc6ba2c394811,99beb2e9687ffd61c92a9875141eabe6f57a71b9,1,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!tty)
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",179294,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","The vulnerability in the original code arises from the lack of a null check for the `tty` variable, which is obtained via `tty_port_tty_get(&port->port->port)`. If this function returns a null pointer, subsequent operations on `tty`, such as `add_wait_queue(&tty->write_wait, &wait)`, could lead to dereferencing a null pointer, resulting in a potential crash or undefined behavior. The fixed code addresses this vulnerability by adding a check for `tty` immediately after its assignment, ensuring that the function returns early if `tty` is null, thus preventing any further operations on it and enhancing overall stability.","The vulnerability in the original code stems from the absence of a check for a null pointer, which could lead to dereferencing an invalid memory address if the pointer is not properly initialized. This oversight can result in crashes or unpredictable behavior when the code attempts to access or manipulate data associated with the null pointer. The fixed code rectifies this issue by introducing a validation step that checks whether the pointer is null before proceeding with any operations. This early exit mechanism ensures that the code only continues execution when it is safe to do so, thereby enhancing stability and reliability.",4,5,4,4,"CWE-476, CWE-690, CWE-824, CWE-1188, CWE-119, CWE-758, CWE-89, CWE-457, CWE-465, CWE-475",N,-1
27,27,27,179306,179306,,Local,Not required,,CVE-2013-0914,https://www.cvedetails.com/cve/CVE-2013-0914/,CWE-264,Low,Partial,Partial,,2013-03-22,3.6,"The flush_signal_handlers function in kernel/signal.c in the Linux kernel before 3.8.4 preserves the value of the sa_restorer field across an exec operation, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application containing a sigaction system call.",2014-02-06,Bypass ,3,https://github.com/torvalds/linux/commit/2ca39528c01a933f6689cd6505ce65bd6d68a530,2ca39528c01a933f6689cd6505ce65bd6d68a530,"signal: always clear sa_restorer on execve

When the new signal handlers are set up, the location of sa_restorer is
not cleared, leaking a parent process's address space location to
children.  This allows for a potential bypass of the parent's ASLR by
examining the sa_restorer value returned when calling sigaction().

Based on what should be considered ""secret"" about addresses, it only
matters across the exec not the fork (since the VMAs haven't changed
until the exec).  But since exec sets SIG_DFL and keeps sa_restorer,
this is where it should be fixed.

Given the few uses of sa_restorer, a ""set"" function was not written
since this would be the only use.  Instead, we use
__ARCH_HAS_SA_RESTORER, as already done in other places.

Example of the leak before applying this patch:

  $ cat /proc/$$/maps
  ...
  7fb9f3083000-7fb9f3238000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  $ ./leak
  ...
  7f278bc74000-7f278be29000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  1 0 (nil) 0x7fb9f30b94a0
  2 4000000 (nil) 0x7f278bcaa4a0
  3 4000000 (nil) 0x7f278bcaa4a0
  4 0 (nil) 0x7fb9f30b94a0
  ...

[akpm@linux-foundation.org: use SA_RESTORER for backportability]
Signed-off-by: Kees Cook <keescook@chromium.org>
Reported-by: Emese Revfy <re.emese@gmail.com>
Cc: Emese Revfy <re.emese@gmail.com>
Cc: PaX Team <pageexec@freemail.hu>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: Serge Hallyn <serge.hallyn@canonical.com>
Cc: Julien Tinnes <jln@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/signal.c,"{""sha"": ""43b0d4a1b7bace76e2dac9a87e2a2f6ab5efdf3e"", ""filename"": ""kernel/signal.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/signal.c?ref=2ca39528c01a933f6689cd6505ce65bd6d68a530"", ""patch"": ""@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n+#ifdef SA_RESTORER\n+\t\tka->sa.sa_restorer = NULL;\n+#endif\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}""}","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",C,"#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
",,,"@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
+#ifdef SA_RESTORER
+		ka->sa.sa_restorer = NULL;
+#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}",linux,2ca39528c01a933f6689cd6505ce65bd6d68a530,f8749452adcddd62e3707709ec2ae4856e70a3f2,1,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
//fix_flaw_line_below:
//#ifdef SA_RESTORER
//fix_flaw_line_below:
//		ka->sa.sa_restorer = NULL;
//fix_flaw_line_below:
//#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",179306,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","The vulnerability in the original code lies in the lack of initialization for the `sa_restorer` field in the `k_sigaction` structure, which could lead to undefined behavior if a signal handler is invoked without a proper restorer function. This oversight may allow for potential exploitation, as attackers could manipulate the signal handling mechanism. The fixed code addresses this vulnerability by explicitly setting `ka->sa.sa_restorer` to `NULL` when the `SA_RESTORER` macro is defined, ensuring that the restorer function is properly initialized and reducing the risk of unintended behavior during signal handling.","The vulnerability in the original code stems from the failure to initialize a critical field related to signal handling, which could lead to undefined behavior when a signal handler is executed. This oversight creates a potential attack vector, as an uninitialized field may allow malicious actors to exploit the signal handling mechanism. The revised code mitigates this vulnerability by ensuring that the problematic field is explicitly set to a safe value when a specific condition is met. This change enhances the robustness of the signal handling process, thereby reducing the risk of exploitation and ensuring more predictable behavior.",2,5,2,2,"CWE-908, CWE-824, CWE-457, CWE-665, CWE-456, CWE-664, CWE-762, CWE-374, CWE-415, CWE-416",N,-1
28,28,28,179338,179338,,Local,Not required,Complete,CVE-2013-0268,https://www.cvedetails.com/cve/CVE-2013-0268/,CWE-264,High,Complete,Complete,,2013-02-17,6.2,"The msr_open function in arch/x86/kernel/msr.c in the Linux kernel before 3.7.6 allows local users to bypass intended capability restrictions by executing a crafted application as root, as demonstrated by msr32.c.",2013-08-22,Bypass ,3,https://github.com/torvalds/linux/commit/c903f0456bc69176912dee6dd25c6a66ee1aed00,c903f0456bc69176912dee6dd25c6a66ee1aed00,"x86/msr: Add capabilities check

At the moment the MSR driver only relies upon file system
checks. This means that anything as root with any capability set
can write to MSRs. Historically that wasn't very interesting but
on modern processors the MSRs are such that writing to them
provides several ways to execute arbitary code in kernel space.
Sample code and documentation on doing this is circulating and
MSR attacks are used on Windows 64bit rootkits already.

In the Linux case you still need to be able to open the device
file so the impact is fairly limited and reduces the security of
some capability and security model based systems down towards
that of a generic ""root owns the box"" setup.

Therefore they should require CAP_SYS_RAWIO to prevent an
elevation of capabilities. The impact of this is fairly minimal
on most setups because they don't have heavy use of
capabilities. Those using SELinux, SMACK or AppArmor rules might
want to consider if their rulesets on the MSR driver could be
tighter.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Horses <stable@kernel.org>
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,arch/x86/kernel/msr.c,"{""sha"": ""4929502c1372db979d7e1b176b22a9981e8ec96e"", ""filename"": ""arch/x86/kernel/msr.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/msr.c?ref=c903f0456bc69176912dee6dd25c6a66ee1aed00"", ""patch"": ""@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n+\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t/* No such CPU */""}","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

",,,"@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */",linux,c903f0456bc69176912dee6dd25c6a66ee1aed00,73b664ceb5f815c38def1c68912b83f83455e9eb,1,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",179338,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","The vulnerability in the original code lies in the lack of permission checks before accessing Model-Specific Registers (MSRs), which could allow unauthorized users to manipulate sensitive CPU features. Specifically, the function `msr_open` did not verify if the calling process had the necessary capabilities, potentially leading to privilege escalation. The fixed code addresses this vulnerability by introducing a permission check using `capable(CAP_SYS_RAWIO)`, which ensures that only processes with the appropriate permissions can access MSRs. If the check fails, the function returns `-EPERM`, effectively preventing unauthorized access.","The vulnerability in the original code stems from the absence of permission checks before allowing access to sensitive system resources, which could enable unauthorized users to manipulate critical CPU features. This oversight could lead to privilege escalation, as any user could potentially interact with hardware-level controls without proper authorization. The revised code rectifies this issue by implementing a capability check that verifies whether the calling process has the necessary permissions to access these resources. If the process lacks the required permissions, the function returns an error, thereby preventing unauthorized access and enhancing system security.",3,5,4,4,"CWE-269,CWE-264,CWE-732,CWE-284,CWE-272,CWE-273,CWE-250,CWE-266,CWE-281,CWE-287",Y,2
29,29,29,179381,179381,,Local,Not required,Complete,CVE-2011-4347,https://www.cvedetails.com/cve/CVE-2011-4347/,CWE-264,High,,,,2013-06-08,4.0,"The kvm_vm_ioctl_assign_device function in virt/kvm/assigned-dev.c in the KVM subsystem in the Linux kernel before 3.1.10 does not verify permission to access PCI configuration space and BAR resources, which allows host OS users to assign PCI devices and cause a denial of service (host OS crash) via a KVM_ASSIGN_PCI_DEVICE operation.",2013-06-10,DoS ,13,https://github.com/torvalds/linux/commit/c4e7f9022e506c6635a5037713c37118e23193e4,c4e7f9022e506c6635a5037713c37118e23193e4,"KVM: Device assignment permission checks

(cherry picked from commit 3d27e23b17010c668db311140b17bbbb70c78fb9)

Only allow KVM device assignment to attach to devices which:

 - Are not bridges
 - Have BAR resources (assume others are special devices)
 - The user has permissions to use

Assigning a bridge is a configuration error, it's not supported, and
typically doesn't result in the behavior the user is expecting anyway.
Devices without BAR resources are typically chipset components that
also don't have host drivers.  We don't want users to hold such devices
captive or cause system problems by fencing them off into an iommu
domain.  We determine ""permission to use"" by testing whether the user
has access to the PCI sysfs resource files.  By default a normal user
will not have access to these files, so it provides a good indication
that an administration agent has granted the user access to the device.

[Yang Bai: add missing #include]
[avi: fix comment style]

Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Yang Bai <hamo.by@gmail.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>",0,virt/kvm/assigned-dev.c,"{""sha"": ""13ab8379b4eb0e9a3665954b917feccf3560769f"", ""filename"": ""Documentation/virtual/kvm/api.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/virtual/kvm/api.txt?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -1134,6 +1134,10 @@ following flags are specified:\n The KVM_DEV_ASSIGN_ENABLE_IOMMU flag is a mandatory option to ensure\n isolation of the device.  Usages not specifying this flag are deprecated.\n \n+Only PCI header type 0 devices with PCI BAR resources are supported by\n+device assignment.  The user requesting this ioctl must have read/write\n+access to the PCI sysfs resource files associated with the device.\n+\n 4.49 KVM_DEASSIGN_PCI_DEVICE\n \n Capability: KVM_CAP_DEVICE_DEASSIGNMENT""}<_**next**_>{""sha"": ""af7910228fb1c31eb00dfb1734d7b019ddf87b2d"", ""filename"": ""virt/kvm/assigned-dev.c"", ""status"": ""modified"", ""additions"": 75, ""deletions"": 0, ""changes"": 75, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/virt/kvm/assigned-dev.c?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -17,6 +17,8 @@\n #include <linux/pci.h>\n #include <linux/interrupt.h>\n #include <linux/slab.h>\n+#include <linux/namei.h>\n+#include <linux/fs.h>\n #include \""irq.h\""\n \n static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n \treturn r;\n }\n \n+/*\n+ * We want to test whether the caller has been granted permissions to\n+ * use this device.  To be able to configure and control the device,\n+ * the user needs access to PCI configuration space and BAR resources.\n+ * These are accessed through PCI sysfs.  PCI config space is often\n+ * passed to the process calling this ioctl via file descriptor, so we\n+ * can't rely on access to that file.  We can check for permissions\n+ * on each of the BAR resource files, which is a pretty clear\n+ * indicator that the user has been granted access to the device.\n+ */\n+static int probe_sysfs_permissions(struct pci_dev *dev)\n+{\n+#ifdef CONFIG_SYSFS\n+\tint i;\n+\tbool bar_found = false;\n+\n+\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n+\t\tchar *kpath, *syspath;\n+\t\tstruct path path;\n+\t\tstruct inode *inode;\n+\t\tint r;\n+\n+\t\tif (!pci_resource_len(dev, i))\n+\t\t\tcontinue;\n+\n+\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n+\t\tif (!kpath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\t/* Per sysfs-rules, sysfs is always at /sys */\n+\t\tsyspath = kasprintf(GFP_KERNEL, \""/sys%s/resource%d\"", kpath, i);\n+\t\tkfree(kpath);\n+\t\tif (!syspath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n+\t\tkfree(syspath);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tinode = path.dentry->d_inode;\n+\n+\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n+\t\tpath_put(&path);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tbar_found = true;\n+\t}\n+\n+\t/* If no resources, probably something special */\n+\tif (!bar_found)\n+\t\treturn -EPERM;\n+\n+\treturn 0;\n+#else\n+\treturn -EINVAL; /* No way to control the device without sysfs */\n+#endif\n+}\n+\n static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n {\n \tint r = 0, idx;\n \tstruct kvm_assigned_dev_kernel *match;\n \tstruct pci_dev *dev;\n+\tu8 header_type;\n \n \tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n \t\treturn -EINVAL;\n@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\tr = -EINVAL;\n \t\tgoto out_free;\n \t}\n+\n+\t/* Don't allow bridges to be assigned */\n+\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n+\tif ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {\n+\t\tr = -EPERM;\n+\t\tgoto out_put;\n+\t}\n+\n+\tr = probe_sysfs_permissions(dev);\n+\tif (r)\n+\t\tgoto out_put;\n+\n \tif (pci_enable_device(dev)) {\n \t\tprintk(KERN_INFO \""%s: Could not enable PCI device\\n\"", __func__);\n \t\tr = -EBUSY;""}"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",C,"	u8 header_type;

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

",,,"@@ -17,6 +17,8 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/namei.h>
+#include <linux/fs.h>
 #include ""irq.h""
 
 static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,
@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,
 	return r;
 }
 
+/*
+ * We want to test whether the caller has been granted permissions to
+ * use this device.  To be able to configure and control the device,
+ * the user needs access to PCI configuration space and BAR resources.
+ * These are accessed through PCI sysfs.  PCI config space is often
+ * passed to the process calling this ioctl via file descriptor, so we
+ * can't rely on access to that file.  We can check for permissions
+ * on each of the BAR resource files, which is a pretty clear
+ * indicator that the user has been granted access to the device.
+ */
+static int probe_sysfs_permissions(struct pci_dev *dev)
+{
+#ifdef CONFIG_SYSFS
+	int i;
+	bool bar_found = false;
+
+	for (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {
+		char *kpath, *syspath;
+		struct path path;
+		struct inode *inode;
+		int r;
+
+		if (!pci_resource_len(dev, i))
+			continue;
+
+		kpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
+		if (!kpath)
+			return -ENOMEM;
+
+		/* Per sysfs-rules, sysfs is always at /sys */
+		syspath = kasprintf(GFP_KERNEL, ""/sys%s/resource%d"", kpath, i);
+		kfree(kpath);
+		if (!syspath)
+			return -ENOMEM;
+
+		r = kern_path(syspath, LOOKUP_FOLLOW, &path);
+		kfree(syspath);
+		if (r)
+			return r;
+
+		inode = path.dentry->d_inode;
+
+		r = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);
+		path_put(&path);
+		if (r)
+			return r;
+
+		bar_found = true;
+	}
+
+	/* If no resources, probably something special */
+	if (!bar_found)
+		return -EPERM;
+
+	return 0;
+#else
+	return -EINVAL; /* No way to control the device without sysfs */
+#endif
+}
+
 static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
+	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;
@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 		r = -EINVAL;
 		goto out_free;
 	}
+
+	/* Don't allow bridges to be assigned */
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
+	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
+		r = -EPERM;
+		goto out_put;
+	}
+
+	r = probe_sysfs_permissions(dev);
+	if (r)
+		goto out_put;
+
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;",linux,c4e7f9022e506c6635a5037713c37118e23193e4,4fd9e326e5001982747225f0f7bb462e34ae9215,1," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
//fix_flaw_line_below:
//	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't allow bridges to be assigned */
//fix_flaw_line_below:
//	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
//fix_flaw_line_below:
//	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
//fix_flaw_line_below:
//		r = -EPERM;
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	r = probe_sysfs_permissions(dev);
//fix_flaw_line_below:
//	if (r)
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",179381," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
","The vulnerability in the original code stemmed from the lack of validation for the type of PCI device being assigned, allowing potentially unsafe devices, such as bridges, to be assigned to the KVM. This could lead to system instability or security issues. The fix introduced a check using `pci_read_config_byte` to read the `header_type` of the device and ensure it is a normal device (`PCI_HEADER_TYPE_NORMAL`). If the device is not of the correct type, the function returns `-EPERM`, preventing the assignment of inappropriate devices and enhancing overall system security.","The vulnerability in the original code allowed for the assignment of potentially unsafe PCI devices, such as bridges, which could lead to system instability or security risks. This lack of validation meant that any device could be assigned without proper checks, increasing the attack surface. The fix implemented a validation step to check the type of PCI device before assignment, ensuring that only appropriate devices could be assigned. By rejecting devices that do not meet the specified criteria, the code now prevents unsafe configurations, thereby enhancing the overall security and stability of the system.",4,4,5,3,"CWE-284,CWE-269,CWE-732,CWE-862,CWE-665,CWE-668,CWE-669,CWE-653,CWE-749,CWE-20",N,-1
30,30,30,179406,179406,,Local,Not required,,CVE-2011-1019,https://www.cvedetails.com/cve/CVE-2011-1019/,CWE-264,Medium,,Partial,,2013-03-01,1.9,The dev_load function in net/core/dev.c in the Linux kernel before 2.6.38 allows local users to bypass an intended CAP_SYS_MODULE capability requirement and load arbitrary modules by leveraging the CAP_NET_ADMIN capability.,2013-03-04,Bypass ,10,https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b,8909c9ad8ff03611c9c96c9a92656213e4bb495b,"net: don't allow CAP_NET_ADMIN to load non-netdev kernel modules

Since a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with
CAP_NET_ADMIN may load any module from /lib/modules/.  This doesn't mean
that CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are
limited to /lib/modules/**.  However, CAP_NET_ADMIN capability shouldn't
allow anybody load any module not related to networking.

This patch restricts an ability of autoloading modules to netdev modules
with explicit aliases.  This fixes CVE-2011-1019.

Arnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior
of loading netdev modules by name (without any prefix) for processes
with CAP_SYS_MODULE to maintain the compatibility with network scripts
that use autoloading netdev modules by aliases like ""eth0"", ""wlan0"".

Currently there are only three users of the feature in the upstream
kernel: ipip, ip_gre and sit.

    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --
    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	fffffff800001000
    CapEff:	fffffff800001000
    CapBnd:	fffffff800001000
    root@albatros:~# modprobe xfs
    FATAL: Error inserting xfs
    (/lib/modules/2.6.38-rc6-00001-g2bf4ca3/kernel/fs/xfs/xfs.ko): Operation not permitted
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit
    sit: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit0
    sit0      Link encap:IPv6-in-IPv4
	      NOARP  MTU:1480  Metric:1

    root@albatros:~# lsmod | grep sit
    sit                    10457  0
    tunnel4                 2957  1 sit

For CAP_SYS_MODULE module loading is still relaxed:

    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	ffffffffffffffff
    CapEff:	ffffffffffffffff
    CapBnd:	ffffffffffffffff
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    xfs                   745319  0

Reference: https://lkml.org/lkml/2011/2/24/203

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
Acked-by: David S. Miller <davem@davemloft.net>
Acked-by: Kees Cook <kees.cook@canonical.com>
Signed-off-by: James Morris <jmorris@namei.org>",2,net/core/dev.c,"{""sha"": ""71caf7a5e6c6cc59fd975f06a0ce6bb304288d52"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -2392,6 +2392,9 @@ extern int netdev_notice(const struct net_device *dev, const char *format, ...)\n extern int netdev_info(const struct net_device *dev, const char *format, ...)\n \t__attribute__ ((format (printf, 2, 3)));\n \n+#define MODULE_ALIAS_NETDEV(device) \\\n+\tMODULE_ALIAS(\""netdev-\"" device)\n+\n #if defined(DEBUG)\n #define netdev_dbg(__dev, format, args...)\t\t\t\\\n \tnetdev_printk(KERN_DEBUG, __dev, format, ##args)""}<_**next**_>{""sha"": ""6561021d22d1fef9b58ec54ec2b394400fb7ba25"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);\n void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n+\tint no_module;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n-\tif (!dev && capable(CAP_NET_ADMIN))\n-\t\trequest_module(\""%s\"", name);\n+\tno_module = !dev;\n+\tif (no_module && capable(CAP_NET_ADMIN))\n+\t\tno_module = request_module(\""netdev-%s\"", name);\n+\tif (no_module && capable(CAP_SYS_MODULE)) {\n+\t\tif (!request_module(\""%s\"", name))\n+\t\t\tpr_err(\""Loading kernel module for a network device \""\n+\""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \""\n+\""instead\\n\"", name);\n+\t}\n }\n EXPORT_SYMBOL(dev_load);\n ""}<_**next**_>{""sha"": ""d1d0e2c256fc4080033a01a621f73b1c3b080b7e"", ""filename"": ""net/ipv4/ip_gre.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_gre.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1765,4 +1765,4 @@ module_exit(ipgre_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_ALIAS_RTNL_LINK(\""gre\"");\n MODULE_ALIAS_RTNL_LINK(\""gretap\"");\n-MODULE_ALIAS(\""gre0\"");\n+MODULE_ALIAS_NETDEV(\""gre0\"");""}<_**next**_>{""sha"": ""a5f58e7cbb26eec188786ff1324cfc540aba1ce1"", ""filename"": ""net/ipv4/ipip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ipip.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -913,4 +913,4 @@ static void __exit ipip_fini(void)\n module_init(ipip_init);\n module_exit(ipip_fini);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""tunl0\"");\n+MODULE_ALIAS_NETDEV(\""tunl0\"");""}<_**next**_>{""sha"": ""d2c16e10f650807ec32cc0502efa32cea8bc93b6"", ""filename"": ""net/ipv6/sit.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/sit.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1290,4 +1290,4 @@ static int __init sit_init(void)\n module_init(sit_init);\n module_exit(sit_cleanup);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""sit0\"");\n+MODULE_ALIAS_NETDEV(\""sit0\"");""}"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
",C,"	int no_module;
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
","	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
",,"@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);
 void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
+	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
-	if (!dev && capable(CAP_NET_ADMIN))
-		request_module(""%s"", name);
+	no_module = !dev;
+	if (no_module && capable(CAP_NET_ADMIN))
+		no_module = request_module(""netdev-%s"", name);
+	if (no_module && capable(CAP_SYS_MODULE)) {
+		if (!request_module(""%s"", name))
+			pr_err(""Loading kernel module for a network device ""
+""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
+""instead\n"", name);
+	}
 }
 EXPORT_SYMBOL(dev_load);
 ",linux,8909c9ad8ff03611c9c96c9a92656213e4bb495b,a5abba989deceb731047425812d268daf7536575,1," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
//fix_flaw_line_below:
//	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
//flaw_line_below:
	if (!dev && capable(CAP_NET_ADMIN))
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//	no_module = !dev;
//fix_flaw_line_below:
//	if (no_module && capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//		no_module = request_module(""netdev-%s"", name);
//fix_flaw_line_below:
//	if (no_module && capable(CAP_SYS_MODULE)) {
//fix_flaw_line_below:
//		if (!request_module(""%s"", name))
//fix_flaw_line_below:
//			pr_err(""Loading kernel module for a network device ""
//fix_flaw_line_below:
//""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
//fix_flaw_line_below:
//""instead\n"", name);
//fix_flaw_line_below:
//	}
 }
",179406," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
","The vulnerability in the original code lies in the potential for a race condition when checking if the network device `dev` is NULL and subsequently calling `request_module(""%s"", name)` without proper checks. This could lead to unauthorized module loading if the device is not found, as it only checks for `CAP_NET_ADMIN`. The fixed code introduces a new variable `no_module` to track whether a module should be requested, and it adds an additional check for `CAP_SYS_MODULE`. This ensures that if a module is requested without the appropriate capabilities, an error message is logged, enhancing security and preventing unauthorized access.","The vulnerability in the original code stems from the lack of adequate checks before loading a kernel module, which could allow unauthorized users to load modules if a network device is not found. This situation arises because the code only verifies one capability, potentially leading to privilege escalation. The revised code addresses this issue by introducing an additional check for a different capability before attempting to load a module. Furthermore, it logs an error message if an attempt is made to load a module without the appropriate permissions, thereby enhancing security and preventing unauthorized access to kernel functionalities.",2,5,4,1,"CWE-269,CWE-264,CWE-274,CWE-284,CWE-270,CWE-266,CWE-250,CWE-732,CWE-693,CWE-285",Y,2
31,31,31,179455,179455,,Local,Not required,Complete,CVE-2014-5206,https://www.cvedetails.com/cve/CVE-2014-5206/,CWE-264,Low,Complete,Complete,,2014-08-18,7.2,"The do_remount function in fs/namespace.c in the Linux kernel through 3.16.1 does not maintain the MNT_LOCK_READONLY bit across a remount of a bind mount, which allows local users to bypass an intended read-only restriction and defeat certain sandbox protection mechanisms via a *mount -o remount* command within a user namespace.",2017-01-06,Bypass ,1,https://github.com/torvalds/linux/commit/a6138db815df5ee542d848318e5dae681590fccd,a6138db815df5ee542d848318e5dae681590fccd,"mnt: Only change user settable mount flags in remount

Kenton Varda <kenton@sandstorm.io> discovered that by remounting a
read-only bind mount read-only in a user namespace the
MNT_LOCK_READONLY bit would be cleared, allowing an unprivileged user
to the remount a read-only mount read-write.

Correct this by replacing the mask of mount flags to preserve
with a mask of mount flags that may be changed, and preserve
all others.   This ensures that any future bugs with this mask and
remount will fail in an easy to detect way where new mount flags
simply won't change.

Cc: stable@vger.kernel.org
Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",1,fs/namespace.c,"{""sha"": ""cb40449ea0dfe8983d45162ef724c45898d2424a"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n-\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n+\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();""}<_**next**_>{""sha"": ""b637a89e1faeb271af0ab5e850e47fdf9d8f487c"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -42,7 +42,9 @@ struct mnt_namespace;\n  * flag, consider how it interacts with shared mounts.\n  */\n #define MNT_SHARED_MASK\t(MNT_UNBINDABLE)\n-#define MNT_PROPAGATION_MASK\t(MNT_SHARED | MNT_UNBINDABLE)\n+#define MNT_USER_SETTABLE_MASK  (MNT_NOSUID | MNT_NODEV | MNT_NOEXEC \\\n+\t\t\t\t | MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME \\\n+\t\t\t\t | MNT_READONLY)\n \n #define MNT_INTERNAL_FLAGS (MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \\\n \t\t\t    MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED)""}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",C,"		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
","		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
",,"@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
-		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
+		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();",linux,a6138db815df5ee542d848318e5dae681590fccd,728dba3a39c66b3d8ac889ddbe38b5b1c264aec3,1,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
//flaw_line_below:
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
//fix_flaw_line_below:
//		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",179455,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","The vulnerability in the original code lies in the handling of the `mnt_flags` variable, where it directly incorporates the existing mount flags using `mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK`. This could allow unauthorized modifications to the mount flags, potentially leading to privilege escalation. The fix addresses this by changing the expression to `mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK`, which ensures that only specific, safe flags are retained while preventing user-settable flags from being propagated. This change enhances security by restricting the modification of mount flags to authorized operations only.","The vulnerability in the original code stems from the improper handling of mount flags, which could allow unauthorized users to modify critical system settings, potentially leading to privilege escalation. Specifically, the code allowed user-settable flags to be propagated, which could be exploited by an attacker to gain elevated permissions. The fix addresses this issue by ensuring that only safe and appropriate flags are retained during the remounting process. By excluding user-settable flags from being propagated, the revised code enhances security and prevents unauthorized modifications, thereby safeguarding the integrity of the system's mount configurations.",3,5,4,5,"CWE-269, CWE-264, CWE-284, CWE-732, CWE-250, CWE-272, CWE-266, CWE-274, CWE-639, CWE-270",N,-1
32,32,32,179487,179487,,Local Network,Single system,,CVE-2014-4027,https://www.cvedetails.com/cve/CVE-2014-4027/,CWE-264,Medium,Partial,,,2014-06-23,2.3,"The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator.",2017-01-06,+Info ,50,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,"target/rd: Refactor rd_build_device_space + rd_release_device_space

This patch refactors rd_build_device_space() + rd_release_device_space()
into rd_allocate_sgl_table() + rd_release_device_space() so that they
may be used seperatly for setup + release of protection information
scatterlists.

Also add explicit memset of pages within rd_allocate_sgl_table() based
upon passed 'init_payload' value.

v2 changes:
  - Drop unused sg_table from rd_release_device_space (Wei)

Cc: Martin K. Petersen <martin.petersen@oracle.com>
Cc: Christoph Hellwig <hch@lst.de>
Cc: Hannes Reinecke <hare@suse.de>
Cc: Sagi Grimberg <sagig@mellanox.com>
Cc: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",23,drivers/target/target_core_rd.c,"{""sha"": ""e9fa879ac27f31f5cbdd61fecf29c4095b366b50"", ""filename"": ""drivers/target/target_core_rd.c"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 45, ""changes"": 113, ""blob_url"": ""https://github.com/torvalds/linux/blob/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/target/target_core_rd.c?ref=4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc"", ""patch"": ""@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)\n \thba->hba_ptr = NULL;\n }\n \n-/*\trd_release_device_space():\n- *\n- *\n- */\n-static void rd_release_device_space(struct rd_dev *rd_dev)\n+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 sg_table_count)\n {\n-\tu32 i, j, page_count = 0, sg_per_table;\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n+\tu32 i, j, page_count = 0, sg_per_table;\n \n-\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n-\t\treturn;\n-\n-\tsg_table = rd_dev->sg_table_array;\n-\n-\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n+\tfor (i = 0; i < sg_table_count; i++) {\n \t\tsg = sg_table[i].sg_table;\n \t\tsg_per_table = sg_table[i].rd_sg_count;\n \n@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n \t\t\t\tpage_count++;\n \t\t\t}\n \t\t}\n-\n \t\tkfree(sg);\n \t}\n \n+\tkfree(sg_table);\n+\treturn page_count;\n+}\n+\n+static void rd_release_device_space(struct rd_dev *rd_dev)\n+{\n+\tu32 page_count;\n+\n+\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n+\t\treturn;\n+\n+\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n+\t\t\t\t\t  rd_dev->sg_table_count);\n+\n \tpr_debug(\""CORE_RD[%u] - Released device space for Ramdisk\""\n \t\t\"" Device ID: %u, pages %u in %u tables total bytes %lu\\n\"",\n \t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n \t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n \n-\tkfree(sg_table);\n \trd_dev->sg_table_array = NULL;\n \trd_dev->sg_table_count = 0;\n }\n@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n  *\n  *\n  */\n-static int rd_build_device_space(struct rd_dev *rd_dev)\n+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n {\n-\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n+\tu32 i = 0, j, page_offset = 0, sg_per_table;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n-\n-\tif (rd_dev->rd_page_count <= 0) {\n-\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n-\t\t\trd_dev->rd_page_count);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\t/* Don't need backing pages for NULLIO */\n-\tif (rd_dev->rd_flags & RDF_NULLIO)\n-\t\treturn 0;\n-\n-\ttotal_sg_needed = rd_dev->rd_page_count;\n-\n-\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n-\n-\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n-\tif (!sg_table) {\n-\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n-\t\t\t\"" scatterlist tables\\n\"");\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\trd_dev->sg_table_array = sg_table;\n-\trd_dev->sg_table_count = sg_tables;\n+\tunsigned char *p;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n+\n+\t\t\tp = kmap(pg);\n+\t\t\tmemset(p, init_payload, PAGE_SIZE);\n+\t\t\tkunmap(pg);\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n+\treturn 0;\n+}\n+\n+static int rd_build_device_space(struct rd_dev *rd_dev)\n+{\n+\tstruct rd_dev_sg_table *sg_table;\n+\tu32 sg_tables, total_sg_needed;\n+\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n+\t\t\t\tsizeof(struct scatterlist));\n+\tint rc;\n+\n+\tif (rd_dev->rd_page_count <= 0) {\n+\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n+\t\t       rd_dev->rd_page_count);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t/* Don't need backing pages for NULLIO */\n+\tif (rd_dev->rd_flags & RDF_NULLIO)\n+\t\treturn 0;\n+\n+\ttotal_sg_needed = rd_dev->rd_page_count;\n+\n+\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n+\n+\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n+\tif (!sg_table) {\n+\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n+\t\t       \"" scatterlist tables\\n\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\trd_dev->sg_table_array = sg_table;\n+\trd_dev->sg_table_count = sg_tables;\n+\n+\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n+\tif (rc)\n+\t\treturn rc;\n+\n \tpr_debug(\""CORE_RD[%u] - Built Ramdisk Device ID: %u space of\""\n-\t\t\"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n-\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n-\t\trd_dev->sg_table_count);\n+\t\t \"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n+\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n+\t\t rd_dev->sg_table_count);\n \n \treturn 0;\n }""}","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
",C,"static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
	u32 i = 0, j, page_offset = 0, sg_per_table;
	unsigned char *p;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
","	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
	struct rd_dev_sg_table *sg_table;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
",,"@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)
 	hba->hba_ptr = NULL;
 }
 
-/*	rd_release_device_space():
- *
- *
- */
-static void rd_release_device_space(struct rd_dev *rd_dev)
+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 sg_table_count)
 {
-	u32 i, j, page_count = 0, sg_per_table;
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
+	u32 i, j, page_count = 0, sg_per_table;
 
-	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
-		return;
-
-	sg_table = rd_dev->sg_table_array;
-
-	for (i = 0; i < rd_dev->sg_table_count; i++) {
+	for (i = 0; i < sg_table_count; i++) {
 		sg = sg_table[i].sg_table;
 		sg_per_table = sg_table[i].rd_sg_count;
 
@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
 				page_count++;
 			}
 		}
-
 		kfree(sg);
 	}
 
+	kfree(sg_table);
+	return page_count;
+}
+
+static void rd_release_device_space(struct rd_dev *rd_dev)
+{
+	u32 page_count;
+
+	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
+		return;
+
+	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,
+					  rd_dev->sg_table_count);
+
 	pr_debug(""CORE_RD[%u] - Released device space for Ramdisk""
 		"" Device ID: %u, pages %u in %u tables total bytes %lu\n"",
 		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
 		rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
 
-	kfree(sg_table);
 	rd_dev->sg_table_array = NULL;
 	rd_dev->sg_table_count = 0;
 }
@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
  *
  *
  */
-static int rd_build_device_space(struct rd_dev *rd_dev)
+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 total_sg_needed, unsigned char init_payload)
 {
-	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
+	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
-
-	if (rd_dev->rd_page_count <= 0) {
-		pr_err(""Illegal page count: %u for Ramdisk device\n"",
-			rd_dev->rd_page_count);
-		return -EINVAL;
-	}
-
-	/* Don't need backing pages for NULLIO */
-	if (rd_dev->rd_flags & RDF_NULLIO)
-		return 0;
-
-	total_sg_needed = rd_dev->rd_page_count;
-
-	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
-
-	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
-	if (!sg_table) {
-		pr_err(""Unable to allocate memory for Ramdisk""
-			"" scatterlist tables\n"");
-		return -ENOMEM;
-	}
-
-	rd_dev->sg_table_array = sg_table;
-	rd_dev->sg_table_count = sg_tables;
+	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
+
+			p = kmap(pg);
+			memset(p, init_payload, PAGE_SIZE);
+			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
+	return 0;
+}
+
+static int rd_build_device_space(struct rd_dev *rd_dev)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 sg_tables, total_sg_needed;
+	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+	int rc;
+
+	if (rd_dev->rd_page_count <= 0) {
+		pr_err(""Illegal page count: %u for Ramdisk device\n"",
+		       rd_dev->rd_page_count);
+		return -EINVAL;
+	}
+
+	/* Don't need backing pages for NULLIO */
+	if (rd_dev->rd_flags & RDF_NULLIO)
+		return 0;
+
+	total_sg_needed = rd_dev->rd_page_count;
+
+	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
+
+	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
+	if (!sg_table) {
+		pr_err(""Unable to allocate memory for Ramdisk""
+		       "" scatterlist tables\n"");
+		return -ENOMEM;
+	}
+
+	rd_dev->sg_table_array = sg_table;
+	rd_dev->sg_table_count = sg_tables;
+
+	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
+	if (rc)
+		return rc;
+
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
-		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
-		rd_dev->rd_dev_id, rd_dev->rd_page_count,
-		rd_dev->sg_table_count);
+		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
+		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
+		 rd_dev->sg_table_count);
 
 	return 0;
 }",linux,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,42201b557471f2fef2e9e028b50a773d99ffc401,1,"static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
//fix_flaw_line_below:
//				 u32 total_sg_needed, unsigned char init_payload)
 {
//flaw_line_below:
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
//flaw_line_below:
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
//flaw_line_below:

//flaw_line_below:
	if (rd_dev->rd_page_count <= 0) {
//flaw_line_below:
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//flaw_line_below:
			rd_dev->rd_page_count);
//flaw_line_below:
		return -EINVAL;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	/* Don't need backing pages for NULLIO */
//flaw_line_below:
	if (rd_dev->rd_flags & RDF_NULLIO)
//flaw_line_below:
		return 0;
//flaw_line_below:

//flaw_line_below:
	total_sg_needed = rd_dev->rd_page_count;
//flaw_line_below:

//flaw_line_below:
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//flaw_line_below:

//flaw_line_below:
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//flaw_line_below:
	if (!sg_table) {
//flaw_line_below:
		pr_err(""Unable to allocate memory for Ramdisk""
//flaw_line_below:
			"" scatterlist tables\n"");
//flaw_line_below:
		return -ENOMEM;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	rd_dev->sg_table_array = sg_table;
//flaw_line_below:
	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			p = kmap(pg);
//fix_flaw_line_below:
//			memset(p, init_payload, PAGE_SIZE);
//fix_flaw_line_below:
//			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
//fix_flaw_line_below:
//	return 0;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	struct rd_dev_sg_table *sg_table;
//fix_flaw_line_below:
//	u32 sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
//fix_flaw_line_below:
//				sizeof(struct scatterlist));
//fix_flaw_line_below:
//	int rc;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (rd_dev->rd_page_count <= 0) {
//fix_flaw_line_below:
//		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//fix_flaw_line_below:
//		       rd_dev->rd_page_count);
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't need backing pages for NULLIO */
//fix_flaw_line_below:
//	if (rd_dev->rd_flags & RDF_NULLIO)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	total_sg_needed = rd_dev->rd_page_count;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//fix_flaw_line_below:
//	if (!sg_table) {
//fix_flaw_line_below:
//		pr_err(""Unable to allocate memory for Ramdisk""
//fix_flaw_line_below:
//		       "" scatterlist tables\n"");
//fix_flaw_line_below:
//		return -ENOMEM;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rd_dev->sg_table_array = sg_table;
//fix_flaw_line_below:
//	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
//fix_flaw_line_below:
//	if (rc)
//fix_flaw_line_below:
//		return rc;
//fix_flaw_line_below:
//
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
//flaw_line_below:
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//flaw_line_below:
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
//flaw_line_below:
		rd_dev->sg_table_count);
//fix_flaw_line_below:
//		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//fix_flaw_line_below:
//		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
//fix_flaw_line_below:
//		 rd_dev->sg_table_count);
 
 	return 0;
 }
",179487,"static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","The vulnerability in the original code lies in the lack of proper initialization of allocated memory for the scatterlist pages. Specifically, after allocating pages with `alloc_pages`, the code does not initialize the memory, which could lead to undefined behavior or security issues if the memory contains sensitive data. The fix introduces a new function, `rd_allocate_sgl_table`, which initializes the allocated pages using `kmap` and `memset` to fill the memory with a specified `init_payload`. This ensures that the memory is properly initialized before use, enhancing security and stability.","The vulnerability in the original code stems from the failure to initialize allocated memory for scatterlist pages, which could lead to undefined behavior or exposure of sensitive data. When memory is allocated, it may contain remnants of previous data, posing a security risk. The revised code addresses this issue by introducing a separate function that initializes the allocated memory with a specific value, ensuring that all pages are set to a known state before use. This change enhances both the security and reliability of the code by preventing the use of uninitialized memory.",2,5,3,2,"CWE-908, CWE-665, CWE-457, CWE-562, CWE-761, CWE-789, CWE-119, CWE-201, CWE-526, CWE-244",N,-1
33,33,33,179553,179553,,Local,Not required,Complete,CVE-2014-3153,https://www.cvedetails.com/cve/CVE-2014-3153/,CWE-264,Low,Complete,Complete,,2014-06-07,7.2,"The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.",2019-04-22,+Priv ,16,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,e9c243a5a6de0be8e584c604d353412584b592f8,"futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)

If uaddr == uaddr2, then we have broken the rule of only requeueing from
a non-pi futex to a pi futex with this call.  If we attempt this, then
dangling pointers may be left for rt_waiter resulting in an exploitable
condition.

This change brings futex_requeue() in line with futex_wait_requeue_pi()
which performs the same check as per commit 6f7b0a2a5c0f (""futex: Forbid
uaddr == uaddr2 in futex_wait_requeue_pi()"")

[ tglx: Compare the resulting keys as well, as uaddrs might be
  	different depending on the mapping ]

Fixes CVE-2014-3153.

Reported-by: Pinkie Pie
Signed-off-by: Will Drewry <wad@chromium.org>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: stable@vger.kernel.org
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Reviewed-by: Darren Hart <dvhart@linux.intel.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/futex.c,"{""sha"": ""663ea2b84a3830ec9c772f78ec7eaa23504bfcc5"", ""filename"": ""kernel/futex.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/torvalds/linux/blob/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/futex.c?ref=e9c243a5a6de0be8e584c604d353412584b592f8"", ""patch"": ""@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tstruct futex_q *this, *next;\n \n \tif (requeue_pi) {\n+\t\t/*\n+\t\t * Requeue PI only works on two distinct uaddrs. This\n+\t\t * check is only valid for private futexes. See below.\n+\t\t */\n+\t\tif (uaddr1 == uaddr2)\n+\t\t\treturn -EINVAL;\n+\n \t\t/*\n \t\t * requeue_pi requires a pi_state, try to allocate it now\n \t\t * without any locks in case it fails.\n@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tif (unlikely(ret != 0))\n \t\tgoto out_put_key1;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (requeue_pi && match_futex(&key1, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \thb1 = hash_futex(&key1);\n \thb2 = hash_futex(&key2);\n \n@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n \tif (ret)\n \t\tgoto out_key2;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (match_futex(&q.key, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n \tfutex_wait_queue_me(hb, &q, to);\n ""}","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",C,"		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

",,,"@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
+		/*
+		 * Requeue PI only works on two distinct uaddrs. This
+		 * check is only valid for private futexes. See below.
+		 */
+		if (uaddr1 == uaddr2)
+			return -EINVAL;
+
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (requeue_pi && match_futex(&key1, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (match_futex(&q.key, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 ",linux,e9c243a5a6de0be8e584c604d353412584b592f8,fad01e866afdbe01a1f3ec06a39c3a8b9e197014,1,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * Requeue PI only works on two distinct uaddrs. This
//fix_flaw_line_below:
//		 * check is only valid for private futexes. See below.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (uaddr1 == uaddr2)
//fix_flaw_line_below:
//			return -EINVAL;
//fix_flaw_line_below:
//
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * The check above which compares uaddrs is not sufficient for
//fix_flaw_line_below:
//	 * shared futexes. We need to compare the keys:
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (requeue_pi && match_futex(&key1, &key2)) {
//fix_flaw_line_below:
//		ret = -EINVAL;
//fix_flaw_line_below:
//		goto out_put_keys;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",179553,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","The vulnerability in the original `futex_requeue` code stemmed from the lack of validation for the user addresses `uaddr1` and `uaddr2` when `requeue_pi` was true, allowing both to point to the same address. This could lead to unintended behavior or security issues, particularly in shared futex scenarios. The fix introduced a check to ensure that `uaddr1` and `uaddr2` are distinct when `requeue_pi` is enabled, returning `-EINVAL` if they are the same. Additionally, it added a key comparison using `match_futex` to further validate the distinctness of the futex keys, enhancing overall robustness against misuse.","The vulnerability in the original code arose from the lack of validation for two user addresses when a specific condition was met, allowing them to point to the same location. This oversight could lead to unintended behavior, including potential security risks in shared scenarios. The fix implemented a check to ensure that the two addresses are distinct, returning an error if they are not. Additionally, it introduced a mechanism to compare the underlying keys associated with these addresses, further enhancing the validation process and preventing misuse in the context of the operation being performed.",2,5,3,4,"CWE-843, CWE-763, CWE-822, CWE-825, CWE-789, CWE-416, CWE-911, CWE-665, CWE-674, CWE-915",N,-1
34,34,34,179559,179559,,Local,Not required,Complete,CVE-2014-3122,https://www.cvedetails.com/cve/CVE-2014-3122/,CWE-264,Low,,,,2014-05-11,4.9,"The try_to_unmap_cluster function in mm/rmap.c in the Linux kernel before 3.14.3 does not properly consider which pages must be locked, which allows local users to cause a denial of service (system crash) by triggering a memory-usage pattern that requires removal of page-table mappings.",2017-12-28,DoS ,12,https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c,57e68e9cd65b4b8eb4045a1e0d0746458502554c,"mm: try_to_unmap_cluster() should lock_page() before mlocking

A BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin
fuzzing with trinity.  The call site try_to_unmap_cluster() does not lock
the pages other than its check_page parameter (which is already locked).

The BUG_ON in mlock_vma_page() is not documented and its purpose is
somewhat unclear, but apparently it serializes against page migration,
which could otherwise fail to transfer the PG_mlocked flag.  This would
not be fatal, as the page would be eventually encountered again, but
NR_MLOCK accounting would become distorted nevertheless.  This patch adds
a comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that
effect.

The call site try_to_unmap_cluster() is fixed so that for page !=
check_page, trylock_page() is attempted (to avoid possible deadlocks as we
already have check_page locked) and mlock_vma_page() is performed only
upon success.  If the page lock cannot be obtained, the page is left
without PG_mlocked, which is again not a problem in the whole unevictable
memory design.

Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Bob Liu <bob.liu@oracle.com>
Reported-by: Sasha Levin <sasha.levin@oracle.com>
Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
Cc: Michel Lespinasse <walken@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Acked-by: Rik van Riel <riel@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Hugh Dickins <hughd@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",2,mm/rmap.c,"{""sha"": ""b1eb53634005606298d115ac5cdeb90cac923957"", ""filename"": ""mm/mlock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mlock.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -79,6 +79,7 @@ void clear_page_mlock(struct page *page)\n  */\n void mlock_vma_page(struct page *page)\n {\n+\t/* Serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \tif (!TestSetPageMlocked(page)) {\n@@ -174,6 +175,7 @@ unsigned int munlock_vma_page(struct page *page)\n \tunsigned int nr_pages;\n \tstruct zone *zone = page_zone(page);\n \n+\t/* For try_to_munlock() and to serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \t/*""}<_**next**_>{""sha"": ""9c3e77396d1a118edb8f2de7d16ff835ed214f0a"", ""filename"": ""mm/rmap.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 2, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/rmap.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n-\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n-\t\t\tif (page == check_page)\n+\t\t\tif (page == check_page) {\n+\t\t\t\t/* we know we have check_page locked */\n+\t\t\t\tmlock_vma_page(page);\n \t\t\t\tret = SWAP_MLOCK;\n+\t\t\t} else if (trylock_page(page)) {\n+\t\t\t\t/*\n+\t\t\t\t * If we can lock the page, perform mlock.\n+\t\t\t\t * Otherwise leave the page alone, it will be\n+\t\t\t\t * eventually encountered again later.\n+\t\t\t\t */\n+\t\t\t\tmlock_vma_page(page);\n+\t\t\t\tunlock_page(page);\n+\t\t\t}\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n ""}","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",C,"			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
","			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
",,"@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
-			mlock_vma_page(page);   /* no-op if already mlocked */
-			if (page == check_page)
+			if (page == check_page) {
+				/* we know we have check_page locked */
+				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
+			} else if (trylock_page(page)) {
+				/*
+				 * If we can lock the page, perform mlock.
+				 * Otherwise leave the page alone, it will be
+				 * eventually encountered again later.
+				 */
+				mlock_vma_page(page);
+				unlock_page(page);
+			}
 			continue;	/* don't unmap */
 		}
 ",linux,57e68e9cd65b4b8eb4045a1e0d0746458502554c,3a025760fc158b3726eac89ee95d7f29599e9dfa,1,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
//flaw_line_below:
			mlock_vma_page(page);   /* no-op if already mlocked */
//flaw_line_below:
			if (page == check_page)
//fix_flaw_line_below:
//			if (page == check_page) {
//fix_flaw_line_below:
//				/* we know we have check_page locked */
//fix_flaw_line_below:
//				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
//fix_flaw_line_below:
//			} else if (trylock_page(page)) {
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * If we can lock the page, perform mlock.
//fix_flaw_line_below:
//				 * Otherwise leave the page alone, it will be
//fix_flaw_line_below:
//				 * eventually encountered again later.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				mlock_vma_page(page);
//fix_flaw_line_below:
//				unlock_page(page);
//fix_flaw_line_below:
//			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",179559,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","The vulnerability in the original code lies in the handling of the `check_page` when the `locked_vma` condition is true. If `check_page` is the same as `page`, the code directly calls `mlock_vma_page(page)` without ensuring that the page is properly locked, which could lead to race conditions or inconsistent states. In the fixed code, an additional check using `trylock_page(page)` is introduced. This ensures that if the page can be locked, it performs the mlock operation; otherwise, it leaves the page alone, preventing potential issues with concurrent access and ensuring safer memory management.","The vulnerability in the original code arises from inadequate handling of page locking when a specific page is being checked for memory locking. If the page to be checked is already locked, the code proceeds to lock it again without verifying its state, which can lead to race conditions and inconsistent memory states. The fixed code addresses this issue by introducing a mechanism to attempt locking the page first. If the page cannot be locked, it avoids performing the memory lock operation, thereby ensuring safer concurrent access and preventing potential memory management errors.",2,4,4,3,"CWE-667,CWE-366,CWE-662,CWE-412,CWE-833,CWE-664,CWE-665,CWE-362,CWE-642,CWE-deadlock",N,-1
35,35,35,179629,179629,,Local,Not required,Complete,CVE-2014-0185,https://www.cvedetails.com/cve/CVE-2014-0185/,CWE-264,Low,Complete,Complete,,2014-05-06,7.2,"sapi/fpm/fpm/fpm_unix.c in the FastCGI Process Manager (FPM) in PHP before 5.4.28 and 5.5.x before 5.5.12 uses 0666 permissions for the UNIX socket, which allows local users to gain privileges via a crafted FastCGI client.",2017-01-06,+Priv ,1,https://github.com/php/php-src/commit/35ceea928b12373a3b1e3eecdc32ed323223a40d,35ceea928b12373a3b1e3eecdc32ed323223a40d,Fix bug #67060: use default mode of 660,1,sapi/fpm/fpm/fpm_unix.c,"{""sha"": ""104279441a7faaaef5aebf0db781ecef3eb8b8fd"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -25,7 +25,7 @@ PHP                                                                        NEWS\n   . Fix bug #64498 ($phar->buildFromDirectory can't compress file with an accent \n     in its name). (PR #588) \n \n-?? ??? 2014, PHP 5.4.28\n+01 May 2014, PHP 5.4.28\n \n - Core:\n   . Fixed bug #61019 (Out of memory on command stream_get_contents). (Mike)\n@@ -55,6 +55,8 @@ PHP                                                                        NEWS\n \n - FPM:\n   . Fixed bug #66482 (unknown entry 'priority' in php-fpm.conf). \n+  . Fixed bug #67060 (sapi/fpm: possible privilege escalation due to insecure \n+    default configuration) (CVE-2014-0185). (Stas)\n \n - JSON:\n   . Fixed bug #66021 (Blank line inside empty array/object when""}<_**next**_>{""sha"": ""ea0e67369cd534448894db87c1ab31a8b7ecad96"", ""filename"": ""sapi/fpm/fpm/fpm_unix.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_unix.c?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */\n \t/* uninitialized */\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n-\twp->socket_mode = 0666;\n+\twp->socket_mode = 0660;\n \n \tif (!c) {\n \t\treturn 0;""}<_**next**_>{""sha"": ""9205d422399b4d5571592fbc1cd57f3419493a80"", ""filename"": ""sapi/fpm/php-fpm.conf.in"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/php-fpm.conf.in?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -166,10 +166,10 @@ listen = 127.0.0.1:9000\n ; permissions must be set in order to allow connections from a web server. Many\n ; BSD-derived systems allow connections regardless of permissions. \n ; Default Values: user and group are set as the running user\n-;                 mode is set to 0666\n+;                 mode is set to 0660\n ;listen.owner = @php_fpm_user@\n ;listen.group = @php_fpm_group@\n-;listen.mode = 0666\n+;listen.mode = 0660\n  \n ; List of ipv4 addresses of FastCGI clients which are allowed to connect.\n ; Equivalent to the FCGI_WEB_SERVER_ADDRS environment variable in the original""}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0666;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",C,"	wp->socket_mode = 0660;
","	wp->socket_mode = 0666;
",,"@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
-	wp->socket_mode = 0666;
+	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;",php-src,35ceea928b12373a3b1e3eecdc32ed323223a40d,2d625b5f81205d7f0217243b0bfe9a77683951e8,1,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
//flaw_line_below:
	wp->socket_mode = 0666;
//fix_flaw_line_below:
//	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",179629,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

	/* uninitialized */
	wp->socket_uid = -1;
	wp->socket_gid = -1;
	wp->socket_mode = 0666;

	if (!c) {
		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","The vulnerability in the original code lies in the default socket permissions set by `wp->socket_mode`, which is initialized to `0666`, allowing read and write access to all users. This can lead to unauthorized access to the socket, posing a security risk. In the fixed code, the default value of `wp->socket_mode` is changed to `0660`, restricting access to the owner and group only, thereby enhancing security. This change mitigates the risk of unauthorized users interacting with the socket, ensuring that only designated users can access it based on the specified owner and group.","The vulnerability in the original code stems from overly permissive default socket permissions, allowing all users to read and write to the socket, which can lead to unauthorized access and potential security breaches. This lack of restriction poses a significant risk, especially in multi-user environments. The fixed code addresses this issue by changing the default permissions to a more restrictive setting, limiting access to only the owner and group. This adjustment significantly enhances security by ensuring that only authorized users can interact with the socket, thereby reducing the likelihood of unauthorized access and potential exploitation.",3,5,3,4,"CWE-732, CWE-266, CWE-284, CWE-668, CWE-281, CWE-269, CWE-264, CWE-282, CWE-732, CWE-270",N,-1
36,36,36,179717,179717,,Remote,Not required,,CVE-2013-2182,https://www.cvedetails.com/cve/CVE-2013-2182/,CWE-264,Medium,Partial,Partial,,2014-06-13,5.8,"The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash.",2014-06-13,Bypass ,2,https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,"Mandril: check decoded URI (fix #92)

Signed-off-by: Eduardo Silva <eduardo@monkey.io>",1,plugins/mandril/mandril.c,"{""sha"": ""820f4416d769860a11599c2ded44762ec729d7ff"", ""filename"": ""plugins/mandril/mandril.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/monkey/monkey/blob/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""raw_url"": ""https://github.com/monkey/monkey/raw/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""contents_url"": ""https://api.github.com/repos/monkey/monkey/contents/plugins/mandril/mandril.c?ref=15f72c1ee5e0afad20232bdf0fcecab8d62a5d89"", ""patch"": ""@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,\n     (void) cs;\n \n     PLUGIN_TRACE(\""[FD %i] Mandril validating URL\"", cs->socket);\n-    if (mk_security_check_url(sr->uri) < 0) {\n+\n+    if (mk_security_check_url(sr->uri_processed) < 0) {\n         PLUGIN_TRACE(\""[FD %i] Close connection, blocked URL\"", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;""}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",C,"
    if (mk_security_check_url(sr->uri_processed) < 0) {
","    if (mk_security_check_url(sr->uri) < 0) {
",,"@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
-    if (mk_security_check_url(sr->uri) < 0) {
+
+    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;",monkey,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,f929f3e6dca9a0ff2e08dcd286346ef7e436c139,1,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
//flaw_line_below:
    if (mk_security_check_url(sr->uri) < 0) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",179717,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","The vulnerability in the original code stemmed from using `sr->uri` in the `mk_security_check_url` function, which could allow unvalidated or malicious URLs to pass through, potentially leading to security breaches. The fix was implemented by changing the argument to `sr->uri_processed`, ensuring that only processed and validated URLs are checked. This change enhances security by preventing the use of raw, potentially harmful URLs, thereby mitigating risks associated with URL validation and ensuring that only safe, intended URLs are evaluated for access control.","The vulnerability in the original code arose from the use of an unprocessed input for URL validation, which could allow malicious URLs to bypass security checks, leading to potential exploitation. This oversight could result in unauthorized access or other security breaches. The fix involved changing the input to a processed version, ensuring that only validated and safe URLs are evaluated during the security check. This modification significantly enhances the security posture by preventing the acceptance of raw, potentially harmful inputs, thereby safeguarding the application against various attack vectors related to URL handling.",3,5,4,4,"CWE-20, CWE-601, CWE-98, CWE-552, CWE-610, CWE-79, CWE-644, CWE-22, CWE-73, CWE-434",N,-1
37,37,37,179719,179719,,Local,Not required,Complete,CVE-2012-6657,https://www.cvedetails.com/cve/CVE-2012-6657/,CWE-264,Low,,,,2014-09-28,4.9,"The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket.",2016-08-22,DoS ,2,https://github.com/torvalds/linux/commit/3e10986d1d698140747fcfc2761ec9cb64c1d582,3e10986d1d698140747fcfc2761ec9cb64c1d582,"net: guard tcp_set_keepalive() to tcp sockets

Its possible to use RAW sockets to get a crash in
tcp_set_keepalive() / sk_reset_timer()

Fix is to make sure socket is a SOCK_STREAM one.

Reported-by: Dave Jones <davej@redhat.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/sock.c,"{""sha"": ""a6000fbad2949f58a079322f4e328e0c051df896"", ""filename"": ""net/core/sock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/sock.c?ref=3e10986d1d698140747fcfc2761ec9cb64c1d582"", ""patch"": ""@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,\n \n \tcase SO_KEEPALIVE:\n #ifdef CONFIG_INET\n-\t\tif (sk->sk_protocol == IPPROTO_TCP)\n+\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n+\t\t    sk->sk_type == SOCK_STREAM)\n \t\t\ttcp_set_keepalive(sk, valbool);\n #endif\n \t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);""}","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",C,"		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
","		if (sk->sk_protocol == IPPROTO_TCP)
",,"@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
-		if (sk->sk_protocol == IPPROTO_TCP)
+		if (sk->sk_protocol == IPPROTO_TCP &&
+		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);",linux,3e10986d1d698140747fcfc2761ec9cb64c1d582,69190e67d4fac49e2f6ea22f46780d0c712214b8,1,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
//flaw_line_below:
		if (sk->sk_protocol == IPPROTO_TCP)
//fix_flaw_line_below:
//		if (sk->sk_protocol == IPPROTO_TCP &&
//fix_flaw_line_below:
//		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",179719,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","The vulnerability in the original code lies in the handling of the `SO_KEEPALIVE` option, where the check for the socket type was missing. Specifically, the code did not verify if `sk->sk_type` was `SOCK_STREAM` before calling `tcp_set_keepalive(sk, valbool)`, potentially allowing incorrect behavior for non-stream sockets. The fix introduced a condition to ensure that `tcp_set_keepalive` is only called if `sk->sk_protocol` is `IPPROTO_TCP` and `sk->sk_type` is `SOCK_STREAM`, thereby preventing inappropriate keepalive settings on sockets that do not support them, enhancing the overall robustness of the socket option handling.","The vulnerability in the original code stemmed from inadequate validation when setting the keepalive option for sockets, as it did not check the socket type before applying the keepalive settings. This oversight could lead to incorrect configurations for non-stream sockets, potentially causing unexpected behavior or crashes. The fix addressed this issue by adding a condition to ensure that the keepalive settings are only applied to the appropriate socket type, thereby preventing inappropriate configurations and enhancing the stability and reliability of the socket option handling in the code.",3,5,4,4,"CWE-628, CWE-665, CWE-754, CWE-573, CWE-684, CWE-666, CWE-235, CWE-252, CWE-281, CWE-393",N,-1
38,38,38,179731,179731,,Local,Not required,Complete,CVE-2015-8660,https://www.cvedetails.com/cve/CVE-2015-8660/,CWE-264,Low,Complete,Complete,,2015-12-28,7.2,"The ovl_setattr function in fs/overlayfs/inode.c in the Linux kernel through 4.3.3 attempts to merge distinct setattr operations, which allows local users to bypass intended access restrictions and modify the attributes of arbitrary overlay files via a crafted application.",2017-09-09,Bypass ,4,https://github.com/torvalds/linux/commit/acff81ec2c79492b180fade3c2894425cd35a545,acff81ec2c79492b180fade3c2894425cd35a545,"ovl: fix permission checking for setattr

[Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()
away - instead of ""copy verbatim with metadata"" + ""chmod/chown/utimes""
(with the former being always safe and the latter failing in case of
insufficient permissions) it tries to combine these two.  Note that copyup
itself will have to do ->setattr() anyway; _that_ is where the elevated
capabilities are right.  Having these two ->setattr() (one to set verbatim
copy of metadata, another to do what overlayfs ->setattr() had been asked
to do in the first place) combined is where it breaks.

Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Cc: <stable@vger.kernel.org>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",4,fs/overlayfs/inode.c,"{""sha"": ""961284936917e69742f837463999c27e90defb43"", ""filename"": ""fs/overlayfs/inode.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/inode.c?ref=acff81ec2c79492b180fade3c2894425cd35a545"", ""patch"": ""@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tif (err)\n \t\tgoto out;\n \n-\tupperdentry = ovl_dentry_upper(dentry);\n-\tif (upperdentry) {\n+\terr = ovl_copy_up(dentry);\n+\tif (!err) {\n+\t\tupperdentry = ovl_dentry_upper(dentry);\n+\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n-\t} else {\n-\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:""}","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",C,"	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

","	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
",,"@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)
 	if (err)
 		goto out;
 
-	upperdentry = ovl_dentry_upper(dentry);
-	if (upperdentry) {
+	err = ovl_copy_up(dentry);
+	if (!err) {
+		upperdentry = ovl_dentry_upper(dentry);
+
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
-	} else {
-		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:",linux,acff81ec2c79492b180fade3c2894425cd35a545,31ade3b83e1821da5fbb2f11b5b3d4ab2ec39db8,1,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
//flaw_line_below:
	upperdentry = ovl_dentry_upper(dentry);
//flaw_line_below:
	if (upperdentry) {
//fix_flaw_line_below:
//	err = ovl_copy_up(dentry);
//fix_flaw_line_below:
//	if (!err) {
//fix_flaw_line_below:
//		upperdentry = ovl_dentry_upper(dentry);
//fix_flaw_line_below:
//
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
//flaw_line_below:
	} else {
//flaw_line_below:
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",179731,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","The vulnerability in the original code arises from the potential for a race condition when accessing the `upperdentry` without ensuring that the necessary data is copied up first. If `upperdentry` is not valid, the function could attempt to modify an invalid or stale reference, leading to undefined behavior. In the fixed code, the vulnerability is addressed by introducing the `ovl_copy_up(dentry)` function call before accessing `upperdentry`. This ensures that any necessary changes are made to the overlay filesystem before proceeding, thus preventing potential data corruption or access violations when calling `notify_change(upperdentry, attr, NULL)`.","The vulnerability in the original code stems from the lack of proper synchronization when accessing shared resources, which can lead to race conditions. Specifically, the code attempts to modify an upper layer without ensuring that the necessary updates have been applied first, potentially resulting in inconsistent or invalid data being processed. The fixed code addresses this issue by introducing a mechanism to ensure that all required changes are made before accessing the shared resource. This change effectively prevents the possibility of operating on stale or invalid data, thereby enhancing the overall stability and security of the code.",4,5,4,0,"CWE-362,CWE-366,CWE-367,CWE-365,CWE-567,CWE-833,CWE-609,CWE-820,CWE-821,CWE-543",N,-1
39,39,39,179756,179756,,Local,Not required,Complete,CVE-2015-6564,https://www.cvedetails.com/cve/CVE-2015-6564/,CWE-264,Medium,Complete,Complete,,2015-08-23,6.9,Use-after-free vulnerability in the mm_answer_pam_free_ctx function in monitor.c in sshd in OpenSSH before 7.0 on non-OpenBSD platforms might allow local users to gain privileges by leveraging control of the sshd uid to send an unexpectedly early MONITOR_REQ_PAM_FREE_CTX request.,2018-09-11,+Priv ,3,https://github.com/openssh/openssh-portable/commit/5e75f5198769056089fb06c4d738ab0e5abc66f7,5e75f5198769056089fb06c4d738ab0e5abc66f7,"set sshpam_ctxt to NULL after free

Avoids use-after-free in monitor when privsep child is compromised.
Reported by Moritz Jodeit; ok dtucker@",1,monitor.c,"{""sha"": ""a91420983ba86eda2619e629265897b3fefed53a"", ""filename"": ""monitor.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/openssh/openssh-portable/blob/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""raw_url"": ""https://github.com/openssh/openssh-portable/raw/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""contents_url"": ""https://api.github.com/repos/openssh/openssh-portable/contents/monitor.c?ref=5e75f5198769056089fb06c4d738ab0e5abc66f7"", ""patch"": ""@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)\n int\n mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n+\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n \n \tdebug3(\""%s\"", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n+\tsshpam_ctxt = sshpam_authok = NULL;\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \""keyboard-interactive\"";\n \tauth_submethod = \""pam\"";\n-\treturn (sshpam_authok == sshpam_ctxt);\n+\treturn r;\n }\n #endif\n ""}"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
",C,"	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
	sshpam_ctxt = sshpam_authok = NULL;
	return r;
","	return (sshpam_authok == sshpam_ctxt);
",,"@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)
 int
 mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
+	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
+	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
-	return (sshpam_authok == sshpam_ctxt);
+	return r;
 }
 #endif
 ",openssh-portable,5e75f5198769056089fb06c4d738ab0e5abc66f7,d4697fe9a28dab7255c60433e4dd23cf7fce8a8b,1," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
//fix_flaw_line_below:
//	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
//fix_flaw_line_below:
//	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
//flaw_line_below:
	return (sshpam_authok == sshpam_ctxt);
//fix_flaw_line_below:
//	return r;
 }
",179756," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
","The vulnerability in the original code lies in the potential use of a dangling pointer, as `sshpam_ctxt` could remain pointing to a freed context after `sshpam_device.free_ctx` is called. This could lead to undefined behavior if `sshpam_authok` is accessed afterward. In the fixed code, the vulnerability is addressed by explicitly setting both `sshpam_ctxt` and `sshpam_authok` to `NULL` after freeing the context. This ensures that any subsequent checks against `sshpam_authok` will not reference a potentially invalid memory location, thus preventing possible security issues related to memory management.","The vulnerability in the original code stems from the risk of accessing a freed memory context, which can lead to undefined behavior and potential security issues. After freeing the context, the code does not nullify the pointers associated with it, leaving them dangling. This could allow for unintended access to invalid memory, potentially leading to exploitation. In the revised code, the vulnerability is mitigated by explicitly setting the relevant pointers to null after the context is freed. This ensures that any future checks or accesses do not reference invalid memory, thereby enhancing the overall security and stability of the code.",2,4,2,1,"CWE-416,CWE-415,CWE-825,CWE-476,CWE-763,CWE-754,CWE-119,CWE-404,CWE-664,CWE-758",N,-1
40,40,40,179850,179850,,Remote,Not required,,CVE-2015-2694,https://www.cvedetails.com/cve/CVE-2015-2694/,CWE-264,Medium,Partial,Partial,,2015-05-25,5.8,"The kdcpreauth modules in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.2 do not properly track whether a client's request has been validated, which allows remote attackers to bypass an intended preauthentication requirement by providing (1) zero bytes of data or (2) an arbitrary realm name, related to plugins/preauth/otp/main.c and plugins/preauth/pkinit/pkinit_srv.c.",2016-12-07,Bypass ,2,https://github.com/krb5/krb5/commit/e3b5a5e5267818c97750b266df50b6a3d4649604,e3b5a5e5267818c97750b266df50b6a3d4649604,"Prevent requires_preauth bypass [CVE-2015-2694]

In the OTP kdcpreauth module, don't set the TKT_FLG_PRE_AUTH bit until
the request is successfully verified.  In the PKINIT kdcpreauth
module, don't respond with code 0 on empty input or an unconfigured
realm.  Together these bugs could cause the KDC preauth framework to
erroneously treat a request as pre-authenticated.

CVE-2015-2694:

In MIT krb5 1.12 and later, when the KDC is configured with PKINIT
support, an unauthenticated remote attacker can bypass the
requires_preauth flag on a client principal and obtain a ciphertext
encrypted in the principal's long-term key.  This ciphertext could be
used to conduct an off-line dictionary attack against the user's
password.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:P/I:P/A:N/E:POC/RL:OF/RC:C

ticket: 8160 (new)
target_version: 1.13.2
tags: pullup
subject: requires_preauth bypass in PKINIT-enabled KDC [CVE-2015-2694]",2,src/plugins/preauth/pkinit/pkinit_srv.c,"{""sha"": ""7941b4aeeef179e21a1e9727b327f312ca4e707a"", ""filename"": ""src/plugins/preauth/otp/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/otp/main.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -42,6 +42,7 @@ static krb5_preauthtype otp_pa_type_list[] =\n struct request_state {\n     krb5_kdcpreauth_verify_respond_fn respond;\n     void *arg;\n+    krb5_enc_tkt_part *enc_tkt_reply;\n };\n \n static krb5_error_code\n@@ -159,6 +160,9 @@ on_response(void *data, krb5_error_code retval, otp_response response)\n     if (retval == 0 && response != otp_response_success)\n         retval = KRB5_PREAUTH_FAILED;\n \n+    if (retval == 0)\n+        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n+\n     rs.respond(rs.arg, retval, NULL, NULL, NULL);\n }\n \n@@ -263,8 +267,6 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n     krb5_data d, plaintext;\n     char *config;\n \n-    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n-\n     /* Get the FAST armor key. */\n     armor_key = cb->fast_armor(context, rock);\n     if (armor_key == NULL) {\n@@ -298,12 +300,14 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n         goto error;\n     }\n \n-    /* Create the request state. */\n+    /* Create the request state.  Save the response callback, and the\n+     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. */\n     rs = k5alloc(sizeof(struct request_state), &retval);\n     if (rs == NULL)\n         goto error;\n     rs->arg = arg;\n     rs->respond = respond;\n+    rs->enc_tkt_reply = enc_tkt_reply;\n \n     /* Get the principal's OTP configuration string. */\n     retval = cb->get_string(context, rock, \""otp\"", &config);""}<_**next**_>{""sha"": ""5b1d73e4a6c4820af9e6c9bb24db67928f6d9b20"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     pkiDebug(\""pkinit_verify_padata: entered!\\n\"");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n \n@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n ""}","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",C,"        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
","        (*respond)(arg, 0, NULL, NULL, NULL);
        (*respond)(arg, 0, NULL, NULL, NULL);
",,"@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 ",krb5,e3b5a5e5267818c97750b266df50b6a3d4649604,527edfaadb648a0dd2a42cd39a5a02a4ac37d7e3,1,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",179850,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","The vulnerability in the original code lies in the handling of the `data` parameter, specifically when it is `NULL` or has a length of zero. In such cases, the function would call `(*respond)(arg, 0, NULL, NULL, NULL);`, which could lead to undefined behavior or a denial of service. The fixed code addresses this by ensuring that if `moddata` is `NULL`, it also responds with an error code `EINVAL`, thus preventing further processing and potential exploitation. This change enhances the robustness of the function by validating inputs more thoroughly before proceeding with sensitive operations.","The vulnerability in the original code arises from inadequate input validation, particularly when handling a specific parameter that could be `NULL` or have a zero length. This oversight allows the function to proceed with operations that assume valid input, potentially leading to undefined behavior or exploitation, such as denial of service. The revised code mitigates this risk by implementing additional checks to ensure that all critical parameters are valid before any processing occurs. This enhancement ensures that the function exits gracefully with an appropriate error response when faced with invalid input, thereby improving overall security and stability.",3,5,"4

The explanation and repair description contains most of the key aspects but has a few gaps. It includes the code before repair and clearly shows the core vulnerability issue around verification of preauth data. However, it lacks some important aspects:

1. No explicit description of the vulnerability
2. No clear explanation of exactly what was changed in the repair
3. No discussion of why the changes fix the vulnerability 
4. No mention of potential impacts or security implications

While the code provides good technical detail about the fix implementation, the missing context and explanation details prevent it from being a complete description. Therefore, a rating of 4 out of 5 is appropriate - comprehensive but not complete.",4,"CWE-20,CWE-476,CWE-805,CWE-1254,CWE-400,CWE-89,CWE-74,CWE-707,CWE-789,CWE-754",N,-1
41,41,41,179856,179856,,Remote,Not required,Partial,CVE-2015-1867,https://www.cvedetails.com/cve/CVE-2015-1867/,CWE-264,Low,Partial,Partial,,2015-08-12,7.5,"Pacemaker before 1.1.13 does not properly evaluate added nodes, which allows remote read-only users to gain privileges via an acl command.",2017-10-09,+Priv ,6,https://github.com/ClusterLabs/pacemaker/commit/84ac07c,84ac07c,"Fix: acl: Do not delay evaluation of added nodes in some situations

It is not appropriate when the node has no children as it is not a
placeholder",3,lib/common/xml.c,"{""sha"": ""716f053f824168e16584efef8e949e2666192e8a"", ""filename"": ""lib/common/xml.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lib/common/xml.c?ref=84ac07c7d02b3badd708b1ef13a2159dede70715"", ""patch"": ""@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)\n \n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n+        char *path = xml_get_path(xml);\n \n-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */\n+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'\n+         * Except in the ACLs section\n+         */\n \n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n \n-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, \""/\""XML_CIB_TAG_ACLS\""/\"") == NULL) {\n                 /* Delay the acl check */\n                 continue;\n \n@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)\n                 break;\n \n             } else {\n-                char *path = xml_get_path(xml);\n                 crm_trace(\""Cannot add new node %s at %s\"", crm_element_name(xml), path);\n \n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)\n                 return;\n             }\n         }\n+        free(path);\n     }\n \n     while (cIter != NULL) {""}","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",C,"        char *path = xml_get_path(xml);
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
        free(path);
","        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                char *path = xml_get_path(xml);
",,"@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
+        char *path = xml_get_path(xml);
 
-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
+         * Except in the ACLs section
+         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)
                 break;
 
             } else {
-                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)
                 return;
             }
         }
+        free(path);
     }
 
     while (cIter != NULL) {",pacemaker,84ac07c,e52eef127b97aa9a05e6d278037bc6da7929a16d,1,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
//fix_flaw_line_below:
//        char *path = xml_get_path(xml);
 
//flaw_line_below:
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
//fix_flaw_line_below:
//        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
//fix_flaw_line_below:
//         * Except in the ACLs section
//fix_flaw_line_below:
//         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
//flaw_line_below:
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
//fix_flaw_line_below:
//            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
//flaw_line_below:
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
//fix_flaw_line_below:
//        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",179856,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","The vulnerability in the original code lies in the lack of proper access control when processing XML nodes, particularly allowing the creation of nodes without sufficient checks in the ACLs section. Specifically, the condition to skip the ACL check for nodes with the attribute `XML_ATTR_ID` did not account for whether the node was within the ACLs section, potentially allowing unauthorized modifications. The fixed code addresses this by adding a check using `strstr(path, ""/""XML_CIB_TAG_ACLS""/"")` to ensure that the ACL check is enforced for nodes within the ACLs section, thereby enhancing security and preventing unauthorized access.","The vulnerability in the original code stems from inadequate access control, allowing the creation of nodes without proper authorization checks, particularly in sensitive areas like the ACLs section. This oversight could lead to unauthorized modifications, as the code permitted certain nodes to bypass security checks based solely on their attributes. The revised code rectifies this issue by introducing a condition that ensures access control is enforced for nodes within the ACLs section, thereby preventing unauthorized changes and enhancing the overall security of the XML processing logic. This change effectively mitigates the risk of privilege escalation.",3,5,4,3,"CWE-284, CWE-285, CWE-287, CWE-269, CWE-732, CWE-266, CWE-264, CWE-862, CWE-863, CWE-282",N,-1
42,42,42,179867,179867,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,arch/x86/mm/mmap.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",C,"static unsigned long stack_maxrandom_size(void)
	unsigned long max = 0;
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
","	unsigned int max = 0;
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
",,"@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {
 	.flags = -1,
 };
 
-static unsigned int stack_maxrandom_size(void)
+static unsigned long stack_maxrandom_size(void)
 {
-	unsigned int max = 0;
+	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
+		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1,"static unsigned int stack_maxrandom_size(void)
//fix_flaw_line_below:
//static unsigned long stack_maxrandom_size(void)
 {
//flaw_line_below:
	unsigned int max = 0;
//fix_flaw_line_below:
//	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
//fix_flaw_line_below:
//		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",179867,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","The vulnerability in the original code arises from the use of an `unsigned int` type for the variable `max`, which limits its range and can lead to integer overflow when calculating the maximum random stack size. Specifically, the expression `((-1U) & STACK_RND_MASK) << PAGE_SHIFT` could exceed the maximum value representable by an `unsigned int`. The fix changes the type of `max` to `unsigned long`, allowing it to accommodate larger values and preventing potential overflow. Additionally, the constant `-1U` is replaced with `-1UL`, ensuring that the bitwise operation is performed on a wider type, further enhancing safety.","The vulnerability in the original code stems from the use of a data type that has a limited range, which can lead to integer overflow during calculations. This overflow occurs when the computed value exceeds the maximum representable value of that type, potentially resulting in incorrect behavior or security issues. The fix addresses this vulnerability by changing the data type to one with a larger range, allowing it to safely handle larger values without overflow. Additionally, the constants used in calculations were adjusted to match the new data type, further ensuring the integrity of the operations performed.",2,4,2,2,"CWE-190, CWE-191, CWE-192, CWE-197, CWE-680, CWE-681, CWE-682, CWE-194, CWE-369, CWE-839",N,-1
43,43,43,179868,179868,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,fs/binfmt_elf.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",C,"	unsigned long random_variable = 0;
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
","	unsigned int random_variable = 0;
		random_variable = get_random_int() & STACK_RND_MASK;
",,"@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
 
 static unsigned long randomize_stack_top(unsigned long stack_top)
 {
-	unsigned int random_variable = 0;
+	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		random_variable = get_random_int() & STACK_RND_MASK;
+		random_variable = (unsigned long) get_random_int();
+		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
//flaw_line_below:
	unsigned int random_variable = 0;
//fix_flaw_line_below:
//	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		random_variable = get_random_int() & STACK_RND_MASK;
//fix_flaw_line_below:
//		random_variable = (unsigned long) get_random_int();
//fix_flaw_line_below:
//		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",179868," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
","The vulnerability in the original code arises from the use of an `unsigned int` type for the `random_variable`, which could lead to truncation of the random value when it exceeds the maximum value of an unsigned integer, potentially resulting in predictable stack addresses. In the fixed code, `random_variable` is changed to `unsigned long`, ensuring that it can accommodate larger random values without truncation. This change enhances the randomness of the stack address calculation, thereby improving security by making it more difficult for attackers to predict the stack layout and exploit potential vulnerabilities.","The vulnerability in the original code stems from the use of a data type that could not adequately handle larger random values, leading to potential truncation and predictability in stack address randomization. This predictability could allow attackers to exploit the stack layout, undermining security measures. In the revised code, the data type was changed to one that can accommodate a wider range of values, thus preventing truncation. This adjustment enhances the randomness of the stack address, making it significantly more difficult for attackers to predict the stack's configuration and exploit any vulnerabilities effectively.",4,3,2,2,"CWE-789, CWE-190, CWE-119, CWE-788, CWE-118, CWE-467, CWE-194, CWE-192, CWE-680, CWE-131",N,-1
44,44,44,179900,179900,,Remote,Not required,Complete,CVE-2015-0278,https://www.cvedetails.com/cve/CVE-2015-0278/,CWE-264,Low,Complete,Complete,,2015-05-18,10.0,"libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",2018-08-13,+Priv ,11,https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c,66ab38918c911bcff025562cf06237d7fedaba0c,"unix: call setgoups before calling setuid/setgid

Partial fix for #1093",0,src/unix/process.c,"{""sha"": ""1efd588b86ef8fcff0f75a1a999c104f2288cadc"", ""filename"": ""src/unix/process.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/libuv/libuv/blob/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""raw_url"": ""https://github.com/libuv/libuv/raw/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""contents_url"": ""https://api.github.com/repos/libuv/libuv/contents/src/unix/process.c?ref=66ab38918c911bcff025562cf06237d7fedaba0c"", ""patch"": ""@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\""setgid()\"");""}","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",C,"  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

",,,"@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+    /* When dropping privileges from root, the `setgroups` call will
+     * remove any extraneous groups. If we don't call this, then
+     * even though our uid has dropped, we may still have groups
+     * that enable us to do super-user things. This will fail if we
+     * aren't root, so don't bother checking the return value, this
+     * is just done as an optimistic privilege dropping function.
+     */
+    SAVE_ERRNO(setgroups(0, NULL));
+  }
+
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");",libuv,66ab38918c911bcff025562cf06237d7fedaba0c,3901ec49767a5b66bebe0a46cf851579f5f040c0,1,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
//fix_flaw_line_below:
//  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
//fix_flaw_line_below:
//    /* When dropping privileges from root, the `setgroups` call will
//fix_flaw_line_below:
//     * remove any extraneous groups. If we don't call this, then
//fix_flaw_line_below:
//     * even though our uid has dropped, we may still have groups
//fix_flaw_line_below:
//     * that enable us to do super-user things. This will fail if we
//fix_flaw_line_below:
//     * aren't root, so don't bother checking the return value, this
//fix_flaw_line_below:
//     * is just done as an optimistic privilege dropping function.
//fix_flaw_line_below:
//     */
//fix_flaw_line_below:
//    SAVE_ERRNO(setgroups(0, NULL));
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",179900,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","The vulnerability in the original code arises from the lack of a `setgroups` call when dropping privileges using `setuid` or `setgid`. This omission allows a process to retain its supplementary group privileges, potentially enabling unauthorized access to resources. In the fixed code, the addition of the `SAVE_ERRNO(setgroups(0, NULL));` line ensures that any extraneous groups are removed when the process drops privileges from root. This change mitigates the risk of privilege escalation by ensuring that the process operates with only the intended user and group privileges, enhancing overall security.","The vulnerability in the original code stems from the failure to clear supplementary group privileges when a process drops its user or group privileges. This oversight allows a process to retain access to potentially sensitive resources, which could lead to unauthorized actions or privilege escalation. The fixed code addresses this issue by introducing a call to remove any extraneous groups before changing the user or group ID. This ensures that the process operates with only the intended privileges, thereby enhancing security and preventing potential exploitation of retained group access.",2,5,4,4,"CWE-264, CWE-272, CWE-269, CWE-271, CWE-266, CWE-250, CWE-273, CWE-265, CWE-274, CWE-279",Y,1
45,45,45,179943,179943,,Local,Not required,,CVE-2014-9644,https://www.cvedetails.com/cve/CVE-2014-9644/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a parenthesized module template expression in the salg_name field, as demonstrated by the vfat(aes) expression, a different vulnerability than CVE-2013-7421.",2018-01-04,,2,https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560,4943ba16bbc2db05115707b3ff7b4874e9e3c560,"crypto: include crypto- module prefix in template

This adds the module loading prefix ""crypto-"" to the template lookup
as well.

For example, attempting to load 'vfat(blowfish)' via AF_ALG now correctly
includes the ""crypto-"" prefix at every level, correctly rejecting ""vfat"":

	net-pf-38
	algif-hash
	crypto-vfat(blowfish)
	crypto-vfat(blowfish)-all
	crypto-vfat

Reported-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Acked-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/algapi.c,"{""sha"": ""f368ba261739fa09be28bc02fe34cf3112099fa8"", ""filename"": ""arch/x86/crypto/fpu.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/fpu.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -17,6 +17,7 @@\n #include <linux/kernel.h>\n #include <linux/module.h>\n #include <linux/slab.h>\n+#include <linux/crypto.h>\n #include <asm/i387.h>\n \n struct crypto_fpu_ctx {\n@@ -159,3 +160,5 @@ void __exit crypto_fpu_exit(void)\n {\n \tcrypto_unregister_template(&crypto_fpu_tmpl);\n }\n+\n+MODULE_ALIAS_CRYPTO(\""fpu\"");""}<_**next**_>{""sha"": ""71a8143e23b13390ec020ffb7f1168ae9ca285fc"", ""filename"": ""crypto/algapi.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algapi.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)\n \n struct crypto_template *crypto_lookup_template(const char *name)\n {\n-\treturn try_then_request_module(__crypto_lookup_template(name), \""%s\"",\n-\t\t\t\t       name);\n+\treturn try_then_request_module(__crypto_lookup_template(name),\n+\t\t\t\t       \""crypto-%s\"", name);\n }\n EXPORT_SYMBOL_GPL(crypto_lookup_template);\n ""}<_**next**_>{""sha"": ""78fb16cab13f9660553a0705941608ec3a59d88a"", ""filename"": ""crypto/authenc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authenc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -721,3 +721,4 @@ module_exit(crypto_authenc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Simple AEAD wrapper for IPsec\"");\n+MODULE_ALIAS_CRYPTO(\""authenc\"");""}<_**next**_>{""sha"": ""024bff2344fcff9d0ae3af5c04b4a75280dd2d4a"", ""filename"": ""crypto/authencesn.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authencesn.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -814,3 +814,4 @@ module_exit(crypto_authenc_esn_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""AEAD wrapper for IPsec with extended sequence numbers\"");\n+MODULE_ALIAS_CRYPTO(\""authencesn\"");""}<_**next**_>{""sha"": ""780ee27b2d43d5f3620d32c4df6c00670b6c48c8"", ""filename"": ""crypto/cbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -289,3 +289,4 @@ module_exit(crypto_cbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cbc\"");""}<_**next**_>{""sha"": ""003bbbd21a2ba9a24f4207f20037d5ee75593726"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -881,3 +881,4 @@ MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm\"");""}<_**next**_>{""sha"": ""63c17d5992f79b5a5ed40a526fa58a532eb3e5dc"", ""filename"": ""crypto/chainiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/chainiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -359,3 +359,4 @@ module_exit(chainiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Chain IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""chainiv\"");""}<_**next**_>{""sha"": ""7a8bfbd548f60835fbf417ab96e43b749a5d283f"", ""filename"": ""crypto/cmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -313,3 +313,4 @@ module_exit(crypto_cmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CMAC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cmac\"");""}<_**next**_>{""sha"": ""650afac10fd78e5ba51a28d7161ee71bcd6f3175"", ""filename"": ""crypto/cryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -955,3 +955,4 @@ module_exit(cryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""cryptd\"");""}<_**next**_>{""sha"": ""2386f731395207a2432d782d10c1421a0577dff3"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -467,3 +467,4 @@ module_exit(crypto_ctr_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n MODULE_ALIAS_CRYPTO(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""ctr\"");""}<_**next**_>{""sha"": ""bd9405820e8ac5ade61d6d6793ec18510d456ad9"", ""filename"": ""crypto/cts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -351,3 +351,4 @@ module_exit(crypto_cts_module_exit);\n \n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""CTS-CBC CipherText Stealing for CBC\"");\n+MODULE_ALIAS_CRYPTO(\""cts\"");""}<_**next**_>{""sha"": ""12011aff097136331f5aca539acb487746efcd69"", ""filename"": ""crypto/ecb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ecb.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -185,3 +185,4 @@ module_exit(crypto_ecb_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ECB block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""ecb\"");""}<_**next**_>{""sha"": ""f116fae766f81611c5530a6d92313c5e88d23fe1"", ""filename"": ""crypto/eseqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/eseqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -267,3 +267,4 @@ module_exit(eseqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Encrypted Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""eseqiv\"");""}<_**next**_>{""sha"": ""2e403f6138c14bbcb048d59256f0fb40e2032f2d"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -1444,3 +1444,4 @@ MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n MODULE_ALIAS_CRYPTO(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm\"");""}<_**next**_>{""sha"": ""72e38c098bb3184d3886ac4054f123dca3bb49ac"", ""filename"": ""crypto/hmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/hmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -268,3 +268,4 @@ module_exit(hmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""HMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""hmac\"");""}<_**next**_>{""sha"": ""6f9908a7ebcbe19f76a4ee306f326f291aff8de9"", ""filename"": ""crypto/lrw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lrw.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -400,3 +400,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LRW block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""lrw\"");""}<_**next**_>{""sha"": ""a8e870444ea9cef0ab4a2c6c919724905c7dbde7"", ""filename"": ""crypto/mcryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/mcryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -703,3 +703,4 @@ module_exit(mcryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async multibuffer crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""mcryptd\"");""}<_**next**_>{""sha"": ""f654965f09338dab066795d8c6ab8618ef263d93"", ""filename"": ""crypto/pcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -295,3 +295,4 @@ module_exit(crypto_pcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""PCBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""pcbc\"");""}<_**next**_>{""sha"": ""c305d4112735cd3b7b18b477299b534b8c0e1b77"", ""filename"": ""crypto/pcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcrypt.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -565,3 +565,4 @@ module_exit(pcrypt_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""Parallel crypto wrapper\"");\n+MODULE_ALIAS_CRYPTO(\""pcrypt\"");""}<_**next**_>{""sha"": ""9daa854cc485b61e97eb7b25ead68da14a47ce88"", ""filename"": ""crypto/seqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(seqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""seqiv\"");""}<_**next**_>{""sha"": ""df76a816cfb22f68ac173d3ef01e2e2f9e166c72"", ""filename"": ""crypto/vmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/vmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -713,3 +713,4 @@ module_exit(vmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""VMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""vmac\"");""}<_**next**_>{""sha"": ""df90b332554cf43fb595623af3e854534a9dc49b"", ""filename"": ""crypto/xcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -286,3 +286,4 @@ module_exit(crypto_xcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XCBC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""xcbc\"");""}<_**next**_>{""sha"": ""f6fd43f100c8c68c7150cad5224fafc5dc61db2c"", ""filename"": ""crypto/xts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XTS block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""xts\"");""}"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
",C,"	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
","	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
",,"@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)
 
 struct crypto_template *crypto_lookup_template(const char *name)
 {
-	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
-				       name);
+	return try_then_request_module(__crypto_lookup_template(name),
+				       ""crypto-%s"", name);
 }
 EXPORT_SYMBOL_GPL(crypto_lookup_template);
 ",linux,4943ba16bbc2db05115707b3ff7b4874e9e3c560,476c7fe20f30818e16339391aeeb01b29818f708,1," struct crypto_template *crypto_lookup_template(const char *name)
 {
//flaw_line_below:
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
//flaw_line_below:
				       name);
//fix_flaw_line_below:
//	return try_then_request_module(__crypto_lookup_template(name),
//fix_flaw_line_below:
//				       ""crypto-%s"", name);
 }
",179943," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
","The vulnerability in the original code lies in the use of the format string in the `try_then_request_module` function, where the format specifier is simply ""%s"". This could potentially lead to format string vulnerabilities if the `name` variable contains malicious input, allowing an attacker to manipulate the output or cause unintended behavior. In the fixed code, the format string is changed to ""crypto-%s"", which mitigates this risk by ensuring that the input is prefixed with ""crypto-"", thus reducing the likelihood of exploitation while maintaining the intended functionality of module requests.","The vulnerability in the original code stems from the use of a generic format string that directly incorporates user input, which can lead to format string vulnerabilities. This allows an attacker to manipulate the output or execute arbitrary code by crafting specific input. The fixed code addresses this issue by modifying the format string to include a specific prefix, thereby constraining the input and reducing the risk of exploitation. This change ensures that the input is treated in a controlled manner, enhancing the security of the function while preserving its intended functionality.",1,4,2,0,"CWE-134, CWE-133, CWE-20, CWE-78, CWE-269, CWE-89, CWE-79, CWE-22, CWE-200, CWE-287",N,-1
46,46,46,180011,180011,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,2,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/api.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",C,"		request_module(""crypto-%s"", name);
			request_module(""crypto-%s-all"", name);
","		request_module(""%s"", name);
			request_module(""%s-all"", name);
",,"@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
-		request_module(""%s"", name);
+		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
-			request_module(""%s-all"", name);
+			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,1,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
//flaw_line_below:
			request_module(""%s-all"", name);
//fix_flaw_line_below:
//			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",180011,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","The vulnerability in the original code lies in the use of `request_module(""%s"", name)` and `request_module(""%s-all"", name)`, which could lead to module loading issues if the `name` variable contains unexpected or malicious input, potentially allowing for arbitrary module loading. This could compromise system security by loading unintended modules. The fix replaces these calls with `request_module(""crypto-%s"", name)` and `request_module(""crypto-%s-all"", name)`, effectively namespacing the module requests. This change restricts the module loading to a specific prefix, reducing the risk of loading unauthorized or harmful modules and enhancing overall security.","The vulnerability in the original code stems from the potential for arbitrary module loading due to the direct use of user-supplied input, which could lead to the execution of unintended or malicious modules. This could compromise system integrity and security by allowing unauthorized access or manipulation of system resources. The fix addresses this issue by introducing a specific prefix for module requests, thereby constraining the loading process to a defined namespace. This change significantly mitigates the risk of loading harmful modules, enhancing the overall security posture of the system by ensuring that only intended modules are loaded.",3,4,4,3,"CWE-470,CWE-827,CWE-427,CWE-611,CWE-610,CWE-23,CWE-73,CWE-426,CWE-808,CWE-99",N,-1
47,47,47,180630,180630,,Local,Not required,Complete,CVE-2015-8966,https://www.cvedetails.com/cve/CVE-2015-8966/,CWE-264,Low,Complete,Complete,,2016-12-08,7.2,"arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call.",2016-12-09,+Priv ,37,https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42,76cc404bfdc0d419c720de4daaf2584542734f42,"[PATCH] arm: fix handling of F_OFD_... in oabi_fcntl64()

Cc: stable@vger.kernel.org # 3.15+
Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",33,arch/arm/kernel/sys_oabi-compat.c,"{""sha"": ""087acb569b63a4bd90982e0c9b15fc2313636c53"", ""filename"": ""arch/arm/kernel/sys_oabi-compat.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 36, ""changes"": 73, ""blob_url"": ""https://github.com/torvalds/linux/blob/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/sys_oabi-compat.c?ref=76cc404bfdc0d419c720de4daaf2584542734f42"", ""patch"": ""@@ -193,55 +193,56 @@ struct oabi_flock64 {\n \tpid_t\tl_pid;\n } __attribute__ ((packed,aligned(4)));\n \n-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+static long do_locks(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n-\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n-\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n-\tunsigned long local_arg = arg;\n-\tint ret;\n+\tstruct oabi_flock64 user;\n+\tmm_segment_t fs;\n+\tlong ret;\n+\n+\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n+\t\t\t   sizeof(user)))\n+\t\treturn -EFAULT;\n+\tkernel.l_type\t= user.l_type;\n+\tkernel.l_whence\t= user.l_whence;\n+\tkernel.l_start\t= user.l_start;\n+\tkernel.l_len\t= user.l_len;\n+\tkernel.l_pid\t= user.l_pid;\n+\n+\tfs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n+\tset_fs(fs);\n+\n+\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n+\t\tuser.l_type\t= kernel.l_type;\n+\t\tuser.l_whence\t= kernel.l_whence;\n+\t\tuser.l_start\t= kernel.l_start;\n+\t\tuser.l_len\t= kernel.l_len;\n+\t\tuser.l_pid\t= kernel.l_pid;\n+\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n+\t\t\t\t &user, sizeof(user)))\n+\t\t\tret = -EFAULT;\n+\t}\n+\treturn ret;\n+}\n \n+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+\t\t\t\t unsigned long arg)\n+{\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n \tcase F_OFD_SETLKW:\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n-\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n-\t\t\t\t   sizeof(user)))\n-\t\t\treturn -EFAULT;\n-\t\tkernel.l_type\t= user.l_type;\n-\t\tkernel.l_whence\t= user.l_whence;\n-\t\tkernel.l_start\t= user.l_start;\n-\t\tkernel.l_len\t= user.l_len;\n-\t\tkernel.l_pid\t= user.l_pid;\n-\t\tlocal_arg = (unsigned long)&kernel;\n-\t\tfs = get_fs();\n-\t\tset_fs(KERNEL_DS);\n-\t}\n-\n-\tret = sys_fcntl64(fd, cmd, local_arg);\n+\t\treturn do_locks(fd, cmd, arg);\n \n-\tswitch (cmd) {\n-\tcase F_GETLK64:\n-\t\tif (!ret) {\n-\t\t\tuser.l_type\t= kernel.l_type;\n-\t\t\tuser.l_whence\t= kernel.l_whence;\n-\t\t\tuser.l_start\t= kernel.l_start;\n-\t\t\tuser.l_len\t= kernel.l_len;\n-\t\t\tuser.l_pid\t= kernel.l_pid;\n-\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n-\t\t\t\t\t &user, sizeof(user)))\n-\t\t\t\tret = -EFAULT;\n-\t\t}\n-\tcase F_SETLK64:\n-\tcase F_SETLKW64:\n-\t\tset_fs(fs);\n+\tdefault:\n+\t\treturn sys_fcntl64(fd, cmd, arg);\n \t}\n-\n-\treturn ret;\n }\n \n struct oabi_epoll_event {""}","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
",C,"static long do_locks(unsigned int fd, unsigned int cmd,
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
		return do_locks(fd, cmd, arg);
	default:
		return sys_fcntl64(fd, cmd, arg);
","	struct oabi_flock64 user;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
	return ret;
",,"@@ -193,55 +193,56 @@ struct oabi_flock64 {
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
-	struct oabi_flock64 user;
 	struct flock64 kernel;
-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
-	unsigned long local_arg = arg;
-	int ret;
+	struct oabi_flock64 user;
+	mm_segment_t fs;
+	long ret;
+
+	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
+			   sizeof(user)))
+		return -EFAULT;
+	kernel.l_type	= user.l_type;
+	kernel.l_whence	= user.l_whence;
+	kernel.l_start	= user.l_start;
+	kernel.l_len	= user.l_len;
+	kernel.l_pid	= user.l_pid;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
+	set_fs(fs);
+
+	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
+		user.l_type	= kernel.l_type;
+		user.l_whence	= kernel.l_whence;
+		user.l_start	= kernel.l_start;
+		user.l_len	= kernel.l_len;
+		user.l_pid	= kernel.l_pid;
+		if (copy_to_user((struct oabi_flock64 __user *)arg,
+				 &user, sizeof(user)))
+			ret = -EFAULT;
+	}
+	return ret;
+}
 
+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+				 unsigned long arg)
+{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
-		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
-				   sizeof(user)))
-			return -EFAULT;
-		kernel.l_type	= user.l_type;
-		kernel.l_whence	= user.l_whence;
-		kernel.l_start	= user.l_start;
-		kernel.l_len	= user.l_len;
-		kernel.l_pid	= user.l_pid;
-		local_arg = (unsigned long)&kernel;
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-	}
-
-	ret = sys_fcntl64(fd, cmd, local_arg);
+		return do_locks(fd, cmd, arg);
 
-	switch (cmd) {
-	case F_GETLK64:
-		if (!ret) {
-			user.l_type	= kernel.l_type;
-			user.l_whence	= kernel.l_whence;
-			user.l_start	= kernel.l_start;
-			user.l_len	= kernel.l_len;
-			user.l_pid	= kernel.l_pid;
-			if (copy_to_user((struct oabi_flock64 __user *)arg,
-					 &user, sizeof(user)))
-				ret = -EFAULT;
-		}
-	case F_SETLK64:
-	case F_SETLKW64:
-		set_fs(fs);
+	default:
+		return sys_fcntl64(fd, cmd, arg);
 	}
-
-	return ret;
 }
 
 struct oabi_epoll_event {",linux,76cc404bfdc0d419c720de4daaf2584542734f42,74bf8efb5fa6e958d2d7c7917b8bb672085ec0c6,1,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
//flaw_line_below:
	struct oabi_flock64 user;
 	struct flock64 kernel;
//flaw_line_below:
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
//flaw_line_below:
	unsigned long local_arg = arg;
//flaw_line_below:
	int ret;
//fix_flaw_line_below:
//	struct oabi_flock64 user;
//fix_flaw_line_below:
//	mm_segment_t fs;
//fix_flaw_line_below:
//	long ret;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//			   sizeof(user)))
//fix_flaw_line_below:
//		return -EFAULT;
//fix_flaw_line_below:
//	kernel.l_type	= user.l_type;
//fix_flaw_line_below:
//	kernel.l_whence	= user.l_whence;
//fix_flaw_line_below:
//	kernel.l_start	= user.l_start;
//fix_flaw_line_below:
//	kernel.l_len	= user.l_len;
//fix_flaw_line_below:
//	kernel.l_pid	= user.l_pid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	fs = get_fs();
//fix_flaw_line_below:
//	set_fs(KERNEL_DS);
//fix_flaw_line_below:
//	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
//fix_flaw_line_below:
//	set_fs(fs);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
//fix_flaw_line_below:
//		user.l_type	= kernel.l_type;
//fix_flaw_line_below:
//		user.l_whence	= kernel.l_whence;
//fix_flaw_line_below:
//		user.l_start	= kernel.l_start;
//fix_flaw_line_below:
//		user.l_len	= kernel.l_len;
//fix_flaw_line_below:
//		user.l_pid	= kernel.l_pid;
//fix_flaw_line_below:
//		if (copy_to_user((struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//				 &user, sizeof(user)))
//fix_flaw_line_below:
//			ret = -EFAULT;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	return ret;
//fix_flaw_line_below:
//}
 
//fix_flaw_line_below:
//asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//				 unsigned long arg)
//fix_flaw_line_below:
//{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
//flaw_line_below:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//flaw_line_below:
				   sizeof(user)))
//flaw_line_below:
			return -EFAULT;
//flaw_line_below:
		kernel.l_type	= user.l_type;
//flaw_line_below:
		kernel.l_whence	= user.l_whence;
//flaw_line_below:
		kernel.l_start	= user.l_start;
//flaw_line_below:
		kernel.l_len	= user.l_len;
//flaw_line_below:
		kernel.l_pid	= user.l_pid;
//flaw_line_below:
		local_arg = (unsigned long)&kernel;
//flaw_line_below:
		fs = get_fs();
//flaw_line_below:
		set_fs(KERNEL_DS);
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	ret = sys_fcntl64(fd, cmd, local_arg);
//fix_flaw_line_below:
//		return do_locks(fd, cmd, arg);
 
//flaw_line_below:
	switch (cmd) {
//flaw_line_below:
	case F_GETLK64:
//flaw_line_below:
		if (!ret) {
//flaw_line_below:
			user.l_type	= kernel.l_type;
//flaw_line_below:
			user.l_whence	= kernel.l_whence;
//flaw_line_below:
			user.l_start	= kernel.l_start;
//flaw_line_below:
			user.l_len	= kernel.l_len;
//flaw_line_below:
			user.l_pid	= kernel.l_pid;
//flaw_line_below:
			if (copy_to_user((struct oabi_flock64 __user *)arg,
//flaw_line_below:
					 &user, sizeof(user)))
//flaw_line_below:
				ret = -EFAULT;
//flaw_line_below:
		}
//flaw_line_below:
	case F_SETLK64:
//flaw_line_below:
	case F_SETLKW64:
//flaw_line_below:
		set_fs(fs);
//fix_flaw_line_below:
//	default:
//fix_flaw_line_below:
//		return sys_fcntl64(fd, cmd, arg);
 	}
//flaw_line_below:

//flaw_line_below:
	return ret;
 }
",180630,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","The vulnerability in the original code arises from the improper handling of user-supplied pointers, specifically in the `sys_oabi_fcntl64` function, where the `arg` pointer is directly manipulated without sufficient validation. This could lead to memory corruption or privilege escalation if an attacker provides a malicious pointer. The fix introduces a new function, `do_locks`, which centralizes the locking logic and ensures that the user data is copied from user space to kernel space before any operations are performed. Additionally, the `set_fs` and `copy_to_user` calls are now properly managed, enhancing security by preventing unauthorized access to kernel memory.","The vulnerability in the original code stems from inadequate validation of user-supplied pointers, which could lead to memory corruption or unauthorized access to kernel memory. Specifically, the code directly manipulates user data without ensuring it is safe, allowing an attacker to exploit this by providing a malicious pointer. The fix addresses this issue by introducing a separate function that centralizes the handling of user data, ensuring it is copied safely from user space to kernel space before any operations are performed. This change enhances security by properly managing memory access and reducing the risk of exploitation.",2,5,4,3,"CWE-119,CWE-787,CWE-416,CWE-476,CWE-468,CWE-120,CWE-122,CWE-121,CWE-415,CWE-825",N,-1
48,48,48,180705,180705,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,2,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/keys/encrypted-keys/encrypted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",C,"	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
",,,"@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 ",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",180705,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","The vulnerability in the original code lies in the lack of a check for the `KEY_FLAG_NEGATIVE` flag in the `key` structure, which could allow unauthorized access to sensitive operations if the key is marked as negative. This oversight could lead to potential security risks, such as processing invalid keys. The fixed code addresses this vulnerability by adding a check with `test_bit(KEY_FLAG_NEGATIVE, &key->flags)`, which ensures that if the key is negative, the function immediately returns `-ENOKEY`, thereby preventing further processing and enhancing the security of the key management system.","The vulnerability in the original code stems from the absence of a check for a specific flag that indicates whether the key is valid or not. This oversight could allow the function to process an invalid or negative key, potentially leading to unauthorized access or manipulation of sensitive data. The fixed code addresses this issue by introducing a validation step that checks the key's status before proceeding with any operations. By ensuring that only valid keys are processed, the updated code enhances security and prevents potential exploitation of the system through invalid key usage.",4,4,3,4,"CWE-287, CWE-284, CWE-285, CWE-923, CWE-288, CWE-347, CWE-345, CWE-322, CWE-797, CWE-346",N,-1
49,49,49,180706,180706,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/trusted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",C,"	struct trusted_key_payload *p;
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
","	struct trusted_key_payload *p = key->payload.data[0];
",,"@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)
  */
 static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
-	struct trusted_key_payload *p = key->payload.data[0];
+	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
+	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
//flaw_line_below:
	struct trusted_key_payload *p = key->payload.data[0];
//fix_flaw_line_below:
//	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
//fix_flaw_line_below:
//	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",180706," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
","The vulnerability in the original code arises from the lack of a check for negative keys, which could lead to unauthorized access or manipulation of key data. Specifically, the absence of a condition to verify if the key is marked as negative (using `KEY_FLAG_NEGATIVE`) allows the function to proceed with potentially invalid or harmful operations. In the fixed code, this vulnerability is addressed by adding a check at the beginning: `if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) return -ENOKEY;`. This ensures that if the key is negative, the function exits early, preventing further processing and enhancing security.","The vulnerability in the original code stems from the lack of validation for negative keys, which could allow unauthorized access or manipulation of sensitive data. Without a proper check, the function could proceed with operations on a key that should not be processed, potentially leading to security breaches. The fixed code addresses this issue by introducing a validation step at the beginning, ensuring that if a key is marked as negative, the function exits immediately. This early termination prevents any further actions on invalid keys, thereby enhancing the overall security of the code.",2,5,5,4,"CWE-20, CWE-285, CWE-502, CWE-269, CWE-757, CWE-754, CWE-1284, CWE-665, CWE-696, CWE-345",N,-1
50,50,50,180707,180707,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/user_defined.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",C,"		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
","		zap = key->payload.data[0];
",,"@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
-		zap = key->payload.data[0];
+		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+			zap = key->payload.data[0];
+		else
+			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
//flaw_line_below:
		zap = key->payload.data[0];
//fix_flaw_line_below:
//		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//			zap = key->payload.data[0];
//fix_flaw_line_below:
//		else
//fix_flaw_line_below:
//			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",180707,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","The vulnerability in the original code lies in the handling of the `zap` variable, which could point to a previously allocated payload even when the key is marked as negative (indicating it should not have a valid payload). This could lead to a use-after-free condition if the key was freed elsewhere, resulting in potential memory corruption or exploitation. The fixed code addresses this by adding a check for the `KEY_FLAG_NEGATIVE` flag before assigning `zap`. If the flag is set, `zap` is explicitly set to `NULL`, preventing the deallocation of an invalid pointer and enhancing memory safety.","The vulnerability in the original code arises from the potential for a use-after-free condition, where a pointer may reference memory that has already been freed. This occurs when the code does not adequately check the state of the key before attempting to free its associated payload, allowing for the possibility of deallocating memory that is still in use. The fixed code resolves this issue by introducing a conditional check to ensure that the key is in a valid state before proceeding with the deallocation. This prevents the code from attempting to free memory that should not be accessed, thereby enhancing overall safety.",4,5,3,5,"CWE-416,CWE-825,CWE-415,CWE-675,CWE-476,CWE-404,CWE-672,CWE-613,CWE-908,CWE-911",N,-1
51,51,51,181632,181632,,Remote,Single system,Partial,CVE-2016-10318,https://www.cvedetails.com/cve/CVE-2016-10318/,CWE-264,Low,,,,2017-04-04,4.0,"A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service.",2017-04-11,DoS ,3,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,"fscrypto: add authorization check for setting encryption policy

On an ext4 or f2fs filesystem with file encryption supported, a user
could set an encryption policy on any empty directory(*) to which they
had readonly access.  This is obviously problematic, since such a
directory might be owned by another user and the new encryption policy
would prevent that other user from creating files in their own directory
(for example).

Fix this by requiring inode_owner_or_capable() permission to set an
encryption policy.  This means that either the caller must own the file,
or the caller must have the capability CAP_FOWNER.

(*) Or also on any regular file, for f2fs v4.6 and later and ext4
    v4.8-rc1 and later; a separate bug fix is coming for that.

Signed-off-by: Eric Biggers <ebiggers@google.com>
Cc: stable@vger.kernel.org # 4.1+; check fs/{ext4,f2fs}
Signed-off-by: Theodore Ts'o <tytso@mit.edu>",0,fs/crypto/policy.c,"{""sha"": ""c9800b1a2e930f65e8fa7a9b052fb80efeba512c"", ""filename"": ""fs/crypto/policy.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/crypto/policy.c?ref=163ae1c6ad6299b19e22b4a35d5ab24a89791a98"", ""patch"": ""@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,\n int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n+\tif (!inode_owner_or_capable(inode))\n+\t\treturn -EACCES;\n+\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n ""}"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",C,"	if (!inode_owner_or_capable(inode))
		return -EACCES;

",,,"@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,
 int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
+	if (!inode_owner_or_capable(inode))
+		return -EACCES;
+
 	if (policy->version != 0)
 		return -EINVAL;
 ",linux,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,c6935931c1894ff857616ff8549b61236a19148f,1," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
//fix_flaw_line_below:
//	if (!inode_owner_or_capable(inode))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",181632," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
","The vulnerability in the original code lies in the lack of access control checks before processing the encryption policy. Specifically, the function does not verify if the caller has the necessary permissions to modify the encryption context of the `inode`, potentially allowing unauthorized users to alter sensitive data. The fix introduces the check `if (!inode_owner_or_capable(inode)) return -EACCES;`, which ensures that only the owner or a user with appropriate capabilities can proceed with the policy processing. This change effectively mitigates the risk of unauthorized access and enhances the security of the encryption context management.","The vulnerability in the original code stems from the absence of access control checks, allowing unauthorized users to potentially modify the encryption policy of a file. This oversight could lead to security breaches, where malicious actors gain the ability to alter sensitive data without proper permissions. The fix addresses this issue by introducing a check that verifies whether the caller has the necessary ownership or capabilities before proceeding with any policy processing. This enhancement ensures that only authorized users can make changes, thereby significantly improving the security and integrity of the encryption context management.",3,4,4,0,"CWE-285, CWE-732, CWE-269, CWE-284, CWE-264, CWE-266, CWE-639, CWE-281, CWE-863, CWE-434",N,-1
52,52,52,181689,181689,,Local,Not required,Complete,CVE-2016-10156,https://www.cvedetails.com/cve/CVE-2016-10156/,CWE-264,Low,Complete,Complete,,2017-01-23,7.2,"A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229.",2017-07-25,,2,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,06eeacb6fe029804f296b065b3ce91e796e1cd0e,"basic: fix touch() creating files with 07777 mode

mode_t is unsigned, so MODE_INVALID < 0 can never be true.

This fixes a possible DoS where any user could fill /run by writing to
a world-writable /run/systemd/show-status.",1,src/basic/fs-util.c,"{""sha"": ""61b651b573afb3f2d7f9e74830063728577e71de"", ""filename"": ""src/basic/fs-util.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/systemd/systemd/blob/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""raw_url"": ""https://github.com/systemd/systemd/raw/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""contents_url"": ""https://api.github.com/repos/systemd/systemd/contents/src/basic/fs-util.c?ref=06eeacb6fe029804f296b065b3ce91e796e1cd0e"", ""patch"": ""@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (parents)\n                 mkdir_parents(path, 0755);\n \n-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n         if (fd < 0)\n                 return -errno;\n ""}","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",C,"        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
","        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
",,"@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
         if (parents)
                 mkdir_parents(path, 0755);
 
-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 ",systemd,06eeacb6fe029804f296b065b3ce91e796e1cd0e,7d82cd4d53f88402edc923f5020c9ad22f9dc154,1,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
//flaw_line_below:
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
//fix_flaw_line_below:
//        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
//fix_flaw_line_below:
//                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",181689,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","The vulnerability in the original code arises from the way the `mode` variable is handled when opening a file. If `mode` is negative or invalid (i.e., `MODE_INVALID`), the code would incorrectly use it, potentially leading to unintended file permissions. In the fixed code, this issue is addressed by changing the expression in the `open` function to `(mode == 0 || mode == MODE_INVALID) ? 0644 : mode`, ensuring that a default permission of `0644` is applied when `mode` is either zero or invalid. This prevents the risk of setting inappropriate file permissions.","The vulnerability in the original code stems from improper handling of file permissions, which could lead to unintended access rights if the provided mode is negative or invalid. This could allow unauthorized users to gain access to files with inappropriate permissions. The fix addresses this issue by ensuring that a default permission is applied when the mode is either zero or invalid, thereby preventing the assignment of potentially harmful permissions. This change enhances security by ensuring that only valid and intended permissions are set when creating or modifying files.",4,5,4,4,"CWE-732, CWE-280, CWE-266, CWE-284, CWE-264, CWE-281, CWE-668, CWE-285, CWE-732, CWE-269",N,-1
53,53,53,181817,181817,,Local,Not required,Complete,CVE-2016-10044,https://www.cvedetails.com/cve/CVE-2016-10044/,CWE-264,Low,Complete,Complete,,2017-02-07,7.2,"The aio_mount function in fs/aio.c in the Linux kernel before 4.7.7 does not properly restrict execute access, which makes it easier for local users to bypass intended SELinux W^X policy restrictions, and consequently gain privileges, via an io_setup system call.",2017-07-24,+Priv Bypass ,6,https://github.com/torvalds/linux/commit/22f6b4d34fcf039c63a94e7670e0da24f8575a5a,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,"aio: mark AIO pseudo-fs noexec

This ensures that do_mmap() won't implicitly make AIO memory mappings
executable if the READ_IMPLIES_EXEC personality flag is set.  Such
behavior is problematic because the security_mmap_file LSM hook doesn't
catch this case, potentially permitting an attacker to bypass a W^X
policy enforced by SELinux.

I have tested the patch on my machine.

To test the behavior, compile and run this:

    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/personality.h>
    #include <linux/aio_abi.h>
    #include <err.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <sys/syscall.h>

    int main(void) {
        personality(READ_IMPLIES_EXEC);
        aio_context_t ctx = 0;
        if (syscall(__NR_io_setup, 1, &ctx))
            err(1, ""io_setup"");

        char cmd[1000];
        sprintf(cmd, ""cat /proc/%d/maps | grep -F '/[aio]'"",
            (int)getpid());
        system(cmd);
        return 0;
    }

In the output, ""rw-s"" is good, ""rwxs"" is bad.

Signed-off-by: Jann Horn <jann@thejh.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/aio.c,"{""sha"": ""4fe81d1c60f962b53392a6b4b0d047f129509c87"", ""filename"": ""fs/aio.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/aio.c?ref=22f6b4d34fcf039c63a94e7670e0da24f8575a5a"", ""patch"": ""@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n-\treturn mount_pseudo(fs_type, \""aio:\"", NULL, &ops, AIO_RING_MAGIC);\n+\tstruct dentry *root = mount_pseudo(fs_type, \""aio:\"", NULL, &ops,\n+\t\t\t\t\t   AIO_RING_MAGIC);\n+\n+\tif (!IS_ERR(root))\n+\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n+\treturn root;\n }\n \n /* aio_setup""}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
",C,"	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
","	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
",,"@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
-	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
+	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
+					   AIO_RING_MAGIC);
+
+	if (!IS_ERR(root))
+		root->d_sb->s_iflags |= SB_I_NOEXEC;
+	return root;
 }
 
 /* aio_setup",linux,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,024c7e3756d8a42fc41fe8a9488488b9b09d1dcc,1,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
//flaw_line_below:
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
//fix_flaw_line_below:
//	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
//fix_flaw_line_below:
//					   AIO_RING_MAGIC);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!IS_ERR(root))
//fix_flaw_line_below:
//		root->d_sb->s_iflags |= SB_I_NOEXEC;
//fix_flaw_line_below:
//	return root;
 }
",181817,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","The vulnerability in the original code lies in the lack of security measures after mounting the pseudo filesystem with `mount_pseudo`. This omission could allow execution of potentially harmful binaries within the mounted filesystem. In the fixed code, the vulnerability is addressed by checking if the `root` variable is not an error using `IS_ERR(root)`. If the mount is successful, the code sets the `s_iflags` of the superblock (`root->d_sb`) to `SB_I_NOEXEC`, which prevents the execution of binaries in the mounted filesystem, thereby enhancing security.","The vulnerability in the original code stems from the lack of restrictions on executing binaries within the mounted pseudo filesystem, which could lead to the execution of malicious code. This oversight poses a significant security risk, as it allows potentially harmful operations to occur without any safeguards. The fixed code addresses this vulnerability by implementing a check to ensure that the mount operation was successful. If it is successful, the code then sets a flag that prevents the execution of binaries in the mounted filesystem, thereby enhancing the overall security and integrity of the system.",2,3,3,1,"CWE-114,CWE-78,CWE-269,CWE-732,CWE-250,CWE-426,CWE-266,CWE-264,CWE-284,CWE-693",Y,8
54,54,54,182067,182067,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,7,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/ecryptfs/main.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
",,,"@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
+	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
+
+	rc = -EINVAL;
+	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
+		goto out_free;
+	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
//fix_flaw_line_below:
//	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = -EINVAL;
//fix_flaw_line_below:
//	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",182067,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The vulnerability in the original code lies in the lack of a check for the maximum filesystem stacking depth, which could lead to a stack overflow or excessive resource consumption if too many filesystems are stacked. Specifically, the variable `s->s_stack_depth` was not initialized or validated, allowing potentially unsafe configurations. The fixed code addresses this vulnerability by introducing a check after setting `s->s_stack_depth` to ensure it does not exceed `FILESYSTEM_MAX_STACK_DEPTH`. If the limit is exceeded, an error message is logged, and the function safely exits, preventing potential crashes or undefined behavior.","The vulnerability in the original code stems from the absence of a safeguard against exceeding the maximum allowed filesystem stacking depth, which could lead to stack overflow or resource exhaustion. This oversight allows for potentially unsafe configurations when multiple filesystems are mounted on top of each other. The fixed code rectifies this issue by implementing a check to verify that the stacking depth does not surpass the defined limit. If the limit is exceeded, an error message is logged, and the function exits gracefully, thereby preventing crashes or undefined behavior associated with excessive filesystem stacking.",3,5,4,4,"CWE-674, CWE-770, CWE-400, CWE-269, CWE-269, CWE-20, CWE-755, CWE-476, CWE-190, CWE-680",N,-1
55,55,55,182068,182068,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,9,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/overlayfs/super.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",C,"	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

",,,"@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
+	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
+				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
+
+	err = -EINVAL;
+	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
+		goto out_put_workpath;
+	}
+
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
//fix_flaw_line_below:
//	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
//fix_flaw_line_below:
//				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	err = -EINVAL;
//fix_flaw_line_below:
//	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_put_workpath;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",182068,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","The vulnerability in the original code lies in the lack of a check for the maximum filesystem stacking depth, which could lead to excessive resource consumption or stack overflow when mounting multiple overlay filesystems. Specifically, the absence of a validation step for `sb->s_stack_depth` could allow an attacker to create a configuration that exceeds the `FILESYSTEM_MAX_STACK_DEPTH`, potentially causing system instability. The fixed code addresses this vulnerability by introducing a check after calculating `sb->s_stack_depth`, ensuring it does not exceed the defined maximum. If it does, an error is logged, and the function exits gracefully, preventing potential exploitation.","The vulnerability in the original code stems from the absence of a check for the maximum allowed stacking depth of filesystems, which could lead to excessive resource usage or even a stack overflow when multiple overlay filesystems are mounted. This oversight could allow an attacker to exploit the system by creating configurations that exceed safe limits, potentially destabilizing the system. The revised code rectifies this issue by implementing a validation step that checks the stacking depth against a predefined maximum. If the limit is exceeded, an error is logged, and the function exits, thereby preventing potential exploitation and ensuring system stability.",4,5,5,4,"CWE-770, CWE-674, CWE-400, CWE-269, CWE-119, CWE-20, CWE-680, CWE-755, CWE-406, CWE-410",N,-1
56,56,56,182778,182778,,Local,Not required,Complete,CVE-2019-13272,https://www.cvedetails.com/cve/CVE-2019-13272/,CWE-264,Low,Complete,Complete,,2019-07-17,7.2,"In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments.",2019-07-25,,1,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,6994eefb0053799d2e07cd140df6c2ea106c41ee,"ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME

Fix two issues:

When called for PTRACE_TRACEME, ptrace_link() would obtain an RCU
reference to the parent's objective credentials, then give that pointer
to get_cred().  However, the object lifetime rules for things like
struct cred do not permit unconditionally turning an RCU reference into
a stable reference.

PTRACE_TRACEME records the parent's credentials as if the parent was
acting as the subject, but that's not the case.  If a malicious
unprivileged child uses PTRACE_TRACEME and the parent is privileged, and
at a later point, the parent process becomes attacker-controlled
(because it drops privileges and calls execve()), the attacker ends up
with control over two processes with a privileged ptrace relationship,
which can be abused to ptrace a suid binary and obtain root privileges.

Fix both of these by always recording the credentials of the process
that is requesting the creation of the ptrace relationship:
current_cred() can't change under us, and current is the proper subject
for access control.

This change is theoretically userspace-visible, but I am not aware of
any code that it will actually break.

Fixes: 64b875f7ac8a (""ptrace: Capture the ptracer's creds not PT_PTRACE_CAP"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,kernel/ptrace.c,"{""sha"": ""705887f63288d4694c5bccd5c77900cbddc1f843"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=6994eefb0053799d2e07cd140df6c2ea106c41ee"", ""patch"": ""@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-\trcu_read_lock();\n-\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n-\trcu_read_unlock();\n+\t__ptrace_link(child, new_parent, current_cred());\n }\n \n /**""}"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
",C,"	__ptrace_link(child, new_parent, current_cred());
","	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
",,"@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-	rcu_read_lock();
-	__ptrace_link(child, new_parent, __task_cred(new_parent));
-	rcu_read_unlock();
+	__ptrace_link(child, new_parent, current_cred());
 }
 
 /**",linux,6994eefb0053799d2e07cd140df6c2ea106c41ee,550d1f5bda33fa3b203d8cf8df1396825dbfd213,1," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
//flaw_line_below:
	rcu_read_lock();
//flaw_line_below:
	__ptrace_link(child, new_parent, __task_cred(new_parent));
//flaw_line_below:
	rcu_read_unlock();
//fix_flaw_line_below:
//	__ptrace_link(child, new_parent, current_cred());
 }
",182778," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
","The vulnerability in the original code arises from using `__task_cred(new_parent)` to retrieve the credentials of the `new_parent` task, which could allow an attacker to manipulate the `new_parent` task's credentials, leading to privilege escalation. This occurs because the `rcu_read_lock()` and `rcu_read_unlock()` do not adequately protect against changes to the `new_parent` task's state during the operation. In the fixed code, the use of `current_cred()` ensures that the credentials of the calling task are used instead, mitigating the risk of unauthorized access and enhancing security by preventing the exploitation of task credential manipulation.","The vulnerability in the original code stems from the potential for an attacker to manipulate the credentials of a task being linked, which could lead to privilege escalation. This occurs because the code retrieves the credentials of the new parent task, allowing for unauthorized access if the task's state changes during the operation. The fix addresses this issue by ensuring that the credentials used are those of the calling task instead. This change effectively prevents the exploitation of task credential manipulation, thereby enhancing security and safeguarding against unauthorized privilege escalation.",2,4,2,1,"CWE-269, CWE-274, CWE-732, CWE-639, CWE-264, CWE-284, CWE-266, CWE-287, CWE-668, CWE-285",N,-1
57,57,57,183067,183067,,Local,Not required,Partial,CVE-2013-1959,https://www.cvedetails.com/cve/CVE-2013-1959/,CWE-264,High,Partial,Partial,,2013-05-03,3.7,"kernel/user_namespace.c in the Linux kernel before 3.8.9 does not have appropriate capability requirements for the uid_map and gid_map files, which allows local users to gain privileges by opening a file within an unprivileged process and then modifying the file within a privileged process.",2013-11-30,+Priv ,2,https://github.com/torvalds/linux/commit/e3211c120a85b792978bcb4be7b2886df18d27f0,e3211c120a85b792978bcb4be7b2886df18d27f0,"userns: Check uid_map's opener's fsuid, not the current fsuid

Signed-off-by: Andy Lutomirski <luto@amacapital.net>",2,kernel/user_namespace.c,"{""sha"": ""5c16f3aa757a0353f8d7621b6b9d16cd586b347e"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=e3211c120a85b792978bcb4be7b2886df18d27f0"", ""patch"": ""@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n-\t\t\tif (uid_eq(uid, current_fsuid()))\n+\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n-\t\t\tif (gid_eq(gid, current_fsgid()))\n+\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n \t\t\t\treturn true;\n \t\t}\n \t}""}","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",C,"			if (uid_eq(uid, file->f_cred->fsuid))
			if (gid_eq(gid, file->f_cred->fsgid))
","			if (uid_eq(uid, current_fsuid()))
			if (gid_eq(gid, current_fsgid()))
",,"@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
-			if (uid_eq(uid, current_fsuid()))
+			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
-			if (gid_eq(gid, current_fsgid()))
+			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}",linux,e3211c120a85b792978bcb4be7b2886df18d27f0,6708075f104c3c9b04b23336bb0366ca30c3931b,1,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
//flaw_line_below:
			if (uid_eq(uid, current_fsuid()))
//fix_flaw_line_below:
//			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
//flaw_line_below:
			if (gid_eq(gid, current_fsgid()))
//fix_flaw_line_below:
//			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",183067,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","The vulnerability in the original code lies in the use of `current_fsuid()` and `current_fsgid()` to check if the user is allowed to map their filesystem IDs. This could allow unauthorized users to gain access by manipulating their IDs, as these functions return the current user's IDs rather than the IDs associated with the file being accessed. The fix replaces these checks with `file->f_cred->fsuid` and `file->f_cred->fsgid`, which ensure that the permissions are validated against the actual credentials of the file's opener, thereby preventing unauthorized ID mappings and enhancing security.","The vulnerability in the original code stems from the reliance on the current user's filesystem IDs to determine permission for mapping IDs, which could be exploited by unauthorized users to gain access. This approach allowed users to manipulate their IDs without proper validation, potentially leading to privilege escalation. The fix addresses this issue by ensuring that the permission checks are based on the credentials associated with the file being accessed, rather than the current user's IDs. This change effectively restricts ID mappings to those that are legitimately permitted, thereby enhancing the overall security of the system.",4,5,3,3,"CWE-269,CWE-284,CWE-266,CWE-274,CWE-264,CWE-287,CWE-639,CWE-732,CWE-286,CWE-863",Y,5
58,58,58,183756,183756,,Remote,Not required,Partial,CVE-2011-2836,https://www.cvedetails.com/cve/CVE-2011-2836/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 does not require Infobar interaction before use of the Windows Media Player plug-in, which makes it easier for remote attackers to have an unspecified impact via crafted Flash content.",2017-09-18,,3,https://github.com/chromium/chromium/commit/d662b905d30cec7899bbb15140dcfacd73506167,d662b905d30cec7899bbb15140dcfacd73506167,"Infobar Windows Media Player plug-in by default.

BUG=51464
Review URL: http://codereview.chromium.org/7080048

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@87500 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/plugin_observer.cc,"{""sha"": ""906950b41191831a36b88c8f067ee2a1b642238d"", ""filename"": ""chrome/browser/plugin_observer.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugin_observer.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(\n   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)\n     UserMetrics::RecordAction(\n         UserMetricsAction(\""BlockedPluginInfobar.Shown.RealPlayer\""));\n+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)\n+    UserMetrics::RecordAction(\n+        UserMetricsAction(\""BlockedPluginInfobar.Shown.WindowsMediaPlayer\""));\n }\n \n BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {""}<_**next**_>{""sha"": ""f35b51953335b0e41197dc96d027b9cf4dab981e"", ""filename"": ""chrome/tools/chromeactions.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/tools/chromeactions.txt?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,7 @@\n 0x84cc82257207df8d\tBlockedPluginInfobar.Shown.QuickTime\n 0x819dbe166b094c47\tBlockedPluginInfobar.Shown.RealPlayer\n 0x65add1afd150b840\tBlockedPluginInfobar.Shown.Shockwave\n+0x0ef80834f3e539cc\tBlockedPluginInfobar.Shown.WindowsMediaPlayer\n 0x114c3050111d8b8d\tBold\n 0x02f476e54c6d58bd\tBookmarkBarFolder_CtxMenu\n 0x3012b56b98c28823\tBookmarkBarFolder_DragEnd\n@@ -869,6 +870,7 @@\n 0x7242962875070018\tOpenAllBookmarksIncognitoWindow\n 0x5e3bd4e3535ecc38\tOpenAllBookmarksNewWindow\n 0x4b858349a1b8bb15\tOpenFile\n+0xedaa8487de2a33c6\tOpenFileManager\n 0x4928347f9423c013\tOpenInternetOptionsDialog\n 0x83af6accb98b9954\tOpenLanguageOptionsDialog\n 0xe7147544a7db079d\tOpenSystemOptionsDialog\n@@ -1085,6 +1087,7 @@\n 0x417bd10a7c5e0210\tTabContextMenu_CloseTab\n 0xa0965146c626cd18\tTabContextMenu_CloseTabsOpenedBy\n 0x6adcbb467523c7d9\tTabContextMenu_CloseTabsToRight\n+0xaadbb71a197d76ad\tTabContextMenu_CompactNavigationBar\n 0x89e073e006a686d1\tTabContextMenu_Duplicate\n 0x88aefc727559ebaf\tTabContextMenu_NewTab\n 0x218d462d319b449c\tTabContextMenu_OpenTabsLeftToRight\n@@ -1136,6 +1139,7 @@\n 0xcd4da03d7cbaeb84\tUpgradeCheck_Upgraded\n 0x624ddd04836efdcd\tUpgrade_Started\n 0xa909d722e2ae4285\tViewAboutConflicts\n+0xf3768ba285ebca7e\tViewAboutFlash\n 0xfb4a178539bac6bd\tViewSource\n 0x6932875212d36f57\tWP_EditImage\n 0x34a770eb3bbf5632\tWP_Gallery""}<_**next**_>{""sha"": ""15ec131719741b1d90bd908eaf45f13068909230"", ""filename"": ""webkit/plugins/npapi/plugin_group.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -25,6 +25,7 @@ const char* PluginGroup::kQuickTimeGroupName = \""QuickTime\"";\n const char* PluginGroup::kShockwaveGroupName = \""Shockwave\"";\n const char* PluginGroup::kRealPlayerGroupName = \""RealPlayer\"";\n const char* PluginGroup::kSilverlightGroupName = \""Silverlight\"";\n+const char* PluginGroup::kWindowsMediaPlayerGroupName = \""Windows Media Player\"";\n \n /*static*/\n std::set<string16>* PluginGroup::policy_disabled_plugin_patterns_;""}<_**next**_>{""sha"": ""deb8461f83347132140b47d59877cb1038814b7f"", ""filename"": ""webkit/plugins/npapi/plugin_group.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.h?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -89,6 +89,7 @@ class PluginGroup {\n   static const char* kShockwaveGroupName;\n   static const char* kRealPlayerGroupName;\n   static const char* kSilverlightGroupName;\n+  static const char* kWindowsMediaPlayerGroupName;\n \n   PluginGroup(const PluginGroup& other);\n ""}<_**next**_>{""sha"": ""24150c9648caa2d8d28a7f21a90309a160fdabab"", ""filename"": ""webkit/plugins/npapi/plugin_list.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_list.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -108,6 +108,9 @@ static const VersionRangeDefinition kDivXVersionRange[] = {\n static const VersionRangeDefinition kRealPlayerVersionRange[] = {\n     { \""\"", \""\"", \""12.0.1.633\"", true }\n };\n+static const VersionRangeDefinition kWindowsMediaPlayerVersionRange[] = {\n+    { \""\"", \""\"", \""\"", true }\n+};\n static const PluginGroupDefinition kGroupDefinitions[] = {\n   kFlashDefinition,\n   { \""apple-quicktime\"", PluginGroup::kQuickTimeGroupName, \""QuickTime Plug-in\"",\n@@ -129,8 +132,9 @@ static const PluginGroupDefinition kGroupDefinitions[] = {\n     kRealPlayerVersionRange, arraysize(kRealPlayerVersionRange),\n     \""http://www.real.com/realplayer/download\"" },\n   // These are here for grouping, no vulnerabilities known.\n-  { \""windows-media-player\"", \""Windows Media Player\"", \""Windows Media Player\"",\n-    NULL, 0, \""\"" },\n+  { \""windows-media-player\"", PluginGroup::kWindowsMediaPlayerGroupName,\n+    \""Windows Media Player\"", kWindowsMediaPlayerVersionRange,\n+    arraysize(kWindowsMediaPlayerVersionRange), \""\"" },\n   { \""microsoft-office\"", \""Microsoft Office\"", \""Microsoft Office\"",\n     NULL, 0, \""\"" },\n };""}","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
",C,"  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
",,,"@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
+    UserMetrics::RecordAction(
+        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
 
 BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {",Chrome,d662b905d30cec7899bbb15140dcfacd73506167,7ad8e414e2fd5dc3207095257500745d8bd16a43,1,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
//fix_flaw_line_below:
//  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
//fix_flaw_line_below:
//    UserMetrics::RecordAction(
//fix_flaw_line_below:
//        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
",183756,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","The vulnerability in the original code lies in its lack of handling for the `kWindowsMediaPlayerGroupName` plugin group, which could lead to incomplete user metrics tracking when this specific plugin is blocked. This omission may result in a lack of visibility into user interactions with the blocked plugin, potentially affecting analytics and user experience assessments. The fixed code addresses this vulnerability by adding an additional `else if` condition that checks if `name` equals `webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName`, ensuring that user metrics are recorded for this plugin as well, thereby enhancing the robustness of the tracking mechanism.","The vulnerability in the original code stems from its failure to account for a specific plugin group, which could lead to incomplete tracking of user interactions when that plugin is blocked. This oversight may result in gaps in analytics, preventing accurate assessments of user behavior and potentially impacting decision-making based on user metrics. The revised code rectifies this issue by introducing an additional condition to check for the previously unhandled plugin group, ensuring that all relevant user interactions are recorded. This enhancement improves the overall reliability and comprehensiveness of the user metrics tracking system.",4,5,3,1,"CWE-778, CWE-710, CWE-471, CWE-402, CWE-400, CWE-346, CWE-345, CWE-342, CWE-203, CWE-200",N,-1
59,59,59,183777,183777,,Remote,Not required,Partial,CVE-2011-2859,https://www.cvedetails.com/cve/CVE-2011-2859/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 uses incorrect permissions for non-gallery pages, which has unspecified impact and attack vectors.",2017-09-18,,12,https://github.com/chromium/chromium/commit/454434f6100cb6a529652a25b5fc181caa7c7f32,454434f6100cb6a529652a25b5fc181caa7c7f32,"Limit extent of webstore app to just chrome.google.com/webstore.

BUG=93497
TEST=Try installing extensions and apps from the webstore, starting both being
initially logged in, and not.


Review URL: http://codereview.chromium.org/7719003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@97986 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/extensions/extension_service.cc,"{""sha"": ""7c68ed1963348c9a9004c2907adb1d4374730617"", ""filename"": ""chrome/browser/extensions/extension_service.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 0, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_service.cc?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(\n   external_extension_url_added_ |= true;\n }\n \n+// If a download url matches one of these patterns and has a referrer of the\n+// webstore, then we're willing to treat that as a gallery download.\n+static const char* kAllowedDownloadURLPatterns[] = {\n+  \""https://clients2.google.com/service/update2*\"",\n+  \""https://clients2.googleusercontent.com/crx/*\""\n+};\n+\n bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n   // Special-case the themes mini-gallery.\n@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n \n+  // We also allow the download to be from a small set of trusted paths.\n+  if (!download_valid) {\n+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {\n+      URLPattern pattern(URLPattern::SCHEME_HTTPS,\n+                         kAllowedDownloadURLPatterns[i]);\n+      if (pattern.MatchesURL(download_url)) {\n+        download_valid = true;\n+        break;\n+      }\n+    }\n+  }\n+\n   // If the command-line gallery URL is set, then be a bit more lenient.\n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(""}<_**next**_>{""sha"": ""a224113c1f4316624bd8d0905d08bff6a7f84530"", ""filename"": ""chrome/browser/resources/webstore_app/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/webstore_app/manifest.json?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -10,10 +10,7 @@\n       \""web_url\"": \""https://chrome.google.com/webstore\""\n     },\n     \""urls\"": [\n-      \""*://chrome.google.com/extensions\"",\n-      \""*://chrome.google.com/webstore\"",\n-      \""*://clients2.google.com/service/update2\"",\n-      \""*://clients2.googleusercontent.com/crx\""\n+      \""https://chrome.google.com/webstore\""\n     ]\n   },\n   \""permissions\"": [""}"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",C,"  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

",,,"@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(
   external_extension_url_added_ |= true;
 }
 
+// If a download url matches one of these patterns and has a referrer of the
+// webstore, then we're willing to treat that as a gallery download.
+static const char* kAllowedDownloadURLPatterns[] = {
+  ""https://clients2.google.com/service/update2*"",
+  ""https://clients2.googleusercontent.com/crx/*""
+};
+
 bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
+  // We also allow the download to be from a small set of trusted paths.
+  if (!download_valid) {
+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
+      URLPattern pattern(URLPattern::SCHEME_HTTPS,
+                         kAllowedDownloadURLPatterns[i]);
+      if (pattern.MatchesURL(download_url)) {
+        download_valid = true;
+        break;
+      }
+    }
+  }
+
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(",Chrome,454434f6100cb6a529652a25b5fc181caa7c7f32,4ff8c349b22f825064f526bf6acd53b3a5aecc02,1," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
  // TODO(erikkay) When that gallery goes away, remove this code.
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
//fix_flaw_line_below:
//  // We also allow the download to be from a small set of trusted paths.
//fix_flaw_line_below:
//  if (!download_valid) {
//fix_flaw_line_below:
//    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
//fix_flaw_line_below:
//      URLPattern pattern(URLPattern::SCHEME_HTTPS,
//fix_flaw_line_below:
//                         kAllowedDownloadURLPatterns[i]);
//fix_flaw_line_below:
//      if (pattern.MatchesURL(download_url)) {
//fix_flaw_line_below:
//        download_valid = true;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      // The referrer gets stripped when transitioning from https to http,
      // or when hitting an unknown test cert and that commonly happens in
      // testing environments.  Given this, we allow an empty referrer when
      // the command-line flag is set.
      // Otherwise, the TLD must match the TLD of the command-line url.
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      // Otherwise, the TLD must match the TLD of the command-line url.
      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",183777," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
","The vulnerability in the original code lies in its strict validation of download URLs, which only checks if the download originates from the webstore app or matches the store's top-level domain (TLD). This could allow malicious downloads from untrusted sources if they matched the TLD. The fix introduces a check for trusted download paths by iterating through `kAllowedDownloadURLPatterns` and using `URLPattern::MatchesURL(download_url)`. This enhancement allows downloads from a predefined set of trusted URLs, thereby improving security by preventing unauthorized downloads while still allowing legitimate ones.","The vulnerability in the original code stems from its reliance on a limited validation mechanism for download URLs, which primarily checks if the download originates from a specific application or matches the top-level domain of a store. This approach could potentially allow malicious downloads from untrusted sources that coincidentally share the same domain. The fix enhances security by introducing a mechanism that checks against a predefined list of trusted download paths, allowing downloads only from these specified sources. This adjustment significantly reduces the risk of unauthorized downloads while still accommodating legitimate ones.",4,5,4,4,"CWE-94, CWE-184, CWE-183, CWE-610, CWE-346, CWE-345, CWE-601, CWE-434, CWE-646, CWE-23",N,-1
60,60,60,183863,183863,,Remote,Not required,,CVE-2011-2782,https://www.cvedetails.com/cve/CVE-2011-2782/,CWE-264,Medium,,Partial,,2011-08-02,4.3,"The drag-and-drop implementation in Google Chrome before 13.0.782.107 on Linux does not properly enforce permissions for files, which allows user-assisted remote attackers to bypass intended access restrictions via unspecified vectors.",2017-09-18,Bypass ,8,https://github.com/chromium/chromium/commit/20d1c99d9b53a0b2b419aae0075494a9d0b86daf,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,"Ensure URL is updated after a cross-site navigation is pre-empted by
an ""ignored"" navigation.

BUG=77507
TEST=NavigationControllerTest.LoadURL_IgnorePreemptsPending

Review URL: http://codereview.chromium.org/6826015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@81307 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/tab_contents/navigation_controller.cc,"{""sha"": ""ba75cd0ab43021ee1a50605b35eacd3e85af8410"", ""filename"": ""content/browser/tab_contents/navigation_controller.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(\n         return false;\n       break;\n     case NavigationType::NAV_IGNORE:\n-      // There is nothing we can do with this navigation, so we just return to\n+      // If a pending navigation was in progress, this canceled it.  We should\n+      // discard it and make sure it is removed from the URL bar.  After that,\n+      // there is nothing we can do with this navigation, so we just return to\n       // the caller that nothing has happened.\n+      if (pending_entry_) {\n+        DiscardNonCommittedEntries();\n+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;\n+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);\n+      }\n       return false;\n     default:\n       NOTREACHED();""}<_**next**_>{""sha"": ""53c65079b58297c19e40fb5bcfd74696ee0aff20"", ""filename"": ""content/browser/tab_contents/navigation_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 76, ""deletions"": 0, ""changes"": 76, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller_unittest.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -143,6 +143,44 @@ void RegisterForAllNavNotifications(TestNotificationTracker* tracker,\n                      Source<NavigationController>(controller));\n }\n \n+class TestTabContentsDelegate : public TabContentsDelegate {\n+ public:\n+  explicit TestTabContentsDelegate() :\n+      navigation_state_change_count_(0) {}\n+\n+  int navigation_state_change_count() {\n+    return navigation_state_change_count_;\n+  }\n+\n+  virtual void OpenURLFromTab(TabContents* source,\n+                              const GURL& url, const GURL& referrer,\n+                              WindowOpenDisposition disposition,\n+                              PageTransition::Type transition) {}\n+\n+  // Keep track of whether the tab has notified us of a navigation state change.\n+  virtual void NavigationStateChanged(const TabContents* source,\n+                                      unsigned changed_flags) {\n+    navigation_state_change_count_++;\n+  }\n+\n+  virtual void AddNewContents(TabContents* source,\n+                              TabContents* new_contents,\n+                              WindowOpenDisposition disposition,\n+                              const gfx::Rect& initial_pos,\n+                              bool user_gesture) {}\n+  virtual void ActivateContents(TabContents* contents) {}\n+  virtual void DeactivateContents(TabContents* contents) {}\n+  virtual void LoadingStateChanged(TabContents* source) {}\n+  virtual void CloseContents(TabContents* source) {}\n+  virtual void MoveContents(TabContents* source, const gfx::Rect& pos) {}\n+  virtual void ToolbarSizeChanged(TabContents* source, bool is_animating) {}\n+  virtual void UpdateTargetURL(TabContents* source, const GURL& url) {}\n+\n+ private:\n+  // The number of times NavigationStateChanged has been called.\n+  int navigation_state_change_count_;\n+};\n+\n // -----------------------------------------------------------------------------\n \n TEST_F(NavigationControllerTest, Defaults) {\n@@ -427,6 +465,44 @@ TEST_F(NavigationControllerTest, LoadURL_BackPreemptsPending) {\n   EXPECT_EQ(kExistingURL1, controller().GetActiveEntry()->url());\n }\n \n+// Tests an ignored navigation when there is a pending new navigation.\n+// This will happen if the user enters a URL, but before that commits, the\n+// current blank page reloads.  See http://crbug.com/77507.\n+TEST_F(NavigationControllerTest, LoadURL_IgnorePreemptsPending) {\n+  TestNotificationTracker notifications;\n+  RegisterForAllNavNotifications(&notifications, &controller());\n+\n+  // Set a TabContentsDelegate to listen for state changes.\n+  scoped_ptr<TestTabContentsDelegate> delegate(new TestTabContentsDelegate());\n+  EXPECT_FALSE(contents()->delegate());\n+  contents()->set_delegate(delegate.get());\n+\n+  // Without any navigations, the renderer starts at about:blank.\n+  const GURL kExistingURL(\""about:blank\"");\n+\n+  // Now make a pending new navigation.\n+  const GURL kNewURL(\""http://eh\"");\n+  controller().LoadURL(kNewURL, GURL(), PageTransition::TYPED);\n+  EXPECT_EQ(0U, notifications.size());\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_TRUE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(1, delegate->navigation_state_change_count());\n+\n+  // Before that commits, a document.write and location.reload can cause the\n+  // renderer to send a FrameNavigate with page_id -1.\n+  rvh()->SendNavigate(-1, kExistingURL);\n+\n+  // This should clear the pending entry and notify of a navigation state\n+  // change, so that we do not keep displaying kNewURL.\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_FALSE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(2, delegate->navigation_state_change_count());\n+\n+  contents()->set_delegate(NULL);\n+}\n+\n TEST_F(NavigationControllerTest, Reload) {\n   TestNotificationTracker notifications;\n   RegisterForAllNavNotifications(&notifications, &controller());""}","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",C,"      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
",,,"@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(
         return false;
       break;
     case NavigationType::NAV_IGNORE:
-      // There is nothing we can do with this navigation, so we just return to
+      // If a pending navigation was in progress, this canceled it.  We should
+      // discard it and make sure it is removed from the URL bar.  After that,
+      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
+      if (pending_entry_) {
+        DiscardNonCommittedEntries();
+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
+      }
       return false;
     default:
       NOTREACHED();",Chrome,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,e2e2411a8144afd467a0b558541521355b543506,1,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  // Save the previous state before we clobber it.
  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  // The pending_entry has no SiteInstance when we are restoring an entry.  We
  // must fill it in here so we can find the entry later by calling
  // GetEntryIndexWithPageID.  In all other cases, the SiteInstance should be
  // assigned already and we shouldn't change it.
  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  // is_in_page must be computed before the entry gets committed.
  details->is_in_page = IsURLInPageNavigation(params.url);

  // Do navigation-type specific actions. These will make and commit an entry.
  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
//flaw_line_below:
      // There is nothing we can do with this navigation, so we just return to
//fix_flaw_line_below:
//      // If a pending navigation was in progress, this canceled it.  We should
//fix_flaw_line_below:
//      // discard it and make sure it is removed from the URL bar.  After that,
//fix_flaw_line_below:
//      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
//fix_flaw_line_below:
//      if (pending_entry_) {
//fix_flaw_line_below:
//        DiscardNonCommittedEntries();
//fix_flaw_line_below:
//        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
//fix_flaw_line_below:
//        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
//fix_flaw_line_below:
//      }
       return false;
     default:
       NOTREACHED();
  }

  // All committed entries should have nonempty content state so WebKit doesn't
  // get confused when we go back to them (see the function for details).
  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  // The active entry's SiteInstance should match our SiteInstance.
  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  // WebKit doesn't set the ""auto"" transition on meta refreshes properly (bug
  // 1051891) so we manually set it for redirects which we normally treat as
  // ""non-user-gestures"" where we want to update stuff after navigations.
  //
  // Note that the redirect check also checks for a pending entry to
  // differentiate real redirects from browser initiated navigations to a
  // redirected entry. This happens when you hit back to go to a page that was
  // the destination of a redirect, we don't want to treat it as a redirect
  // even though that's what its transition will be. See bug 1117048.
  //
  // TODO(brettw) write a test for this complicated logic.
  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  // Now prep the rest of the details for the notification and broadcast.
  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",183863,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","The vulnerability in the original code lies in the handling of the `NavigationType::NAV_IGNORE` case, where it simply returned false without properly managing the state of a pending navigation. This could lead to inconsistencies in the navigation state and potentially leave stale entries in the URL bar. The fixed code addresses this by adding logic to discard any non-committed entries when a navigation is ignored, ensuring that `DiscardNonCommittedEntries()` is called and the URL bar is updated with `tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags)`. This enhances the robustness of the navigation handling by maintaining a consistent state.","The vulnerability in the original code arises from inadequate handling of navigation states when a navigation is ignored. Specifically, the code fails to manage pending navigations properly, which could result in stale or inconsistent entries remaining in the navigation history and the URL bar. The fixed code addresses this issue by implementing a mechanism to discard any non-committed entries when a navigation is ignored. This ensures that the navigation state is consistently updated, preventing potential confusion for users and maintaining the integrity of the navigation history.",4,5,4,2,"CWE-754, CWE-664, CWE-362, CWE-667, CWE-665, CWE-666, CWE-371, CWE-374, CWE-825, CWE-672",N,-1
61,61,61,183905,183905,,Remote,Not required,Partial,CVE-2011-2798,https://www.cvedetails.com/cve/CVE-2011-2798/,CWE-264,Low,,,,2011-08-02,5.0,"Google Chrome before 13.0.782.107 does not properly restrict access to internal schemes, which allows remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,10,https://github.com/chromium/chromium/commit/ce891a86763d3540e2612be26938a6163310efe0,ce891a86763d3540e2612be26938a6163310efe0,"Prevent navigation to chrome-devtools: and chrome-internal: schemas from http

BUG=87815
Review URL: http://codereview.chromium.org/7275032

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@91002 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/renderer/chrome_content_renderer_client.cc,"{""sha"": ""510dd6385437789e15aa0d0a1b7d6c111cd46d55"", ""filename"": ""chrome/renderer/chrome_content_renderer_client.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/chrome_content_renderer_client.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {\n           switches::kEnableIPCFuzzing)) {\n     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());\n   }\n-  // chrome: pages should not be accessible by normal content, and should\n-  // also be unable to script anything but themselves (to help limit the damage\n-  // that a corrupt chrome: page could cause).\n+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be\n+  // accessible by normal content, and should also be unable to script\n+  // anything but themselves (to help limit the damage that a corrupt\n+  // page could cause).\n   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));\n   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);\n \n+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);\n+\n+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);\n+\n   // chrome-extension: resources shouldn't trigger insecure content warnings.\n   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));\n   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);""}<_**next**_>{""sha"": ""3f6e1091b739477234c7eadcf38ba4b0907d2e28"", ""filename"": ""content/common/url_constants.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/url_constants.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -8,6 +8,9 @@ namespace chrome {\n \n const char kAboutScheme[] = \""about\"";\n const char kBlobScheme[] = \""blob\"";\n+\n+// Before adding new chrome schemes please check with security@chromium.org.\n+// There are security implications associated with introducing new schemes.\n const char kChromeDevToolsScheme[] = \""chrome-devtools\"";\n const char kChromeInternalScheme[] = \""chrome-internal\"";\n const char kChromeUIScheme[] = \""chrome\"";""}","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",C,"  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

",,,"@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
-  // chrome: pages should not be accessible by normal content, and should
-  // also be unable to script anything but themselves (to help limit the damage
-  // that a corrupt chrome: page could cause).
+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
+  // accessible by normal content, and should also be unable to script
+  // anything but themselves (to help limit the damage that a corrupt
+  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
+
+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
+
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);",Chrome,ce891a86763d3540e2612be26938a6163310efe0,0b481bf80794b5c18646b62cec75efebdce7b28d,1,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  // search_extension is null if not enabled.
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
//flaw_line_below:
  // chrome: pages should not be accessible by normal content, and should
//flaw_line_below:
  // also be unable to script anything but themselves (to help limit the damage
//flaw_line_below:
  // that a corrupt chrome: page could cause).
//fix_flaw_line_below:
//  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
//fix_flaw_line_below:
//  // accessible by normal content, and should also be unable to script
//fix_flaw_line_below:
//  // anything but themselves (to help limit the damage that a corrupt
//fix_flaw_line_below:
//  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
//fix_flaw_line_below:
//  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
//fix_flaw_line_below:
//
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",183905,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","The vulnerability in the original code stemmed from insufficient isolation of certain URL schemes, specifically `chrome:`, which could allow malicious content to access sensitive resources or execute scripts. This lack of proper security measures could lead to cross-site scripting (XSS) attacks or other security breaches. The fixed code addresses this vulnerability by adding additional lines to register the `dev_tools_scheme` and `internal_scheme` as display-isolated, ensuring that these schemes cannot be accessed or scripted by normal content. This enhances the overall security posture by limiting potential attack vectors.","The vulnerability in the original code arose from inadequate isolation of certain URL schemes, which could allow untrusted content to access sensitive resources or execute scripts, potentially leading to cross-site scripting attacks or other security issues. This lack of proper security measures created a risk of malicious exploitation. The fixed code addresses this vulnerability by implementing additional security measures to ensure that specific schemes are registered as display-isolated. This change effectively prevents normal content from accessing or scripting these sensitive schemes, thereby enhancing the overall security and reducing the risk of exploitation.",4,5,2,0,"CWE-79,CWE-749,CWE-20,CWE-346,CWE-434,CWE-601,CWE-610,CWE-940,CWE-345,CWE-284",N,-1
62,62,62,184594,184594,,Remote,Not required,,CVE-2011-3956,https://www.cvedetails.com/cve/CVE-2011-3956/,CWE-264,Low,,Partial,,2012-02-08,5.0,"The extension implementation in Google Chrome before 17.0.963.46 does not properly handle sandboxed origins, which might allow remote attackers to bypass the Same Origin Policy via a crafted extension.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/04915c26ea193247b8a29aa24bfa34578ef5d39e,04915c26ea193247b8a29aa24bfa34578ef5d39e,"[Qt] Remove an unnecessary masking from swapBgrToRgb()
https://bugs.webkit.org/show_bug.cgi?id=103630

Reviewed by Zoltan Herczeg.

Get rid of a masking command in swapBgrToRgb() to speed up a little bit.

* platform/graphics/qt/GraphicsContext3DQt.cpp:
(WebCore::swapBgrToRgb):


git-svn-id: svn://svn.chromium.org/blink/trunk@136375 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp,"{""sha"": ""2867e26b69edeaaffebebe3be0f993335b6d4929"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -1,3 +1,15 @@\n+2012-12-03  Gabor Rapcsanyi  <rgabor@webkit.org>\n+\n+        [Qt] Remove an unnecessary masking from swapBgrToRgb()\n+        https://bugs.webkit.org/show_bug.cgi?id=103630\n+\n+        Reviewed by Zoltan Herczeg.\n+\n+        Get rid of a masking command in swapBgrToRgb() to speed up a little bit.\n+\n+        * platform/graphics/qt/GraphicsContext3DQt.cpp:\n+        (WebCore::swapBgrToRgb):\n+\n 2012-12-03  Mikhail Pozdnyakov  <mikhail.pozdnyakov@intel.com>\n \n         CSS Device Adaptation: window.innerWidth returns wrong value if CSS viewport descriptors are applied""}<_**next**_>{""sha"": ""540c501ee1c4d98a24046786c6a1ccf758f33f38"", ""filename"": ""third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()\n \n static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);\n }\n \n #if USE(ACCELERATED_COMPOSITING)""}"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
",C,"    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
","    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
",,"@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()
 
 static inline quint32 swapBgrToRgb(quint32 pixel)
 {
-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
 
 #if USE(ACCELERATED_COMPOSITING)",Chrome,04915c26ea193247b8a29aa24bfa34578ef5d39e,8046e095da6b7fa572ac89972ec041b951c52433,1," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
//flaw_line_below:
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
//fix_flaw_line_below:
//    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
",184594," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
","The vulnerability in the original `swapBgrToRgb` function arises from the incorrect bit manipulation, which can lead to unexpected results when swapping color channels. Specifically, the expression `((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff)` improperly masks the shifted values, potentially losing color information. In the fixed code, the expression is modified to `(((pixel << 16) | (pixel >> 16)) & 0x00ff00ff)`, ensuring that both the left and right shifts are combined before applying the mask. This change preserves the integrity of the color data, resulting in a correct BGR to RGB conversion.","The vulnerability in the original code stems from improper bit manipulation during the color channel swapping process, which can lead to incorrect color representation. Specifically, the method of shifting and masking the pixel data can result in the loss of color information, causing unexpected output. The fixed code addresses this issue by altering the way the shifts are combined before applying the mask, ensuring that all relevant color data is preserved. This adjustment guarantees a correct transformation of the color channels, thereby enhancing the accuracy of the color representation in the output.",1,5,2,2,"CWE-682, CWE-192, CWE-197, CWE-190, CWE-191, CWE-681, CWE-195, CWE-194, CWE-193, CWE-196",N,-1
63,63,63,184889,184889,,Remote,Not required,,CVE-2013-2905,https://www.cvedetails.com/cve/CVE-2013-2905/,CWE-264,Low,Partial,,,2013-08-21,5.0,"The SharedMemory::Create function in memory/shared_memory_posix.cc in Google Chrome before 29.0.1547.57 uses weak permissions under /dev/shm/, which allows attackers to obtain sensitive information via direct access to a POSIX shared-memory file.",2017-09-18,+Info ,39,https://github.com/chromium/chromium/commit/afb848acb43ba316097ab4fddfa38dbd80bc6a71,afb848acb43ba316097ab4fddfa38dbd80bc6a71,"Posix: fix named SHM mappings permissions.

Make sure that named mappings in /dev/shm/ aren't created with
broad permissions.

BUG=254159
R=mark@chromium.org, markus@chromium.org

Review URL: https://codereview.chromium.org/17779002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@209814 0039d316-1c4b-4281-b951-d872f2087c98",3,base/memory/shared_memory_posix.cc,"{""sha"": ""2be787d75331d708f9f125ba995f6c42b3691325"", ""filename"": ""base/memory/shared_memory_posix.cc"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 4, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_posix.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <fcntl.h>\n #include <sys/mman.h>\n #include <sys/stat.h>\n+#include <sys/types.h>\n #include <unistd.h>\n \n #include \""base/file_util.h\""\n@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n \n-    fp = file_util::OpenFile(path, \""w+x\"");\n-    if (fp == NULL && options.open_existing) {\n-      // \""w+\"" will truncate if it already exists.\n-      fp = file_util::OpenFile(path, \""a+\"");\n+    // Make sure that the file is opened without any permission\n+    // to other users on the system.\n+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;\n+\n+    // First, try to create the file.\n+    int fd = HANDLE_EINTR(\n+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));\n+    if (fd == -1 && options.open_existing) {\n+      // If this doesn't work, try and open an existing file in append mode.\n+      // Opening an existing file in a world writable directory has two main\n+      // security implications:\n+      // - Attackers could plant a file under their control, so ownership of\n+      //   the file is checked below.\n+      // - Attackers could plant a symbolic link so that an unexpected file\n+      //   is opened, so O_NOFOLLOW is passed to open().\n+      fd = HANDLE_EINTR(\n+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));\n+\n+      // Check that the current user owns the file.\n+      // If uid != euid, then a more complex permission model is used and this\n+      // API is not appropriate.\n+      const uid_t real_uid = getuid();\n+      const uid_t effective_uid = geteuid();\n+      struct stat sb;\n+      if (fd >= 0 &&\n+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||\n+           sb.st_uid != effective_uid)) {\n+        LOG(ERROR) <<\n+            \""Invalid owner when opening existing shared memory file.\"";\n+        HANDLE_EINTR(close(fd));\n+        return false;\n+      }\n+\n+      // An existing file was opened, so its size should not be fixed.\n       fix_size = false;\n     }\n+    fp = NULL;\n+    if (fd >= 0) {\n+      // \""a+\"" is always appropriate: if it's a new file, a+ is similar to w+.\n+      fp = fdopen(fd, \""a+\"");\n+    }\n   }\n   if (fp && fix_size) {\n     // Get current size.""}<_**next**_>{""sha"": ""b1b664a61830eac54bdecc4dfcf97de9eddfa9a4"", ""filename"": ""base/memory/shared_memory_unittest.cc"", ""status"": ""modified"", ""additions"": 72, ""deletions"": 1, ""changes"": 73, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_unittest.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,8 @@\n #endif\n #include \""base/memory/scoped_ptr.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/rand_util.h\""\n+#include \""base/strings/string_number_conversions.h\""\n #include \""base/sys_info.h\""\n #include \""base/test/multiprocess_test.h\""\n #include \""base/threading/platform_thread.h\""\n@@ -21,6 +23,9 @@\n \n #if defined(OS_POSIX)\n #include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n #endif\n \n static const int kNumThreads = 5;\n@@ -401,7 +406,73 @@ TEST(SharedMemoryTest, AnonymousExecutable) {\n   EXPECT_EQ(0, mprotect(shared_memory.memory(), shared_memory.requested_size(),\n                         PROT_READ | PROT_EXEC));\n }\n-#endif\n+\n+// Android supports a different permission model than POSIX for its \""ashmem\""\n+// shared memory implementation. So the tests about file permissions are not\n+// included on Android.\n+#if !defined(OS_ANDROID)\n+\n+// Set a umask and restore the old mask on destruction.\n+class ScopedUmaskSetter {\n+ public:\n+  explicit ScopedUmaskSetter(mode_t target_mask) {\n+    old_umask_ = umask(target_mask);\n+  }\n+  ~ScopedUmaskSetter() { umask(old_umask_); }\n+ private:\n+  mode_t old_umask_;\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(ScopedUmaskSetter);\n+};\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsAnonymous) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should be able to read the shared memory\n+  // file.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsNamed) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  std::string shared_mem_name = \""shared_perm_test-\"" + IntToString(getpid()) +\n+      \""-\"" + Uint64ToString(RandUint64());\n+  options.name = &shared_mem_name;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+  // Clean-up the backing file name immediately, we don't need it.\n+  EXPECT_TRUE(shared_memory.Delete(shared_mem_name));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should have been able to open the shared\n+  // memory file while its name existed.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+#endif  // !defined(OS_ANDROID)\n+\n+#endif  // defined(OS_POSIX)\n \n // Map() will return addresses which are aligned to the platform page size, this\n // varies from platform to platform though.  Since we'd like to advertise a""}","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",C,"    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
","    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
",,"@@ -8,6 +8,7 @@
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <unistd.h>
 
 #include ""base/file_util.h""
@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
-    fp = file_util::OpenFile(path, ""w+x"");
-    if (fp == NULL && options.open_existing) {
-      // ""w+"" will truncate if it already exists.
-      fp = file_util::OpenFile(path, ""a+"");
+    // Make sure that the file is opened without any permission
+    // to other users on the system.
+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
+
+    // First, try to create the file.
+    int fd = HANDLE_EINTR(
+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
+    if (fd == -1 && options.open_existing) {
+      // If this doesn't work, try and open an existing file in append mode.
+      // Opening an existing file in a world writable directory has two main
+      // security implications:
+      // - Attackers could plant a file under their control, so ownership of
+      //   the file is checked below.
+      // - Attackers could plant a symbolic link so that an unexpected file
+      //   is opened, so O_NOFOLLOW is passed to open().
+      fd = HANDLE_EINTR(
+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
+
+      // Check that the current user owns the file.
+      // If uid != euid, then a more complex permission model is used and this
+      // API is not appropriate.
+      const uid_t real_uid = getuid();
+      const uid_t effective_uid = geteuid();
+      struct stat sb;
+      if (fd >= 0 &&
+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
+           sb.st_uid != effective_uid)) {
+        LOG(ERROR) <<
+            ""Invalid owner when opening existing shared memory file."";
+        HANDLE_EINTR(close(fd));
+        return false;
+      }
+
+      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
+    fp = NULL;
+    if (fd >= 0) {
+      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
+      fp = fdopen(fd, ""a+"");
+    }
   }
   if (fp && fix_size) {
     // Get current size.",Chrome,afb848acb43ba316097ab4fddfa38dbd80bc6a71,aea03bd0389780cae5f50d6317cbe0d6b0d0735d,1,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  // This function theoretically can block on the disk, but realistically
  // the temporary files we create will just go into the buffer cache
  // and be deleted before they ever make it out to disk.
  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    // It doesn't make sense to have a open-existing private piece of shmem
    DCHECK(!options.open_existing);
    // Q: Why not use the shm_open() etc. APIs?
    // A: Because they're limited to 4mb on OS X.  FFFFFFFUUUUUUUUUUU
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    // Deleting the file prevents anyone else from mapping it in (making it
    // private), and prevents the need for cleanup (once the last fd is closed,
    // it is truly freed).
    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
//flaw_line_below:
    fp = file_util::OpenFile(path, ""w+x"");
//flaw_line_below:
    if (fp == NULL && options.open_existing) {
//flaw_line_below:
      // ""w+"" will truncate if it already exists.
//flaw_line_below:
      fp = file_util::OpenFile(path, ""a+"");
//fix_flaw_line_below:
//    // Make sure that the file is opened without any permission
//fix_flaw_line_below:
//    // to other users on the system.
//fix_flaw_line_below:
//    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // First, try to create the file.
//fix_flaw_line_below:
//    int fd = HANDLE_EINTR(
//fix_flaw_line_below:
//        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
//fix_flaw_line_below:
//    if (fd == -1 && options.open_existing) {
//fix_flaw_line_below:
//      // If this doesn't work, try and open an existing file in append mode.
//fix_flaw_line_below:
//      // Opening an existing file in a world writable directory has two main
//fix_flaw_line_below:
//      // security implications:
//fix_flaw_line_below:
//      // - Attackers could plant a file under their control, so ownership of
//fix_flaw_line_below:
//      //   the file is checked below.
//fix_flaw_line_below:
//      // - Attackers could plant a symbolic link so that an unexpected file
//fix_flaw_line_below:
//      //   is opened, so O_NOFOLLOW is passed to open().
//fix_flaw_line_below:
//      fd = HANDLE_EINTR(
//fix_flaw_line_below:
//          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // Check that the current user owns the file.
//fix_flaw_line_below:
//      // If uid != euid, then a more complex permission model is used and this
//fix_flaw_line_below:
//      // API is not appropriate.
//fix_flaw_line_below:
//      const uid_t real_uid = getuid();
//fix_flaw_line_below:
//      const uid_t effective_uid = geteuid();
//fix_flaw_line_below:
//      struct stat sb;
//fix_flaw_line_below:
//      if (fd >= 0 &&
//fix_flaw_line_below:
//          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
//fix_flaw_line_below:
//           sb.st_uid != effective_uid)) {
//fix_flaw_line_below:
//        LOG(ERROR) <<
//fix_flaw_line_below:
//            ""Invalid owner when opening existing shared memory file."";
//fix_flaw_line_below:
//        HANDLE_EINTR(close(fd));
//fix_flaw_line_below:
//        return false;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
//fix_flaw_line_below:
//    fp = NULL;
//fix_flaw_line_below:
//    if (fd >= 0) {
//fix_flaw_line_below:
//      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
//fix_flaw_line_below:
//      fp = fdopen(fd, ""a+"");
//fix_flaw_line_below:
//    }
   }
   if (fp && fix_size) {
     // Get current size.
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",184889,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","The vulnerability in the original code arises from the way it opens files for shared memory, particularly when using `file_util::OpenFile(path, ""w+x"")`. This approach allows potential attackers to exploit race conditions by creating a symbolic link or a file with the same name in a writable directory, leading to unauthorized access or manipulation of the shared memory file. The fixed code addresses this vulnerability by using `open()` with `O_CREAT | O_EXCL` and `O_NOFOLLOW`, ensuring that the file is created with restricted permissions (`kOwnerOnly`) and that the ownership of existing files is validated, thus preventing unauthorized access and enhancing security.","The vulnerability in the original code stems from the insecure handling of file creation and opening, which allows attackers to exploit race conditions by creating symbolic links or files in writable directories. This could lead to unauthorized access or manipulation of shared memory files, compromising security. The revised code mitigates this risk by implementing stricter file opening mechanisms that ensure files are created with exclusive permissions and checks for ownership of existing files. This approach prevents unauthorized users from gaining access to sensitive shared memory resources, thereby enhancing overall security.",4,5,5,4,"CWE-367, CWE-379, CWE-362, CWE-377, CWE-552, CWE-732, CWE-269, CWE-275, CWE-281, CWE-668",N,-1
64,64,64,184959,184959,,Remote,Not required,,CVE-2013-2874,https://www.cvedetails.com/cve/CVE-2013-2874/,CWE-264,Medium,Partial,,,2013-07-10,4.3,"Google Chrome before 28.0.1500.71 on Windows, when an Nvidia GPU is used, allows remote attackers to bypass intended restrictions on access to screen data via vectors involving IPC transmission of GL textures.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,"DevTools: handle devtools renderer unresponsiveness during beforeunload event interception

This patch fixes the crash which happenes under the following conditions:
1. DevTools window is in undocked state
2. DevTools renderer is unresponsive
3. User attempts to close inspected page

BUG=322380

Review URL: https://codereview.chromium.org/84883002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@237611 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/devtools/devtools_window.cc,"{""sha"": ""41b7b2f30b4a4a051e13365cd4255fbbb0d1b0b3"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -587,6 +587,29 @@ IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n       &chrome::CloseAllBrowsers));\n }\n \n+// Tests that inspected tab gets closed if devtools renderer\n+// becomes unresponsive during beforeunload event interception.\n+// @see http://crbug.com/322380\n+IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n+                       TestUndockedDevToolsUnresponsive) {\n+  ASSERT_TRUE(test_server()->Start());\n+  LoadTestPage(kDebuggerTestPage);\n+  DevToolsWindow* devtools_window = OpenDevToolWindowOnWebContents(\n+      GetInspectedTab());\n+  devtools_window->SetDockSideForTest(DEVTOOLS_DOCK_SIDE_UNDOCKED);\n+  content::WindowedNotificationObserver devtools_close_observer(\n+      content::NOTIFICATION_WEB_CONTENTS_DESTROYED,\n+      content::Source<content::WebContents>(\n+          devtools_window->web_contents()));\n+\n+  ASSERT_TRUE(content::ExecuteScript(\n+      devtools_window->web_contents()->GetRenderViewHost(),\n+      \""window.addEventListener('beforeunload',\""\n+      \""function(event) { while (true); });\""));\n+  CloseInspectedTab();\n+  devtools_close_observer.Wait();\n+}\n+\n // Flaky, see crbug.com/323847.\n //\n // Tests that BeforeUnload event gets called on devtools that are opened""}<_**next**_>{""sha"": ""7ed6e01669c949516d82e6aaab0dd7b5229d5303"", ""filename"": ""chrome/browser/devtools/devtools_window.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_window.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {\n }\n \n void DevToolsWindow::InspectedContentsClosing() {\n+  intercepted_page_beforeunload_ = false;\n   web_contents_->GetRenderViewHost()->ClosePage();\n }\n ""}"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",C,"  intercepted_page_beforeunload_ = false;
",,,"@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {
 }
 
 void DevToolsWindow::InspectedContentsClosing() {
+  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
 ",Chrome,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,d4eca59b36fc7957334f425de843022176b7dcfd,1," void DevToolsWindow::InspectedContentsClosing() {
//fix_flaw_line_below:
//  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",184959," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
","The vulnerability in the original code lies in the lack of handling for the `intercepted_page_beforeunload_` variable, which could lead to unintended behavior when a page is closing, potentially allowing unsaved changes to be lost without warning. By adding the line `intercepted_page_beforeunload_ = false;` in the fixed code, the developer ensures that any pending unload events are properly reset before closing the page. This change mitigates the risk of data loss by explicitly managing the state of the `intercepted_page_beforeunload_` variable, thus providing a more controlled and predictable closing behavior for the web contents.","The vulnerability in the original code stems from the lack of proper handling for page unload events, which could result in the loss of unsaved changes or data when a page is closed. This oversight may allow users to inadvertently close a page without any warning or confirmation, leading to potential data loss. The fixed code addresses this issue by explicitly resetting the state related to page unload events before closing the page. This ensures that any pending actions or warnings are appropriately managed, providing a safer and more user-friendly experience when closing web content.",3,4,1,2,"CWE-459, CWE-664, CWE-914, CWE-784, CWE-909, CWE-754, CWE-665, CWE-912, CWE-706, CWE-459",N,-1
65,65,65,184960,184960,,Remote,Not required,,CVE-2013-2876,https://www.cvedetails.com/cve/CVE-2013-2876/,CWE-264,Low,Partial,,,2013-07-10,5.0,"browser/extensions/api/tabs/tabs_api.cc in Google Chrome before 28.0.1500.71 does not properly enforce restrictions on the capture of screenshots by extensions, which allows remote attackers to obtain sensitive information about the content of a previous page via vectors involving an interstitial page.",2017-09-18,+Info ,15,https://github.com/chromium/chromium/commit/016da29386308754274675e65fdb73cf9d59dc2d,016da29386308754274675e65fdb73cf9d59dc2d,"Don't allow extensions to take screenshots of interstitial pages. Branched from
https://codereview.chromium.org/14885004/ which is trying to test it.

BUG=229504

Review URL: https://chromiumcodereview.appspot.com/14954004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@198297 0039d316-1c4b-4281-b951-d872f2087c98",4,chrome/browser/extensions/api/tabs/tabs_api.cc,"{""sha"": ""445857fa0029392571ed26bee157c0b441e2cbf9"", ""filename"": ""chrome/browser/extensions/api/tabs/tabs_api.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/tabs/tabs_api.cc?ref=016da29386308754274675e65fdb73cf9d59dc2d"", ""patch"": ""@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {\n     }\n   }\n \n-  // captureVisibleTab() can return an image containing sensitive information\n-  // that the browser would otherwise protect.  Ensure the extension has\n-  // permission to do this.\n-  if (!GetExtension()->CanCaptureVisiblePage(\n-        web_contents->GetURL(),\n-        SessionID::IdForTab(web_contents),\n-        &error_)) {\n+  // Use the last committed URL rather than the active URL for permissions\n+  // checking, since the visible page won't be updated until it has been\n+  // committed. A canonical example of this is interstitials, which show the\n+  // URL of the new/loading page (active) but would capture the content of the\n+  // old page (last committed).\n+  //\n+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.\n+  // http://crbug.com/237908.\n+  NavigationEntry* last_committed_entry =\n+      web_contents->GetController().GetLastCommittedEntry();\n+  GURL last_committed_url = last_committed_entry ?\n+      last_committed_entry->GetURL() : GURL();\n+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,\n+                                             SessionID::IdForTab(web_contents),\n+                                             &error_)) {\n     return false;\n   }\n ""}","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",C,"  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
","  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
",,"@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {
     }
   }
 
-  // captureVisibleTab() can return an image containing sensitive information
-  // that the browser would otherwise protect.  Ensure the extension has
-  // permission to do this.
-  if (!GetExtension()->CanCaptureVisiblePage(
-        web_contents->GetURL(),
-        SessionID::IdForTab(web_contents),
-        &error_)) {
+  // Use the last committed URL rather than the active URL for permissions
+  // checking, since the visible page won't be updated until it has been
+  // committed. A canonical example of this is interstitials, which show the
+  // URL of the new/loading page (active) but would capture the content of the
+  // old page (last committed).
+  //
+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
+  // http://crbug.com/237908.
+  NavigationEntry* last_committed_entry =
+      web_contents->GetController().GetLastCommittedEntry();
+  GURL last_committed_url = last_committed_entry ?
+      last_committed_entry->GetURL() : GURL();
+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
+                                             SessionID::IdForTab(web_contents),
+                                             &error_)) {
     return false;
   }
 ",Chrome,016da29386308754274675e65fdb73cf9d59dc2d,7b97cf95eb604105998ab67571c30725fe015ba8,1,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        // Schema validation should make this unreachable.
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
//flaw_line_below:
  // captureVisibleTab() can return an image containing sensitive information
//flaw_line_below:
  // that the browser would otherwise protect.  Ensure the extension has
//flaw_line_below:
  // permission to do this.
//flaw_line_below:
  if (!GetExtension()->CanCaptureVisiblePage(
//flaw_line_below:
        web_contents->GetURL(),
//flaw_line_below:
        SessionID::IdForTab(web_contents),
//flaw_line_below:
        &error_)) {
//fix_flaw_line_below:
//  // Use the last committed URL rather than the active URL for permissions
//fix_flaw_line_below:
//  // checking, since the visible page won't be updated until it has been
//fix_flaw_line_below:
//  // committed. A canonical example of this is interstitials, which show the
//fix_flaw_line_below:
//  // URL of the new/loading page (active) but would capture the content of the
//fix_flaw_line_below:
//  // old page (last committed).
//fix_flaw_line_below:
//  //
//fix_flaw_line_below:
//  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
//fix_flaw_line_below:
//  // http://crbug.com/237908.
//fix_flaw_line_below:
//  NavigationEntry* last_committed_entry =
//fix_flaw_line_below:
//      web_contents->GetController().GetLastCommittedEntry();
//fix_flaw_line_below:
//  GURL last_committed_url = last_committed_entry ?
//fix_flaw_line_below:
//      last_committed_entry->GetURL() : GURL();
//fix_flaw_line_below:
//  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
//fix_flaw_line_below:
//                                             SessionID::IdForTab(web_contents),
//fix_flaw_line_below:
//                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",184960,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","The vulnerability in the original code arises from using the active URL of the `web_contents` for permission checks via `GetExtension()->CanCaptureVisiblePage()`. This could lead to security issues, especially with interstitial pages, where the active URL may not reflect the content being captured. The fix addresses this by utilizing the last committed URL instead, obtained through `web_contents->GetController().GetLastCommittedEntry()`. This change ensures that the permission check aligns with the actual content being captured, thereby enhancing security and preventing potential misuse of the screenshot functionality.","The vulnerability in the original code stems from using the active URL for permission checks, which can lead to security risks, particularly with interstitial pages that display a new URL while capturing content from an old page. This mismatch can allow unauthorized access to sensitive information. The fix addresses this issue by switching to the last committed URL for permission verification, ensuring that the check corresponds to the actual content being captured. This change enhances security by preventing potential misuse of the screenshot functionality and ensuring that only the intended content is captured.",3,5,4,5,"CWE-284,CWE-863,CWE-732,CWE-425,CWE-285,CWE-287,CWE-639,CWE-862,CWE-269,CWE-434",N,-1
66,66,66,185091,185091,,Remote,Not required,Partial,CVE-2013-0889,https://www.cvedetails.com/cve/CVE-2013-0889/,CWE-264,Medium,Partial,Partial,,2013-02-23,6.8,"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly enforce a user gesture requirement before proceeding with a file download, which might make it easier for remote attackers to execute arbitrary code via a crafted file.",2018-10-30,Exec Code ,6,https://github.com/chromium/chromium/commit/1538367452b549d929aabb13d54c85ab99f65cd3,1538367452b549d929aabb13d54c85ab99f65cd3,"For ""Dangerous"" file type, no user gesture will bypass the download warning.

BUG=170569
Review URL: https://codereview.chromium.org/12039015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@178072 0039d316-1c4b-4281-b951-d872f2087c98",3,chrome/browser/download/chrome_download_manager_delegate.cc,"{""sha"": ""9a56c725c6ea2e3a022ad0ab5fdbbf5990b6e93c"", ""filename"": ""chrome/browser/download/chrome_download_manager_delegate.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/chrome_download_manager_delegate.cc?ref=1538367452b549d929aabb13d54c85ab99f65cd3"", ""patch"": ""@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n     bool visited_referrer_before) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n \n-  // Anything loaded directly from the address bar is OK.\n-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)\n-    return false;\n-\n   // Extensions that are not from the gallery are considered dangerous.\n   // When off-store install is disabled we skip this, since in this case, we\n   // will not offer to install the extension.\n@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n   // page has been visited before today.\n   download_util::DownloadDangerLevel danger_level =\n       download_util::GetFileDangerLevel(suggested_path.BaseName());\n-  if (danger_level == download_util::AllowOnUserGesture)\n+  if (danger_level == download_util::AllowOnUserGesture) {\n+    if (download.GetTransitionType() &\n+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {\n+      return false;\n+    }\n     return !download.HasUserGesture() || !visited_referrer_before;\n+  }\n \n   return danger_level == download_util::Dangerous;\n }""}","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
",C,"  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
  }
","  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (danger_level == download_util::AllowOnUserGesture)
",,"@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
-  // Anything loaded directly from the address bar is OK.
-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
-    return false;
-
   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
-  if (danger_level == download_util::AllowOnUserGesture)
+  if (danger_level == download_util::AllowOnUserGesture) {
+    if (download.GetTransitionType() &
+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
+      return false;
+    }
     return !download.HasUserGesture() || !visited_referrer_before;
+  }
 
   return danger_level == download_util::Dangerous;
 }",Chrome,1538367452b549d929aabb13d54c85ab99f65cd3,9b95c83639a96a499e6af8d445f47086fd40a206,1,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
//flaw_line_below:
  // Anything loaded directly from the address bar is OK.
//flaw_line_below:
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
//flaw_line_below:
    return false;
//flaw_line_below:

   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  // Anything the user has marked auto-open is OK if it's user-initiated.
  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

  // ""Allow on user gesture"" is OK when we have a user gesture and the hosting
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
//flaw_line_below:
  if (danger_level == download_util::AllowOnUserGesture)
//fix_flaw_line_below:
//  if (danger_level == download_util::AllowOnUserGesture) {
//fix_flaw_line_below:
//    if (download.GetTransitionType() &
//fix_flaw_line_below:
//            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
//fix_flaw_line_below:
//      return false;
//fix_flaw_line_below:
//    }
     return !download.HasUserGesture() || !visited_referrer_before;
//fix_flaw_line_below:
//  }
 
   return danger_level == download_util::Dangerous;
 }
",185091,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","The vulnerability in the original code lies in the handling of the `PAGE_TRANSITION_FROM_ADDRESS_BAR` transition type, which could incorrectly classify a file as safe when it should be considered dangerous. Specifically, if the `danger_level` was `AllowOnUserGesture`, the code did not check for the transition type before returning a value, potentially allowing unsafe downloads. The fix introduces a conditional check for `download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR` within the `AllowOnUserGesture` block, ensuring that files downloaded from the address bar are correctly identified as safe or dangerous based on user gestures and referrer status.","The vulnerability in the original code stems from inadequate checks for certain conditions that could lead to unsafe file downloads being incorrectly classified as safe. Specifically, the logic allowed files to bypass necessary safety checks based on user gestures and transition types, potentially exposing users to harmful content. The fix addresses this issue by introducing a conditional check that ensures the transition type is evaluated before determining the safety of a file. This adjustment ensures that files downloaded under specific circumstances are properly assessed, thereby enhancing the overall security of the download process.",3,5,4,5,"CWE-285, CWE-434, CWE-284, CWE-732, CWE-287, CWE-22, CWE-434, CWE-441, CWE-494, CWE-436",N,-1
67,67,67,185132,185132,,Remote,Not required,Partial,CVE-2013-0918,https://www.cvedetails.com/cve/CVE-2013-0918/,CWE-264,Medium,Partial,Partial,,2013-03-28,6.8,"Google Chrome before 26.0.1410.43 does not prevent navigation to developer tools in response to a drag-and-drop operation, which allows user-assisted remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,4,https://github.com/chromium/chromium/commit/0a57375ad73780e61e1770a9d88b0529b0dbd33b,0a57375ad73780e61e1770a9d88b0529b0dbd33b,"Let the browser handle external navigations from DevTools.

BUG=180555


Review URL: https://chromiumcodereview.appspot.com/12531004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@186793 0039d316-1c4b-4281-b951-d872f2087c98",1,content/renderer/render_view_impl.cc,"{""sha"": ""67a61c2652e551b60816bb1a445b332e04edbd90"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -22,6 +22,7 @@\n #include \""chrome/common/chrome_notification_types.h\""\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/chrome_switches.h\""\n+#include \""chrome/common/url_constants.h\""\n #include \""chrome/test/base/in_process_browser_test.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/child_process_data.h\""\n@@ -504,6 +505,25 @@ IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestConsoleOnNavigateBack) {\n   RunTest(\""testConsoleOnNavigateBack\"", kNavigateBackTestPage);\n }\n \n+\n+// Tests that external navigation from inspector page is always handled by\n+// DevToolsWindow and results in inspected page navigation.\n+IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestDevToolsExternalNavigation) {\n+  OpenDevToolsWindow(kDebuggerTestPage);\n+  GURL url = test_server()->GetURL(kNavigateBackTestPage);\n+  content::WindowedNotificationObserver observer(\n+      content::NOTIFICATION_LOAD_STOP,\n+      content::NotificationService::AllSources());\n+  ASSERT_TRUE(content::ExecuteScript(\n+      window_->web_contents(),\n+      std::string(\""window.location = \\\""\"") + url.spec() + \""\\\""\""));\n+  observer.Wait();\n+\n+  ASSERT_TRUE(window_->web_contents()->GetURL().\n+                  SchemeIs(chrome::kChromeDevToolsScheme));\n+  ASSERT_EQ(GetInspectedTab()->GetURL(), url);\n+}\n+\n // Tests that inspector will reattach to inspected page when it is reloaded\n // after a crash. See http://crbug.com/101952\n IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestReattachAfterCrash) {""}<_**next**_>{""sha"": ""53e390b6f828d74f69c8c03f10acf0497c5fda41"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n       !url.SchemeIs(chrome::kAboutScheme)) {\n     bool send_referrer = false;\n \n-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses\n-    // must be handled by the browser process so that the correct bindings and\n-    // data sources can be registered.\n+    // All navigations to or from WebUI URLs or within WebUI-enabled\n+    // RenderProcesses must be handled by the browser process so that the\n+    // correct bindings and data sources can be registered.\n     // Similarly, navigations to view-source URLs or within ViewSource mode\n     // must be handled by the browser process (except for reloads - those are\n     // safe to leave within the renderer).\n@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n     // blessed with file permissions.\n     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();\n     bool is_initial_navigation = page_id_ == -1;\n-    bool should_fork = HasWebUIScheme(url) ||\n+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||\n         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||\n         url.SchemeIs(chrome::kViewSourceScheme) ||\n         (frame->isViewSourceModeEnabled() &&""}","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",C,"    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
","    bool should_fork = HasWebUIScheme(url) ||
",,"@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
-    // must be handled by the browser process so that the correct bindings and
-    // data sources can be registered.
+    // All navigations to or from WebUI URLs or within WebUI-enabled
+    // RenderProcesses must be handled by the browser process so that the
+    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
-    bool should_fork = HasWebUIScheme(url) ||
+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&",Chrome,0a57375ad73780e61e1770a9d88b0529b0dbd33b,e3cb4529d79a4993535da612dafedc8c40f075bb,1,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      // Targeted links may try to navigate a swapped out frame.  Allow the
      // browser process to navigate the tab instead.  Note that it is also
      // possible for non-targeted navigations (from this view) to arrive
      // here just after we are swapped out.  It's ok to send them to the
      // browser, as long as they're for the top level frame.
      // TODO(creis): Ensure this supports targeted form submissions when
      // fixing http://crbug.com/101395.
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      // We should otherwise ignore in-process iframe navigations, if they
      // arrive just after we are swapped out.
      return WebKit::WebNavigationPolicyIgnore;
    }

    // Allow kSwappedOutURL to complete.
    return default_policy;
  }

  // Webkit is asking whether to navigate to a new URL.
  // This is fine normally, except if we're showing UI from one security
  // context and they're trying to navigate to a different context.
  const GURL& url = request.url();

  // A content initiated navigation may have originated from a link-click,
  // script, drag-n-drop operation, etc.
  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  // Experimental:
  // If --enable-strict-site-isolation or --site-per-process is enabled, send
  // all top-level navigations to the browser to let it swap processes when
  // crossing site boundaries.  This is currently expected to break some script
  // calls and navigations, such as form submissions.
  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    // TODO(cevans): revisit whether this site check is still necessary once
    // crbug.com/101395 is fixed.
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  // If the browser is interested, then give it a chance to look at the request.
  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      // Reset these counters as the RenderView could be reused for the next
      // navigation.
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

  // Detect when we're crossing a permission-based boundary (e.g. into or out of
  // an extension or app origin, leaving a WebUI page, etc). We only care about
  // top-level navigations (not iframes). But we sometimes navigate to
  // about:blank to clear a tab, and we want to still allow that.
  //
  // Note: this is known to break POST submissions when crossing process
  // boundaries until http://crbug.com/101395 is fixed.  This is better for
  // security than loading a WebUI, extension or app page in the wrong process.
  // POST requests don't work because this mechanism does not preserve form
  // POST data. We will need to send the request's httpBody data up to the
  // browser process, and issue a special POST navigation in WebKit (via
  // FrameLoader::loadFrameRequest). See ResourceDispatcher and WebURLLoaderImpl
  // for examples of how to send the httpBody data.
  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
//flaw_line_below:
    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
//flaw_line_below:
    // must be handled by the browser process so that the correct bindings and
//flaw_line_below:
    // data sources can be registered.
//fix_flaw_line_below:
//    // All navigations to or from WebUI URLs or within WebUI-enabled
//fix_flaw_line_below:
//    // RenderProcesses must be handled by the browser process so that the
//fix_flaw_line_below:
//    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
//flaw_line_below:
    bool should_fork = HasWebUIScheme(url) ||
//fix_flaw_line_below:
//    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      // Give the embedder a chance.
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Detect when a page is ""forking"" a new tab that can be safely rendered in
  // its own process.  This is done by sites like Gmail that try to open links
  // in new windows without script connections back to the original page.  We
  // treat such cases as browser navigations (in which we will create a new
  // renderer for a cross-site navigation), rather than WebKit navigations.
  //
  // We use the following heuristic to decide whether to fork a new page in its
  // own process:
  // The parent page must open a new tab to about:blank, set the new tab's
  // window.opener to null, and then redirect the tab to a cross-site URL using
  // JavaScript.
  //
  // TODO(creis): Deprecate this logic once we can rely on rel=noreferrer
  // (see below).
  bool is_fork =
      // Must start from a tab showing about:blank, which is later redirected.
      old_url == GURL(chrome::kAboutBlankURL) &&
      // Must be the first real navigation of the tab.
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      // The parent page must have set the child's window.opener to null before
      // redirecting to the desired URL.
      frame->opener() == NULL &&
      // Must be a top-level frame.
      frame->parent() == NULL &&
      // Must not have issued the request from this page.
      is_content_initiated &&
      // Must be targeted at the current tab.
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      // Must be a JavaScript navigation, which appears as ""other"".
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    // Open the URL via the browser, not via WebKit.
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",185132,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","The vulnerability in the original code lies in the handling of navigation requests, particularly regarding the `should_fork` condition. The code did not adequately account for navigations involving WebUI URLs or scenarios where the current frame's URL and the old URL were both WebUI URLs, potentially allowing unauthorized access or improper handling of sensitive data. The fix introduced an additional check for `HasWebUIScheme(old_url)`, ensuring that navigations to or from WebUI URLs are correctly managed by the browser process, thereby enhancing security and preventing potential exploitation of the navigation policy.","The vulnerability in the original code stemmed from inadequate handling of navigation requests, particularly regarding the conditions under which certain URLs could be processed. This oversight could allow unauthorized access to sensitive data or improper navigation handling, especially in scenarios involving specific URL schemes. The fix addressed this issue by introducing additional checks to ensure that navigations involving certain URL types were properly managed by the browser process. This enhancement effectively mitigated the risk of exploitation by ensuring that all relevant navigation scenarios were securely handled, thereby improving the overall security of the navigation policy.",3,5,3,3,"CWE-601,CWE-20,CWE-287,CWE-284,CWE-732,CWE-610,CWE-799,CWE-22,CWE-200,CWE-285",N,-1
68,68,68,185137,185137,,Remote,Not required,Partial,CVE-2013-0922,https://www.cvedetails.com/cve/CVE-2013-0922/,CWE-264,Low,Partial,Partial,,2013-03-28,7.5,"Google Chrome before 26.0.1410.43 does not properly restrict brute-force access attempts against web sites that require HTTP Basic Authentication, which has unspecified impact and attack vectors.",2017-09-18,,3,https://github.com/chromium/chromium/commit/28aaa72a03df96fa1934876b0efbbc7e6b4b38af,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,"Revert cross-origin auth prompt blocking.
BUG=174129

Review URL: https://chromiumcodereview.appspot.com/12183030

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@181113 0039d316-1c4b-4281-b951-d872f2087c98",2,content/browser/loader/resource_dispatcher_host_impl.cc,"{""sha"": ""0c104bc1f37c86331b1ae2422cdcf9281f9e2bea"", ""filename"": ""chrome/browser/ui/login/login_prompt_browsertest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/login/login_prompt_browsertest.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -754,7 +754,9 @@ IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, NoLoginPromptForFavicon) {\n }\n \n // Block crossdomain subresource login prompting as a phishing defense.\n-IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, BlockCrossdomainPrompt) {\n+// Disabled per http://crbug.com/174179.\n+IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest,\n+                       DISABLED_BlockCrossdomainPrompt) {\n   const char* kTestPage = \""files/login/load_img_from_b.html\"";\n \n   host_resolver()->AddRule(\""www.a.com\"", \""127.0.0.1\"");""}<_**next**_>{""sha"": ""2eef4361367985c52af103d34c78596b70145ca8"", ""filename"": ""content/browser/loader/resource_dispatcher_host_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/loader/resource_dispatcher_host_impl.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n \n-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n-      return false;\n+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.\n+    // The code once did this, but was changed due to http://crbug.com/174129.\n+    // http://crbug.com/174179 has been filed to track this issue.\n   }\n \n   return true;""}","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
",C,"    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
","    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
",,"@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
-      return false;
+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
+    // The code once did this, but was changed due to http://crbug.com/174129.
+    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;",Chrome,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,f7bbda81940376c6b64e0c3dc8ed189788d3a72e,1,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  // Prevent third-party content from prompting for login, unless it is
  // a proxy that is trying to authenticate.  This is often the foundation
  // of a scam to extract credentials for another domain from the user.
  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
//flaw_line_below:
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
//flaw_line_below:
      return false;
//fix_flaw_line_below:
//    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
//fix_flaw_line_below:
//    // The code once did this, but was changed due to http://crbug.com/174129.
//fix_flaw_line_below:
//    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
",185137,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","The vulnerability in the original code lies in the handling of the `HTTP_AUTH_RESOURCE_BLOCKED_CROSS` resource type, where the function incorrectly allows authentication requests to proceed even when they should be blocked. Specifically, the check for `resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS` was intended to prevent unauthorized access but was removed, potentially exposing the application to cross-origin resource sharing (CORS) issues. In the fixed code, this check is commented out, indicating awareness of the issue and a plan to address it, while also tracking the problem through associated bug reports, thus improving code maintainability and security awareness.","The vulnerability in the original code stems from the improper handling of authentication requests, particularly in scenarios involving cross-origin resources. The code allowed requests to proceed even when they should have been blocked, potentially exposing the application to unauthorized access and security risks. In the revised code, the problematic check has been commented out, indicating a recognition of the issue and a commitment to address it in the future. This change reflects an increased awareness of security concerns and a proactive approach to maintaining the integrity of the authentication process.",4,5,4,3,"CWE-287, CWE-346, CWE-942, CWE-306, CWE-602, CWE-294, CWE-284, CWE-288, CWE-807, CWE-601",N,-1
69,69,69,185242,185242,,Remote,Not required,,CVE-2012-5155,https://www.cvedetails.com/cve/CVE-2012-5155/,CWE-264,Low,,Partial,,2013-01-15,5.0,"Google Chrome before 24.0.1312.52 on Mac OS X does not use an appropriate sandboxing approach for worker processes, which makes it easier for remote attackers to bypass intended access restrictions via unspecified vectors.",2013-01-16,Bypass ,1,https://github.com/chromium/chromium/commit/0d7717faeaef5b72434632c95c78bee4883e2573,0d7717faeaef5b72434632c95c78bee4883e2573,"Fix OS_MACOS typos. Should be OS_MACOSX.

BUG=163208
TEST=none

Review URL: https://codereview.chromium.org/12829005

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@189130 0039d316-1c4b-4281-b951-d872f2087c98",1,base/path_service_unittest.cc,"{""sha"": ""5f281d129df93d16b739e0d510cc3be239a0e63a"", ""filename"": ""base/path_service_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/path_service_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {\n       check_path_exists = false;\n   }\n #endif\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&\n       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {\n     if (path.ReferencesParent())""}<_**next**_>{""sha"": ""a235b103504c93d8af66da907f900407b4403ad5"", ""filename"": ""chrome/browser/autofill/autofill_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/autofill/autofill_browsertest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -746,7 +746,7 @@ IN_PROC_BROWSER_TEST_F(AutofillTest, DISABLED_AutofillFormWithRepeatedField) {\n }\n \n // http://crbug.com/150084\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n #define MAYBE_AutofillFormWithNonAutofillableField \\\n     AutofillFormWithNonAutofillableField\n #else""}<_**next**_>{""sha"": ""ccb0f539f442af28ef148360a0dd427d0452e4ec"", ""filename"": ""chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/download_path_reservation_tracker_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -455,7 +455,7 @@ TEST_F(DownloadPathReservationTrackerTest, UpdatesToTargetPath) {\n \n // Tests for long name truncation. On other platforms automatic truncation\n // is not performed (yet).\n-#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_CHROMEOS)\n+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_CHROMEOS)\n \n TEST_F(DownloadPathReservationTrackerTest, BasicTruncation) {\n   int real_max_length =""}<_**next**_>{""sha"": ""2953c4dd7373425370e7e29b37e48e77819820c3"", ""filename"": ""chrome/browser/ui/browser_command_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 23, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser_command_controller_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -255,28 +255,8 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   chrome::ToggleFullscreenMode(browser());\n   ASSERT_TRUE(browser()->window()->IsFullscreen());\n   browser()->command_controller()->FullscreenStateChanged();\n-#if defined(OS_MACOS)\n-  // Mac leaves things enabled in fullscreen.\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n-  EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_LOCATION));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_SEARCH));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_MENU_BAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_NEXT_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_PREVIOUS_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_BOOKMARKS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_DEVELOPER_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FEEDBACK));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPTIONS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_IMPORT_SETTINGS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_EDIT_SEARCH_ENGINES));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_VIEW_PASSWORDS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#else\n-  // Windows and GTK disable most commands in fullscreen.\n+\n+  // Most commands are disabled in fullscreen.\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n@@ -295,7 +275,6 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n   EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#endif  // defined(OS_MACOS)\n \n   // Exit fullscreen.\n   chrome::ToggleFullscreenMode(browser());""}","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",C,"#if defined(OS_MACOSX)
","#if defined(OS_MAC)
",,"@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {
       check_path_exists = false;
   }
 #endif
-#if defined(OS_MAC)
+#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())",Chrome,0d7717faeaef5b72434632c95c78bee4883e2573,49d66d27f59c7f8e6f170a2cf313822f49e4e3b0,1,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  // Some paths might not exist on some platforms in which case confirming
  // |result| is true and !path.empty() is the best we can do.
  bool check_path_exists = true;
#if defined(OS_POSIX)
  // If chromium has never been started on this account, the cache path may not
  // exist.
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  // On the linux try-bots: a path is returned (e.g. /home/chrome-bot/Desktop),
  // but it doesn't exist.
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    // On Windows XP, the Quick Launch folder for the ""Default User"" doesn't
    // exist by default. At least confirm that the path returned begins with the
    // Default User's profile path.
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    // There is no pinned-to-taskbar shortcuts prior to Win7.
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
//flaw_line_below:
#if defined(OS_MAC)
//fix_flaw_line_below:
//#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",185242,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","The vulnerability in the original code lies in the handling of directory types, particularly for macOS, where the preprocessor directive `#if defined(OS_MAC)` was used instead of `#if defined(OS_MACOSX)`. This could lead to incorrect path validation for macOS, potentially allowing unauthorized access to parent directories via `path.ReferencesParent()`. The fix was implemented by changing the directive to `#if defined(OS_MACOSX)`, ensuring that the correct conditions are checked for macOS, thus preventing the function from erroneously validating paths that reference parent directories and enhancing overall security.","The vulnerability in the original code stemmed from an incorrect preprocessor directive that failed to properly handle directory types specific to macOS, potentially allowing unauthorized access to sensitive paths. This oversight could lead to security risks by permitting the validation of paths that reference parent directories, which should be restricted. The fix involved updating the preprocessor directive to accurately reflect the macOS environment, ensuring that the code correctly checks for the intended conditions. This change effectively mitigated the risk by preventing the validation of potentially unsafe paths, thereby enhancing the overall security of the function.",3,5,3,4,"CWE-22, CWE-426, CWE-1239, CWE-99, CWE-41, CWE-73, CWE-35, CWE-36, CWE-650, CWE-23",N,-1
70,70,70,185375,185375,,Remote,Not required,Partial,CVE-2014-3160,https://www.cvedetails.com/cve/CVE-2014-3160/,CWE-264,Medium,Partial,Partial,,2014-07-20,6.8,"The ResourceFetcher::canRequest function in core/fetch/ResourceFetcher.cpp in Blink, as used in Google Chrome before 36.0.1985.125, does not properly restrict subresource requests associated with SVG files, which allows remote attackers to bypass the Same Origin Policy via a crafted file.",2017-01-06,Bypass ,7,https://github.com/chromium/chromium/commit/ee281f7cac9df44fe241a37f188b28be8845ded0,ee281f7cac9df44fe241a37f188b28be8845ded0,"Enforce SVG image security rules

SVG images have unique security rules that prevent them from loading
any external resources. This patch enforces these rules in
ResourceFetcher::canRequest for all non-data-uri resources. This locks
down our SVG resource handling and fixes two security bugs.

In the case of SVG images that reference other images, we had a bug
where a cached subresource would be used directly from the cache.
This has been fixed because the canRequest check occurs before we use
cached resources.

In the case of SVG images that use CSS imports, we had a bug where
imports were blindly requested. This has been fixed by stopping all
non-data-uri requests in SVG images.

With this patch we now match Gecko's behavior on both testcases.

BUG=380885, 382296

Review URL: https://codereview.chromium.org/320763002

git-svn-id: svn://svn.chromium.org/blink/trunk@176084 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp,"{""sha"": ""447f133110eb629a1d8572dc9c3005dba7697deb"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,3 @@\n+rect {\n+    fill: red;\n+}\n\\ No newline at end of file""}<_**next**_>{""sha"": ""2b23c4527dedc04e28e1fa5189005c5e2901efe3"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <style>\n+        @import url(http://localhost:8000/security/resources/css-import.css);\n+    </style>\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""green\""/>\n+</svg>""}<_**next**_>{""sha"": ""fb20e4cb86d84079925c31dc5db87d401231b1c0"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,4 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>""}<_**next**_>{""sha"": ""73a75e35fd9d98a5c3235e84d9d1dfaddcfe58b9"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -1,6 +1,5 @@\n-<svg xmlns=\""http://www.w3.org/2000/svg\""\n-     xmlns:xlink=\""http://www.w3.org/1999/xlink\""\n-     width=\""100\"" height=\""100\"">\n-    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\""\n-           width=\""100\"" height=\""100\""/>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n </svg>""}<_**next**_>{""sha"": ""480e114a4a66420372b26e21bf21799ecc527306"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n+</svg>\n+\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""b926b53dd3e9948965e23b6a8dbffcab49f9c2bd"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,27 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<object id=\""precache\"" data=\""resources/image-wrapper.svg\"" width=\""100\"" height=\""100\""></object>\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<img id=\""image\"" src=\""\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('precache').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        var image = document.getElementById('image');\n+        image.onload = function() {\n+            // FIXME: crbug.com/382170 SVG onload event bug.\n+            setTimeout(function() {\n+                if (window.testRunner)\n+                    testRunner.notifyDone();\n+            }, 20);\n+        }\n+        image.src = \""resources/image-wrapper.svg\"";\n+    }, 20);\n+}\n+\n+</script>""}<_**next**_>{""sha"": ""2cca3b4cae0eea0f586f1862cc50b21ee80a39ae"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100\"" height=\""100\"" fill=\""green\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""7c61abbb8315871f6dc444916b0f035dd713667c"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<img id=\""image\"" src=\""resources/image-with-css-import.svg\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('image').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        if (window.testRunner)\n+            testRunner.notifyDone();\n+    }, 30);\n+}\n+</script>""}<_**next**_>{""sha"": ""a8dac743c0eeeba9102288a453e2df94595fb999"", ""filename"": ""third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -59,6 +59,7 @@\n #include \""core/timing/Performance.h\""\n #include \""core/timing/ResourceTimingInfo.h\""\n #include \""core/frame/Settings.h\""\n+#include \""core/svg/graphics/SVGImageChromeClient.h\""\n #include \""platform/Logging.h\""\n #include \""platform/TraceEvent.h\""\n #include \""platform/weborigin/SecurityOrigin.h\""\n@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res\n         break;\n     }\n \n+    // SVG Images have unique security rules that prevent all subresource requests\n+    // except for data urls.\n+    if (type != Resource::MainResource) {\n+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())\n+            return false;\n+    }\n+\n     // Last of all, check for insecure content. We do this last so that when\n     // folks block insecure content with a CSP policy, they don't get a warning.\n     // They'll still get a warning in the console about CSP blocking the load.""}","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",C,"    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }

",,,"@@ -59,6 +59,7 @@
 #include ""core/timing/Performance.h""
 #include ""core/timing/ResourceTimingInfo.h""
 #include ""core/frame/Settings.h""
+#include ""core/svg/graphics/SVGImageChromeClient.h""
 #include ""platform/Logging.h""
 #include ""platform/TraceEvent.h""
 #include ""platform/weborigin/SecurityOrigin.h""
@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res
         break;
     }
 
+    // SVG Images have unique security rules that prevent all subresource requests
+    // except for data urls.
+    if (type != Resource::MainResource) {
+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
+            return false;
+    }
+
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.",Chrome,ee281f7cac9df44fe241a37f188b28be8845ded0,41df074d67ea3069264890bd8fe5b65403083a17,1,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    // FIXME: Convert this to check the isolated world's Content Security Policy once webkit.org/b/104520 is solved.
    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    // Some types of resources can be loaded only from the same origin. Other
    // types of resources, like Images, Scripts, and CSS, can be loaded from
    // any URL.
    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        // By default these types of resources can be loaded from any origin.
        // FIXME: Are we sure about Resource::Font?
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    // Don't send CSP messages for preloads, we might never actually display those items.
    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
//fix_flaw_line_below:
//    // SVG Images have unique security rules that prevent all subresource requests
//fix_flaw_line_below:
//    // except for data urls.
//fix_flaw_line_below:
//    if (type != Resource::MainResource) {
//fix_flaw_line_below:
//        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
//fix_flaw_line_below:
//            return false;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.

    // FIXME: Should we consider forPreload here?
    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",185375,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","The vulnerability in the original code lies in the handling of SVG images, where it did not enforce strict security rules for subresource requests, potentially allowing unauthorized access to resources. Specifically, the code failed to check if the request was for an SVG image and whether the URL was a data URL, which could lead to security breaches. The fix introduced a new condition that checks if the resource type is not `Resource::MainResource` and if the frame is an SVG image client, ensuring that only data URLs are permitted. This effectively restricts unauthorized subresource requests, enhancing security.","The vulnerability in the original code stemmed from inadequate security checks for SVG images, allowing unauthorized subresource requests that could compromise security. Specifically, it did not restrict requests to only data URLs, which could lead to potential exploitation. The fix implemented a new condition that ensures requests for SVG images are only allowed if they are data URLs, thereby enforcing stricter security rules. This change effectively mitigates the risk of unauthorized access to resources, ensuring that only safe and intended requests are processed, thus enhancing the overall security of the resource fetching mechanism.",4,5,4,3,"CWE-287,CWE-284,CWE-732,CWE-285,CWE-346,CWE-601,CWE-610,CWE-434,CWE-436,CWE-79",N,-1
71,71,71,185623,185623,,Remote,Not required,Partial,CVE-2015-6768,https://www.cvedetails.com/cve/CVE-2015-6768/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy via unspecified vectors, a different vulnerability than CVE-2015-6770.",2017-09-13,Bypass ,1,https://github.com/chromium/chromium/commit/4c8b008f055f79e622344627fed7f820375a4f01,4c8b008f055f79e622344627fed7f820375a4f01,"Change Document::detach() to RELEASE_ASSERT all subframes are gone.

BUG=556724,577105

Review URL: https://codereview.chromium.org/1667573002

Cr-Commit-Position: refs/heads/master@{#373642}",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""112c8cd99e3f5587281d9fe297c61e280725fcbd"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=4c8b008f055f79e622344627fed7f820375a4f01"", ""patch"": ""@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)\n void Document::detach(const AttachContext& context)\n {\n     TRACE_EVENT0(\""blink\"", \""Document::detach\"");\n-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n     if (!isActive())\n         return;\n ""}"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",C,"    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
","    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
",,"@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)
 void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 ",Chrome,4c8b008f055f79e622344627fed7f820375a4f01,6bc4255ecd25658b430cec1f6191e0044c5e6c7f,1," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
//flaw_line_below:
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
//fix_flaw_line_below:
//    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    // Frame navigation can cause a new Document to be attached. Don't allow that, since that will
    // cause a situation where LocalFrame still has a Document attached after this finishes!
    // Normally, it shouldn't actually be possible to trigger navigation here. However, plugins
    // (see below) can cause lots of crazy things to happen, since plugin detach involves nested
    // message loops.
    FrameNavigationDisabler navigationDisabler(*m_frame);
    // Defer widget updates to avoid plugins trying to run script inside ScriptForbiddenScope,
    // which will crash the renderer after https://crrev.com/200984
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    // Don't allow script to run in the middle of detach() because a detaching Document is not in a
    // consistent state.
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    // FIXME: consider using ActiveDOMObject.
    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    // FIXME: This shouldn't be needed once LocalDOMWindow becomes ExecutionContext.
    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            // Documents that are not a root document use the AXObjectCache in
            // their root document. Node::removedFrom is called after the
            // document has been detached so it can't find the root document.
            // We do the removals here instead.
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    // If this Document is associated with a live DocumentLoader, the
    // DocumentLoader will take care of clearing the FetchContext. Deferring
    // to the DocumentLoader when possible also prevents prematurely clearing
    // the context in the case where multiple Documents end up associated with
    // a single DocumentLoader (e.g., navigating to a javascript: url).
    if (!loader())
        m_fetcher->clearContext();
    // If this document is the master for an HTMLImportsController, sever that
    // relationship. This ensures that we don't leave import loads in flight,
    // thinking they should have access to a valid frame when they don't.
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    // This is required, as our LocalFrame might delete itself as soon as it detaches
    // us. However, this violates Node::detach() semantics, as it's never
    // possible to re-attach. Eventually Document::detach() should be renamed,
    // or this setting of the frame to 0 could be made explicit in each of the
    // callers of Document::detach().
    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    // FIXME: Currently we call notifyContextDestroyed() only in
    // Document::detach(), which means that we don't call
    // notifyContextDestroyed() for a document that doesn't get detached.
    // If such a document has any observer, the observer won't get
    // a contextDestroyed() notification. This can happen for a document
    // created by DOMImplementation::createDocument().
    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",185623," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
","The vulnerability in the original code lies in the use of `ASSERT` to check the condition `!m_frame || m_frame->tree().childCount() == 0`, which only triggers in debug builds and does not prevent execution in release builds. This could lead to undefined behavior if `detach` is called when `m_frame` is not null and has child nodes, potentially causing memory corruption or crashes. The fix replaces `ASSERT` with `RELEASE_ASSERT`, ensuring that the condition is enforced in both debug and release builds, thus preventing the function from executing under unsafe conditions.","The vulnerability in the original code stems from the use of an assertion that only activates in debug builds, allowing the function to execute in release builds even when certain preconditions are not met. This could lead to undefined behavior, such as memory corruption or crashes, if the function is called under unsafe conditions. The fix replaces the assertion with a more robust check that is enforced in both debug and release builds, ensuring that the function does not proceed unless the necessary conditions are satisfied, thereby enhancing the overall stability and safety of the code.",4,5,1,0,"CWE-617,CWE-573,CWE-670,CWE-754,CWE-476,CWE-628,CWE-703,CWE-758,CWE-188,CWE-684",N,-1
72,72,72,185628,185628,,Remote,Not required,Partial,CVE-2015-6772,https://www.cvedetails.com/cve/CVE-2015-6772/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Blink, as used in Google Chrome before 47.0.2526.73, does not prevent javascript: URL navigation while a document is being detached, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that improperly interacts with a plugin.",2017-09-13,Bypass ,2,https://github.com/chromium/chromium/commit/0b1b7baa4695c945a1b0bea1f0636f1219139e8e,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,"Open Offline Pages in CCT from Downloads Home.

When the respective feature flag is enabled, offline pages opened from
the Downloads Home will use CCT instead of normal tabs.

Bug: 824807
Change-Id: I6d968b8b0c51aaeb7f26332c7ada9f927e151a65
Reviewed-on: https://chromium-review.googlesource.com/977321
Commit-Queue: Carlos Knippschild <carlosk@chromium.org>
Reviewed-by: Ted Choc <tedchoc@chromium.org>
Reviewed-by: Bernhard Bauer <bauerb@chromium.org>
Reviewed-by: Jian Li <jianli@chromium.org>
Cr-Commit-Position: refs/heads/master@{#546545}",1,chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc,"{""sha"": ""7376c8909786382981dc04215c9e9a8fd4de5c86"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 13, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -6,18 +6,30 @@\n \n import android.app.Activity;\n import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.net.Uri;\n+import android.os.Bundle;\n+import android.provider.Browser;\n+import android.support.customtabs.CustomTabsIntent;\n \n import org.chromium.base.ApplicationStatus;\n+import org.chromium.base.ContextUtils;\n import org.chromium.base.annotations.CalledByNative;\n import org.chromium.base.annotations.JNINamespace;\n import org.chromium.chrome.browser.ChromeTabbedActivity;\n+import org.chromium.chrome.browser.IntentHandler;\n+import org.chromium.chrome.browser.LaunchIntentDispatcher;\n import org.chromium.chrome.browser.offlinepages.OfflinePageOrigin;\n import org.chromium.chrome.browser.offlinepages.OfflinePageUtils;\n import org.chromium.chrome.browser.profiles.Profile;\n import org.chromium.chrome.browser.tab.Tab;\n import org.chromium.chrome.browser.tabmodel.TabModel.TabLaunchType;\n import org.chromium.chrome.browser.tabmodel.document.AsyncTabCreationParams;\n import org.chromium.chrome.browser.tabmodel.document.TabDelegate;\n+import org.chromium.content_public.browser.LoadUrlParams;\n+\n+import java.util.Map;\n \n /**\n  * Serves as an interface between Download Home UI and offline page related items that are to be\n@@ -28,7 +40,6 @@\n     private static OfflinePageDownloadBridge sInstance;\n     private static boolean sIsTesting;\n     private long mNativeOfflinePageDownloadBridge;\n-    private boolean mIsLoaded;\n \n     /**\n      * @return An {@link OfflinePageDownloadBridge} instance singleton.  If one\n@@ -54,29 +65,73 @@ public void destroy() {\n         if (mNativeOfflinePageDownloadBridge != 0) {\n             nativeDestroy(mNativeOfflinePageDownloadBridge);\n             mNativeOfflinePageDownloadBridge = 0;\n-            mIsLoaded = false;\n         }\n     }\n \n     /**\n-     * 'Opens' the offline page identified by the given URL and offlineId.\n-     * This is done by creating a new tab and navigating it to the saved local snapshot.\n-     * No automatic redirection is happening based on the connection status.\n-     * If the item with specified GUID is not found or can't be opened, nothing happens.\n+     * 'Opens' the offline page identified by the given URL and offlineId by navigating to the saved\n+     * local snapshot. No automatic redirection is happening based on the connection status. If the\n+     * item with specified GUID is not found or can't be opened, nothing happens.\n      */\n     @CalledByNative\n-    private static void openItem(String url, long offlineId) {\n+    private static void openItem(final String url, final long offlineId, final boolean openInCct) {\n         OfflinePageUtils.getLoadUrlParamsForOpeningOfflineVersion(url, offlineId, (params) -> {\n             if (params == null) return;\n-            ComponentName componentName = getComponentName();\n-            AsyncTabCreationParams asyncParams = componentName == null\n-                    ? new AsyncTabCreationParams(params)\n-                    : new AsyncTabCreationParams(params, componentName);\n-            final TabDelegate tabDelegate = new TabDelegate(false);\n-            tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+            if (openInCct) {\n+                openItemInCct(offlineId, params);\n+            } else {\n+                openItemInNewTab(offlineId, params);\n+            }\n         });\n     }\n \n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a new tab.\n+     */\n+    private static void openItemInNewTab(long offlineId, LoadUrlParams params) {\n+        ComponentName componentName = getComponentName();\n+        AsyncTabCreationParams asyncParams = componentName == null\n+                ? new AsyncTabCreationParams(params)\n+                : new AsyncTabCreationParams(params, componentName);\n+        final TabDelegate tabDelegate = new TabDelegate(false);\n+        tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+    }\n+\n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a CCT.\n+     */\n+    private static void openItemInCct(long offlineId, LoadUrlParams params) {\n+        final Context context;\n+        if (ApplicationStatus.hasVisibleActivities()) {\n+            context = ApplicationStatus.getLastTrackedFocusedActivity();\n+        } else {\n+            context = ContextUtils.getApplicationContext();\n+        }\n+\n+        CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();\n+        builder.setShowTitle(true);\n+        builder.addDefaultShareMenuItem();\n+\n+        CustomTabsIntent customTabIntent = builder.build();\n+        customTabIntent.intent.setData(Uri.parse(params.getUrl()));\n+\n+        Intent intent = LaunchIntentDispatcher.createCustomTabActivityIntent(\n+                context, customTabIntent.intent);\n+        intent.setPackage(context.getPackageName());\n+        intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());\n+\n+        IntentHandler.addTrustedIntentExtras(intent);\n+        if (!(context instanceof Activity)) intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n+\n+        Bundle bundle = new Bundle();\n+        for (Map.Entry<String, String> entry : params.getExtraHeaders().entrySet()) {\n+            bundle.putString(entry.getKey(), entry.getValue());\n+        }\n+        intent.putExtra(Browser.EXTRA_HEADERS, bundle);\n+\n+        context.startActivity(intent);\n+    }\n+\n     /**\n      * Starts download of the page currently open in the specified Tab.\n      * If tab's contents are not yet loaded completely, we'll wait for it""}<_**next**_>{""sha"": ""3f9788b4276be03dea3ec489544bcc80bebfb2b0"", ""filename"": ""chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,\n+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());\n }\n \n // TODO(dewittj): Move to Download UI Adapter.""}","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
",C,"      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
","      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
",,"@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
 
 // TODO(dewittj): Move to Download UI Adapter.",Chrome,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,2f40b7e4357adc7fe930a1e69d7c26347a4da9d4,1,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
//flaw_line_below:
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
//fix_flaw_line_below:
//      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
//fix_flaw_line_below:
//      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
",185628,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","The vulnerability in the original code lies in the lack of control over how offline pages are opened, potentially leading to unintended behavior or security issues when invoking `Java_OfflinePageDownloadBridge_openItem`. The function did not account for user preferences or context, which could result in a poor user experience or expose sensitive data. The fixed code addresses this by adding an additional parameter, `offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()`, which likely checks user settings or conditions before opening the item, thereby enhancing security and ensuring that the behavior aligns with user expectations.","The vulnerability in the original code stems from the lack of user context or preferences when opening offline items, which could lead to unintended behavior or security risks, such as exposing sensitive information or providing a poor user experience. The fixed code addresses this issue by introducing an additional parameter that likely checks user settings or conditions before proceeding with the action. This enhancement ensures that the behavior of opening offline items is more aligned with user expectations and preferences, thereby improving both security and usability in the application.",4,5,1,3,"CWE-287, CWE-284, CWE-269, CWE-522, CWE-200, CWE-732, CWE-285, CWE-266, CWE-250, CWE-359",N,-1
73,73,73,185666,185666,,Remote,Not required,,CVE-2015-6786,https://www.cvedetails.com/cve/CVE-2015-6786/,CWE-264,Medium,,Partial,,2015-12-05,4.3,"The CSPSourceList::matches function in WebKit/Source/core/frame/csp/CSPSourceList.cpp in the Content Security Policy (CSP) implementation in Google Chrome before 47.0.2526.73 accepts a blob:, data:, or filesystem: URL as a match for a * pattern, which allows remote attackers to bypass intended scheme restrictions in opportunistic circumstances by leveraging a policy that relies on this pattern.",2017-09-13,Bypass ,10,https://github.com/chromium/chromium/commit/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,"Disallow CSP source * matching of data:, blob:, and filesystem: URLs

The CSP spec specifically excludes matching of data:, blob:, and
filesystem: URLs with the source '*' wildcard. This adds checks to make
sure that doesn't happen, along with tests.

BUG=534570
R=mkwst@chromium.org

Review URL: https://codereview.chromium.org/1361763005

Cr-Commit-Position: refs/heads/master@{#350950}",6,third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp,"{""sha"": ""04d7709facd4a533ebbc5a285bda64d95f90f5a3"", ""filename"": ""chrome/common/extensions/docs/templates/articles/app_csp.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/app_csp.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -51,12 +51,12 @@ <h2 id=\""what\"">What is the CSP for Chrome Apps?</h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' data: chrome-extension-resource: 'unsafe-inline';\n img-src 'self' data: chrome-extension-resource:;\n frame-src 'self' data: chrome-extension-resource:;\n font-src 'self' data: chrome-extension-resource:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <p>""}<_**next**_>{""sha"": ""e999f552168a0f8bf82aaa4254e03fa4d88e9788"", ""filename"": ""chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/offline_apps.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -135,12 +135,12 @@ <h2 id=\""possibilities\""> Security restrictions </h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' blob: data: filesystem: 'unsafe-inline';\n img-src 'self' blob: data: filesystem:;\n frame-src 'self' blob: data: filesystem:;\n font-src 'self' blob: data: filesystem:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <h2 id=\""manifest\""> Specifying offline_enabled </h2>""}<_**next**_>{""sha"": ""de9843014321c9dadb4a16669eb2d0c36cb9929c"", ""filename"": ""extensions/common/manifest_handlers/csp_info.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/manifest_handlers/csp_info.cc?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -34,7 +34,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     // Platform apps can only use local resources by default.\n     \""default-src 'self' blob: filesystem: chrome-extension-resource:;\""\n     // For remote resources, they can fetch them via XMLHttpRequest.\n-    \"" connect-src *;\""\n+    \"" connect-src * data: blob: filesystem:;\""\n     // And serve them via data: or same-origin (blob:, filesystem:) URLs\n     \"" style-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"" 'unsafe-inline';\""\n     \"" img-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"";\""\n@@ -45,7 +45,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     //    spotty connectivity.\n     // 2. Fetching via XHR and serving via blob: URLs currently does not allow\n     //    streaming or partial buffering.\n-    \"" media-src *;\"";\n+    \"" media-src * data: blob: filesystem:;\"";\n \n int GetValidatorOptions(Extension* extension) {\n   int options = csp_validator::OPTIONS_NONE;""}<_**next**_>{""sha"": ""6c0916c1fed2dbaf5abdca20cab530114b9cad3b"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""status"": ""added"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -0,0 +1,61 @@\n+<!DOCTYPE html>\n+<html>\n+    <head>\n+    <title>script-src disallowed wildcard use</title>\n+    <script src=\""../../../resources/testharness.js\""></script>\n+    <script src=\""../../../resources/testharnessreport.js\""></script>\n+    <meta http-equiv=\""Content-Security-Policy\"" content=\""script-src 'nonce-nonce' *\"">\n+    </head>\n+    <body>\n+    <script nonce=\""nonce\"">\n+        var t1 = async_test('data: URIs should not match *');\n+        t1.step(function() {\n+            var script = document.createElement(\""script\"");\n+            script.src = 'data:application/javascript,';\n+            script.addEventListener('load', t1.step_func(function() {\n+                assert_unreached('Should not successfully load data URI.');\n+            }));\n+            script.addEventListener('error', t1.step_func(function() {\n+                t1.done();\n+            }));\n+            document.head.appendChild(script);\n+        });\n+\n+        var t2 = async_test('blob: URIs should not match *');\n+        t2.step(function() {\n+            var b = new Blob([''], { type: 'application/javascript' });\n+            var script = document.createElement('script');\n+            script.addEventListener('load', t2.step_func(function() {\n+                assert_unreached('Should not successfully load blob URI.');\n+            }));\n+            script.addEventListener('error', t2.step_func(function() {\n+                t2.done();\n+            }));\n+\n+            script.src = URL.createObjectURL(b);\n+            document.head.appendChild(script);\n+        });\n+\n+        if (window.webkitRequestFileSystem) {\n+            var t3 = async_test('filesystem URIs should not match *');\n+            window.webkitRequestFileSystem(TEMPORARY, 1024*1024 /*1MB*/, function(fs) {\n+                fs.root.getFile('fail.js', {create: true}, function(fileEntry) {\n+                    fileEntry.createWriter(function(fileWriter) {\n+                        var script = document.createElement('script');\n+\n+                        script.addEventListener('load', t3.step_func(function() {\n+                            assert_unreached('Should not successfully load filesystem URI.');\n+                        }));\n+                        script.addEventListener('error', t3.step_func(function() {\n+                            t3.done();\n+                        }));\n+\n+                        script.src = fileEntry.toURL('application/javascript');\n+                        document.body.appendChild(script);\n+                    });\n+                });\n+            });\n+        }\n+    </script>\n+    </body>\n+</html>""}<_**next**_>{""sha"": ""1191abce7fe4c98eaeefc3dd95e90342aa113ade"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 7, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct\n \n bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n-    if (m_allowStar)\n+    // The CSP spec specifically states that data:, blob:, and filesystem URLs\n+    // should not be captured by a '*\"" source\n+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the\n+    // case of a full wildcard, data:, blob:, and filesystem: URLs are\n+    // explicitly checked for in the source list before allowing them through.\n+    if (m_allowStar) {\n+        if (url.protocolIs(\""blob\"") || url.protocolIs(\""data\"") || url.protocolIs(\""filesystem\""))\n+            return hasSourceMatchInList(url, redirectStatus);\n         return true;\n+    }\n \n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n \n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n \n-    for (size_t i = 0; i < m_list.size(); ++i) {\n-        if (m_list[i].matches(effectiveURL, redirectStatus))\n-            return true;\n-    }\n-\n-    return false;\n+    return hasSourceMatchInList(effectiveURL, redirectStatus);\n }\n \n bool CSPSourceList::allowInline() const\n@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo\n     m_hashAlgorithmsUsed |= algorithm;\n }\n \n+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n+{\n+    for (size_t i = 0; i < m_list.size(); ++i) {\n+        if (m_list[i].matches(url, redirectStatus))\n+            return true;\n+    }\n+\n+    return false;\n+}\n \n } // namespace blink""}<_**next**_>{""sha"": ""fceb8158a1b7c8c9471676d479833eb499d3f012"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -50,6 +50,8 @@ class CORE_EXPORT CSPSourceList {\n     void addSourceNonce(const String& nonce);\n     void addSourceHash(const ContentSecurityPolicyHashAlgorithm&, const DigestValue& hash);\n \n+    bool hasSourceMatchInList(const KURL&, ContentSecurityPolicy::RedirectStatus) const;\n+\n     ContentSecurityPolicy* m_policy;\n     Vector<CSPSource> m_list;\n     String m_directiveName;""}<_**next**_>{""sha"": ""106e8e72f16939961020c1bffd149182cce45d3b"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -54,6 +54,24 @@ TEST_F(CSPSourceListTest, BasicMatchingNone)\n     EXPECT_FALSE(sourceList.matches(KURL(base, \""https://example.test/\"")));\n }\n \n+TEST_F(CSPSourceListTest, BasicMatchingStar)\n+{\n+    KURL base;\n+    String sources = \""*\"";\n+    CSPSourceList sourceList(csp.get(), \""script-src\"");\n+    parseSourceList(sourceList, sources);\n+\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""https://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/bar\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/bar\"")));\n+\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""data:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""blob:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""filesystem:https://example.test/\"")));\n+}\n+\n TEST_F(CSPSourceListTest, BasicMatchingSelf)\n {\n     KURL base;""}"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
",C,"    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
    }
    return hasSourceMatchInList(effectiveURL, redirectStatus);
","    if (m_allowStar)
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
",,"@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct
 
 bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
-    if (m_allowStar)
+    // The CSP spec specifically states that data:, blob:, and filesystem URLs
+    // should not be captured by a '*"" source
+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
+    // case of a full wildcard, data:, blob:, and filesystem: URLs are
+    // explicitly checked for in the source list before allowing them through.
+    if (m_allowStar) {
+        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
+            return hasSourceMatchInList(url, redirectStatus);
         return true;
+    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
-    for (size_t i = 0; i < m_list.size(); ++i) {
-        if (m_list[i].matches(effectiveURL, redirectStatus))
-            return true;
-    }
-
-    return false;
+    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
 
 bool CSPSourceList::allowInline() const
@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo
     m_hashAlgorithmsUsed |= algorithm;
 }
 
+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
+{
+    for (size_t i = 0; i < m_list.size(); ++i) {
+        if (m_list[i].matches(url, redirectStatus))
+            return true;
+    }
+
+    return false;
+}
 
 } // namespace blink",Chrome,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,4b86b23ef2edc67efd12a111ad4ddf83ca53329c,1," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
//flaw_line_below:
    if (m_allowStar)
//fix_flaw_line_below:
//    // The CSP spec specifically states that data:, blob:, and filesystem URLs
//fix_flaw_line_below:
//    // should not be captured by a '*"" source
//fix_flaw_line_below:
//    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
//fix_flaw_line_below:
//    // case of a full wildcard, data:, blob:, and filesystem: URLs are
//fix_flaw_line_below:
//    // explicitly checked for in the source list before allowing them through.
//fix_flaw_line_below:
//    if (m_allowStar) {
//fix_flaw_line_below:
//        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
//fix_flaw_line_below:
//            return hasSourceMatchInList(url, redirectStatus);
         return true;
//fix_flaw_line_below:
//    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
//flaw_line_below:
    for (size_t i = 0; i < m_list.size(); ++i) {
//flaw_line_below:
        if (m_list[i].matches(effectiveURL, redirectStatus))
//flaw_line_below:
            return true;
//flaw_line_below:
    }
//flaw_line_below:

//flaw_line_below:
    return false;
//fix_flaw_line_below:
//    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
",185666," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
","The vulnerability in the original code lies in the unconditional acceptance of all URLs when `m_allowStar` is true, which could allow potentially harmful `data:`, `blob:`, and `filesystem:` URLs to bypass security checks. This is problematic as it contradicts the Content Security Policy (CSP) specifications. The fixed code addresses this vulnerability by adding a conditional check for these specific protocols. If `m_allowStar` is true and the URL matches any of these protocols, it calls `hasSourceMatchInList(url, redirectStatus)` to ensure that these URLs are properly validated against the source list before allowing access, thus enhancing security.","The vulnerability in the original code stems from the unrestricted acceptance of all URLs when a wildcard is allowed, which could lead to the execution of potentially harmful content from `data:`, `blob:`, and `filesystem:` sources. This oversight violates security guidelines, as it permits unsafe URLs to bypass necessary checks. The revised code mitigates this risk by introducing specific checks for these protocols when a wildcard is enabled. By ensuring that these URLs are validated against a predefined source list before granting access, the updated implementation adheres to security standards and protects against potential exploitation.",3,3,4,1,"CWE-346,CWE-434,CWE-611,CWE-159,CWE-284,CWE-749,CWE-345,CWE-646,CWE-183,CWE-913",N,-1
74,74,74,186091,186091,,Remote,Not required,Partial,CVE-2016-1631,https://www.cvedetails.com/cve/CVE-2016-1631/,CWE-264,Medium,Partial,Partial,,2016-03-05,6.8,"The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",2016-12-02,Bypass ,4,https://github.com/chromium/chromium/commit/dd77c2a41c72589d929db0592565125ca629fb2c,dd77c2a41c72589d929db0592565125ca629fb2c,"Fix PPB_Flash_MessageLoop.

This CL suspends script callbacks and resource loads while running nested message loop using PPB_Flash_MessageLoop.

BUG=569496

Review URL: https://codereview.chromium.org/1559113002

Cr-Commit-Position: refs/heads/master@{#374529}",0,content/renderer/pepper/ppb_flash_message_loop_impl.cc,"{""sha"": ""279bfc99449026df2d8c842a91b95a674a451c07"", ""filename"": ""chrome/test/ppapi/ppapi_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/ppapi/ppapi_browsertest.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -1105,6 +1105,7 @@ IN_PROC_BROWSER_TEST_F(PPAPINaClPNaClNonSfiTest, MAYBE_PNACL_NONSFI(View)) {\n   RunTest( \\\n       LIST_TEST(FlashMessageLoop_Basics) \\\n       LIST_TEST(FlashMessageLoop_RunWithoutQuit) \\\n+      LIST_TEST(FlashMessageLoop_SuspendScriptCallbackWhileRunning) \\\n   )\n \n #if defined(OS_LINUX)  // Disabled due to flakiness http://crbug.com/316925""}<_**next**_>{""sha"": ""89ac5adde7a0e7de7fc17cdfa3527311a31cee90"", ""filename"": ""content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/pepper/ppb_flash_message_loop_impl.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -7,6 +7,7 @@\n #include \""base/callback.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""ppapi/c/pp_errors.h\""\n+#include \""third_party/WebKit/public/web/WebView.h\""\n \n using ppapi::thunk::PPB_Flash_MessageLoop_API;\n \n@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n+    blink::WebView::willEnterModalLoop();\n+\n     base::MessageLoop::current()->Run();\n+\n+    blink::WebView::didExitModalLoop();\n   }\n   // Don't access data members of the class below.\n ""}<_**next**_>{""sha"": ""2043cbeb11c6b01f8662ccf28702a9006268f3f9"", ""filename"": ""ppapi/tests/test_flash_message_loop.cc"", ""status"": ""modified"", ""additions"": 111, ""deletions"": 6, ""changes"": 117, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -5,27 +5,97 @@\n #include \""ppapi/tests/test_flash_message_loop.h\""\n \n #include \""ppapi/c/pp_macros.h\""\n+#include \""ppapi/c/ppb_var.h\""\n #include \""ppapi/cpp/core.h\""\n+#include \""ppapi/cpp/dev/scriptable_object_deprecated.h\""\n #include \""ppapi/cpp/logging.h\""\n #include \""ppapi/cpp/module.h\""\n #include \""ppapi/cpp/private/flash_message_loop.h\""\n #include \""ppapi/tests/testing_instance.h\""\n \n+namespace {\n+\n+const char kDidRunScriptCallback[] = \""DidRunScriptCallback\"";\n+\n+}  // namespace\n+\n+class TestFlashMessageLoop::InstanceSO\n+    : public pp::deprecated::ScriptableObject {\n+ public:\n+  explicit InstanceSO(TestFlashMessageLoop* owner) : owner_(owner) {}\n+\n+  ~InstanceSO() override {\n+    if (owner_)\n+      owner_->clear_instance_so();\n+  }\n+\n+  // pp::deprecated::ScriptableObject overrides.\n+  bool HasMethod(const pp::Var& name, pp::Var* exception) override {\n+    if (!name.is_string())\n+      return false;\n+    return name.AsString() == kDidRunScriptCallback;\n+  }\n+\n+  pp::Var Call(const pp::Var& method_name,\n+               const std::vector<pp::Var>& args,\n+               pp::Var* exception) override {\n+    if (!method_name.is_string())\n+      return false;\n+    std::string name = method_name.AsString();\n+\n+    if (name == kDidRunScriptCallback) {\n+      if (args.size() != 0) {\n+        *exception = pp::Var(\""Bad argument to DidRunScriptCallback()\"");\n+      } else if (owner_) {\n+        owner_->DidRunScriptCallback();\n+      }\n+    } else {\n+      *exception = pp::Var(\""Bad function call\"");\n+    }\n+\n+    return pp::Var();\n+  }\n+\n+  void clear_owner() { owner_ = nullptr; }\n+\n+ private:\n+  TestFlashMessageLoop* owner_;\n+};\n+\n REGISTER_TEST_CASE(FlashMessageLoop);\n \n TestFlashMessageLoop::TestFlashMessageLoop(TestingInstance* instance)\n     : TestCase(instance),\n-      message_loop_(NULL),\n-      callback_factory_(this) {\n-}\n+      message_loop_(nullptr),\n+      instance_so_(nullptr),\n+      suspend_script_callback_result_(false),\n+      callback_factory_(this) {}\n \n TestFlashMessageLoop::~TestFlashMessageLoop() {\n   PP_DCHECK(!message_loop_);\n+\n+  ResetTestObject();\n+  if (instance_so_)\n+    instance_so_->clear_owner();\n }\n \n void TestFlashMessageLoop::RunTests(const std::string& filter) {\n   RUN_TEST(Basics, filter);\n   RUN_TEST(RunWithoutQuit, filter);\n+  RUN_TEST(SuspendScriptCallbackWhileRunning, filter);\n+}\n+\n+void TestFlashMessageLoop::DidRunScriptCallback() {\n+  // Script callbacks are not supposed to run while the Flash message loop is\n+  // running.\n+  if (message_loop_)\n+    suspend_script_callback_result_ = false;\n+}\n+\n+pp::deprecated::ScriptableObject* TestFlashMessageLoop::CreateTestObject() {\n+  if (!instance_so_)\n+    instance_so_ = new InstanceSO(this);\n+  return instance_so_;\n }\n \n std::string TestFlashMessageLoop::TestBasics() {\n@@ -38,7 +108,7 @@ std::string TestFlashMessageLoop::TestBasics() {\n \n   ASSERT_TRUE(message_loop_);\n   delete message_loop_;\n-  message_loop_ = NULL;\n+  message_loop_ = nullptr;\n \n   ASSERT_EQ(PP_OK, result);\n   PASS();\n@@ -54,14 +124,49 @@ std::string TestFlashMessageLoop::TestRunWithoutQuit() {\n \n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n     ASSERT_TRUE(false);\n   }\n \n   ASSERT_EQ(PP_ERROR_ABORTED, result);\n   PASS();\n }\n \n+std::string TestFlashMessageLoop::TestSuspendScriptCallbackWhileRunning() {\n+  suspend_script_callback_result_ = true;\n+  message_loop_ = new pp::flash::MessageLoop(instance_);\n+\n+  pp::CompletionCallback callback = callback_factory_.NewCallback(\n+      &TestFlashMessageLoop::TestSuspendScriptCallbackTask);\n+  pp::Module::Get()->core()->CallOnMainThread(0, callback);\n+  message_loop_->Run();\n+\n+  ASSERT_TRUE(message_loop_);\n+  delete message_loop_;\n+  message_loop_ = nullptr;\n+\n+  ASSERT_TRUE(suspend_script_callback_result_);\n+  PASS();\n+}\n+\n+void TestFlashMessageLoop::TestSuspendScriptCallbackTask(int32_t unused) {\n+  pp::Var exception;\n+  pp::Var rev = instance_->ExecuteScript(\n+      \""(function() {\""\n+      \""  function delayedHandler() {\""\n+      \""    document.getElementById('plugin').DidRunScriptCallback();\""\n+      \""  }\""\n+      \""  setTimeout(delayedHandler, 1);\""\n+      \""})()\"",\n+      &exception);\n+  if (!exception.is_undefined())\n+    suspend_script_callback_result_ = false;\n+\n+  pp::CompletionCallback callback =\n+      callback_factory_.NewCallback(&TestFlashMessageLoop::QuitMessageLoopTask);\n+  pp::Module::Get()->core()->CallOnMainThread(500, callback);\n+}\n+\n void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n   if (message_loop_)\n     message_loop_->Quit();\n@@ -72,7 +177,7 @@ void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n void TestFlashMessageLoop::DestroyMessageLoopResourceTask(int32_t unused) {\n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n   } else {\n     PP_NOTREACHED();\n   }""}<_**next**_>{""sha"": ""31b27916cc2d8b006f8bcd0125975bf157f5f492"", ""filename"": ""ppapi/tests/test_flash_message_loop.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 2, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.h?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -20,19 +20,37 @@ class MessageLoop;\n class TestFlashMessageLoop : public TestCase {\n  public:\n   explicit TestFlashMessageLoop(TestingInstance* instance);\n-  virtual ~TestFlashMessageLoop();\n+  ~TestFlashMessageLoop() override;\n \n   // TestCase implementation.\n-  virtual void RunTests(const std::string& filter);\n+  void RunTests(const std::string& filter) override;\n+\n+  void clear_instance_so() { instance_so_ = nullptr; }\n+\n+  void DidRunScriptCallback();\n \n  private:\n+  // ScriptableObject implementation.\n+  class InstanceSO;\n+\n+  // TestCase protected overrides.\n+  pp::deprecated::ScriptableObject* CreateTestObject() override;\n+\n   std::string TestBasics();\n   std::string TestRunWithoutQuit();\n+  std::string TestSuspendScriptCallbackWhileRunning();\n \n+  void TestSuspendScriptCallbackTask(int32_t unused);\n   void QuitMessageLoopTask(int32_t unused);\n   void DestroyMessageLoopResourceTask(int32_t unused);\n \n   pp::flash::MessageLoop* message_loop_;\n+\n+  // The scriptable object and result storage for the\n+  // SuspendScriptCallbackWhileRunning test.\n+  InstanceSO* instance_so_;\n+  bool suspend_script_callback_result_;\n+\n   pp::CompletionCallbackFactory<TestFlashMessageLoop> callback_factory_;\n };\n ""}","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
",C,"    blink::WebView::willEnterModalLoop();


    blink::WebView::didExitModalLoop();
",,,"@@ -7,6 +7,7 @@
 #include ""base/callback.h""
 #include ""base/message_loop/message_loop.h""
 #include ""ppapi/c/pp_errors.h""
+#include ""third_party/WebKit/public/web/WebView.h""
 
 using ppapi::thunk::PPB_Flash_MessageLoop_API;
 
@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
+    blink::WebView::willEnterModalLoop();
+
     base::MessageLoop::current()->Run();
+
+    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 ",Chrome,dd77c2a41c72589d929db0592565125ca629fb2c,fc51e9e93e12a0f3d6b4f3e1f33c5e252d0dff95,1,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  // It is possible that the PPB_Flash_MessageLoop_Impl object has been
  // destroyed when the nested message loop exits.
  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
//fix_flaw_line_below:
//    blink::WebView::willEnterModalLoop();
//fix_flaw_line_below:
//
     base::MessageLoop::current()->Run();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 
  return state_protector->result();
}
",186091,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","The vulnerability in the original code lies in the lack of proper handling for modal loops, which can lead to issues such as re-entrancy or inconsistent state management when the message loop is running. Specifically, the absence of calls to `blink::WebView::willEnterModalLoop()` and `blink::WebView::didExitModalLoop()` means that the system does not properly notify the web view about entering and exiting a modal loop, potentially causing unexpected behavior. The fixed code addresses this by adding these calls, ensuring that the modal state is correctly managed and that the web view is aware of the loop's status, thus enhancing stability and security.","The vulnerability in the original code stems from the lack of proper management of modal loop states, which can lead to issues such as re-entrancy and inconsistent behavior during the execution of the message loop. Without notifying the system when entering or exiting a modal loop, the application may not handle user interactions or state transitions correctly, potentially resulting in crashes or unexpected behavior. The revised code addresses this vulnerability by explicitly adding notifications for entering and exiting the modal loop, ensuring that the system maintains a consistent state and properly manages user interactions during the loop's execution.",2,5,3,4,"CWE-749, CWE-412, CWE-413, CWE-362, CWE-367, CWE-364, CWE-366, CWE-371, CWE-664, CWE-691",N,-1
75,75,75,187364,187364,,Remote,Not required,Partial,CVE-2015-3845,https://www.cvedetails.com/cve/CVE-2015-3845/,CWE-264,Medium,Partial,Partial,,2015-09-30,6.8,"The Parcel::appendFrom function in libs/binder/Parcel.cpp in Binder in Android before 5.1.1 LMY48M does not consider parcel boundaries during identification of binder objects in an append operation, which allows attackers to obtain a different application's privileges via a crafted application, aka internal bug 17312693.",2015-10-01,,1,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20,e68cbc3e9e66df4231e70efa3e9c41abc12aea20,"Disregard alleged binder entities beyond parcel bounds

When appending one parcel's contents to another, ignore binder
objects within the source Parcel that appear to lie beyond the
formal bounds of that Parcel's data buffer.

Bug 17312693

Change-Id: If592a260f3fcd9a56fc160e7feb2c8b44c73f514
(cherry picked from commit 27182be9f20f4f5b48316666429f09b9ecc1f22e)
",1,libs/binder/Parcel.cpp,"{""filename"": ""libs/binder/Parcel.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/libs/binder/Parcel.cpp"", ""patch"": ""@@ -411,7 +411,7 @@\n\n     // Count objects in range\n     for (int i = 0; i < (int) size; i++) {\n         size_t off = objects[i];\n-        if ((off >= offset) && (off < offset + len)) {\n+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {\n             if (firstIndex == -1) {\n                 firstIndex = i;\n             }\n""}","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",C,"        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
","        if ((off >= offset) && (off < offset + len)) {
",,"@@ -411,7 +411,7 @@

     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
-        if ((off >= offset) && (off < offset + len)) {
+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
",Android,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20%5E/,1,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 // range checks against the source parcel size
 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
//flaw_line_below:
        if ((off >= offset) && (off < offset + len)) {
//fix_flaw_line_below:
//        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
 // grow data
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

 // append data
    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 // grow objects
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 // append and acquire objects
 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
 // If this is a file descriptor, we need to dup it so the
 // new Parcel now owns its own fd, and can declare that we
 // officially know we have fds.
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",187364,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","The vulnerability in the original code arises from the condition used to check object offsets within the `for` loop, specifically the expression `if ((off >= offset) && (off < offset + len))`. This could allow for an out-of-bounds access if `off` exceeds the allocated memory for `mData`, leading to potential memory corruption or unauthorized access. The fix modifies this condition to `if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len))`, ensuring that the entire size of the `flat_binder_object` is accounted for, thus preventing any out-of-bounds access and enhancing memory safety.","The vulnerability in the original code stems from inadequate checks on object offsets, which could lead to accessing memory outside the allocated bounds. This oversight allows for potential memory corruption or unauthorized access, posing a significant security risk. The fix addresses this issue by enhancing the condition that verifies the validity of the offsets, ensuring that the entire size of the objects being accessed is within the permissible range. This adjustment effectively prevents out-of-bounds access, thereby improving the overall memory safety and integrity of the code.",3,4,3,3,"CWE-119, CWE-125, CWE-787, CWE-823, CWE-124, CWE-788, CWE-122, CWE-121, CWE-120, CWE-126",N,-1
76,76,76,187420,187420,,Remote,Not required,Complete,CVE-2016-3913,https://www.cvedetails.com/cve/CVE-2016-3913/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"media/libmediaplayerservice/MediaPlayerService.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate a certain static_cast operation, which allows attackers to gain privileges via a crafted application, aka internal bug 30204103.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d,0c3b93c8c2027e74af642967eee5c142c8fd185d,"MediaPlayerService: avoid invalid static cast

Bug: 30204103
Change-Id: Ie0dd3568a375f1e9fed8615ad3d85184bcc99028
(cherry picked from commit ee0a0e39acdcf8f97e0d6945c31ff36a06a36e9d)
",0,media/libmediaplayerservice/MediaPlayerService.cpp,"{""filename"": ""media/libmediaplayerservice/MediaPlayerService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.cpp"", ""patch"": ""@@ -558,6 +558,12 @@\n\n     mClients.remove(client);\n }\n \n+bool MediaPlayerService::hasClient(wp<Client> client)\n+{\n+    Mutex::Autolock lock(mLock);\n+    return mClients.indexOf(client) != NAME_NOT_FOUND;\n+}\n+\n MediaPlayerService::Client::Client(\n         const sp<MediaPlayerService>& service, pid_t pid,\n         int32_t connId, const sp<IMediaPlayerClient>& client,\n@@ -1086,6 +1092,10 @@\n\n     ALOGV(\""setNextPlayer\"");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n+    if (!mService->hasClient(c)) {\n+      return BAD_VALUE;\n+    }\n+\n     mNextClient = c;\n \n     if (c != NULL) {\n""}<_**next**_>{""filename"": ""media/libmediaplayerservice/MediaPlayerService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.h"", ""patch"": ""@@ -226,6 +226,7 @@\n\n     virtual status_t            dump(int fd, const Vector<String16>& args);\n \n             void                removeClient(wp<Client> client);\n+            bool                hasClient(wp<Client> client);\n \n     enum {\n         MEDIASERVER_PROCESS_DEATH = 0,\n""}","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",C,"    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

",,,"@@ -558,6 +558,12 @@

     mClients.remove(client);
 }
 
+bool MediaPlayerService::hasClient(wp<Client> client)
+{
+    Mutex::Autolock lock(mLock);
+    return mClients.indexOf(client) != NAME_NOT_FOUND;
+}
+
 MediaPlayerService::Client::Client(
         const sp<MediaPlayerService>& service, pid_t pid,
         int32_t connId, const sp<IMediaPlayerClient>& client,
@@ -1086,6 +1092,10 @@

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
+    if (!mService->hasClient(c)) {
+      return BAD_VALUE;
+    }
+
     mNextClient = c;
 
     if (c != NULL) {
",Android,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d%5E/,1,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
//fix_flaw_line_below:
//    if (!mService->hasClient(c)) {
//fix_flaw_line_below:
//      return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",187420,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","The vulnerability in the original code lies in the lack of validation for the `player` parameter before it is cast to a `Client` object. This could allow an unauthorized or invalid client to be set as `mNextClient`, potentially leading to unauthorized access or manipulation of media playback. The fix introduces a check using `mService->hasClient(c)` to ensure that the client is valid before proceeding. If the client is not valid, the function returns `BAD_VALUE`, effectively preventing any further operations that could compromise the integrity of the media player service.","The vulnerability in the original code stems from the absence of validation for the input parameter, allowing potentially unauthorized or invalid clients to be processed. This oversight could lead to security issues, such as unauthorized access to media playback controls or manipulation of the media player state. The fix addresses this vulnerability by implementing a validation check to ensure that the client is legitimate before any further actions are taken. If the client fails the validation, the function immediately returns an error, thereby preventing any unsafe operations and enhancing the overall security of the media player service.",3,0,3,1,"CWE-284,CWE-285,CWE-287,CWE-306,CWE-346,CWE-436,CWE-20,CWE-288,CWE-807,CWE-749",N,-1
77,77,77,187425,187425,,Remote,Not required,Complete,CVE-2016-3900,https://www.cvedetails.com/cve/CVE-2016-3900/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69,047eec456943dc082e33220d28abb7df4e089f69,"ServiceManager: Allow system services running as secondary users to add services

This should be reverted when all system services have been cleaned up to not
do this. A process looking up a service while running in the background will
see the service registered by the active user (assuming the service is
registered on every user switch), not the service registered by the user that
the process itself belongs to.

BUG: 30795333
Change-Id: I1b74d58be38ed358f43c163692f9e704f8f31dbe
(cherry picked from commit e6bbe69ba739c8a08837134437aaccfea5f1d943)
",1,cmds/servicemanager/service_manager.c,"{""filename"": ""cmds/servicemanager/Android.mk"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/Android.mk"", ""patch"": ""@@ -18,7 +18,7 @@\n\n include $(BUILD_EXECUTABLE)\n \n include $(CLEAR_VARS)\n-LOCAL_SHARED_LIBRARIES := liblog libselinux\n+LOCAL_SHARED_LIBRARIES := liblog libcutils libselinux\n LOCAL_SRC_FILES := service_manager.c binder.c\n LOCAL_CFLAGS += $(svc_c_flags)\n LOCAL_MODULE := servicemanager\n""}<_**next**_>{""filename"": ""cmds/servicemanager/service_manager.c"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/service_manager.c"", ""patch"": ""@@ -8,6 +8,8 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n+#include <cutils/multiuser.h>\n+\n #include <private/android_filesystem_config.h>\n \n #include <selinux/android.h>\n@@ -122,7 +124,7 @@\n\n {\n     const char *perm = \""add\"";\n \n-    if (uid >= AID_APP) {\n+    if (multiuser_get_app_id(uid) >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n""}","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",C,"    if (multiuser_get_app_id(uid) >= AID_APP) {
","    if (uid >= AID_APP) {
",,"@@ -8,6 +8,8 @@

 #include <stdlib.h>
 #include <string.h>
 
+#include <cutils/multiuser.h>
+
 #include <private/android_filesystem_config.h>
 
 #include <selinux/android.h>
@@ -122,7 +124,7 @@

 {
     const char *perm = ""add"";
 
-    if (uid >= AID_APP) {
+    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
",Android,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69%5E/,1,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
//flaw_line_below:
    if (uid >= AID_APP) {
//fix_flaw_line_below:
//    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",187425,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","The vulnerability in the original code lies in the direct comparison of the `uid` variable with `AID_APP`, which could potentially allow unauthorized applications to register services if the `uid` is manipulated. This check does not account for multi-user environments, where user IDs may not be straightforward. The fix replaces `uid >= AID_APP` with `multiuser_get_app_id(uid) >= AID_APP`, ensuring that the application ID is correctly derived from the user ID, thereby preventing unauthorized service registration by apps in a multi-user context and enhancing overall security.","The vulnerability in the original code stems from an inadequate check that allows applications to register services based solely on user ID comparisons. This approach fails to consider the complexities of multi-user environments, where user IDs can be manipulated or misinterpreted, potentially granting unauthorized access. The fix addresses this issue by implementing a more robust method to derive the application ID from the user ID, ensuring that only legitimate users can register services. This change enhances security by preventing unauthorized applications from exploiting the registration process in a multi-user context.",4,4,2,2,"CWE-287,CWE-284,CWE-639,CWE-522,CWE-269,CWE-285,CWE-520,CWE-263,CWE-266,CWE-264",Y,10
78,78,78,187427,187427,,Remote,Not required,Complete,CVE-2016-3890,https://www.cvedetails.com/cve/CVE-2016-3890/,CWE-264,High,Complete,Complete,,2016-09-11,7.6,"The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842.",2017-08-12,+Priv ,1,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d,014b01706cc64dc9c2ad94a96f62e07c058d0b5d,"adb: use asocket's close function when closing.

close_all_sockets was assuming that all registered local sockets used
local_socket_close as their close function. However, this is not true
for JDWP sockets.

Bug: http://b/28347842
Change-Id: I40a1174845cd33f15f30ce70828a7081cd5a087e
(cherry picked from commit 53eb31d87cb84a4212f4850bf745646e1fb12814)
",1,adb/sockets.cpp,"{""filename"": ""adb/sockets.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/adb/sockets.cpp"", ""patch"": ""@@ -39,8 +39,6 @@\n\n #include \""sysdeps/mutex.h\""\n #include \""transport.h\""\n \n-static void local_socket_close(asocket* s);\n-\n static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();\n static unsigned local_socket_next_id = 1;\n \n@@ -118,7 +116,7 @@\n\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n-            local_socket_close(s);\n+            s->close(s);\n             goto restart;\n         }\n     }\n""}","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
",C,"            s->close(s);
","            local_socket_close(s);
",,"@@ -39,8 +39,6 @@

 #include ""sysdeps/mutex.h""
 #include ""transport.h""
 
-static void local_socket_close(asocket* s);
-
 static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
@@ -118,7 +116,7 @@

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close(s);
+            s->close(s);
             goto restart;
         }
     }
",Android,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d%5E/,1,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
//flaw_line_below:
            local_socket_close(s);
//fix_flaw_line_below:
//            s->close(s);
             goto restart;
         }
     }
}
",187427,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","The vulnerability in the original code arises from the use of the function `local_socket_close(s)`, which modifies the socket list while iterating over it, potentially leading to undefined behavior or skipping sockets. This is particularly problematic because the loop relies on the integrity of the list during iteration. In the fixed code, the function call is changed to `s->close(s)`, which presumably handles the socket closure more safely, ensuring that the list's integrity is maintained during the iteration. This change mitigates the risk of accessing invalid memory or encountering an infinite loop due to list modifications.","The vulnerability in the original code stems from modifying a data structure while iterating over it, which can lead to unpredictable behavior, such as skipping elements or accessing invalid memory. This occurs because the closure of an element alters the list, potentially disrupting the iteration process. The fixed code addresses this issue by changing the method used to close the elements, ensuring that the modification of the data structure is handled in a way that maintains the integrity of the iteration. This adjustment prevents the risks associated with concurrent modifications during the loop execution.",2,5,4,4,"CWE-664,CWE-665,CWE-662,CWE-366,CWE-367,CWE-412,CWE-562,CWE-833,CWE-843,CWE-1265",N,-1
79,79,79,187796,187796,,Remote,Not required,Complete,CVE-2016-2494,https://www.cvedetails.com/cve/CVE-2016-2494/,CWE-264,Medium,Complete,Complete,,2016-06-12,9.3,"Off-by-one error in sdcard/sdcard.c in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28085658.",2016-11-29,+Priv ,1,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d,864e2e22fcd0cba3f5e67680ccabd0302dfda45d,"Fix overflow in path building

An incorrect size was causing an unsigned value
to wrap, causing it to write past the end of
the buffer.

Bug: 28085658
Change-Id: Ie9625c729cca024d514ba2880ff97209d435a165
",1,sdcard/sdcard.c,"{""filename"": ""sdcard/sdcard.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/sdcard/sdcard.c"", ""patch"": ""@@ -337,7 +337,7 @@\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\n         if (pathlen < 0) {\n             return -1;\n         }\n""}","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",C,"        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
","        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
",,"@@ -337,7 +337,7 @@

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
",Android,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d%5E/,1,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
//flaw_line_below:
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
//fix_flaw_line_below:
//        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",187796,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","The vulnerability in the original code arises from the incorrect buffer size calculation when recursively calling `get_node_path_locked` for the parent node. Specifically, the expression `bufsize - namelen - 2` does not account for the null terminator, potentially leading to a buffer overflow if the buffer is not large enough to hold the additional characters. In the fixed code, this is corrected by changing the expression to `bufsize - namelen - 1`, ensuring that there is sufficient space for the null terminator and preventing potential overflow vulnerabilities. This change enhances the safety of memory operations within the function.","The vulnerability in the original code stems from an incorrect calculation of the buffer size during recursive calls, which could lead to a buffer overflow. Specifically, the code did not properly account for the space needed for a null terminator when determining how much of the buffer was available. This oversight could allow for writing beyond the allocated memory, potentially corrupting data or causing crashes. The fixed code addresses this issue by adjusting the buffer size calculation to ensure that there is adequate space for the null terminator, thereby enhancing the overall safety and stability of the function.",3,5,3,3,"CWE-131,CWE-120,CWE-119,CWE-787,CWE-122,CWE-788,CWE-121,CWE-805,CWE-823,CWE-789",N,-1
80,80,80,187905,187905,,Remote,Not required,Complete,CVE-2016-2449,https://www.cvedetails.com/cve/CVE-2016-2449/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"services/camera/libcameraservice/device3/Camera3Device.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate template IDs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27568958.",2016-05-10,+Priv ,7,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353,b04aee833c5cfb6b31b8558350feb14bb1a0f353,"Camera3Device: Validate template ID

Validate template ID before creating a default request.

Bug: 26866110
Bug: 27568958
Change-Id: Ifda457024f1d5c2b1382f189c1a8d5fda852d30d
",0,services/camera/libcameraservice/device3/Camera3Device.cpp,"{""filename"": ""services/camera/libcameraservice/device3/Camera3Device.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/services/camera/libcameraservice/device3/Camera3Device.cpp"", ""patch"": ""@@ -43,6 +43,7 @@\n\n #include <utils/Trace.h>\n #include <utils/Timers.h>\n \n+#include \""CameraService.h\""\n #include \""utils/CameraTraces.h\""\n #include \""mediautils/SchedulingPolicyService.h\""\n #include \""device3/Camera3Device.h\""\n@@ -1115,6 +1116,13 @@\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\""%s: for template %d\"", __FUNCTION__, templateId);\n+\n+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {\n+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, \""26866110\"",\n+                IPCThreadState::self()->getCallingUid(), NULL, 0);\n+        return BAD_VALUE;\n+    }\n+\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n""}","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",C,"
    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

",,,"@@ -43,6 +43,7 @@

 #include <utils/Trace.h>
 #include <utils/Timers.h>
 
+#include ""CameraService.h""
 #include ""utils/CameraTraces.h""
 #include ""mediautils/SchedulingPolicyService.h""
 #include ""device3/Camera3Device.h""
@@ -1115,6 +1116,13 @@

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
+
+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
+                IPCThreadState::self()->getCallingUid(), NULL, 0);
+        return BAD_VALUE;
+    }
+
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353%5E/,1,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
//fix_flaw_line_below:
//                IPCThreadState::self()->getCallingUid(), NULL, 0);
//fix_flaw_line_below:
//        return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 // OK
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",187905,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","The vulnerability in the original code lies in the lack of validation for the `templateId` parameter, which could allow an attacker to pass an out-of-bounds value, potentially leading to memory corruption or access violations when accessing `mRequestTemplateCache[templateId]`. The fixed code addresses this vulnerability by introducing a check that ensures `templateId` is within valid bounds (greater than 0 and less than `CAMERA3_TEMPLATE_COUNT`). If the check fails, it logs an error and returns `BAD_VALUE`, thus preventing unsafe memory access and enhancing the overall robustness of the function.","The vulnerability in the original code stems from the absence of validation for an input parameter, allowing an attacker to provide an out-of-bounds value. This could lead to memory corruption or access violations when the code attempts to access an array using this unchecked parameter. The revised code mitigates this risk by implementing a validation check to ensure the input falls within a specified range. If the input fails this check, the code logs an error and returns an appropriate error value, thereby preventing unsafe memory access and enhancing the overall security and stability of the function.",4,5,4,4,"CWE-125,CWE-129,CWE-789,CWE-823,CWE-119,CWE-126,CWE-788,CWE-824,CWE-825,CWE-131",N,-1
81,81,81,187906,187906,,Remote,Not required,Complete,CVE-2016-2448,https://www.cvedetails.com/cve/CVE-2016-2448/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not properly validate entry data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27533704.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,"NuPlayerStreamListener: NULL and bounds check before memcpy

Bug: 27533704
Change-Id: I992a7709b92b1cbc3114c97bec48a3fc5b22ba6e
",1,media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp,"{""filename"": ""media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""patch"": ""@@ -144,8 +144,17 @@\n\n         copy = size;\n     }\n \n+    if (entry->mIndex >= mBuffers.size()) {\n+        return ERROR_MALFORMED;\n+    }\n+\n+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);\n+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {\n+        return ERROR_MALFORMED;\n+    }\n+\n     memcpy(data,\n-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n+           (const uint8_t *)mem->pointer()\n             + entry->mOffset,\n            copy);\n \n""}","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",C,"    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

           (const uint8_t *)mem->pointer()
","           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
",,"@@ -144,8 +144,17 @@

         copy = size;
     }
 
+    if (entry->mIndex >= mBuffers.size()) {
+        return ERROR_MALFORMED;
+    }
+
+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
+        return ERROR_MALFORMED;
+    }
+
     memcpy(data,
-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
+           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b%5E/,1,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
//fix_flaw_line_below:
//    if (entry->mIndex >= mBuffers.size()) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
//fix_flaw_line_below:
//    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     memcpy(data,
//flaw_line_below:
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
//fix_flaw_line_below:
//           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",187906,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","The vulnerability in the original code arises from the lack of checks on the `entry->mIndex` and the memory buffer accessed via `mBuffers.editItemAt(entry->mIndex)`. If `entry->mIndex` exceeds the bounds of `mBuffers`, it could lead to out-of-bounds memory access, potentially causing crashes or exploitation. The fixed code addresses this vulnerability by adding checks to ensure that `entry->mIndex` is within the valid range of `mBuffers` and that the memory accessed is valid and sufficiently sized. This prevents unsafe memory operations and enhances the overall robustness of the `read` function.","The vulnerability in the original code stems from inadequate validation of memory access, which could lead to out-of-bounds reads or writes. Specifically, the code does not check whether the index used to access a memory buffer is within valid limits, potentially allowing access to unallocated or restricted memory areas. This oversight could result in crashes or exploitation by malicious actors. The revised code rectifies this issue by implementing checks to ensure that the index is valid and that the memory being accessed is appropriately sized, thereby enhancing the safety and stability of the memory operations performed.",4,5,4,1,"CWE-119,CWE-125,CWE-787,CWE-126,CWE-788,CWE-823,CWE-824,CWE-129,CWE-131,CWE-789",N,-1
82,82,82,187907,187907,,Remote,Not required,Complete,CVE-2016-2440,https://www.cvedetails.com/cve/CVE-2016-2440/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libs/binder/IPCThreadState.cpp in Binder in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 mishandles object references, which allows attackers to gain privileges via a crafted application, aka internal bug 27252896.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a,a59b827869a2ea04022dd225007f29af8d61837a,"Fix issue #27252896: Security Vulnerability -- weak binder

Sending transaction to freed BBinder through weak handle
can cause use of a (mostly) freed object.  We need to try to
safely promote to a strong reference first.

Change-Id: Ic9c6940fa824980472e94ed2dfeca52a6b0fd342
(cherry picked from commit c11146106f94e07016e8e26e4f8628f9a0c73199)
",2,libs/binder/IPCThreadState.cpp,"{""filename"": ""libs/binder/IPCThreadState.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/libs/binder/IPCThreadState.cpp"", ""patch"": ""@@ -1083,8 +1083,16 @@\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n-                sp<BBinder> b((BBinder*)tr.cookie);\n-                error = b->transact(tr.code, buffer, &reply, tr.flags);\n+                // We only have a weak reference on the target object, so we must first try to\n+                // safely acquire a strong reference before doing anything else with it.\n+                if (reinterpret_cast<RefBase::weakref_type*>(\n+                        tr.target.ptr)->attemptIncStrong(this)) {\n+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,\n+                            &reply, tr.flags);\n+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);\n+                } else {\n+                    error = UNKNOWN_TRANSACTION;\n+                }\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n""}","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",C,"                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
","                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
",,"@@ -1083,8 +1083,16 @@

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
-                sp<BBinder> b((BBinder*)tr.cookie);
-                error = b->transact(tr.code, buffer, &reply, tr.flags);
+                // We only have a weak reference on the target object, so we must first try to
+                // safely acquire a strong reference before doing anything else with it.
+                if (reinterpret_cast<RefBase::weakref_type*>(
+                        tr.target.ptr)->attemptIncStrong(this)) {
+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
+                            &reply, tr.flags);
+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
+                } else {
+                    error = UNKNOWN_TRANSACTION;
+                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
",Android,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a%5E/,1,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 // NOTE: This assertion is not valid, because the object may no
 // longer exist (thus the (BBinder*)cast above resulting in a different
 // memory address).
 //ALOG_ASSERT(refs->refBase() == obj,
 //           ""BR_DECREFS: object %p does not match cookie %p (expected %p)"",
 //           refs, obj, refs->refBase());
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
 // We have inherited a reduced priority from the caller, but do not
 // want to run in that state in this process.  The driver set our
 // priority already (though not our scheduling class), so bounce
 // it back to the default before invoking the transaction.
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
 // We want to use the inherited priority from the caller.
 // Ensure this thread is in the background scheduling class,
 // since the driver won't modify scheduling classes for us.
 // The scheduling group is reset to default by the caller
 // once this method returns after the transaction is complete.
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }

 //ALOGI("">>>> TRANSACT from pid %d uid %d\n"", mCallingPid, mCallingUid);

 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
//flaw_line_below:
                sp<BBinder> b((BBinder*)tr.cookie);
//flaw_line_below:
                error = b->transact(tr.code, buffer, &reply, tr.flags);
//fix_flaw_line_below:
//                // We only have a weak reference on the target object, so we must first try to
//fix_flaw_line_below:
//                // safely acquire a strong reference before doing anything else with it.
//fix_flaw_line_below:
//                if (reinterpret_cast<RefBase::weakref_type*>(
//fix_flaw_line_below:
//                        tr.target.ptr)->attemptIncStrong(this)) {
//fix_flaw_line_below:
//                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
//fix_flaw_line_below:
//                            &reply, tr.flags);
//fix_flaw_line_below:
//                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    error = UNKNOWN_TRANSACTION;
//fix_flaw_line_below:
//                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 //ALOGI(""<<<< TRANSACT from pid %d restore pid %d uid %d\n"",
 //     mCallingPid, origPid, origUid);
 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",187907,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","The vulnerability in the original code lies in the handling of the `BR_TRANSACTION` case, where a weak reference to a target object is used without ensuring a strong reference is acquired first. This could lead to a use-after-free condition if the object is deleted while still being referenced, potentially allowing an attacker to exploit this by sending malicious commands. The fix introduces a check using `attemptIncStrong(this)` to safely acquire a strong reference before proceeding with the transaction. This ensures that the object remains valid during the transaction, mitigating the risk of dereferencing a dangling pointer.","The vulnerability in the original code arises from the lack of proper reference management when handling transactions, specifically using weak references without ensuring a strong reference is acquired first. This oversight can lead to a use-after-free scenario, where an object may be deleted while still being accessed, potentially allowing for exploitation through malicious commands. The fix addresses this issue by implementing a check to safely acquire a strong reference before proceeding with any operations on the object. This change ensures that the object remains valid throughout the transaction, thereby mitigating the risk of dereferencing invalid memory.",4,5,4,4,"CWE-416, CWE-825, CWE-672, CWE-911, CWE-665, CWE-119, CWE-476, CWE-415, CWE-664, CWE-909",N,-1
83,83,83,187909,187909,,Remote,Not required,Complete,CVE-2016-2430,https://www.cvedetails.com/cve/CVE-2016-2430/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libbacktrace/Backtrace.cpp in debuggerd in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows attackers to gain privileges via an application containing a crafted symbol name, aka internal bug 27299236.",2016-05-10,+Priv ,0,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0,ad54cfed4516292654c997910839153264ae00a0,"Don't demangle symbol names.

Bug: http://b/27299236
Change-Id: I26ef47f80d4d6048a316ba51e83365ff65d70439
",12,libbacktrace/Backtrace.cpp,"{""filename"": ""libbacktrace/Backtrace.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/libbacktrace/Backtrace.cpp"", ""patch"": ""@@ -54,24 +54,8 @@\n\n   }\n }\n \n-extern \""C\"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,\n-                                int* status);\n-\n std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n-  if (!func_name.empty()) {\n-#if defined(__APPLE__)\n-    // Mac OS' __cxa_demangle demangles \""f\"" as \""float\""; last tested on 10.7.\n-    if (func_name[0] != '_') {\n-      return func_name;\n-    }\n-#endif\n-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n-    if (name) {\n-      func_name = name;\n-      free(name);\n-    }\n-  }\n   return func_name;\n }\n \n""}"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
",C,,"  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
",,"@@ -54,24 +54,8 @@

   }
 }
 
-extern ""C"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,
-                                int* status);
-
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
-  if (!func_name.empty()) {
-#if defined(__APPLE__)
-    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
-    if (func_name[0] != '_') {
-      return func_name;
-    }
-#endif
-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
-    if (name) {
-      func_name = name;
-      free(name);
-    }
-  }
   return func_name;
 }
 
",Android,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0%5E/,1," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
//flaw_line_below:
  if (!func_name.empty()) {
//flaw_line_below:
#if defined(__APPLE__)
//flaw_line_below:
    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
//flaw_line_below:
    if (func_name[0] != '_') {
//flaw_line_below:
      return func_name;
//flaw_line_below:
    }
//flaw_line_below:
#endif
//flaw_line_below:
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
//flaw_line_below:
    if (name) {
//flaw_line_below:
      func_name = name;
//flaw_line_below:
      free(name);
//flaw_line_below:
    }
//flaw_line_below:
  }
   return func_name;
 }
",187909," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
","The vulnerability in the original code lies in the use of `__cxa_demangle` to process function names, which could lead to memory management issues, particularly if `name` is not properly freed or if `func_name` is manipulated incorrectly. Additionally, the conditional check for `func_name[0] != '_'` could inadvertently skip valid function names. In the fixed code, the unnecessary complexity is removed by directly returning `func_name` without attempting demangling or additional checks, thus eliminating potential memory leaks and simplifying the logic, ensuring safer and more predictable behavior.","The vulnerability in the original code stems from improper memory management and potential misuse of a demangling function, which could lead to memory leaks if the allocated memory is not freed correctly. Additionally, the logic that checks the first character of the function name could inadvertently exclude valid names, resulting in incomplete or incorrect outputs. In the revised code, this complexity is eliminated by directly returning the function name without any demangling or conditional checks, thereby simplifying the logic and ensuring that memory management issues are avoided, leading to safer and more reliable code execution.",3,5,4,2,"CWE-119, CWE-401, CWE-789, CWE-415, CWE-416, CWE-672, CWE-476, CWE-825, CWE-763, CWE-908",N,-1
84,84,84,187912,187912,,Remote,Not required,Complete,CVE-2016-2420,https://www.cvedetails.com/cve/CVE-2016-2420/,CWE-264,Medium,Complete,Complete,,2016-04-17,9.3,"rootdir/init.rc in Android 4.x before 4.4.4 does not ensure that the /data/tombstones directory exists for the Debuggerd component, which allows attackers to gain privileges via a crafted application, aka internal bug 26403620.",2016-04-22,+Priv ,1,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c,81df1cc77722000f8d0025c1ab00ced123aa573c,"Don't create tombstone directory.

Partial backport of cf79748.

Bug: http://b/26403620
Change-Id: Ib877ab6cfab6aef079830c5a50ba81141ead35ee
",12,debuggerd/tombstone.cpp,"{""filename"": ""debuggerd/tombstone.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/debuggerd/tombstone.cpp"", ""patch"": ""@@ -743,21 +743,8 @@\n\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n \n-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n-    _LOG(&log, logtype::ERROR, \""failed to create %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n-    _LOG(&log, logtype::ERROR, \""failed to change ownership of %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n   int fd = -1;\n-  char* path = NULL;\n-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n-    path = find_and_open_tombstone(&fd);\n-  } else {\n-    _LOG(&log, logtype::ERROR, \""Failed to restore security context, not writing tombstone.\\n\"");\n-  }\n+  char* path = find_and_open_tombstone(&fd);\n \n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \""Skipping tombstone write, nothing to do.\\n\"");\n""}","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
",C,"  char* path = find_and_open_tombstone(&fd);
","  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
",,"@@ -743,21 +743,8 @@

   log.current_tid = tid;
   log.crashed_tid = tid;
 
-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
-    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
-    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
   int fd = -1;
-  char* path = NULL;
-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
-    path = find_and_open_tombstone(&fd);
-  } else {
-    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
-  }
+  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
",Android,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c%5E/,1,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
//flaw_line_below:
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

   int fd = -1;
//flaw_line_below:
  char* path = NULL;
//flaw_line_below:
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
//flaw_line_below:
    path = find_and_open_tombstone(&fd);
//flaw_line_below:
  } else {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
//flaw_line_below:
  }
//fix_flaw_line_below:
//  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 // Preserve amfd since it can be modified through the calls below without
 // being closed.
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

 // Either of these file descriptors can be -1, any error is ignored.
  close(amfd);
  close(fd);

 return path;
}
",187912,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","The vulnerability in the original code lies in the improper handling of the file descriptor `fd` and the potential failure of the `selinux_android_restorecon` function. If `selinux_android_restorecon` fails, the code attempts to open a tombstone file without checking if `fd` is valid, leading to a possible null pointer dereference when `find_and_open_tombstone` is called. In the fixed code, the call to `find_and_open_tombstone` is moved before the security context restoration check, ensuring that `fd` is validated immediately. This change prevents the code from proceeding with an invalid file descriptor, thus enhancing stability and security.","The vulnerability in the original code arises from the lack of proper validation for a critical resource before proceeding with operations that depend on it. Specifically, the code attempts to open a resource without ensuring that the necessary security context has been successfully restored. This oversight can lead to undefined behavior or crashes if the resource is not valid. In the revised code, the sequence of operations is adjusted to validate the resource immediately after attempting to open it, ensuring that any subsequent actions are only taken if the resource is confirmed to be valid, thereby enhancing the overall robustness and security of the implementation.",4,5,5,4,"CWE-404, CWE-456, CWE-672, CWE-665, CWE-666, CWE-754, CWE-273, CWE-252, CWE-476, CWE-685",N,-1
85,85,85,187913,187913,,Remote,Not required,Complete,CVE-2016-2419,https://www.cvedetails.com/cve/CVE-2016-2419/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IDrm.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize a certain key-request data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26323455.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34,5a856f2092f7086aa0fea9ae06b9255befcdcd34,"Fix info leak vulnerability of IDrm

bug: 26323455
Change-Id: I25bb30d3666ab38d5150496375ed2f55ecb23ba8
",1,media/libmedia/IDrm.cpp,"{""filename"": ""media/libmedia/IDrm.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/media/libmedia/IDrm.cpp"", ""patch"": ""@@ -658,7 +658,7 @@\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n-            DrmPlugin::KeyRequestType keyRequestType;\n+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n""}","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
","            DrmPlugin::KeyRequestType keyRequestType;
",,"@@ -658,7 +658,7 @@

 
             Vector<uint8_t> request;
             String8 defaultUrl;
-            DrmPlugin::KeyRequestType keyRequestType;
+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
",Android,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34%5E/,1,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
//flaw_line_below:
            DrmPlugin::KeyRequestType keyRequestType;
//fix_flaw_line_below:
//            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187913,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The vulnerability in the original code stemmed from the lack of proper validation when reading data from the `Parcel`, particularly in cases like `GET_KEY_REQUEST`, where `readVector(data, sessionId)` and `readVector(data, initData)` could lead to buffer overflows if the input data was larger than expected. This could allow an attacker to manipulate the input and potentially execute arbitrary code. The fixed code addresses this vulnerability by ensuring that the data read from the `Parcel` is properly validated and handled, thus preventing potential buffer overflow attacks and enhancing overall security.","The vulnerability in the original code was primarily due to insufficient validation of input data, which could lead to buffer overflows and potential exploitation by attackers. Specifically, the code read data from an external source without adequately checking its size, allowing for the possibility of writing beyond allocated memory. The fixed code addresses this issue by implementing proper validation checks before reading data, ensuring that the input is within expected limits. This change significantly enhances the security of the code by preventing unauthorized access and manipulation of memory, thereby mitigating the risk of exploitation.",3,5,4,4,"CWE-119,CWE-120,CWE-131,CWE-789,CWE-20,CWE-787,CWE-125,CWE-129,CWE-805,CWE-122",N,-1
86,86,86,187915,187915,,Remote,Not required,Complete,CVE-2016-2417,https://www.cvedetails.com/cve/CVE-2016-2417/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IOMX.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a parameter data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26914474.",2017-09-07,Bypass +Info ,30,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84,1171e7c047bf79e7c93342bb6a812c9edd86aa84,"Clear allocation to avoid info leak

Bug: 26914474
Change-Id: Ie1a86e86d78058d041149fe599a4996e7f8185cf
",24,media/libmedia/IOMX.cpp,"{""filename"": ""media/libmedia/IOMX.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/media/libmedia/IOMX.cpp"", ""patch"": ""@@ -618,34 +618,39 @@\n\n \n             size_t size = data.readInt64();\n \n-            void *params = malloc(size);\n-            data.read(params, size);\n+            status_t err = NO_MEMORY;\n+            void *params = calloc(size, 1);\n+            if (params) {\n+                err = data.read(params, size);\n+                if (err != OK) {\n+                    android_errorWriteLog(0x534e4554, \""26914474\"");\n+                } else {\n+                    switch (code) {\n+                        case GET_PARAMETER:\n+                            err = getParameter(node, index, params, size);\n+                            break;\n+                        case SET_PARAMETER:\n+                            err = setParameter(node, index, params, size);\n+                            break;\n+                        case GET_CONFIG:\n+                            err = getConfig(node, index, params, size);\n+                            break;\n+                        case SET_CONFIG:\n+                            err = setConfig(node, index, params, size);\n+                            break;\n+                        case SET_INTERNAL_OPTION:\n+                        {\n+                            InternalOptionType type =\n+                                (InternalOptionType)data.readInt32();\n \n-            status_t err;\n-            switch (code) {\n-                case GET_PARAMETER:\n-                    err = getParameter(node, index, params, size);\n-                    break;\n-                case SET_PARAMETER:\n-                    err = setParameter(node, index, params, size);\n-                    break;\n-                case GET_CONFIG:\n-                    err = getConfig(node, index, params, size);\n-                    break;\n-                case SET_CONFIG:\n-                    err = setConfig(node, index, params, size);\n-                    break;\n-                case SET_INTERNAL_OPTION:\n-                {\n-                    InternalOptionType type =\n-                        (InternalOptionType)data.readInt32();\n+                            err = setInternalOption(node, index, type, params, size);\n+                            break;\n+                        }\n \n-                    err = setInternalOption(node, index, type, params, size);\n-                    break;\n+                        default:\n+                            TRESPASS();\n+                    }\n                 }\n-\n-                default:\n-                    TRESPASS();\n             }\n \n             reply->writeInt32(err);\n""}","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
                        default:
                            TRESPASS();
                    }
","            void *params = malloc(size);
            data.read(params, size);
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
                    err = setInternalOption(node, index, type, params, size);
                    break;
                default:
                    TRESPASS();
",,"@@ -618,34 +618,39 @@

 
             size_t size = data.readInt64();
 
-            void *params = malloc(size);
-            data.read(params, size);
+            status_t err = NO_MEMORY;
+            void *params = calloc(size, 1);
+            if (params) {
+                err = data.read(params, size);
+                if (err != OK) {
+                    android_errorWriteLog(0x534e4554, ""26914474"");
+                } else {
+                    switch (code) {
+                        case GET_PARAMETER:
+                            err = getParameter(node, index, params, size);
+                            break;
+                        case SET_PARAMETER:
+                            err = setParameter(node, index, params, size);
+                            break;
+                        case GET_CONFIG:
+                            err = getConfig(node, index, params, size);
+                            break;
+                        case SET_CONFIG:
+                            err = setConfig(node, index, params, size);
+                            break;
+                        case SET_INTERNAL_OPTION:
+                        {
+                            InternalOptionType type =
+                                (InternalOptionType)data.readInt32();
 
-            status_t err;
-            switch (code) {
-                case GET_PARAMETER:
-                    err = getParameter(node, index, params, size);
-                    break;
-                case SET_PARAMETER:
-                    err = setParameter(node, index, params, size);
-                    break;
-                case GET_CONFIG:
-                    err = getConfig(node, index, params, size);
-                    break;
-                case SET_CONFIG:
-                    err = setConfig(node, index, params, size);
-                    break;
-                case SET_INTERNAL_OPTION:
-                {
-                    InternalOptionType type =
-                        (InternalOptionType)data.readInt32();
+                            err = setInternalOption(node, index, type, params, size);
+                            break;
+                        }
 
-                    err = setInternalOption(node, index, type, params, size);
-                    break;
+                        default:
+                            TRESPASS();
+                    }
                 }
-
-                default:
-                    TRESPASS();
             }
 
             reply->writeInt32(err);
",Android,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84%5E/,1,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
//flaw_line_below:
            void *params = malloc(size);
//flaw_line_below:
            data.read(params, size);
//fix_flaw_line_below:
//            status_t err = NO_MEMORY;
//fix_flaw_line_below:
//            void *params = calloc(size, 1);
//fix_flaw_line_below:
//            if (params) {
//fix_flaw_line_below:
//                err = data.read(params, size);
//fix_flaw_line_below:
//                if (err != OK) {
//fix_flaw_line_below:
//                    android_errorWriteLog(0x534e4554, ""26914474"");
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    switch (code) {
//fix_flaw_line_below:
//                        case GET_PARAMETER:
//fix_flaw_line_below:
//                            err = getParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_PARAMETER:
//fix_flaw_line_below:
//                            err = setParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case GET_CONFIG:
//fix_flaw_line_below:
//                            err = getConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_CONFIG:
//fix_flaw_line_below:
//                            err = setConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_INTERNAL_OPTION:
//fix_flaw_line_below:
//                        {
//fix_flaw_line_below:
//                            InternalOptionType type =
//fix_flaw_line_below:
//                                (InternalOptionType)data.readInt32();
 
//flaw_line_below:
            status_t err;
//flaw_line_below:
            switch (code) {
//flaw_line_below:
                case GET_PARAMETER:
//flaw_line_below:
                    err = getParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_PARAMETER:
//flaw_line_below:
                    err = setParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case GET_CONFIG:
//flaw_line_below:
                    err = getConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_CONFIG:
//flaw_line_below:
                    err = setConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_INTERNAL_OPTION:
//flaw_line_below:
                {
//flaw_line_below:
                    InternalOptionType type =
//flaw_line_below:
                        (InternalOptionType)data.readInt32();
//fix_flaw_line_below:
//                            err = setInternalOption(node, index, type, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        }
 
//flaw_line_below:
                    err = setInternalOption(node, index, type, params, size);
//flaw_line_below:
                    break;
//fix_flaw_line_below:
//                        default:
//fix_flaw_line_below:
//                            TRESPASS();
//fix_flaw_line_below:
//                    }
                 }
//flaw_line_below:

//flaw_line_below:
                default:
//flaw_line_below:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187915,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The vulnerability in the original code arises from the use of `malloc(size)` to allocate memory for `params` without validating the size, which could lead to a buffer overflow if an attacker sends a maliciously crafted `Parcel` containing a large size value. This could allow for arbitrary code execution or memory corruption. In the fixed code, the allocation is changed to `calloc(size, 1)`, which initializes the allocated memory to zero, and the code checks if the allocation was successful before proceeding to read data into `params`. Additionally, error handling is added to log an error if reading fails, enhancing overall security.","The vulnerability in the original code stems from the use of dynamic memory allocation without proper validation of the requested size, which could lead to buffer overflows if an attacker provides a malicious input. This oversight allows for potential memory corruption or arbitrary code execution. In the revised code, the allocation method is changed to ensure that the memory is initialized to zero, and it includes a check to confirm that the allocation was successful before proceeding with data reading. Additionally, error handling is implemented to log issues if reading fails, thereby enhancing the overall security of the code.",4,5,4,3,"CWE-119,CWE-789,CWE-401,CWE-131,CWE-476,CWE-122,CWE-787,CWE-120,CWE-20,CWE-754",N,-1
87,87,87,187916,187916,,Remote,Not required,Complete,CVE-2016-2416,https://www.cvedetails.com/cve/CVE-2016-2416/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"libs/gui/BufferQueueConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for the android.permission.DUMP permission, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via a dump request, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27046057.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,"Add SN logging

Bug 27046057

Change-Id: Iede7c92e59e60795df1ec7768ebafd6b090f1c27
",0,libs/gui/BufferQueueConsumer.cpp,"{""filename"": ""libs/gui/BufferQueueConsumer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/libs/gui/BufferQueueConsumer.cpp"", ""patch"": ""@@ -529,6 +529,7 @@\n\n             \""android.permission.DUMP\""), pid, uid)) {\n         result.appendFormat(\""Permission Denial: can't dump BufferQueueConsumer \""\n                 \""from pid=%d, uid=%d\\n\"", pid, uid);\n+        android_errorWriteWithInfoLog(0x534e4554, \""27046057\"", uid, NULL, 0);\n     } else {\n         mCore->dump(result, prefix);\n     }\n""}","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
",C,"        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
",,,"@@ -529,6 +529,7 @@

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
+        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
",Android,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a%5E/,1,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
",187916,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","The vulnerability in the original code lies in the lack of logging for unauthorized access attempts to the `BufferQueueConsumer::dump` function. When a user without the necessary permissions tries to access this function, the code only appends a denial message to the `result` string, failing to record the incident for further analysis. The fixed code addresses this issue by adding the line `android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);`, which logs the unauthorized access attempt, including the user ID (`uid`), thereby enhancing security and enabling better tracking of permission violations.","The vulnerability in the original code stems from its failure to log unauthorized access attempts when a user without the necessary permissions tries to execute a specific function. This lack of logging means that potential security breaches go unrecorded, making it difficult to track and analyze unauthorized access incidents. The revised code addresses this issue by incorporating a logging mechanism that captures details of the unauthorized attempt, including the users identity. This enhancement not only improves security by providing a record of permission violations but also aids in monitoring and responding to potential threats more effectively.",4,5,3,4,"CWE-778, CWE-223, CWE-532, CWE-778, CWE-424, CWE-693, CWE-612, CWE-117, CWE-779, CWE-402",N,-1
88,88,88,187928,187928,,Local,Not required,Complete,CVE-2016-0846,https://www.cvedetails.com/cve/CVE-2016-0846/,CWE-264,Low,Complete,Complete,,2016-04-17,7.2,"libs/binder/IMemory.cpp in the IMemory Native Interface in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider the heap size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26877992.",2017-09-07,+Priv ,14,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149,f3199c228aced7858b75a8070b8358c155ae0149,"Sanity check IMemory access versus underlying mmap

Bug 26877992

Change-Id: Ibbf4b1061e4675e4e96bc944a865b53eaf6984fe
",3,libs/binder/IMemory.cpp,"{""filename"": ""libs/binder/IMemory.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/libs/binder/IMemory.cpp"", ""patch"": ""@@ -26,6 +26,7 @@\n\n #include <sys/mman.h>\n \n #include <binder/IMemory.h>\n+#include <cutils/log.h>\n #include <utils/KeyedVector.h>\n #include <utils/threads.h>\n #include <utils/Atomic.h>\n@@ -187,15 +188,26 @@\n\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n-                    mOffset = o;\n-                    mSize = s;\n+                    size_t heapSize = mHeap->getSize();\n+                    if (s <= heapSize\n+                            && o >= 0\n+                            && (static_cast<size_t>(o) <= heapSize - s)) {\n+                        mOffset = o;\n+                        mSize = s;\n+                    } else {\n+                        // Hm.\n+                        android_errorWriteWithInfoLog(0x534e4554,\n+                            \""26877992\"", -1, NULL, 0);\n+                        mOffset = 0;\n+                        mSize = 0;\n+                    }\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n-    return mHeap;\n+    return (mSize > 0) ? mHeap : 0;\n }\n \n // ---------------------------------------------------------------------------\n""}","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
",C,"                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
    return (mSize > 0) ? mHeap : 0;
","                    mOffset = o;
                    mSize = s;
    return mHeap;
",,"@@ -26,6 +26,7 @@

 #include <sys/mman.h>
 
 #include <binder/IMemory.h>
+#include <cutils/log.h>
 #include <utils/KeyedVector.h>
 #include <utils/threads.h>
 #include <utils/Atomic.h>
@@ -187,15 +188,26 @@

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
-                    mOffset = o;
-                    mSize = s;
+                    size_t heapSize = mHeap->getSize();
+                    if (s <= heapSize
+                            && o >= 0
+                            && (static_cast<size_t>(o) <= heapSize - s)) {
+                        mOffset = o;
+                        mSize = s;
+                    } else {
+                        // Hm.
+                        android_errorWriteWithInfoLog(0x534e4554,
+                            ""26877992"", -1, NULL, 0);
+                        mOffset = 0;
+                        mSize = 0;
+                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
-    return mHeap;
+    return (mSize > 0) ? mHeap : 0;
 }
 
 // ---------------------------------------------------------------------------
",Android,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149%5E/,1,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
//flaw_line_below:
                    mOffset = o;
//flaw_line_below:
                    mSize = s;
//fix_flaw_line_below:
//                    size_t heapSize = mHeap->getSize();
//fix_flaw_line_below:
//                    if (s <= heapSize
//fix_flaw_line_below:
//                            && o >= 0
//fix_flaw_line_below:
//                            && (static_cast<size_t>(o) <= heapSize - s)) {
//fix_flaw_line_below:
//                        mOffset = o;
//fix_flaw_line_below:
//                        mSize = s;
//fix_flaw_line_below:
//                    } else {
//fix_flaw_line_below:
//                        // Hm.
//fix_flaw_line_below:
//                        android_errorWriteWithInfoLog(0x534e4554,
//fix_flaw_line_below:
//                            ""26877992"", -1, NULL, 0);
//fix_flaw_line_below:
//                        mOffset = 0;
//fix_flaw_line_below:
//                        mSize = 0;
//fix_flaw_line_below:
//                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
//flaw_line_below:
    return mHeap;
//fix_flaw_line_below:
//    return (mSize > 0) ? mHeap : 0;
 }
",187928,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","The vulnerability in the original code lies in the lack of validation for the values of `o` (offset) and `s` (size) after they are read from the `reply` object. This could allow an attacker to specify arbitrary values, potentially leading to buffer overflows or memory corruption. The fixed code addresses this vulnerability by introducing checks to ensure that `s` does not exceed the actual size of the memory heap (`heapSize`), that `o` is non-negative, and that the offset plus size does not exceed the heap's bounds. If these conditions are not met, it resets `mOffset` and `mSize` to zero and logs an error.","The vulnerability in the original code stems from the absence of validation for the offset and size values obtained from a remote transaction. This oversight allows an attacker to manipulate these values, potentially leading to buffer overflows or memory corruption, as the code does not ensure that the specified range is safe. The revised code rectifies this issue by implementing checks to confirm that the size does not exceed the actual memory limits and that the offset is valid. If the conditions are violated, the code resets the offset and size to zero and logs an error, enhancing overall security.",2,5,4,3,"CWE-119,CWE-131,CWE-789,CWE-823,CWE-129,CWE-130,CWE-787,CWE-125,CWE-788,CWE-120",N,-1
89,89,89,187958,187958,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",1,services/camera/libcameraservice/CameraService.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",C,"            client->dumpClient(fd, args);
","            client->dump(fd, args);
",,"@@ -985,6 +985,14 @@

     mClientPid = 0;
 }
 
+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {
+    // No dumping of clients directly over Binder,
+    // must go through CameraService::dump
+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, ""26265403"",
+            IPCThreadState::self()->getCallingUid(), NULL, 0);
+    return OK;
+}
+
 status_t CameraService::BasicClient::startCameraOps() {
     int32_t res;
 
@@ -1222,7 +1230,7 @@

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
-            client->dump(fd, args);
+            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 // failed to lock - CameraService is probably deadlocked
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
//flaw_line_below:
            client->dump(fd, args);
//fix_flaw_line_below:
//            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

 // Dump camera traces if there were any
        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 // change logging level
 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",187958,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","The vulnerability in the original code lies in the use of `client->dump(fd, args);`, which could potentially allow a malicious client to execute arbitrary code or access sensitive information if the client is not properly validated. This could lead to unauthorized access to camera resources or data. In the fixed code, the function call was changed to `client->dumpClient(fd, args);`, which likely implements additional security checks or restrictions, ensuring that only authorized clients can access the camera service's dump functionality, thereby mitigating the risk of exploitation and enhancing overall security.","The vulnerability in the original code stems from the lack of proper validation for client instances, which could allow unauthorized access to sensitive camera information or functionality. This could lead to potential exploitation by malicious clients, enabling them to execute arbitrary actions or retrieve confidential data. The fix in the updated code addresses this issue by modifying the method used to interact with client instances, likely incorporating additional security checks or restrictions. This change ensures that only authorized clients can access the camera service's functionalities, thereby enhancing the overall security and integrity of the system.",4,4,4,5,"CWE-284,CWE-285,CWE-287,CWE-306,CWE-288,CWE-522,CWE-346,CWE-923,CWE-200,CWE-732",N,-1
90,90,90,187959,187959,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/Camera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",C,"    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -158,6 +158,10 @@

 }
 
 status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",187959," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
","The vulnerability in the original `Camera2Client::dump` function arises from its extensive logging of sensitive camera parameters, such as GPS coordinates and client information, which could be exploited by an attacker to gain unauthorized access to private data. This exposure could lead to privacy violations or security breaches. In the fixed code, the `dump` function has been modified to call `BasicClient::dump(fd, args)` instead, effectively delegating the logging responsibility to a more secure implementation. This change minimizes the risk of sensitive data exposure by reducing the amount of information logged directly in `Camera2Client`.","The vulnerability in the original code stems from its extensive logging of sensitive information, including client details and camera parameters, which could be exploited by malicious actors to access private data. This excessive exposure poses significant privacy and security risks. In the revised code, the logging functionality has been streamlined by delegating the dump operation to a more secure implementation. This change effectively reduces the amount of sensitive information logged, thereby mitigating the risk of unauthorized access and enhancing the overall security posture of the application.",4,5,4,4,"CWE-532, CWE-200, CWE-359, CWE-540, CWE-497, CWE-117, CWE-215, CWE-779, CWE-209, CWE-732",N,-1
91,91,91,187960,187960,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/CameraClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -112,6 +112,10 @@

 }
 
 status_t CameraClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",187960," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
","The vulnerability in the original `CameraClient::dump` function arises from the potential for a buffer overflow when using `snprintf` to write formatted data into the `buffer` array. If the formatted string exceeds the defined `SIZE` of 256 bytes, it could lead to memory corruption or crashes. The fix involves moving the buffer handling code to a new function, `dumpClient`, while `CameraClient::dump` now simply calls `BasicClient::dump`. This change encapsulates the buffer management in a separate function, reducing the risk of overflow and improving code maintainability.","The vulnerability in the original code stems from the potential for a buffer overflow due to improper handling of string formatting and writing to a fixed-size buffer. If the formatted output exceeds the allocated space, it could overwrite adjacent memory, leading to undefined behavior, crashes, or security exploits. The fix addresses this issue by separating the buffer management into a new function, which isolates the risky operations. The main function now delegates the task to a more secure implementation, effectively reducing the risk of overflow and enhancing overall code safety and maintainability.",4,4,3,4,"CWE-120, CWE-787, CWE-119, CWE-121, CWE-122, CWE-134, CWE-788, CWE-242, CWE-680, CWE-131",N,-1
92,92,92,187961,187961,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api2/CameraDeviceClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -480,6 +480,10 @@

 }
 
 status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187961," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The vulnerability in the original `CameraDeviceClient::dump` function stemmed from its direct handling of the `fd` and `args` parameters, which could lead to improper data exposure or manipulation, potentially allowing unauthorized access to sensitive information. The fixed code addresses this issue by delegating the dump operation to `BasicClient::dump`, which likely implements more secure handling of these parameters. Additionally, the original functionality is preserved in a separate `dumpClient` method, ensuring that sensitive operations are encapsulated and managed appropriately, thereby enhancing the overall security of the code.","The vulnerability in the original code arose from the direct exposure of sensitive information through a method that handled parameters without adequate security measures, potentially allowing unauthorized access or manipulation of data. This could lead to information leaks or exploitation by malicious actors. The fixed code mitigates this risk by delegating the dump operation to a more secure method that likely incorporates better access controls and data handling practices. Additionally, the original functionality is preserved in a separate method, ensuring that sensitive operations are managed appropriately while enhancing the overall security posture of the application.",4,4,2,2,"CWE-200, CWE-213, CWE-552, CWE-732, CWE-285, CWE-269, CWE-668, CWE-284, CWE-311, CWE-312",N,-1
93,93,93,187962,187962,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api_pro/ProCamera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -331,6 +331,10 @@

 }
 
 status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187962," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The vulnerability in the original `ProCamera2Client::dump` function stemmed from its direct handling of the dump operation, which could potentially expose sensitive information about the camera client, such as `mCameraId` and `mClientPid`, through the `result` string. This could lead to information leakage if the dump output was accessible to unauthorized users. The fix involved separating the dump functionality into `dumpClient`, which encapsulates the sensitive operations, while the `dump` function now simply calls `BasicClient::dump`, thereby reducing the risk of exposing sensitive data and ensuring that only authorized components can access detailed client information.","The vulnerability in the original code arose from the direct exposure of sensitive information during the dump operation, which could be accessed by unauthorized users, potentially leading to information leakage. This included details about the clients state and identity, which should be protected. The fix involved restructuring the code to separate the sensitive dump logic into a different function, ensuring that the main dump function no longer directly handles sensitive data. This change limits access to critical information, thereby enhancing security by ensuring that only authorized components can retrieve detailed client information.",3,5,2,2,"CWE-200, CWE-532, CWE-359, CWE-552, CWE-538, CWE-522, CWE-312, CWE-319, CWE-668, CWE-269",N,-1
94,94,94,187986,187986,,Local Network,Not required,Complete,CVE-2016-0809,https://www.cvedetails.com/cve/CVE-2016-0809/,CWE-264,Low,Complete,Complete,,2016-02-06,8.3,"Use-after-free vulnerability in the wifi_cleanup function in bcmdhd/wifi_hal/wifi_hal.cpp in Wi-Fi in Android 6.x before 2016-02-01 allows attackers to gain privileges by leveraging access to the local physical environment during execution of a crafted application, aka internal bug 25753768.",2016-03-14,+Priv ,2,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,"Fix use-after-free in wifi_cleanup()

Release reference to cmd only after possibly calling getType().


BUG: 25753768
Change-Id: Id2156ce51acec04e8364706cf7eafc7d4adae9eb
(cherry picked from commit d7f3cb9915d9ac514393d0ad7767662958054b8f https://googleplex-android-review.git.corp.google.com/#/c/815223)
",2,bcmdhd/wifi_hal/wifi_hal.cpp,"{""filename"": ""bcmdhd/wifi_hal/wifi_hal.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/bcmdhd/wifi_hal/wifi_hal.cpp"", ""patch"": ""@@ -335,12 +335,12 @@\n\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n-            /* release reference added when command is saved */\n-            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\""Cancelling command %p:%s did not work\"", cmd, (cmd ? cmd->getType(): \""\""));\n                 bad_commands++;\n             }\n+            /* release reference added when command is saved */\n+            cmd->releaseRef();\n         }\n     }\n \n""}","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",C,"            /* release reference added when command is saved */
            cmd->releaseRef();
","            /* release reference added when command is saved */
            cmd->releaseRef();
",,"@@ -335,12 +335,12 @@

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
-            /* release reference added when command is saved */
-            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
+            /* release reference added when command is saved */
+            cmd->releaseRef();
         }
     }
 
",Android,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1%5E/,1,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
 // As a fallback set the cleanup flag to TRUE
        ALOGE(""could not write to the cleanup socket"");
 } else {
 // Listen to the response
 // Hopefully we dont get errors or get hung up
 // Not much can be done in that case, but assume that
 // it has rx'ed the Exit message to exit the thread.
 // As a fallback set the cleanup flag to TRUE
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
//flaw_line_below:
            /* release reference added when command is saved */
//flaw_line_below:
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
//fix_flaw_line_below:
//            /* release reference added when command is saved */
//fix_flaw_line_below:
//            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",187986,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","The vulnerability in the original code lies in the order of operations within the `wifi_cleanup` function, specifically regarding the handling of the `cmd->releaseRef()` call. In the vulnerable code, this reference release occurs after the check for whether the command was successfully canceled, which could lead to a use-after-free scenario if the command is accessed after being released. The fixed code addresses this by moving the `cmd->releaseRef()` call to occur after the command cancellation check, ensuring that the command is not accessed after its reference has been released, thus preventing potential memory corruption or crashes.","The vulnerability in the original code stems from the improper management of resource references, which could lead to a use-after-free condition. Specifically, the code released a reference to a command before confirming that the command had been successfully canceled, allowing for potential access to freed memory. This could result in undefined behavior, crashes, or security issues. The fixed code resolves this vulnerability by rearranging the order of operations, ensuring that the reference is only released after confirming the command's cancellation, thereby preventing any access to memory that has already been freed and enhancing overall stability.",2,5,4,4,"CWE-416,CWE-825,CWE-672,CWE-415,CWE-911,CWE-665,CWE-401,CWE-822,CWE-119,CWE-913",N,-1
95,95,95,187990,187990,,Local,Not required,Complete,CVE-2016-0807,https://www.cvedetails.com/cve/CVE-2016-0807/,CWE-264,Low,Complete,Complete,,2016-02-06,7.2,"The get_build_id function in elf_utils.cpp in Debuggerd in Android 6.x before 2016-02-01 allows attackers to gain privileges via a crafted application that mishandles a Desc Size element in an ELF Note, aka internal bug 25187394.",2016-03-11,+Priv ,4,https://android.googlesource.com/platform%2Fsystem%2Fcore/+/d917514bd6b270df431ea4e781a865764d406120,d917514bd6b270df431ea4e781a865764d406120,"Fix incorrect check of descsz value.

Bug: 25187394

(cherry picked from commit 1fa55234d6773e09e3bb934419b5b6cc0df981c9)

Change-Id: Idbc9071e8b2b25a062c4e94118808d6e19d443d9
",4,debuggerd/elf_utils.cpp,"{""filename"": ""debuggerd/elf_utils.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/debuggerd/elf_utils.cpp"", ""patch"": ""@@ -63,10 +63,10 @@\n\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           // Skip the name (which is the owner and should be \""GNU\"").\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n-          uint8_t build_id_data[128];\n-          if (nhdr.n_namesz > sizeof(build_id_data)) {\n-            ALOGE(\""Possible corrupted note, name size value is too large: %u\"",\n-                  nhdr.n_namesz);\n+          uint8_t build_id_data[160];\n+          if (nhdr.n_descsz > sizeof(build_id_data)) {\n+            ALOGE(\""Possible corrupted note, desc size value is too large: %u\"",\n+                  nhdr.n_descsz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n""}","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",C,"          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
","          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
",,"@@ -63,10 +63,10 @@

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
-          uint8_t build_id_data[128];
-          if (nhdr.n_namesz > sizeof(build_id_data)) {
-            ALOGE(""Possible corrupted note, name size value is too large: %u"",
-                  nhdr.n_namesz);
+          uint8_t build_id_data[160];
+          if (nhdr.n_descsz > sizeof(build_id_data)) {
+            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
+                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
",Android,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120%5E/,1,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 // First read the rest of the header.
 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 // Looking for the .note.gnu.build-id note.
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
//flaw_line_below:
          uint8_t build_id_data[128];
//flaw_line_below:
          if (nhdr.n_namesz > sizeof(build_id_data)) {
//flaw_line_below:
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
//flaw_line_below:
                  nhdr.n_namesz);
//fix_flaw_line_below:
//          uint8_t build_id_data[160];
//fix_flaw_line_below:
//          if (nhdr.n_descsz > sizeof(build_id_data)) {
//fix_flaw_line_below:
//            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
//fix_flaw_line_below:
//                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
 // Move past the extra note data.
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",187990,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","The vulnerability in the original code stemmed from the fixed-size array `build_id_data[128]`, which could lead to a buffer overflow if `nhdr.n_descsz` exceeded 128 bytes. This could allow an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution or data corruption. In the fixed code, the size of `build_id_data` was increased to 160 bytes, providing a larger buffer to accommodate potential larger sizes of `nhdr.n_descsz`. Additionally, the error message was updated to reflect the correct context, enhancing the clarity of the logging for potential corruption issues.","The vulnerability in the original code was due to a fixed-size buffer that could lead to a buffer overflow if the size of the data being read exceeded the allocated space. This could allow an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution or data corruption. In the revised code, the buffer size was increased to accommodate larger data, thereby reducing the risk of overflow. Additionally, the error handling was improved to provide clearer logging for potential corruption issues, enhancing the overall robustness and security of the code.",2,4,3,4,"CWE-119, CWE-120, CWE-121, CWE-122, CWE-131, CWE-788, CWE-787, CWE-789, CWE-680, CWE-190",N,-1
96,96,96,187994,187994,,Remote,Not required,Complete,CVE-2015-6640,https://www.cvedetails.com/cve/CVE-2015-6640/,CWE-264,Medium,Complete,Complete,,2016-01-06,9.3,"The prctl_set_vma_anon_name function in kernel/sys.c in Android before 5.1.1 LMY49F and 6.0 before 2016-01-01 does not ensure that only one vma is accessed in a certain update action, which allows attackers to gain privileges or cause a denial of service (vma list corruption) via a crafted application, aka internal bug 20017123.",2016-12-07,DoS +Priv ,1,https://android.googlesource.com/kernel%2Fcommon/+/69bfe2d957d903521d32324190c2754cb073be15,69bfe2d957d903521d32324190c2754cb073be15,"mm: fix prctl_set_vma_anon_name

prctl_set_vma_anon_name could attempt to set the name across
two vmas at the same time due to a typo, which might corrupt
the vma list.  Fix it to use tmp instead of end to limit
the name setting to a single vma at a time.

Change-Id: Ie32d8ddb0fd547efbeedd6528acdab5ca5b308b4
Reported-by: Jed Davis <jld@mozilla.com>
Signed-off-by: Colin Cross <ccross@android.com>
",1,kernel/sys.c,"{""filename"": ""kernel/sys.c"", ""raw_url"": ""https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/kernel/sys.c"", ""patch"": ""@@ -1934,7 +1934,7 @@\n\n \t\t\ttmp = end;\n \n \t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n-\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n+\t\terror = prctl_update_vma_anon_name(vma, &prev, start, tmp,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n""}","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",C,"		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
","		error = prctl_update_vma_anon_name(vma, &prev, start, end,
",,"@@ -1934,7 +1934,7 @@

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
-		error = prctl_update_vma_anon_name(vma, &prev, start, end,
+		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
",Android,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15%5E/,1,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
//flaw_line_below:
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
//fix_flaw_line_below:
//		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",187994,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","The vulnerability in the original code lies in the handling of the `end` variable during the call to `prctl_update_vma_anon_name`. Specifically, the code incorrectly uses `end` instead of `tmp`, which could lead to an out-of-bounds access if `end` exceeds the valid range of the virtual memory area (VMA). This could potentially allow for memory corruption or unauthorized access. In the fixed code, the call to `prctl_update_vma_anon_name` is updated to use `tmp` instead of `end`, ensuring that the function operates within the correct bounds of the VMA, thus mitigating the risk of such vulnerabilities.","The vulnerability in the original code arises from improper handling of memory boundaries, which could lead to out-of-bounds access during a specific function call. This flaw allows the potential for memory corruption or unauthorized access, as the code does not adequately ensure that the specified range remains within valid limits. The fix addresses this issue by adjusting the parameters passed to the function, ensuring that the range is correctly constrained to valid memory areas. This change effectively mitigates the risk of accessing memory outside the intended boundaries, enhancing the overall security and stability of the code.",2,5,2,4,"CWE-119, CWE-125, CWE-787, CWE-788, CWE-823, CWE-124, CWE-126, CWE-789, CWE-120, CWE-129",N,-1
97,97,97,188143,188143,,Remote,Not required,Complete,CVE-2015-3849,https://www.cvedetails.com/cve/CVE-2015-3849/,CWE-264,Medium,Complete,Complete,,2015-09-30,9.3,"The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255.",2015-10-01,Exec Code ,6,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,"DO NOT MERGE: Ensure that unparcelling Region only reads the expected number of bytes

bug: 20883006
Change-Id: I4f109667fb210a80fbddddf5f1bfb7ef3a02b6ce
",1,core/jni/android/graphics/Region.cpp,"{""filename"": ""core/jni/android/graphics/Region.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/core/jni/android/graphics/Region.cpp"", ""patch"": ""@@ -218,7 +218,12 @@\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n-    region->readFromMemory(regionData, size);\n+    size_t actualSize = region->readFromMemory(regionData, size);\n+\n+    if (size != actualSize) {\n+        delete region;\n+        return NULL;\n+    }\n \n     return reinterpret_cast<jlong>(region);\n }\n""}","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
",C,"    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
","    region->readFromMemory(regionData, size);
",,"@@ -218,7 +218,12 @@

         return NULL;
     }
     SkRegion* region = new SkRegion;
-    region->readFromMemory(regionData, size);
+    size_t actualSize = region->readFromMemory(regionData, size);
+
+    if (size != actualSize) {
+        delete region;
+        return NULL;
+    }
 
     return reinterpret_cast<jlong>(region);
 }
",Android,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3%5E/,1,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
//flaw_line_below:
    region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//    size_t actualSize = region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (size != actualSize) {
//fix_flaw_line_below:
//        delete region;
//fix_flaw_line_below:
//        return NULL;
//fix_flaw_line_below:
//    }
 
     return reinterpret_cast<jlong>(region);
 }
",188143,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","The vulnerability in the original code lies in the lack of validation for the size of the data read into the `SkRegion` object. Specifically, after calling `region->readFromMemory(regionData, size)`, there was no check to ensure that the actual size of the data read matched the expected `size`. This could lead to memory corruption or undefined behavior if the data was incomplete or malformed. The fixed code addresses this by introducing a check for `size != actualSize` after reading the memory. If the sizes do not match, the code safely deletes the `region` object and returns `NULL`, preventing potential exploitation.","The vulnerability in the original code stems from the lack of validation for the size of data being processed, which could lead to memory corruption or undefined behavior if the input data is incomplete or malformed. Specifically, the code reads data into a newly created object without confirming that the amount of data read matches the expected size. The fixed code addresses this issue by implementing a check to compare the expected size with the actual size of the data read. If there is a mismatch, the code safely cleans up the allocated memory and returns an error, thereby preventing potential exploitation.",3,5,4,4,"CWE-131,CWE-119,CWE-789,CWE-122,CWE-787,CWE-120,CWE-788,CWE-400,CWE-130,CWE-20",N,-1
98,98,98,188170,188170,,Remote,Not required,Complete,CVE-2016-3909,https://www.cvedetails.com/cve/CVE-2016-3909/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990.",2016-11-28,+Priv ,2,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba,c48ef757cc50906e8726a3bebc3b60716292cdba,"Fix build breakage caused by commit
940829f69b52d6038db66a9c727534636ecc456d.

Change-Id: I4776db4a26fb3c31bb994d48788373fe569c812a
(cherry picked from commit baa9146401e28c5acf54dea21ddd197f0d3a8fcd)
",2,media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp,"{""filename"": ""media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""patch"": ""@@ -213,8 +213,8 @@\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n-                ALOGE(\""Too small output buffer for reference frame: %zu bytes\"",\n-                        outHeader->nAllocLen);\n+                ALOGE(\""Too small output buffer for reference frame: %lu bytes\"",\n+                        (unsigned long)outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \""30033990\"");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n""}","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",C,"                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
","                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
",,"@@ -213,8 +213,8 @@

             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
-                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
-                        outHeader->nAllocLen);
+                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
+                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba%5E/,1,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
//flaw_line_below:
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
//flaw_line_below:
                        outHeader->nAllocLen);
//fix_flaw_line_below:
//                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
//fix_flaw_line_below:
//                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 // decoder deals in ms (int32_t), OMX in us (int64_t)
 // so use fake timestamp instead
 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 // The PV decoder is lying to us, sometimes it'll claim to only have
 // consumed a subset of the buffer when it clearly consumed all of it.
 // ignore whatever it says...
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 // H263 doesn't have VOL header, the frame size information is in short header, i.e. the
 // decoder may detect size change after PVDecodeVideoFrame.
 if (handlePortSettingsChange()) {
 return;
 }

 // decoder deals in ms, OMX in us.
        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",188170,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","The vulnerability in the original code lies in the handling of the output buffer size, specifically in the check for `outHeader->nAllocLen` against `frameSize`. If `outHeader->nAllocLen` is less than `frameSize`, the code logs an error and signals an error state, but it does not prevent further processing, which could lead to buffer overflows or undefined behavior. The fix ensures that the error handling is robust by adding a check for the output buffer size before proceeding with the decoding process, thus preventing potential memory corruption and ensuring that the application behaves correctly under all conditions.","The vulnerability in the original code stems from inadequate checks on buffer sizes, which could lead to buffer overflows or memory corruption during processing. Specifically, the code fails to properly validate the output buffer's allocated length against the required size before proceeding with operations that assume sufficient space is available. The fix addresses this issue by implementing a more stringent validation step that ensures the output buffer is appropriately sized before any decoding or data manipulation occurs, thereby enhancing the overall stability and security of the application by preventing potential crashes or undefined behavior.",2,5,4,4,"CWE-119, CWE-120, CWE-131, CWE-789, CWE-788, CWE-787, CWE-122, CWE-129, CWE-191, CWE-680",N,-1
99,99,99,188178,188178,,Remote,Not required,Complete,CVE-2016-3871,https://www.cvedetails.com/cve/CVE-2016-3871/,CWE-264,Medium,Complete,Complete,,2016-09-11,9.3,"Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022.",2017-08-12,Overflow +Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,"Fix build

Change-Id: I48ba34b3df9c9a896d4b18c3f48e41744b7dab54
",1,media/libstagefright/codecs/mp3dec/SoftMP3.cpp,"{""filename"": ""media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""patch"": ""@@ -122,7 +122,7 @@\n\n \n void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n-        ALOGE(\""memset buffer too small: got %lu, expected %zu\"", (unsigned long)outHeader->nAllocLen, len);\n+        ALOGE(\""memset buffer too small: got %u, expected %zu\"", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \""29422022\"");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n""}"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",C,"        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
","        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
",,"@@ -122,7 +122,7 @@

 
 void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
-        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
+        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad%5E/,1," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
//flaw_line_below:
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
//fix_flaw_line_below:
//        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",188178," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
","The vulnerability in the original code lies in the use of the format specifier `%lu` for logging the value of `outHeader->nAllocLen`, which is of type `size_t`. This can lead to incorrect output on platforms where `size_t` is not equivalent to `unsigned long`, potentially causing confusion or misinterpretation of the buffer size. The fixed code addresses this issue by changing the format specifier to `%u`, which correctly matches the type of `outHeader->nAllocLen` when it is cast to an unsigned integer, ensuring accurate logging and reducing the risk of miscommunication regarding buffer sizes.","The vulnerability in the original code stems from the incorrect use of a format specifier for logging, which can lead to misrepresentation of data types. Specifically, using a format specifier that does not match the actual type of the variable can result in undefined behavior or incorrect output, potentially causing confusion during debugging or error handling. The fixed code resolves this issue by updating the format specifier to align with the variable's type, ensuring that the logged information accurately reflects the intended values and reducing the risk of misinterpretation or errors in the logging process.",4,5,4,4,"CWE-134, CWE-704, CWE-843, CWE-755, CWE-457, CWE-119, CWE-628, CWE-502, CWE-170, CWE-843",N,-1
100,100,100,188253,188253,,Remote,Not required,Complete,CVE-2016-2452,https://www.cvedetails.com/cve/CVE-2016-2452/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673.",2016-05-10,+Priv ,24,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f,65756b4082cd79a2d99b2ccb5b392291fd53703f,"SoftAMR: check input buffer size to avoid overflow.

Bug: 27662364
Change-Id: I47380545ea7d85845e141e722b0d84f498d27145
",1,media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp,"{""filename"": ""media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""patch"": ""@@ -286,6 +286,13 @@\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n+        if (inHeader->nFilledLen == 0) {\n+            inInfo->mOwnedByUs = false;\n+            inQueue.erase(inQueue.begin());\n+            notifyEmptyBufferDone(inHeader);\n+            continue;\n+        }\n+\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n@@ -321,6 +328,17 @@\n\n                 return;\n             }\n \n+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n+            // for WMF since MIME_IETF is used when calling AMRDecode.\n+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n+\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n+\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n@@ -370,7 +388,12 @@\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n-            CHECK_GE(inHeader->nFilledLen, frameSize);\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""patch"": ""@@ -104,7 +104,6 @@\n\n ; INCLUDES\n ----------------------------------------------------------------------------*/\n #include    \""typedef.h\""\n-#include    \""mode.h\""\n #include    \""frame_type_3gpp.h\""\n \n /*--------------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""patch"": ""@@ -87,6 +87,7 @@\n\n \n #include \""gsm_amr_typedefs.h\""\n #include \""frame_type_3gpp.h\""\n+#include \""amrdecode.h\""\n \n /*--------------------------------------------------------------------------*/\n #ifdef __cplusplus\n@@ -136,19 +137,6 @@\n\n                          Word8 *id);\n \n     /*\n-     * AMRDecode steps into the part of the library that decodes the raw data\n-     * speech bits for the decoding process. It returns the address offset of\n-     * the next frame to be decoded.\n-     */\n-    Word16 AMRDecode(\n-        void                      *state_data,\n-        enum Frame_Type_3GPP      frame_type,\n-        UWord8                    *speech_bits_ptr,\n-        Word16                    *raw_pcm_buffer,\n-        Word16                    input_format\n-    );\n-\n-    /*\n      * This function resets the state memory used by the GSM AMR decoder. This\n      * function returns zero. It will return negative one if there is an error.\n      */\n""}","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",C,"        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
","            CHECK_GE(inHeader->nFilledLen, frameSize);
",,"@@ -286,6 +286,13 @@

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
+        if (inHeader->nFilledLen == 0) {
+            inInfo->mOwnedByUs = false;
+            inQueue.erase(inQueue.begin());
+            notifyEmptyBufferDone(inHeader);
+            continue;
+        }
+
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
@@ -321,6 +328,17 @@

                 return;
             }
 
+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
+            // for WMF since MIME_IETF is used when calling AMRDecode.
+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
+
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
+
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
@@ -370,7 +388,12 @@

             }
 
             size_t frameSize = getFrameSize(mode);
-            CHECK_GE(inHeader->nFilledLen, frameSize);
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f%5E/,1,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
//fix_flaw_line_below:
//        if (inHeader->nFilledLen == 0) {
//fix_flaw_line_below:
//            inInfo->mOwnedByUs = false;
//fix_flaw_line_below:
//            inQueue.erase(inQueue.begin());
//fix_flaw_line_below:
//            notifyEmptyBufferDone(inHeader);
//fix_flaw_line_below:
//            continue;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
//fix_flaw_line_below:
//            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
//fix_flaw_line_below:
//            // for WMF since MIME_IETF is used when calling AMRDecode.
//fix_flaw_line_below:
//            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {
 // This is bad, should never have happened, but did. Abort now.

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
//flaw_line_below:
            CHECK_GE(inHeader->nFilledLen, frameSize);
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
 // Produce silence instead of comfort noise and for
 // speech lost/no data.
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",188253,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","The vulnerability in the original code arises from insufficient checks on the `inHeader->nFilledLen` before processing the input buffer, which could lead to buffer overflows or undefined behavior if the input data is smaller than expected. Specifically, the code does not verify that `inHeader->nFilledLen` is adequate for the frame size required by the decoder, potentially allowing the `AMRDecode` function to read beyond the allocated buffer. The fix introduces checks to ensure that `inHeader->nFilledLen` is compared against the expected `frameSize` before proceeding with decoding, thus preventing potential memory corruption and ensuring safer buffer handling.","The vulnerability in the original code stems from inadequate validation of input buffer sizes before processing, which could lead to buffer overflows or undefined behavior. Specifically, the code fails to ensure that the input buffer contains enough data for the decoding operation, allowing the decoder to read beyond the allocated memory. The fix addresses this issue by implementing checks to verify that the input buffer's size is sufficient for the expected data before any decoding occurs. This enhancement prevents potential memory corruption and ensures safer handling of input data, thereby improving overall code stability and security.",3,5,5,5,"CWE-119, CWE-120, CWE-788, CWE-125, CWE-131, CWE-789, CWE-680, CWE-122, CWE-20, CWE-129",N,-1
