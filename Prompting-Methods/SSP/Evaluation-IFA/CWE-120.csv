,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,F1_Clarity_C5,F2_Relevance_C5,F3_Completeness_C5,F4_Actionability_C5,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,0,182672,182672,,Remote,Not required,Partial,CVE-2019-17113,https://www.cvedetails.com/cve/CVE-2019-17113/,CWE-120,Low,Partial,Partial,,2019-10-03,7.5,"In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow.",2019-10-10,Overflow ,7,https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe,927688ddab43c2b203569de79407a899e734fabe,"[Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team)

git-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@12127 56274372-70c3-4bfc-bfc3-4c3a0b034d27",16,libopenmpt/libopenmpt_modplug.c,"{""sha"": ""da13edc3f46b224ecb223e9316f06825ee4b7e75"", ""filename"": ""libopenmpt/libopenmpt_modplug.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 32, ""changes"": 46, ""blob_url"": ""https://github.com/OpenMPT/openmpt/blob/927688ddab43c2b203569de79407a899e734fabe/libopenmpt/libopenmpt_modplug.c"", ""raw_url"": ""https://github.com/OpenMPT/openmpt/raw/927688ddab43c2b203569de79407a899e734fabe/libopenmpt/libopenmpt_modplug.c"", ""contents_url"": ""https://api.github.com/repos/OpenMPT/openmpt/contents/libopenmpt/libopenmpt_modplug.c?ref=927688ddab43c2b203569de79407a899e734fabe"", ""patch"": ""@@ -478,53 +478,35 @@ LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)\n LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n-\tunsigned int retval;\n-\tsize_t tmpretval;\n+\tchar buf[32];\n \tif(!file) return 0;\n \tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n-\tif(!str){\n-\t\tif(buff){\n-\t\t\t*buff = '\\0';\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\ttmpretval = strlen(str);\n-\tif(tmpretval>=INT_MAX){\n-\t\ttmpretval = INT_MAX-1;\n+\tmemset(buf,0,32);\n+\tif(str){\n+\t\tstrncpy(buf,str,31);\n+\t\topenmpt_free_string(str);\n \t}\n-\tretval = (int)tmpretval;\n \tif(buff){\n-\t\tmemcpy(buff,str,retval+1);\n-\t\tbuff[retval] = '\\0';\n+\t\tstrncpy(buff,buf,32);\n \t}\n-\topenmpt_free_string(str);\n-\treturn retval;\n+\treturn (unsigned int)strlen(buf);\n }\n \n LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n-\tunsigned int retval;\n-\tsize_t tmpretval;\n+\tchar buf[32];\n \tif(!file) return 0;\n \tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n-\tif(!str){\n-\t\tif(buff){\n-\t\t\t*buff = '\\0';\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\ttmpretval = strlen(str);\n-\tif(tmpretval>=INT_MAX){\n-\t\ttmpretval = INT_MAX-1;\n+\tmemset(buf,0,32);\n+\tif(str){\n+\t\tstrncpy(buf,str,31);\n+\t\topenmpt_free_string(str);\n \t}\n-\tretval = (int)tmpretval;\n \tif(buff){\n-\t\tmemcpy(buff,str,retval+1);\n-\t\tbuff[retval] = '\\0';\n+\t\tstrncpy(buff,buf,32);\n \t}\n-\topenmpt_free_string(str);\n-\treturn retval;\n+\treturn (unsigned int)strlen(buf);\n }\n \n LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)""}"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	unsigned int retval;
	size_t tmpretval;
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
 	}
	retval = (int)tmpretval;
 	if(buff){
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
 	}
	openmpt_free_string(str);
	return retval;
 }
",C,"	char buf[32];
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
		strncpy(buff,buf,32);
	return (unsigned int)strlen(buf);
","	unsigned int retval;
	size_t tmpretval;
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
	retval = (int)tmpretval;
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
	openmpt_free_string(str);
	return retval;
",,"@@ -478,53 +478,35 @@ LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
-	unsigned int retval;
-	size_t tmpretval;
+	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
-	if(!str){
-		if(buff){
-			*buff = '\0';
-		}
-		return 0;
-	}
-	tmpretval = strlen(str);
-	if(tmpretval>=INT_MAX){
-		tmpretval = INT_MAX-1;
+	memset(buf,0,32);
+	if(str){
+		strncpy(buf,str,31);
+		openmpt_free_string(str);
 	}
-	retval = (int)tmpretval;
 	if(buff){
-		memcpy(buff,str,retval+1);
-		buff[retval] = '\0';
+		strncpy(buff,buf,32);
 	}
-	openmpt_free_string(str);
-	return retval;
+	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
-	unsigned int retval;
-	size_t tmpretval;
+	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
-	if(!str){
-		if(buff){
-			*buff = '\0';
-		}
-		return 0;
-	}
-	tmpretval = strlen(str);
-	if(tmpretval>=INT_MAX){
-		tmpretval = INT_MAX-1;
+	memset(buf,0,32);
+	if(str){
+		strncpy(buf,str,31);
+		openmpt_free_string(str);
 	}
-	retval = (int)tmpretval;
 	if(buff){
-		memcpy(buff,str,retval+1);
-		buff[retval] = '\0';
+		strncpy(buff,buf,32);
 	}
-	openmpt_free_string(str);
-	return retval;
+	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)",openmpt,927688ddab43c2b203569de79407a899e734fabe,47a3b0663202d3e8b3f2f6231052a344cd8134e3,1," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
//flaw_line_below:
	unsigned int retval;
//flaw_line_below:
	size_t tmpretval;
//fix_flaw_line_below:
//	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
//flaw_line_below:
	if(!str){
//flaw_line_below:
		if(buff){
//flaw_line_below:
			*buff = '\0';
//flaw_line_below:
		}
//flaw_line_below:
		return 0;
//flaw_line_below:
	}
//flaw_line_below:
	tmpretval = strlen(str);
//flaw_line_below:
	if(tmpretval>=INT_MAX){
//flaw_line_below:
		tmpretval = INT_MAX-1;
//fix_flaw_line_below:
//	memset(buf,0,32);
//fix_flaw_line_below:
//	if(str){
//fix_flaw_line_below:
//		strncpy(buf,str,31);
//fix_flaw_line_below:
//		openmpt_free_string(str);
 	}
//flaw_line_below:
	retval = (int)tmpretval;
 	if(buff){
//flaw_line_below:
		memcpy(buff,str,retval+1);
//flaw_line_below:
		buff[retval] = '\0';
//fix_flaw_line_below:
//		strncpy(buff,buf,32);
 	}
//flaw_line_below:
	openmpt_free_string(str);
//flaw_line_below:
	return retval;
//fix_flaw_line_below:
//	return (unsigned int)strlen(buf);
 }
",182672," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	unsigned int retval;
	size_t tmpretval;
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
 	}
	retval = (int)tmpretval;
 	if(buff){
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
 	}
	openmpt_free_string(str);
	return retval;
 }
"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
","The vulnerability in the original code arises from the use of `memcpy` to copy the instrument name into the `buff` variable without proper bounds checking, which could lead to a buffer overflow if the length of `str` exceeds the size of `buff`. Additionally, the code does not adequately handle cases where `str` is longer than `INT_MAX`, potentially causing undefined behavior. In the fixed code, the use of a temporary buffer `buf[32]` with `strncpy` ensures that only a maximum of 31 characters are copied, preventing overflow. The `buff` is also safely populated with the contents of `buf`, ensuring proper memory management.","The vulnerability in the original code stems from the lack of proper bounds checking when copying data into a buffer, which can lead to buffer overflow if the source string exceeds the buffer's capacity. This oversight can result in memory corruption, crashes, or potential exploitation by attackers. The fixed code addresses this issue by introducing a temporary buffer with a defined size and using a safer copying method that limits the number of characters copied. This ensures that the buffer is not overflowed, thereby enhancing the overall security and stability of the code.",4,5,3,5,"CWE-119, CWE-120, CWE-131, CWE-787, CWE-788, CWE-121, CWE-122, CWE-680, CWE-789, CWE-125",N,-1
1,1,1,182673,182673,,Remote,Not required,Partial,CVE-2019-17113,https://www.cvedetails.com/cve/CVE-2019-17113/,CWE-120,Low,Partial,Partial,,2019-10-03,7.5,"In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow.",2019-10-10,Overflow ,7,https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe,927688ddab43c2b203569de79407a899e734fabe,"[Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team)

git-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@12127 56274372-70c3-4bfc-bfc3-4c3a0b034d27",16,libopenmpt/libopenmpt_modplug.c,"{""sha"": ""da13edc3f46b224ecb223e9316f06825ee4b7e75"", ""filename"": ""libopenmpt/libopenmpt_modplug.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 32, ""changes"": 46, ""blob_url"": ""https://github.com/OpenMPT/openmpt/blob/927688ddab43c2b203569de79407a899e734fabe/libopenmpt/libopenmpt_modplug.c"", ""raw_url"": ""https://github.com/OpenMPT/openmpt/raw/927688ddab43c2b203569de79407a899e734fabe/libopenmpt/libopenmpt_modplug.c"", ""contents_url"": ""https://api.github.com/repos/OpenMPT/openmpt/contents/libopenmpt/libopenmpt_modplug.c?ref=927688ddab43c2b203569de79407a899e734fabe"", ""patch"": ""@@ -478,53 +478,35 @@ LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)\n LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n-\tunsigned int retval;\n-\tsize_t tmpretval;\n+\tchar buf[32];\n \tif(!file) return 0;\n \tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n-\tif(!str){\n-\t\tif(buff){\n-\t\t\t*buff = '\\0';\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\ttmpretval = strlen(str);\n-\tif(tmpretval>=INT_MAX){\n-\t\ttmpretval = INT_MAX-1;\n+\tmemset(buf,0,32);\n+\tif(str){\n+\t\tstrncpy(buf,str,31);\n+\t\topenmpt_free_string(str);\n \t}\n-\tretval = (int)tmpretval;\n \tif(buff){\n-\t\tmemcpy(buff,str,retval+1);\n-\t\tbuff[retval] = '\\0';\n+\t\tstrncpy(buff,buf,32);\n \t}\n-\topenmpt_free_string(str);\n-\treturn retval;\n+\treturn (unsigned int)strlen(buf);\n }\n \n LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n-\tunsigned int retval;\n-\tsize_t tmpretval;\n+\tchar buf[32];\n \tif(!file) return 0;\n \tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n-\tif(!str){\n-\t\tif(buff){\n-\t\t\t*buff = '\\0';\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\ttmpretval = strlen(str);\n-\tif(tmpretval>=INT_MAX){\n-\t\ttmpretval = INT_MAX-1;\n+\tmemset(buf,0,32);\n+\tif(str){\n+\t\tstrncpy(buf,str,31);\n+\t\topenmpt_free_string(str);\n \t}\n-\tretval = (int)tmpretval;\n \tif(buff){\n-\t\tmemcpy(buff,str,retval+1);\n-\t\tbuff[retval] = '\\0';\n+\t\tstrncpy(buff,buf,32);\n \t}\n-\topenmpt_free_string(str);\n-\treturn retval;\n+\treturn (unsigned int)strlen(buf);\n }\n \n LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)""}"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	unsigned int retval;
	size_t tmpretval;
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
 	}
	retval = (int)tmpretval;
 	if(buff){
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
 	}
	openmpt_free_string(str);
	return retval;
 }
",C,"	char buf[32];
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
		strncpy(buff,buf,32);
	return (unsigned int)strlen(buf);
","	unsigned int retval;
	size_t tmpretval;
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
	retval = (int)tmpretval;
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
	openmpt_free_string(str);
	return retval;
",,"@@ -478,53 +478,35 @@ LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
-	unsigned int retval;
-	size_t tmpretval;
+	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
-	if(!str){
-		if(buff){
-			*buff = '\0';
-		}
-		return 0;
-	}
-	tmpretval = strlen(str);
-	if(tmpretval>=INT_MAX){
-		tmpretval = INT_MAX-1;
+	memset(buf,0,32);
+	if(str){
+		strncpy(buf,str,31);
+		openmpt_free_string(str);
 	}
-	retval = (int)tmpretval;
 	if(buff){
-		memcpy(buff,str,retval+1);
-		buff[retval] = '\0';
+		strncpy(buff,buf,32);
 	}
-	openmpt_free_string(str);
-	return retval;
+	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
-	unsigned int retval;
-	size_t tmpretval;
+	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
-	if(!str){
-		if(buff){
-			*buff = '\0';
-		}
-		return 0;
-	}
-	tmpretval = strlen(str);
-	if(tmpretval>=INT_MAX){
-		tmpretval = INT_MAX-1;
+	memset(buf,0,32);
+	if(str){
+		strncpy(buf,str,31);
+		openmpt_free_string(str);
 	}
-	retval = (int)tmpretval;
 	if(buff){
-		memcpy(buff,str,retval+1);
-		buff[retval] = '\0';
+		strncpy(buff,buf,32);
 	}
-	openmpt_free_string(str);
-	return retval;
+	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)",openmpt,927688ddab43c2b203569de79407a899e734fabe,47a3b0663202d3e8b3f2f6231052a344cd8134e3,1," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
//flaw_line_below:
	unsigned int retval;
//flaw_line_below:
	size_t tmpretval;
//fix_flaw_line_below:
//	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
//flaw_line_below:
	if(!str){
//flaw_line_below:
		if(buff){
//flaw_line_below:
			*buff = '\0';
//flaw_line_below:
		}
//flaw_line_below:
		return 0;
//flaw_line_below:
	}
//flaw_line_below:
	tmpretval = strlen(str);
//flaw_line_below:
	if(tmpretval>=INT_MAX){
//flaw_line_below:
		tmpretval = INT_MAX-1;
//fix_flaw_line_below:
//	memset(buf,0,32);
//fix_flaw_line_below:
//	if(str){
//fix_flaw_line_below:
//		strncpy(buf,str,31);
//fix_flaw_line_below:
//		openmpt_free_string(str);
 	}
//flaw_line_below:
	retval = (int)tmpretval;
 	if(buff){
//flaw_line_below:
		memcpy(buff,str,retval+1);
//flaw_line_below:
		buff[retval] = '\0';
//fix_flaw_line_below:
//		strncpy(buff,buf,32);
 	}
//flaw_line_below:
	openmpt_free_string(str);
//flaw_line_below:
	return retval;
//fix_flaw_line_below:
//	return (unsigned int)strlen(buf);
 }
",182673," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	unsigned int retval;
	size_t tmpretval;
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	if(!str){
		if(buff){
			*buff = '\0';
		}
		return 0;
	}
	tmpretval = strlen(str);
	if(tmpretval>=INT_MAX){
		tmpretval = INT_MAX-1;
 	}
	retval = (int)tmpretval;
 	if(buff){
		memcpy(buff,str,retval+1);
		buff[retval] = '\0';
 	}
	openmpt_free_string(str);
	return retval;
 }
"," LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
","The vulnerability in the original code arises from the use of `memcpy` to copy the sample name into `buff` without proper bounds checking, which could lead to a buffer overflow if the sample name exceeds the allocated size of `buff`. Additionally, the code does not ensure that `buff` is large enough to hold the copied string, risking memory corruption. In the fixed code, the use of a temporary buffer `buf[32]` with `strncpy` ensures that only a maximum of 31 characters are copied, preventing overflow. The `memset` function initializes `buf`, and the final copy to `buff` is also bounded, enhancing safety.","The vulnerability in the original code stems from the potential for buffer overflow due to the lack of proper size checks when copying data into a destination buffer. If the source string exceeds the allocated size of the destination, it could overwrite adjacent memory, leading to undefined behavior or security issues. The revised code addresses this vulnerability by introducing a temporary buffer with a defined size and using a safer copying method that limits the number of characters copied. This ensures that the destination buffer is not exceeded, thereby preventing overflow and enhancing overall memory safety.",4,5,4,4,"CWE-119, CWE-120, CWE-121, CWE-122, CWE-787, CWE-788, CWE-805, CWE-806, CWE-131, CWE-170",N,-1
2,2,2,183007,183007,,Remote,Not required,Partial,CVE-2018-14879,https://www.cvedetails.com/cve/CVE-2018-14879/,CWE-120,Low,Partial,Partial,,2019-10-03,7.5,The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file().,2019-10-11,Overflow ,4,https://github.com/the-tcpdump-group/tcpdump/commit/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,"(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely

get_next_file() did not check the return value of strlen() and
underflowed an array index if the line read by fgets() from the file
started with \0. This caused an out-of-bounds read and could cause a
write. Add the missing check.

This vulnerability was discovered by Brian Carpenter & Geeknik Labs.",2,tcpdump.c,"{""sha"": ""043bda1d7aca523ac17d555e5bcd1e09a676adfe"", ""filename"": ""tcpdump.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tcpdump.c?ref=9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6"", ""patch"": ""@@ -699,13 +699,15 @@ static char *\n get_next_file(FILE *VFile, char *ptr)\n {\n \tchar *ret;\n+\tsize_t len;\n \n \tret = fgets(ptr, PATH_MAX, VFile);\n \tif (!ret)\n \t\treturn NULL;\n \n-\tif (ptr[strlen(ptr) - 1] == '\\n')\n-\t\tptr[strlen(ptr) - 1] = '\\0';\n+\tlen = strlen (ptr);\n+\tif (len > 0 && ptr[len - 1] == '\\n')\n+\t\tptr[len - 1] = '\\0';\n \n \treturn ret;\n }""}"," get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
	size_t len;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
	len = strlen (ptr);
	if (len > 0 && ptr[len - 1] == '\n')
		ptr[len - 1] = '\0';
 
 	return ret;
 }
"," get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
	if (ptr[strlen(ptr) - 1] == '\n')
		ptr[strlen(ptr) - 1] = '\0';
 
 	return ret;
 }
",C,"	size_t len;
	len = strlen (ptr);
	if (len > 0 && ptr[len - 1] == '\n')
		ptr[len - 1] = '\0';
","	if (ptr[strlen(ptr) - 1] == '\n')
		ptr[strlen(ptr) - 1] = '\0';
",,"@@ -699,13 +699,15 @@ static char *
 get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
+	size_t len;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
-	if (ptr[strlen(ptr) - 1] == '\n')
-		ptr[strlen(ptr) - 1] = '\0';
+	len = strlen (ptr);
+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';
 
 	return ret;
 }",tcpdump,9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,1," get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
//fix_flaw_line_below:
//	size_t len;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
//flaw_line_below:
	if (ptr[strlen(ptr) - 1] == '\n')
//flaw_line_below:
		ptr[strlen(ptr) - 1] = '\0';
//fix_flaw_line_below:
//	len = strlen (ptr);
//fix_flaw_line_below:
//	if (len > 0 && ptr[len - 1] == '\n')
//fix_flaw_line_below:
//		ptr[len - 1] = '\0';
 
 	return ret;
 }
",183007," get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
	if (ptr[strlen(ptr) - 1] == '\n')
		ptr[strlen(ptr) - 1] = '\0';
 
 	return ret;
 }
"," get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
	size_t len;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
	len = strlen (ptr);
	if (len > 0 && ptr[len - 1] == '\n')
		ptr[len - 1] = '\0';
 
 	return ret;
 }
","The vulnerability in the original code arises from the potential for a buffer overflow when using `strlen(ptr)` to determine the length of the string read into `ptr`. If `fgets` reads a string that is exactly `PATH_MAX` characters long, `strlen(ptr)` will return `PATH_MAX`, leading to an out-of-bounds access when checking `ptr[strlen(ptr) - 1]`. The fixed code addresses this by introducing a `size_t len` variable to store the length of `ptr`, ensuring that the check for the newline character is safe and does not exceed the bounds of the buffer, thus preventing potential buffer overflow vulnerabilities.","The vulnerability in the original code stems from the risk of accessing memory outside the allocated buffer when determining the length of the string read from a file. If the input string reaches the maximum allowed size, the code could attempt to check a character beyond the end of the buffer, leading to undefined behavior or crashes. The revised code mitigates this issue by storing the length of the string in a separate variable before performing any checks. This ensures that all operations remain within the bounds of the allocated memory, effectively preventing potential buffer overflow vulnerabilities.",3,1,2,1,"CWE-119, CWE-125, CWE-788, CWE-120, CWE-122, CWE-787, CWE-121, CWE-126, CWE-466, CWE-123",N,-1
3,3,3,188035,188035,,Remote,Not required,Complete,CVE-2017-0594,https://www.cvedetails.com/cve/CVE-2017-0594/,CWE-120,Medium,Complete,Complete,,2017-05-12,9.3,"An elevation of privilege vulnerability in codecs/aacenc/SoftAACEncoder2.cpp in libstagefright in Mediaserver could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34617444.",2019-10-02,Exec Code +Priv ,9,https://android.googlesource.com/platform/frameworks/av/+/594bf934384920618d2b6ce0bcda1f60144cb3eb,594bf934384920618d2b6ce0bcda1f60144cb3eb,"Add bounds check in SoftAACEncoder2::onQueueFilled()

Original code blindly copied some header information into the
user-supplied buffer without checking for sufficient space.
The code does check when it gets to filling the data -- it's
just the header copies that weren't checked.

Bug: 34617444
Test: ran POC before/after
Change-Id: I6e80ec90616f6cd02bb8316cd2d6e309b7e4729d
(cherry picked from commit 6231243626b8b9c57593b1f0ee417f2c4af4c0aa)
",0,media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp,"{""filename"": ""media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/594bf934384920618d2b6ce0bcda1f60144cb3eb/media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp"", ""patch"": ""@@ -510,6 +510,15 @@\n\n \n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n+\n+        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {\n+            ALOGE(\""b/34617444\"");\n+            android_errorWriteLog(0x534e4554,\""34617444\"");\n+            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n+            mSignalledError = true;\n+            return;\n+        }\n+\n         outHeader->nFilledLen = encInfo.confSize;\n         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;\n \n""}","void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (!mSentCodecSpecificData) {

 if (outQueue.empty()) {
 return;
 }

 if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
 if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
 }

        AACENC_InfoStruct encInfo;
 if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
 uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
 }

 size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

 if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
 }

 for (;;) {

 while (mInputSize < numBytesPerInputFrame) {

 if (mSawInputEOS || inQueue.empty()) {
 return;
 }

 BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

 const void *inData = inHeader->pBuffer + inHeader->nOffset;

 size_t copy = numBytesPerInputFrame - mInputSize;
 if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
 }

 if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
 }

 if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
 }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

            inHeader->nTimeStamp +=
 (copy * 1000000ll / mSampleRate)
 / (mNumChannels * sizeof(int16_t));

 if (inHeader->nFilledLen == 0) {
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

                    memset((uint8_t *)mInputFrame + mInputSize,
 0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
 }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
 }
 }


 if (outQueue.empty()) {
 return;
 }

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

 uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
 size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

 void* inBuffer[] = { (unsigned char *)mInputFrame };
        INT   inBufferIds[] = { IN_AUDIO_DATA };
        INT   inBufferSize[] = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[] = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

 void* outBuffer[] = { outPtr };
        INT   outBufferIds[] = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[] = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

        AACENC_ERROR encoderErr = AACENC_OK;
 size_t nOutputBytes = 0;

 do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
 &inBufDesc,
 &outBufDesc,
 &inargs,
 &outargs);

 if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

 if (outargs.numInSamples > 0) {
 int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
 if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
 &mInputFrame[outargs.numInSamples],
 sizeof(int16_t) * numRemainingSamples);
 }
                    inargs.numInSamples -= outargs.numInSamples;
 }
 }
 } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

 if (mSawInputEOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
 }
}
","void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (!mSentCodecSpecificData) {

 if (outQueue.empty()) {
 return;
 }

 if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
 if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
 }

        AACENC_InfoStruct encInfo;
 if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
 uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
 }

 size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

 if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
 }

 for (;;) {

 while (mInputSize < numBytesPerInputFrame) {

 if (mSawInputEOS || inQueue.empty()) {
 return;
 }

 BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

 const void *inData = inHeader->pBuffer + inHeader->nOffset;

 size_t copy = numBytesPerInputFrame - mInputSize;
 if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
 }

 if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
 }

 if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
 }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

            inHeader->nTimeStamp +=
 (copy * 1000000ll / mSampleRate)
 / (mNumChannels * sizeof(int16_t));

 if (inHeader->nFilledLen == 0) {
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

                    memset((uint8_t *)mInputFrame + mInputSize,
 0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
 }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
 }
 }


 if (outQueue.empty()) {
 return;
 }

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

 uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
 size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

 void* inBuffer[] = { (unsigned char *)mInputFrame };
        INT   inBufferIds[] = { IN_AUDIO_DATA };
        INT   inBufferSize[] = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[] = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

 void* outBuffer[] = { outPtr };
        INT   outBufferIds[] = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[] = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

        AACENC_ERROR encoderErr = AACENC_OK;
 size_t nOutputBytes = 0;

 do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
 &inBufDesc,
 &outBufDesc,
 &inargs,
 &outargs);

 if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

 if (outargs.numInSamples > 0) {
 int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
 if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
 &mInputFrame[outargs.numInSamples],
 sizeof(int16_t) * numRemainingSamples);
 }
                    inargs.numInSamples -= outargs.numInSamples;
 }
 }
 } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

 if (mSawInputEOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
 }
}
",C,"
        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

",,,"@@ -510,6 +510,15 @@

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
+
+        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
+            ALOGE(""b/34617444"");
+            android_errorWriteLog(0x534e4554,""34617444"");
+            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
+            mSignalledError = true;
+            return;
+        }
+
         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/594bf934384920618d2b6ce0bcda1f60144cb3eb/,https://android.googlesource.com/platform/frameworks/av/+/594bf934384920618d2b6ce0bcda1f60144cb3eb%5E/,1,"void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (!mSentCodecSpecificData) {
 // The very first thing we want to output is the codec specific
 // data. It does not require any input data but we will need an
 // output buffer to store it in.

 if (outQueue.empty()) {
 return;
 }

 if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
 if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
 }

        AACENC_InfoStruct encInfo;
 if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
//fix_flaw_line_below:
//            ALOGE(""b/34617444"");
//fix_flaw_line_below:
//            android_errorWriteLog(0x534e4554,""34617444"");
//fix_flaw_line_below:
//            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
//fix_flaw_line_below:
//            mSignalledError = true;
//fix_flaw_line_below:
//            return;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
 uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
 }

 size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

 // Limit input size so we only get one ELD frame
 if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
 }

 for (;;) {
 // We do the following until we run out of buffers.

 while (mInputSize < numBytesPerInputFrame) {
 // As long as there's still input data to be read we
 // will drain ""kNumSamplesPerFrame * mNumChannels"" samples
 // into the ""mInputFrame"" buffer and then encode those
 // as a unit into an output buffer.

 if (mSawInputEOS || inQueue.empty()) {
 return;
 }

 BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

 const void *inData = inHeader->pBuffer + inHeader->nOffset;

 size_t copy = numBytesPerInputFrame - mInputSize;
 if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
 }

 if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
 }

 if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
 }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

 // ""Time"" on the input buffer has in effect advanced by the
 // number of audio frames we just advanced nOffset by.
            inHeader->nTimeStamp +=
 (copy * 1000000ll / mSampleRate)
 / (mNumChannels * sizeof(int16_t));

 if (inHeader->nFilledLen == 0) {
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

 // Pad any remaining data with zeroes.
                    memset((uint8_t *)mInputFrame + mInputSize,
 0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
 }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
 }
 }

 // At this  point we have all the input data necessary to encode
 // a single frame, all we need is an output buffer to store the result
 // in.

 if (outQueue.empty()) {
 return;
 }

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

 uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
 size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

 void* inBuffer[] = { (unsigned char *)mInputFrame };
        INT   inBufferIds[] = { IN_AUDIO_DATA };
        INT   inBufferSize[] = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[] = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

 void* outBuffer[] = { outPtr };
        INT   outBufferIds[] = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[] = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

 // Encode the mInputFrame, which is treated as a modulo buffer
        AACENC_ERROR encoderErr = AACENC_OK;
 size_t nOutputBytes = 0;

 do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
 &inBufDesc,
 &outBufDesc,
 &inargs,
 &outargs);

 if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

 if (outargs.numInSamples > 0) {
 int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
 if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
 &mInputFrame[outargs.numInSamples],
 sizeof(int16_t) * numRemainingSamples);
 }
                    inargs.numInSamples -= outargs.numInSamples;
 }
 }
 } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

 if (mSawInputEOS) {
 // We also tag this output buffer with EOS if it corresponds
 // to the final input buffer.
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
 }
}
",188035,"void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (!mSentCodecSpecificData) {

 if (outQueue.empty()) {
 return;
 }

 if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
 if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
 }

        AACENC_InfoStruct encInfo;
 if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
 uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
 }

 size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

 if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
 }

 for (;;) {

 while (mInputSize < numBytesPerInputFrame) {

 if (mSawInputEOS || inQueue.empty()) {
 return;
 }

 BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

 const void *inData = inHeader->pBuffer + inHeader->nOffset;

 size_t copy = numBytesPerInputFrame - mInputSize;
 if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
 }

 if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
 }

 if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
 }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

            inHeader->nTimeStamp +=
 (copy * 1000000ll / mSampleRate)
 / (mNumChannels * sizeof(int16_t));

 if (inHeader->nFilledLen == 0) {
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

                    memset((uint8_t *)mInputFrame + mInputSize,
 0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
 }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
 }
 }


 if (outQueue.empty()) {
 return;
 }

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

 uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
 size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

 void* inBuffer[] = { (unsigned char *)mInputFrame };
        INT   inBufferIds[] = { IN_AUDIO_DATA };
        INT   inBufferSize[] = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[] = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

 void* outBuffer[] = { outPtr };
        INT   outBufferIds[] = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[] = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

        AACENC_ERROR encoderErr = AACENC_OK;
 size_t nOutputBytes = 0;

 do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
 &inBufDesc,
 &outBufDesc,
 &inargs,
 &outargs);

 if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

 if (outargs.numInSamples > 0) {
 int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
 if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
 &mInputFrame[outargs.numInSamples],
 sizeof(int16_t) * numRemainingSamples);
 }
                    inargs.numInSamples -= outargs.numInSamples;
 }
 }
 } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

 if (mSawInputEOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
 }
}
","void SoftAACEncoder2::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (!mSentCodecSpecificData) {

 if (outQueue.empty()) {
 return;
 }

 if (AACENC_OK != aacEncEncode(mAACEncoder, NULL, NULL, NULL, NULL)) {
            ALOGE(""Unable to initialize encoder for profile / sample-rate / bit-rate / channels"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

        OMX_U32 actualBitRate  = aacEncoder_GetParam(mAACEncoder, AACENC_BITRATE);
 if (mBitRate != actualBitRate) {
            ALOGW(""Requested bitrate %u unsupported, using %u"", mBitRate, actualBitRate);
 }

        AACENC_InfoStruct encInfo;
 if (AACENC_OK != aacEncInfo(mAACEncoder, &encInfo)) {
            ALOGE(""Failed to get AAC encoder info"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
 uint8_t *out = outHeader->pBuffer + outHeader->nOffset;
        memcpy(out, encInfo.confBuf, encInfo.confSize);

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mSentCodecSpecificData = true;
 }

 size_t numBytesPerInputFrame =
        mNumChannels * kNumSamplesPerFrame * sizeof(int16_t);

 if (mAACProfile == OMX_AUDIO_AACObjectELD && numBytesPerInputFrame > 512) {
        numBytesPerInputFrame = 512;
 }

 for (;;) {

 while (mInputSize < numBytesPerInputFrame) {

 if (mSawInputEOS || inQueue.empty()) {
 return;
 }

 BufferInfo *inInfo = *inQueue.begin();
            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

 const void *inData = inHeader->pBuffer + inHeader->nOffset;

 size_t copy = numBytesPerInputFrame - mInputSize;
 if (copy > inHeader->nFilledLen) {
                copy = inHeader->nFilledLen;
 }

 if (mInputFrame == NULL) {
                mInputFrame = new int16_t[numBytesPerInputFrame / sizeof(int16_t)];
 }

 if (mInputSize == 0) {
                mInputTimeUs = inHeader->nTimeStamp;
 }

            memcpy((uint8_t *)mInputFrame + mInputSize, inData, copy);
            mInputSize += copy;

            inHeader->nOffset += copy;
            inHeader->nFilledLen -= copy;

            inHeader->nTimeStamp +=
 (copy * 1000000ll / mSampleRate)
 / (mNumChannels * sizeof(int16_t));

 if (inHeader->nFilledLen == 0) {
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                    mSawInputEOS = true;

                    memset((uint8_t *)mInputFrame + mInputSize,
 0,
                           numBytesPerInputFrame - mInputSize);

                    mInputSize = numBytesPerInputFrame;
 }

                inQueue.erase(inQueue.begin());
                inInfo->mOwnedByUs = false;
                notifyEmptyBufferDone(inHeader);

                inData = NULL;
                inHeader = NULL;
                inInfo = NULL;
 }
 }


 if (outQueue.empty()) {
 return;
 }

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

 uint8_t *outPtr = (uint8_t *)outHeader->pBuffer + outHeader->nOffset;
 size_t outAvailable = outHeader->nAllocLen - outHeader->nOffset;

        AACENC_InArgs inargs;
        AACENC_OutArgs outargs;
        memset(&inargs, 0, sizeof(inargs));
        memset(&outargs, 0, sizeof(outargs));
        inargs.numInSamples = numBytesPerInputFrame / sizeof(int16_t);

 void* inBuffer[] = { (unsigned char *)mInputFrame };
        INT   inBufferIds[] = { IN_AUDIO_DATA };
        INT   inBufferSize[] = { (INT)numBytesPerInputFrame };
        INT   inBufferElSize[] = { sizeof(int16_t) };

        AACENC_BufDesc inBufDesc;
        inBufDesc.numBufs           = sizeof(inBuffer) / sizeof(void*);
        inBufDesc.bufs              = (void**)&inBuffer;
        inBufDesc.bufferIdentifiers = inBufferIds;
        inBufDesc.bufSizes          = inBufferSize;
        inBufDesc.bufElSizes        = inBufferElSize;

 void* outBuffer[] = { outPtr };
        INT   outBufferIds[] = { OUT_BITSTREAM_DATA };
        INT   outBufferSize[] = { 0 };
        INT   outBufferElSize[] = { sizeof(UCHAR) };

        AACENC_BufDesc outBufDesc;
        outBufDesc.numBufs           = sizeof(outBuffer) / sizeof(void*);
        outBufDesc.bufs              = (void**)&outBuffer;
        outBufDesc.bufferIdentifiers = outBufferIds;
        outBufDesc.bufSizes          = outBufferSize;
        outBufDesc.bufElSizes        = outBufferElSize;

        AACENC_ERROR encoderErr = AACENC_OK;
 size_t nOutputBytes = 0;

 do {
            memset(&outargs, 0, sizeof(outargs));

            outBuffer[0] = outPtr;
            outBufferSize[0] = outAvailable - nOutputBytes;

            encoderErr = aacEncEncode(mAACEncoder,
 &inBufDesc,
 &outBufDesc,
 &inargs,
 &outargs);

 if (encoderErr == AACENC_OK) {
                outPtr += outargs.numOutBytes;
                nOutputBytes += outargs.numOutBytes;

 if (outargs.numInSamples > 0) {
 int numRemainingSamples = inargs.numInSamples - outargs.numInSamples;
 if (numRemainingSamples > 0) {
                        memmove(mInputFrame,
 &mInputFrame[outargs.numInSamples],
 sizeof(int16_t) * numRemainingSamples);
 }
                    inargs.numInSamples -= outargs.numInSamples;
 }
 }
 } while (encoderErr == AACENC_OK && inargs.numInSamples > 0);

        outHeader->nFilledLen = nOutputBytes;

        outHeader->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;

 if (mSawInputEOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 }

        outHeader->nTimeStamp = mInputTimeUs;

#if 0
        ALOGI(""sending %d bytes of data (time = %lld us, flags = 0x%08lx)"",
              nOutputBytes, mInputTimeUs, outHeader->nFlags);

        hexdump(outHeader->pBuffer + outHeader->nOffset, outHeader->nFilledLen);
#endif

        outQueue.erase(outQueue.begin());
        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        outHeader = NULL;
        outInfo = NULL;

        mInputSize = 0;
 }
}
","The vulnerability in the original code arises from a lack of bounds checking when writing codec-specific data to the output buffer. Specifically, the code does not verify whether the output buffer, referenced by `outHeader`, has enough allocated space (`nAllocLen`) to accommodate the size of the data being copied (`encInfo.confSize`). This could lead to a buffer overflow, potentially allowing an attacker to overwrite adjacent memory. The fix introduces a check that ensures `outHeader->nOffset + encInfo.confSize` does not exceed `outHeader->nAllocLen`, preventing the overflow and enhancing the code's robustness against such vulnerabilities.","The vulnerability in the original code stems from the absence of bounds checking when writing data to an output buffer, which could lead to a buffer overflow. This oversight allows for the possibility of writing beyond the allocated memory, potentially corrupting adjacent memory and leading to undefined behavior or security exploits. The fix addresses this issue by implementing a check to ensure that the total size of the data being written does not exceed the allocated size of the output buffer. This safeguard effectively prevents buffer overflows, enhancing the overall security and stability of the code.",3,5,5,4,"CWE-119,CWE-120,CWE-787,CWE-788,CWE-121,CWE-122,CWE-125,CWE-131,CWE-680,CWE-789",Y,2
