,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,F1_Clarity_C5,F2_Relevance_C5,F3_Completeness_C5,F4_Actionability_C5
0,0,180116,180116,,Remote,Not required,Partial,CVE-2016-7143,https://www.cvedetails.com/cve/CVE-2016-7143/,CWE-285,Medium,Partial,Partial,,2016-09-21,6.8,The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,2016-11-28,,6,https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824,818a3fda944b26d4814132cee14cfda4ea4aa824,"SASL: Disallow beginning : and space anywhere in AUTHENTICATE parameter

This is a FIX FOR A SECURITY VULNERABILITY. All Charybdis users must
apply this fix if you support SASL on your servers, or unload m_sasl.so
in the meantime.",0,modules/m_sasl.c,"{""sha"": ""93c5a04124f3ee7f5bce71dfd65ced91749c532e"", ""filename"": ""modules/m_sasl.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/charybdis-ircd/charybdis/blob/818a3fda944b26d4814132cee14cfda4ea4aa824/modules/m_sasl.c"", ""raw_url"": ""https://github.com/charybdis-ircd/charybdis/raw/818a3fda944b26d4814132cee14cfda4ea4aa824/modules/m_sasl.c"", ""contents_url"": ""https://api.github.com/repos/charybdis-ircd/charybdis/contents/modules/m_sasl.c?ref=818a3fda944b26d4814132cee14cfda4ea4aa824"", ""patch"": ""@@ -91,6 +91,12 @@ m_authenticate(struct Client *client_p, struct Client *source_p,\n \t\treturn 0;\n \t}\n \n+\tif (*parv[1] == ':' || strchr(parv[1], ' '))\n+\t{\n+\t\texit_client(client_p, client_p, client_p, \""Malformed AUTHENTICATE\"");\n+\t\treturn 0;\n+\t}\n+\n \tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n \tif (saslserv_p == NULL || !IsService(saslserv_p))\n \t{""}","m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
","m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
",C,"	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

",,,"@@ -91,6 +91,12 @@ m_authenticate(struct Client *client_p, struct Client *source_p,
 		return 0;
 	}
 
+	if (*parv[1] == ':' || strchr(parv[1], ' '))
+	{
+		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
+		return 0;
+	}
+
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{",charybdis,818a3fda944b26d4814132cee14cfda4ea4aa824,f92b4d81d44580cd6df2d0b2f3cdfd7ad067ecd4,1,"m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
//fix_flaw_line_below:
//	if (*parv[1] == ':' || strchr(parv[1], ' '))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
",180116,"m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
","m_authenticate(struct Client *client_p, struct Client *source_p,
	int parc, const char *parv[])
{
	struct Client *agent_p = NULL;
	struct Client *saslserv_p = NULL;

	/* They really should use CAP for their own sake. */
	if(!IsCapable(source_p, CLICAP_SASL))
		return 0;

	if (strlen(client_p->id) == 3)
	{
		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
 		return 0;
 	}
 
	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{
		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(source_p->localClient->sasl_complete)
	{
		*source_p->localClient->sasl_agent = '\0';
		source_p->localClient->sasl_complete = 0;
	}

	if(strlen(parv[1]) > 400)
	{
		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
		return 0;
	}

	if(!*source_p->id)
	{
		/* Allocate a UID. */
		strcpy(source_p->id, generate_uid());
		add_to_id_hash(source_p->id, source_p);
	}

	if(*source_p->localClient->sasl_agent)
		agent_p = find_id(source_p->localClient->sasl_agent);

	if(agent_p == NULL)
	{
		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
					source_p->host, source_p->sockhost);

		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1], source_p->certfp);
		else
			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
						parv[1]);

		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
	}
	else
		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
				parv[1]);
	source_p->localClient->sasl_out++;

	return 0;
}
","The vulnerability in the original code lies in the lack of validation for the `parv[1]` input, which could allow an attacker to inject malicious data, potentially leading to command injection or buffer overflow. Specifically, if `parv[1]` starts with a colon (`:`) or contains spaces, it could disrupt the expected format of the SASL authentication command. The fixed code addresses this vulnerability by adding a check for these conditions: `if (*parv[1] == ':' || strchr(parv[1], ' '))`, which ensures that malformed input is rejected early, thus preventing potential exploitation and enhancing the overall security of the authentication process.","The vulnerability in the original code stems from inadequate input validation, allowing an attacker to manipulate the authentication process by providing malformed input. Specifically, the absence of checks for certain characters could lead to command injection or unexpected behavior, compromising the integrity of the authentication mechanism. The revised code addresses this issue by implementing a validation step that checks for specific invalid characters in the input. This early rejection of malformed input effectively mitigates the risk of exploitation, thereby enhancing the security of the authentication process and ensuring that only properly formatted data is processed.","CWE-20,CWE-78,CWE-89,CWE-94,CWE-95,CWE-287,CWE-285,CWE-74,CWE-290,CWE-77",Y,7.0,3.0,3.0,3.0,4.0
1,1,182620,182620,,Local,Not required,Complete,CVE-2016-7035,https://www.cvedetails.com/cve/CVE-2016-7035/,CWE-285,Low,Complete,Complete,,2018-09-10,7.2,"An authorization flaw was found in Pacemaker before 1.1.16, where it did not properly guard its IPC interface. An attacker with an unprivileged account on a Pacemaker node could use this flaw to, for example, force the Local Resource Manager daemon to execute a script as root and thereby gain root access on the machine.",2019-10-09,+Priv ,3,https://github.com/ClusterLabs/pacemaker/commit/5d71e65049,5d71e65049,"High: libcrmcommon: fix CVE-2016-7035 (improper IPC guarding)

It was discovered that at some not so uncommon circumstances, some
pacemaker daemons could be talked to, via libqb-facilitated IPC, by
unprivileged clients due to flawed authorization decision.  Depending
on the capabilities of affected daemons, this might equip unauthorized
user with local privilege escalation or up to cluster-wide remote
execution of possibly arbitrary commands when such user happens to
reside at standard or remote/guest cluster node, respectively.

The original vulnerability was introduced in an attempt to allow
unprivileged IPC clients to clean up the file system materialized
leftovers in case the server (otherwise responsible for the lifecycle
of these files) crashes.  While the intended part of such behavior is
now effectively voided (along with the unintended one), a best-effort
fix to address this corner case systemically at libqb is coming along
(https://github.com/ClusterLabs/libqb/pull/231).

Affected versions:  1.1.10-rc1 (2013-04-17) - 1.1.15 (2016-06-21)
Impact:             Important
CVSSv3 ranking:     8.8 : AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H

Credits for independent findings, in chronological order:
  Jan ""poki"" Pokorný, of Red Hat
  Alain Moulle, of ATOS/BULL",9,lib/common/ipc.c,"{""sha"": ""2949837e3737874799d01745d59fde36235aefc6"", ""filename"": ""lib/common/ipc.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 11, ""changes"": 14, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/5d71e65049d143435b03d6b3709d82900f32276f/lib/common/ipc.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/5d71e65049d143435b03d6b3709d82900f32276f/lib/common/ipc.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lib/common/ipc.c?ref=5d71e65049d143435b03d6b3709d82900f32276f"", ""patch"": ""@@ -293,7 +293,6 @@ crm_client_disconnect_all(qb_ipcs_service_t *service)\n crm_client_t *\n crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n-    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n \n     crm_client_t *client = NULL;\n@@ -304,7 +303,6 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n     }\n \n     if (gid_cluster == 0) {\n-        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n@@ -314,16 +312,10 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n         }\n     }\n \n-    if(gid_cluster != 0 && gid_client != 0) {\n-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n-\n-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n-            best_uid = QB_MAX(uid_client, uid_server);\n-            crm_trace(\""Allowing user %u to clean up after disconnect\"", best_uid);\n-        }\n-\n+    if (uid_client != 0) {\n         crm_trace(\""Giving access to group %u\"", gid_cluster);\n-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n+        /* Passing -1 to chown(2) means don't change */\n+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n \n     crm_client_init();""}"," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
        /* Passing -1 to chown(2) means don't change */
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
"," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if(gid_cluster != 0 && gid_client != 0) {
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
            best_uid = QB_MAX(uid_client, uid_server);
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
        }
         crm_trace(""Giving access to group %u"", gid_cluster);
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
",C,"    if (uid_client != 0) {
        /* Passing -1 to chown(2) means don't change */
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
","    static uid_t uid_server = 0;
        uid_server = getuid();
    if(gid_cluster != 0 && gid_client != 0) {
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
            best_uid = QB_MAX(uid_client, uid_server);
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
        }
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
",,"@@ -293,7 +293,6 @@ crm_client_disconnect_all(qb_ipcs_service_t *service)
 crm_client_t *
 crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
-    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;
@@ -304,7 +303,6 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
     }
 
     if (gid_cluster == 0) {
-        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
@@ -314,16 +312,10 @@ crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
         }
     }
 
-    if(gid_cluster != 0 && gid_client != 0) {
-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
-
-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
-            best_uid = QB_MAX(uid_client, uid_server);
-            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
-        }
-
+    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+        /* Passing -1 to chown(2) means don't change */
+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();",pacemaker,5d71e65049,23f8e91a3ee1f9b4d55a50274ee932895dc2d355,1," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
//flaw_line_below:
    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
//flaw_line_below:
        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
//flaw_line_below:
    if(gid_cluster != 0 && gid_client != 0) {
//flaw_line_below:
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
//flaw_line_below:

//flaw_line_below:
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
//flaw_line_below:
            best_uid = QB_MAX(uid_client, uid_server);
//flaw_line_below:
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
//flaw_line_below:
        }
//flaw_line_below:

//fix_flaw_line_below:
//    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
//flaw_line_below:
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
//fix_flaw_line_below:
//        /* Passing -1 to chown(2) means don't change */
//fix_flaw_line_below:
//        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
",182620," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
    static uid_t uid_server = 0;
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
        uid_server = getuid();
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if(gid_cluster != 0 && gid_client != 0) {
        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */
        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */
            best_uid = QB_MAX(uid_client, uid_server);
            crm_trace(""Allowing user %u to clean up after disconnect"", best_uid);
        }
         crm_trace(""Giving access to group %u"", gid_cluster);
        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
"," crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;

    CRM_LOG_ASSERT(c);
    if (c == NULL) {
        return NULL;
     }
 
     if (gid_cluster == 0) {
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
                crm_warn(""Could not find group for user %s"", CRM_DAEMON_USER);
                have_error = TRUE;
            }
         }
     }
 
    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
        /* Passing -1 to chown(2) means don't change */
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();

    /* TODO: Do our own auth checking, return NULL if unauthorized */
    client = calloc(1, sizeof(crm_client_t));

    client->ipcs = c;
    client->kind = CRM_CLIENT_IPC;
    client->pid = crm_ipcs_client_pid(c);

    client->id = crm_generate_uuid();

    crm_debug(""Connecting %p for uid=%d gid=%d pid=%u id=%s"", c, uid_client, gid_client, client->pid, client->id);

#if ENABLE_ACL
    client->user = uid2username(uid_client);
#endif

    g_hash_table_insert(client_connections, c, client);
    return client;
}
","The vulnerability in the original code lies in the improper handling of user permissions, specifically in the conditional checks involving `uid_client` and `uid_server`. The code allowed access to the IPC connection even if `uid_client` was zero, which could lead to unauthorized access. In the fixed code, the check for `uid_client` is modified to ensure that it is not zero before granting access to the group `gid_cluster`. This change prevents unauthorized users from being granted access, thereby enhancing the security of the `qb_ipcs_connection_auth_set` function call.","The vulnerability in the original code stems from inadequate authorization checks, allowing potentially unauthorized users to gain access to sensitive resources. Specifically, the code permitted access even when the user ID was zero, which could indicate a lack of proper privileges. In the revised code, this issue was addressed by ensuring that access is only granted if the user ID is non-zero, thereby enforcing stricter authorization controls. This change effectively mitigates the risk of unauthorized access, enhancing the overall security of the system by ensuring that only legitimate users can interact with the resource.","CWE-285,CWE-287,CWE-284,CWE-863,CWE-269,CWE-425,CWE-306,CWE-862,CWE-288,CWE-732",Y,1.0,4.0,4.0,3.0,4.0
2,2,187175,187175,,Remote,Not required,,CVE-2018-16074,https://www.cvedetails.com/cve/CVE-2018-16074/,CWE-285,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.,2019-07-01,Bypass ,21,https://github.com/chromium/chromium/commit/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,"Avoid sharing process for blob URLs with null origin.

Previously, when a frame with a unique origin, such as from a data
URL, created a blob URL, the blob URL looked like blob:null/guid and
resulted in a site URL of ""blob:"" when navigated to.  This incorrectly
allowed all such blob URLs to share a process, even if they were
created by different sites.

This CL changes the site URL assigned in such cases to be the full
blob URL, which includes the GUID.  This avoids process sharing for
all blob URLs with unique origins.

This fix is conservative in the sense that it would also isolate
different blob URLs created by the same unique origin from each other.
This case isn't expected to be common, so it's unlikely to affect
process count.  There's ongoing work to maintain a GUID for unique
origins, so longer-term, we could try using that to track down the
creator and potentially use that GUID in the site URL instead of the
blob URL's GUID, to avoid unnecessary process isolation in scenarios
like this.

Note that as part of this, we discovered a bug where data URLs aren't
able to script blob URLs that they create: https://crbug.com/865254.
This scripting bug should be fixed independently of this CL, and as
far as we can tell, this CL doesn't regress scripting cases like this
further.

Bug: 863623
Change-Id: Ib50407adbba3d5ee0cf6d72d3df7f8d8f24684ee
Reviewed-on: https://chromium-review.googlesource.com/1142389
Commit-Queue: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Charlie Reis <creis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#576318}",0,content/browser/site_instance_impl.cc,"{""sha"": ""df77d7f7605bce424440a1c109d17011a4fd51b2"", ""filename"": ""content/browser/site_instance_impl.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 1, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -449,10 +449,30 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n   // This is useful for cases like file URLs.\n   if (!origin.unique()) {\n     // Prefer to use the scheme of |origin| rather than |url|, to correctly\n-    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).\n+    // cover blob:file: and filesystem:file: URIs (see also\n+    // https://crbug.com/697111).\n     DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \"":\"");\n   } else if (url.has_scheme()) {\n+    // In some cases, it is not safe to use just the scheme as a site URL, as\n+    // that might allow two URLs created by different sites to to share a\n+    // process.  See https://crbug.com/863623.\n+    //\n+    // TODO(alexmos,creis): This should eventually be expanded to certain other\n+    // schemes, such as data: and file:.\n+    if (url.SchemeIsBlob()) {\n+      // We get here for blob URLs of form blob:null/guid.  Use the full URL\n+      // with the guid in that case, which isolates all blob URLs with unique\n+      // origins from each other.  Remove hash from the URL, since\n+      // same-document navigations shouldn't use a different site URL.\n+      if (url.has_ref()) {\n+        GURL::Replacements replacements;\n+        replacements.ClearRef();\n+        url = url.ReplaceComponents(replacements);\n+      }\n+      return url;\n+    }\n+\n     DCHECK(!url.scheme().empty());\n     return GURL(url.scheme() + \"":\"");\n   }""}<_**next**_>{""sha"": ""8e92db4991f5bd591ca12d2b684078b07ababf2a"", ""filename"": ""content/browser/site_instance_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_instance_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_instance_impl_unittest.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -344,6 +344,17 @@ TEST_F(SiteInstanceTest, GetSiteForURL) {\n   EXPECT_EQ(\""file\"", site_url.scheme());\n   EXPECT_FALSE(site_url.has_host());\n \n+  // Blob URLs created from a unique origin use the full URL as the site URL,\n+  // except for the hash.\n+  test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_EQ(site_url, test_url);\n+  test_url = GURL(\""blob:null/1029e5a4-2983-4b90-a585-ed217563acfeb#foo\"");\n+  site_url = SiteInstanceImpl::GetSiteForURL(nullptr, test_url);\n+  EXPECT_NE(site_url, test_url);\n+  EXPECT_FALSE(site_url.has_ref());\n+  EXPECT_TRUE(site_url.EqualsIgnoringRef(test_url));\n+\n   // Private domains are preserved, appspot being such a site.\n   test_url = GURL(\n       \""blob:http://www.example.appspot.com:44/\""""}<_**next**_>{""sha"": ""7aa65cb6339166c914b910740b39f352ebeb7033"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 50, ""deletions"": 0, ""changes"": 50, ""blob_url"": ""https://github.com/chromium/chromium/blob/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b1f87486936ca0d6d9abf4d3b9b423a9c976fd59/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=b1f87486936ca0d6d9abf4d3b9b423a9c976fd59"", ""patch"": ""@@ -12675,4 +12675,54 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n             subframe->effective_frame_policy().sandbox_flags);\n }\n \n+// Ensure that when two cross-site frames have subframes with unique origins,\n+// and those subframes create blob URLs and navigate to them, the blob URLs end\n+// up in different processes. See https://crbug.com/863623.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       TwoBlobURLsWithNullOriginDontShareProcess) {\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/navigation_controller/page_with_data_iframe.html\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+  FrameTreeNode* root = web_contents()->GetFrameTree()->root();\n+  FrameTreeNode* subframe = root->child_at(0);\n+\n+  // Create a blob URL in the subframe, and navigate to it.\n+  TestNavigationObserver observer(shell()->web_contents());\n+  std::string blob_script =\n+      \""var blob = new Blob(['foo'], {type : 'text/html'});\""\n+      \""var url = URL.createObjectURL(blob);\""\n+      \""location = url;\"";\n+  EXPECT_TRUE(ExecuteScript(subframe, blob_script));\n+  observer.Wait();\n+  RenderFrameHostImpl* subframe_rfh = subframe->current_frame_host();\n+  EXPECT_TRUE(subframe_rfh->GetLastCommittedURL().SchemeIsBlob());\n+\n+  // Open a cross-site popup and repeat these steps.\n+  GURL popup_url(embedded_test_server()->GetURL(\n+      \""b.com\"", \""/navigation_controller/page_with_data_iframe.html\""));\n+  Shell* new_shell = OpenPopup(root, popup_url, \""\"");\n+  FrameTreeNode* popup_root =\n+      static_cast<WebContentsImpl*>(new_shell->web_contents())\n+          ->GetFrameTree()\n+          ->root();\n+  FrameTreeNode* popup_subframe = popup_root->child_at(0);\n+\n+  TestNavigationObserver popup_observer(new_shell->web_contents());\n+  EXPECT_TRUE(ExecuteScript(popup_subframe, blob_script));\n+  popup_observer.Wait();\n+  RenderFrameHostImpl* popup_subframe_rfh =\n+      popup_subframe->current_frame_host();\n+  EXPECT_TRUE(popup_subframe_rfh->GetLastCommittedURL().SchemeIsBlob());\n+\n+  // Ensure that the two blob subframes don't share a process or SiteInstance.\n+  EXPECT_NE(subframe->current_frame_host()->GetSiteInstance(),\n+            popup_subframe->current_frame_host()->GetSiteInstance());\n+  EXPECT_NE(\n+      subframe->current_frame_host()->GetSiteInstance()->GetProcess(),\n+      popup_subframe->current_frame_host()->GetSiteInstance()->GetProcess());\n+  EXPECT_NE(\n+      subframe->current_frame_host()->GetSiteInstance()->GetSiteURL(),\n+      popup_subframe->current_frame_host()->GetSiteInstance()->GetSiteURL());\n+}\n+\n }  // namespace content""}","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    // In some cases, it is not safe to use just the scheme as a site URL, as
    // that might allow two URLs created by different sites to to share a
    // process.  See https://crbug.com/863623.
    //
    // TODO(alexmos,creis): This should eventually be expanded to certain other
    // schemes, such as data: and file:.
    if (url.SchemeIsBlob()) {
      // We get here for blob URLs of form blob:null/guid.  Use the full URL
      // with the guid in that case, which isolates all blob URLs with unique
      // origins from each other.  Remove hash from the URL, since
      // same-document navigations shouldn't use a different site URL.
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
",C,"    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
    // In some cases, it is not safe to use just the scheme as a site URL, as
    // that might allow two URLs created by different sites to to share a
    // process.  See https://crbug.com/863623.
    //
    // TODO(alexmos,creis): This should eventually be expanded to certain other
    // schemes, such as data: and file:.
    if (url.SchemeIsBlob()) {
      // We get here for blob URLs of form blob:null/guid.  Use the full URL
      // with the guid in that case, which isolates all blob URLs with unique
      // origins from each other.  Remove hash from the URL, since
      // same-document navigations shouldn't use a different site URL.
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

",,,"@@ -449,10 +449,30 @@ GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
   // This is useful for cases like file URLs.
   if (!origin.unique()) {
     // Prefer to use the scheme of |origin| rather than |url|, to correctly
-    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).
+    // cover blob:file: and filesystem:file: URIs (see also
+    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
+    // In some cases, it is not safe to use just the scheme as a site URL, as
+    // that might allow two URLs created by different sites to to share a
+    // process.  See https://crbug.com/863623.
+    //
+    // TODO(alexmos,creis): This should eventually be expanded to certain other
+    // schemes, such as data: and file:.
+    if (url.SchemeIsBlob()) {
+      // We get here for blob URLs of form blob:null/guid.  Use the full URL
+      // with the guid in that case, which isolates all blob URLs with unique
+      // origins from each other.  Remove hash from the URL, since
+      // same-document navigations shouldn't use a different site URL.
+      if (url.has_ref()) {
+        GURL::Replacements replacements;
+        replacements.ClearRef();
+        url = url.ReplaceComponents(replacements);
+      }
+      return url;
+    }
+
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }",Chrome,b1f87486936ca0d6d9abf4d3b9b423a9c976fd59,0ea138d60b5c616ac59cd0561022a3105fd35f01,1,"GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  // TODO(fsamuel, creis): For some reason appID is not recognized as a host.
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  // Isolated origins should use the full origin as their site URL. A subdomain
  // of an isolated origin should also use that isolated origin's site URL. It
  // is important to check |url| rather than |real_url| here, since some
  // effective URLs (such as for NTP) need to be resolved prior to the isolated
  // origin lookup.
  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  // If the url has a host, then determine the site.  Skip file URLs to avoid a
  // situation where site URL of file://localhost/ would mismatch Blink's origin
  // (which ignores the hostname in this case - see https://crbug.com/776160).
  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    // Only keep the scheme and registered domain of |origin|.
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  // If there is no host but there is a scheme, return the scheme.
   // This is useful for cases like file URLs.
   if (!origin.unique()) {
     // Prefer to use the scheme of |origin| rather than |url|, to correctly
//flaw_line_below:
    // cover blob: and filesystem: URIs (see also https://crbug.com/697111).
//fix_flaw_line_below:
//    // cover blob:file: and filesystem:file: URIs (see also
//fix_flaw_line_below:
//    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
//fix_flaw_line_below:
//    // In some cases, it is not safe to use just the scheme as a site URL, as
//fix_flaw_line_below:
//    // that might allow two URLs created by different sites to to share a
//fix_flaw_line_below:
//    // process.  See https://crbug.com/863623.
//fix_flaw_line_below:
//    //
//fix_flaw_line_below:
//    // TODO(alexmos,creis): This should eventually be expanded to certain other
//fix_flaw_line_below:
//    // schemes, such as data: and file:.
//fix_flaw_line_below:
//    if (url.SchemeIsBlob()) {
//fix_flaw_line_below:
//      // We get here for blob URLs of form blob:null/guid.  Use the full URL
//fix_flaw_line_below:
//      // with the guid in that case, which isolates all blob URLs with unique
//fix_flaw_line_below:
//      // origins from each other.  Remove hash from the URL, since
//fix_flaw_line_below:
//      // same-document navigations shouldn't use a different site URL.
//fix_flaw_line_below:
//      if (url.has_ref()) {
//fix_flaw_line_below:
//        GURL::Replacements replacements;
//fix_flaw_line_below:
//        replacements.ClearRef();
//fix_flaw_line_below:
//        url = url.ReplaceComponents(replacements);
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//      return url;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  // Otherwise the URL should be invalid; return an empty site.
  DCHECK(!url.is_valid()) << url;
  return GURL();
}
",187175,"GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

   if (!origin.unique()) {
    // cover blob:file: and filesystem:file: URIs (see also
    // https://crbug.com/697111).
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    // In some cases, it is not safe to use just the scheme as a site URL, as
    // that might allow two URLs created by different sites to to share a
    // process.  See https://crbug.com/863623.
    //
    // TODO(alexmos,creis): This should eventually be expanded to certain other
    // schemes, such as data: and file:.
    if (url.SchemeIsBlob()) {
      // We get here for blob URLs of form blob:null/guid.  Use the full URL
      // with the guid in that case, which isolates all blob URLs with unique
      // origins from each other.  Remove hash from the URL, since
      // same-document navigations shouldn't use a different site URL.
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","The vulnerability in the original code arises from the handling of URLs, particularly in the case of blob URLs, which could allow different sites to share a process, compromising security. Specifically, the code did not differentiate between blob URLs and other schemes, potentially leading to cross-origin issues. The fix introduces a check for `url.SchemeIsBlob()`, ensuring that blob URLs are treated uniquely by returning the full URL without the hash, thus isolating them from other blob URLs. This change enhances security by preventing unintended sharing of processes between different origins.","The vulnerability in the original code stems from inadequate handling of certain URL schemes, particularly blob URLs, which could lead to cross-origin security issues by allowing different sites to share a process. This oversight could enable malicious sites to exploit shared resources, compromising user data and privacy. The fix addresses this vulnerability by introducing a specific check for blob URLs, ensuring they are treated distinctly and returned in their full form without any hash components. This adjustment effectively isolates blob URLs, enhancing security by preventing unintended interactions between different origins.","CWE-346,CWE-610,CWE-200,CWE-611,CWE-918,CWE-942,CWE-601,CWE-79,CWE-264,CWE-668",N,-1.0,3.0,5.0,5.0,4.0
3,3,187201,187201,,Remote,Not required,,CVE-2018-16086,https://www.cvedetails.com/cve/CVE-2018-16086/,CWE-285,Medium,Partial,Partial,,2019-06-27,5.8,Insufficient policy enforcement in extensions API in Google Chrome prior to 69.0.3497.81 allowed an attacker who convinced a user to install a malicious extension to bypass navigation restrictions via a crafted Chrome Extension.,2019-07-01,Bypass ,2,https://github.com/chromium/chromium/commit/8247b125c7b6888dc1c3932e19d6d8fe5a74a460,8247b125c7b6888dc1c3932e19d6d8fe5a74a460,"Extensions: Prevent content script injection in the New tab Page.

r487664 disallowed content script injection in the New Tab Page. However, the
check in RendererPermissionsPolicyDelegate::IsRestrictedUrl for the same, might
not work due to the following reasons:
  - There might be a race between checking if the extension can inject the
    script and setting the new tab url in the renderer (SearchBouncer).
  - The New Tab page url in the SearchBouncer might be set incorrectly due to
    incorrect handling of multiple profiles by InstantService.

Fix this by checking if the current renderer process is an Instant (NTP)
renderer. This should work since the NTP renderer process should not be shared
with other sites.

BUG=844428, 662610

Change-Id: I45f6b27fb2680d3b8df6e1da223452ffee09b0d8
Reviewed-on: https://chromium-review.googlesource.com/1068607
Reviewed-by: Devlin <rdevlin.cronin@chromium.org>
Commit-Queue: Karan Bhatia <karandeepb@chromium.org>
Cr-Commit-Position: refs/heads/master@{#563031}",1,chrome/renderer/extensions/renderer_permissions_policy_delegate.cc,"{""sha"": ""28fcf0e428f5f70b3fc85ccf1706aa699b534547"", ""filename"": ""chrome/browser/extensions/content_script_apitest.cc"", ""status"": ""modified"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/browser/extensions/content_script_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/browser/extensions/content_script_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/content_script_apitest.cc?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -20,8 +20,10 @@\n #include \""chrome/browser/search/search.h\""\n #include \""chrome/browser/ui/browser.h\""\n #include \""chrome/browser/ui/javascript_dialogs/javascript_dialog_tab_helper.h\""\n+#include \""chrome/browser/ui/search/local_ntp_test_utils.h\""\n #include \""chrome/browser/ui/tabs/tab_strip_model.h\""\n #include \""chrome/common/chrome_switches.h\""\n+#include \""chrome/common/webui_url_constants.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/javascript_dialog_manager.h\""\n #include \""content/public/browser/render_frame_host.h\""\n@@ -798,4 +800,63 @@ IN_PROC_BROWSER_TEST_F(ContentScriptApiTest, ExecuteScriptBypassingSandbox) {\n   ASSERT_TRUE(catcher.GetNextResult()) << catcher.message();\n }\n \n+// Test fixture which sets a custom NTP Page.\n+// TODO(karandeepb): Similar logic to set up a custom NTP is used elsewhere as\n+// well. Abstract this away into a reusable test fixture class.\n+class NTPInterceptionTest : public ExtensionApiTest {\n+ public:\n+  NTPInterceptionTest()\n+      : https_test_server_(net::EmbeddedTestServer::TYPE_HTTPS) {}\n+\n+  // ExtensionApiTest override:\n+  void SetUpOnMainThread() override {\n+    ExtensionApiTest::SetUpOnMainThread();\n+    test_data_dir_ = test_data_dir_.AppendASCII(\""ntp_content_script\"");\n+    https_test_server_.ServeFilesFromDirectory(test_data_dir_);\n+    ASSERT_TRUE(https_test_server_.Start());\n+\n+    GURL ntp_url = https_test_server_.GetURL(\""/fake_ntp.html\"");\n+    local_ntp_test_utils::SetUserSelectedDefaultSearchProvider(\n+        profile(), https_test_server_.base_url().spec(), ntp_url.spec());\n+  }\n+\n+  const net::EmbeddedTestServer* https_test_server() const {\n+    return &https_test_server_;\n+  }\n+\n+ private:\n+  net::EmbeddedTestServer https_test_server_;\n+  DISALLOW_COPY_AND_ASSIGN(NTPInterceptionTest);\n+};\n+\n+// Ensure extensions can't inject a content script into the New Tab page.\n+// Regression test for crbug.com/844428.\n+IN_PROC_BROWSER_TEST_F(NTPInterceptionTest, ContentScript) {\n+  // Load an extension which tries to inject a script into every frame.\n+  ExtensionTestMessageListener listener(\""ready\"", false /*will_reply*/);\n+  const Extension* extension = LoadExtension(test_data_dir_);\n+  ASSERT_TRUE(extension);\n+  ASSERT_TRUE(listener.WaitUntilSatisfied());\n+\n+  // Create a corresponding off the record profile for the current profile. This\n+  // is necessary to reproduce crbug.com/844428, which occurs in part due to\n+  // incorrect handling of multiple profiles by the NTP code.\n+  Browser* incognito_browser = CreateIncognitoBrowser(profile());\n+  ASSERT_TRUE(incognito_browser);\n+\n+  // Ensure that the extension isn't able to inject the script into the New Tab\n+  // Page.\n+  ui_test_utils::NavigateToURL(browser(), GURL(chrome::kChromeUINewTabURL));\n+  content::WebContents* web_contents =\n+      browser()->tab_strip_model()->GetActiveWebContents();\n+  ASSERT_TRUE(search::IsInstantNTP(web_contents));\n+\n+  bool script_injected_in_ntp = false;\n+  ASSERT_TRUE(ExecuteScriptAndExtractBool(\n+      web_contents,\n+      \""window.domAutomationController.send(document.title !== 'Fake NTP');\"",\n+      &script_injected_in_ntp));\n+  EXPECT_FALSE(script_injected_in_ntp);\n+}\n+\n }  // namespace extensions""}<_**next**_>{""sha"": ""22fcfa02bd9589a462e2d404ebea98a4e9ad8ca2"", ""filename"": ""chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/extensions/renderer_permissions_policy_delegate.cc?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -4,8 +4,9 @@\n \n #include \""chrome/renderer/extensions/renderer_permissions_policy_delegate.h\""\n \n+#include \""base/command_line.h\""\n+#include \""chrome/common/chrome_switches.h\""\n #include \""chrome/common/extensions/extension_constants.h\""\n-#include \""chrome/renderer/searchbox/search_bouncer.h\""\n #include \""extensions/common/constants.h\""\n #include \""extensions/common/extensions_client.h\""\n #include \""extensions/common/manifest_constants.h\""\n@@ -33,7 +34,8 @@ bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n     return true;\n   }\n \n-  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          ::switches::kInstantProcess)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;""}<_**next**_>{""sha"": ""558f3ed4b5027c73094ec0118f3fda2793022be1"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""status"": ""added"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/background.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/background.js?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,5 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+chrome.test.sendMessage('ready');""}<_**next**_>{""sha"": ""b8a5a02f13fb19e4fdd03f0c176f4c79cdaf5379"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/content_script.js?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,7 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+document.addEventListener('DOMContentLoaded', function() {\n+  document.title = 'injected';\n+});""}<_**next**_>{""sha"": ""2a39a503af9fbc28778166b6b3ae9d2b4114f8e3"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/fake_ntp.html?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+  <title>Fake NTP</title>\n+</head>\n+<body>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""efa8cc384007b32738737fdfa336623d3a22493c"", ""filename"": ""chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""status"": ""added"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8247b125c7b6888dc1c3932e19d6d8fe5a74a460/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/ntp_content_script/manifest.json?ref=8247b125c7b6888dc1c3932e19d6d8fe5a74a460"", ""patch"": ""@@ -0,0 +1,23 @@\n+{\n+  \""manifest_version\"": 2,\n+  \""name\"": \""NTP content script injection\"",\n+  \""version\"": \""1\"",\n+  \""description\"": \""Test for crbug.com/844428\"",\n+  \""content_scripts\"": [\n+    {\n+      \""matches\"": [\n+        \""<all_urls>\""\n+      ],\n+      \""js\"": [\n+        \""content_script.js\""\n+      ],\n+      \""run_at\"": \""document_start\"",\n+      \""all_frames\"": true\n+    }\n+  ],\n+  \""background\"": {\n+    \""scripts\"": [\n+      \""background.js\""\n+    ]\n+  }\n+}""}","bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
","bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
",C,"  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          ::switches::kInstantProcess)) {
","  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
",,"@@ -4,8 +4,9 @@
 
 #include ""chrome/renderer/extensions/renderer_permissions_policy_delegate.h""
 
+#include ""base/command_line.h""
+#include ""chrome/common/chrome_switches.h""
 #include ""chrome/common/extensions/extension_constants.h""
-#include ""chrome/renderer/searchbox/search_bouncer.h""
 #include ""extensions/common/constants.h""
 #include ""extensions/common/extensions_client.h""
 #include ""extensions/common/manifest_constants.h""
@@ -33,7 +34,8 @@ bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
     return true;
   }
 
-  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;",Chrome,8247b125c7b6888dc1c3932e19d6d8fe5a74a460,3d1cba08168abe3a7c51639e49659b8381dfb66f,1,"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
//flaw_line_below:
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
//fix_flaw_line_below:
//  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
//fix_flaw_line_below:
//          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
",187201,"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
","bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          ::switches::kInstantProcess)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
","The vulnerability in the original code lies in the reliance on `SearchBouncer::GetInstance()->IsNewTabPage(document_url)` to determine if a URL is restricted, which could potentially allow unauthorized access to scripting on new tab pages. This could be exploited by malicious extensions. The fix replaces this check with `base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kInstantProcess)`, which provides a more secure method of determining if the current process is allowed to script the page. This change enhances security by ensuring that only processes explicitly marked as safe can access restricted URLs, thereby mitigating the risk of exploitation.","The vulnerability in the original code stems from an inadequate check that allowed potentially malicious extensions to script new tab pages, posing a security risk. This could enable unauthorized access and manipulation of sensitive content. The fix addresses this issue by replacing the original check with a more robust mechanism that verifies the current process's legitimacy. This change ensures that only processes explicitly designated as safe can interact with restricted URLs, thereby enhancing the overall security posture and preventing exploitation by malicious actors seeking to manipulate the browser environment.","CWE-284, CWE-749, CWE-20, CWE-416, CWE-269, CWE-732, CWE-346, CWE-1321, CWE-610, CWE-942",N,-1.0,4.0,5.0,3.0,3.0
