,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,F1_Clarity_C5,F2_Relevance_C5,F3_Completeness_C5,F4_Actionability_C5
0,0,177857,177857,,Remote,Not required,Partial,CVE-2019-13636,https://www.cvedetails.com/cve/CVE-2019-13636/,CWE-59,Medium,,Partial,,2019-07-17,5.8,"In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c.",2019-07-24,,6,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,dce4683cbbe107a95f1f0d45fabc304acfb5d71a,,1,,,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  size_t buffered = 0, n;
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
",C,"	  int flags = O_RDONLY | binary_transput;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
","	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
",61d7788b83b302207a67b82786f4fd79e3538f30,"@@ -238,8 +238,13 @@ plan_a (char const *filename)
     {
       if (S_ISREG (instat.st_mode))
         {
-	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
+	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
+	  int ifd;
+
+	  if (! follow_symlinks)
+	    flags |= O_NOFOLLOW;
+	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
@@ -340,6 +345,7 @@ plan_a (char const *filename)
 static void
 plan_b (char const *filename)
 {
+  int flags = O_RDONLY | binary_transput;
   int ifd;
   FILE *ifp;
   int c;
@@ -353,7 +359,9 @@ plan_b (char const *filename)
 
   if (instat.st_size == 0)
     filename = NULL_DEVICE;
-  if ((ifd = safe_open (filename, O_RDONLY | binary_transput, 0)) < 0
+  if (! follow_symlinks)
+    flags |= O_NOFOLLOW;
+  if ((ifd = safe_open (filename, flags, 0)) < 0
       || ! (ifp = fdopen (ifd, binary_transput ? ""rb"" : ""r"")))
     pfatal (""Can't open file %s"", quotearg (filename));
   if (TMPINNAME_needs_removal)",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=61d7788b83b302207a67b82786f4fd79e3538f30,1,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
//flaw_line_below:
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
//fix_flaw_line_below:
//	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
//fix_flaw_line_below:
//	  int ifd;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	  if (! follow_symlinks)
//fix_flaw_line_below:
//	    flags |= O_NOFOLLOW;
//fix_flaw_line_below:
//	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
",177857,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  size_t buffered = 0, n;
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","The vulnerability in the original code arises from the lack of handling symbolic links when opening files, which could lead to unintended file access or manipulation. Specifically, the `safe_open` function is called with flags that do not prevent following symbolic links, potentially exposing sensitive files. In the fixed code, a new variable `flags` is introduced, and the `O_NOFOLLOW` flag is conditionally added based on the `follow_symlinks` variable. This change ensures that symbolic links are not followed unless explicitly allowed, thereby mitigating the risk of unauthorized file access.","The vulnerability in the original code stems from the lack of protection against symbolic link traversal, which could allow an attacker to manipulate or access unintended files. This oversight could lead to unauthorized access to sensitive data or system files, posing a significant security risk. The fixed code addresses this vulnerability by introducing a mechanism to conditionally prevent following symbolic links when opening files. By implementing this safeguard, the code ensures that only the intended files are accessed, thereby enhancing security and reducing the risk of exploitation through symbolic link attacks.","CWE-59,CWE-61,CWE-73,CWE-40,CWE-66,CWE-426,CWE-386,CWE-610,CWE-367,CWE-363",Y,1.0,2,4,2,4
1,1,179457,179457,,Local,Not required,Complete,CVE-2014-5045,https://www.cvedetails.com/cve/CVE-2014-5045/,CWE-59,High,Complete,Complete,,2014-08-01,6.2,"The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program.",2017-01-06,DoS ,2,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,295dc39d941dc2ae53d5c170365af4c9d5c16212,"fs: umount on symlink leaks mnt count

Currently umount on symlink blocks following umount:

/vz is separate mount

# ls /vz/ -al | grep test
drwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir
lrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir
# umount -l /vz/testlink
umount: /vz/testlink: not mounted (expected)

# lsof /vz
# umount /vz
umount: /vz: device is busy. (unexpected)

In this case mountpoint_last() gets an extra refcount on path->mnt

Signed-off-by: Vasily Averin <vvs@openvz.org>
Acked-by: Ian Kent <raven@themaw.net>
Acked-by: Jeff Layton <jlayton@primarydata.com>
Cc: stable@vger.kernel.org
Signed-off-by: Christoph Hellwig <hch@lst.de>",1,fs/namei.c,"{""sha"": ""9eb787e5c167fb601845590f0181d249bf515fb0"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=295dc39d941dc2ae53d5c170365af4c9d5c16212"", ""patch"": ""@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n-\tpath->mnt = mntget(nd->path.mnt);\n+\tpath->mnt = nd->path.mnt;\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n+\tmntget(path->mnt);\n \tfollow_mount(path);\n \terror = 0;\n out:""}","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
",C,"	path->mnt = nd->path.mnt;
	mntget(path->mnt);
","	path->mnt = mntget(nd->path.mnt);
",,"@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)
 		goto out;
 	}
 	path->dentry = dentry;
-	path->mnt = mntget(nd->path.mnt);
+	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
+	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:",linux,295dc39d941dc2ae53d5c170365af4c9d5c16212,6fcc5420bfb91049a318bb4d88fe471248b5b391,1,"mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
//flaw_line_below:
	path->mnt = mntget(nd->path.mnt);
//fix_flaw_line_below:
//	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
//fix_flaw_line_below:
//	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
",179457,"mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","The vulnerability in the original code lies in the handling of the `path->mnt` assignment, which could lead to a use-after-free condition if the `mnt` reference is not properly managed. Specifically, the code assigns `path->mnt` using `mntget(nd->path.mnt)` but does not ensure that the reference count is correctly incremented before using it in `follow_mount(path)`. In the fixed code, this issue is addressed by directly assigning `path->mnt` to `nd->path.mnt` and then calling `mntget(path->mnt)` before `follow_mount(path)`, ensuring that the mount reference is valid and properly managed throughout the function.","The vulnerability in the original code stems from improper management of resource references, which could lead to a use-after-free condition. Specifically, the code assigns a resource reference without ensuring that it is properly incremented before being used in subsequent operations. This oversight could result in accessing a resource that has already been freed, leading to potential crashes or security issues. The fixed code addresses this vulnerability by ensuring that the resource reference is correctly managed and incremented before any further operations are performed, thereby preventing the risk of accessing invalid memory.","CWE-416,CWE-672,CWE-825,CWE-415,CWE-911,CWE-665,CWE-119,CWE-401,CWE-772,CWE-404",N,-1.0,2,5,4,1
2,2,179776,179776,,Local,Not required,Complete,CVE-2015-5287,https://www.cvedetails.com/cve/CVE-2015-5287/,CWE-59,Medium,Complete,Complete,,2015-12-07,6.9,"The abrt-hook-ccpp help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users with certain permissions to gain privileges via a symlink attack on a file with a predictable name, as demonstrated by /var/tmp/abrt/abrt-hax-coredump or /var/spool/abrt/abrt-hax-coredump.",2016-12-07,+Priv ,2,https://github.com/abrt/abrt/commit/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,"ccpp: save abrt core files only to new files

Prior this commit abrt-hook-ccpp saved a core file generated by a
process running a program whose name starts with ""abrt"" in
DUMP_LOCATION/$(basename program)-coredump. If the file was a symlink,
the hook followed and wrote core file to the symlink's target.

Addresses CVE-2015-5287

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""58d9c28d20a2534cb92eea1dbb19069064393751"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/abrt/abrt/blob/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=3c1b60cfa62d39e5fff5a53a5bc53dae189e740e"", ""patch"": ""@@ -718,7 +718,8 @@ int main(int argc, char** argv)\n         if (snprintf(path, sizeof(path), \""%s/%s-coredump\"", g_settings_dump_location, last_slash) >= sizeof(path))\n             error_msg_and_die(\""Error saving '%s': truncated long file path\"", path);\n \n-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n+        unlink(path);\n+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n         if (core_size < 0 || fsync(abrt_core_fd) != 0)\n         {""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
",C,"        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
","        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
",,"@@ -718,7 +718,8 @@ int main(int argc, char** argv)
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
+        unlink(path);
+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {",abrt,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,dec3089ff88fe7ada77058dca6ed3ad88c18ee16,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
//flaw_line_below:
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
//fix_flaw_line_below:
//        unlink(path);
//fix_flaw_line_below:
//        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;

        // Disabled for now: /proc/PID/smaps tends to be BIG,
        // and not much more informative than /proc/PID/maps:
        // dd_copy_file(dd, FILENAME_SMAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
",179776,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","The vulnerability in the original code arises from the potential for a race condition when handling file descriptors, particularly with the `unlink(path)` operation. If the `unlink` is called before the file is fully created or if multiple processes attempt to create the same file simultaneously, it could lead to unexpected behavior or security issues, such as exposing sensitive data. The fix in the modified code introduces the use of `O_EXCL` in the `xopen3` function, ensuring that the file is created exclusively, preventing race conditions by failing if the file already exists. This change enhances the security and reliability of file handling in the application.","The vulnerability in the original code stems from the potential for race conditions when creating and managing files, particularly during the unlinking process. If multiple processes attempt to create or delete the same file simultaneously, it could lead to unexpected behavior, such as file corruption or unauthorized access to sensitive data. The revised code addresses this issue by implementing exclusive file creation, which ensures that a file cannot be created if it already exists. This change effectively mitigates the risk of race conditions, enhancing the overall security and stability of the file handling operations.","CWE-367, CWE-362, CWE-366, CWE-364, CWE-365, CWE-363, CWE-667, CWE-659, CWE-374, CWE-673",N,-1.0,"4

The explanation provides clear details about core dump handling with well-structured code and useful comments. It explains various configurations and error checking steps. However, it could be more comprehensible with additional high-level documentation about the purpose and flow.","5

The explanation and repair description is fully relevant to the code snippet. The provided text contains an exact match of the code that needs to be repaired, showing the full context around the unlink() call that was causing race condition vulnerabilities. The code snippet corresponds precisely to the crash handler routine for the ABRT crash reporting system with all the relevant variables, logic flow, and error handling. The full code for the main() function is present, allowing complete understanding of the vulnerability context.","2

The explanation and repair description is limited in detail. The code shows a vulnerability and fix related to file handling and secure file creation, but lacks clear explanation of:

1. The specific nature of the race condition vulnerability being fixed
2. The impact/risks of the vulnerability
3. How the fix (adding unlink(path) before open) resolves the issue
4. Best practices for secure file handling that this fix follows

A complete explanation would include these details while the current code mainly just shows the fix without proper explanation of the security implications and rationale.

The rating of 2 out of 5 reflects that while some fix information is present in the code itself, the explanation and repair description lack important details needed to fully understand the vulnerability and repair.","5

The explanation provides highly detailed, step-by-step information about how to handle core dumps and vulnerability management, including specific code snippets, configuration parameters, repair steps, and error handling. It includes clear information about:

1. File permission handling
2. Core dump management
3. Error checking and validation
4. Resource cleanup
5. Security considerations

The text gives complete implementation details that would allow someone to act on the vulnerability and implement proper fixes."
3,3,179781,179781,,Local,Not required,Partial,CVE-2015-5273,https://www.cvedetails.com/cve/CVE-2015-5273/,CWE-59,Low,,Partial,,2015-12-07,3.6,The abrt-action-install-debuginfo-to-abrt-cache help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users to write to arbitrary files via a symlink attack on unpacked.cpio in a pre-created directory with a predictable name in /var/tmp.,2016-12-07,,37,https://github.com/abrt/abrt/commit/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,"a-a-i-d-to-abrt-cache: make own random temporary directory

The set-user-ID wrapper must use own new temporary directory in order to
avoid security issues with unpacking specially crafted debuginfo
packages that might be used to create files or symlinks anywhere on the
file system as the abrt user.

Withot the forking code the temporary directory would remain on the
filesystem in the case where all debuginfo data are already available.
This is caused by the fact that the underlying libreport functionality
accepts path to a desired temporary directory and creates it only if
necessary. Otherwise, the directory is not touched at all.

This commit addresses CVE-2015-5273

Signed-off-by: Jakub Filak <jfilak@redhat.com>",4,src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c,"{""sha"": ""005cc9da147fc0adcfc85b82f6805bb399d28284"", ""filename"": ""src/plugins/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/Makefile.am?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -371,6 +371,7 @@ abrt_action_install_debuginfo_to_abrt_cache_CPPFLAGS = \\\n     -D_GNU_SOURCE \\\n     -DBIN_DIR=\\\""$(bindir)\\\"" \\\n     -DSBIN_DIR=\\\""$(sbindir)\\\"" \\\n+    -DLARGE_DATA_TMP_DIR=\\\""$(LARGE_DATA_TMP_DIR)\\\"" \\\n     $(LIBREPORT_CFLAGS) \\\n     -Wall -Wwrite-strings \\\n     -fPIE""}<_**next**_>{""sha"": ""52d00de6291968a4bd5c72f18ca27ddd7a1a7f77"", ""filename"": ""src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 4, ""changes"": 41, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -108,8 +108,14 @@ int main(int argc, char **argv)\n         build_ids_self_fd = xasprintf(\""/proc/self/fd/%d\"", build_ids_fd);\n     }\n \n-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n-    const char *args[11];\n+    char tmp_directory[] = LARGE_DATA_TMP_DIR\""/abrt-tmp-debuginfo.XXXXXX\"";\n+    if (mkdtemp(tmp_directory) == NULL)\n+        perror_msg_and_die(\""Failed to create working directory\"");\n+\n+    log_info(\""Created working directory: %s\"", tmp_directory);\n+\n+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */\n+    const char *args[13];\n     {\n         const char *verbs[] = { \""\"", \""-v\"", \""-vv\"", \""-vvv\"" };\n         unsigned i = 0;\n@@ -130,6 +136,8 @@ int main(int argc, char **argv)\n             args[i++] = \""--repo\"";\n             args[i++] = repo;\n         }\n+        args[i++] = \""--tmpdir\"";\n+        args[i++] = tmp_directory;\n         args[i++] = \""--\"";\n         args[i] = NULL;\n     }\n@@ -204,6 +212,31 @@ int main(int argc, char **argv)\n         umask(0022);\n     }\n \n-    execvp(EXECUTABLE, (char **)args);\n-    error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    pid_t pid = fork();\n+    if (pid < 0)\n+        perror_msg_and_die(\""fork\"");\n+\n+    if (pid == 0)\n+    {\n+        execvp(EXECUTABLE, (char **)args);\n+        error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    }\n+\n+    int status;\n+    if (safe_waitpid(pid, &status, 0) < 0)\n+        perror_msg_and_die(\""waitpid\"");\n+\n+    if (rmdir(tmp_directory) >= 0)\n+        log_info(\""Removed working directory: %s\"", tmp_directory);\n+    else if (errno != ENOENT)\n+        perror_msg(\""Failed to remove working directory\"");\n+\n+    /* Normal execution should exit here. */\n+    if (WIFEXITED(status))\n+        return WEXITSTATUS(status);\n+\n+    if (WIFSIGNALED(status))\n+        error_msg_and_die(\""Child terminated with signal %d\"", WTERMSIG(status));\n+\n+    error_msg_and_die(\""Child exit failed\"");\n }""}","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
 }
","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
 }
",C,"    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
","    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
",,"@@ -108,8 +108,14 @@ int main(int argc, char **argv)
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
-    const char *args[11];
+    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
+    if (mkdtemp(tmp_directory) == NULL)
+        perror_msg_and_die(""Failed to create working directory"");
+
+    log_info(""Created working directory: %s"", tmp_directory);
+
+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
+    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
@@ -130,6 +136,8 @@ int main(int argc, char **argv)
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
+        args[i++] = ""--tmpdir"";
+        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }
@@ -204,6 +212,31 @@ int main(int argc, char **argv)
         umask(0022);
     }
 
-    execvp(EXECUTABLE, (char **)args);
-    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    pid_t pid = fork();
+    if (pid < 0)
+        perror_msg_and_die(""fork"");
+
+    if (pid == 0)
+    {
+        execvp(EXECUTABLE, (char **)args);
+        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    }
+
+    int status;
+    if (safe_waitpid(pid, &status, 0) < 0)
+        perror_msg_and_die(""waitpid"");
+
+    if (rmdir(tmp_directory) >= 0)
+        log_info(""Removed working directory: %s"", tmp_directory);
+    else if (errno != ENOENT)
+        perror_msg(""Failed to remove working directory"");
+
+    /* Normal execution should exit here. */
+    if (WIFEXITED(status))
+        return WEXITSTATUS(status);
+
+    if (WIFSIGNALED(status))
+        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
+
+    error_msg_and_die(""Child exit failed"");
 }",abrt,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,bfd3a454cd0a10e8384f8ce421e752867259c874,1,"int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
//flaw_line_below:
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
//flaw_line_below:
    const char *args[11];
//fix_flaw_line_below:
//    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
//fix_flaw_line_below:
//    if (mkdtemp(tmp_directory) == NULL)
//fix_flaw_line_below:
//        perror_msg_and_die(""Failed to create working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    log_info(""Created working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
//fix_flaw_line_below:
//    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
//fix_flaw_line_below:
//        args[i++] = ""--tmpdir"";
//fix_flaw_line_below:
//        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1
// We forgot to sanitize PYTHONPATH. And who knows what else we forgot
// (especially considering *future* new variables of this kind).
// We switched to clearing entire environment instead:

        // However since we communicate through environment variables
        // we have to keep a whitelist of variables to keep.
        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        // Now we can clear the environment
        clearenv();

        // And once again set whitelisted variables
        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        // Adding configure --bindir and --sbindir to the PATH so that
        // abrt-action-install-debuginfo doesn't fail when spawning
        // abrt-action-trim-files
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
//flaw_line_below:
    execvp(EXECUTABLE, (char **)args);
//flaw_line_below:
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    pid_t pid = fork();
//fix_flaw_line_below:
//    if (pid < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""fork"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (pid == 0)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        execvp(EXECUTABLE, (char **)args);
//fix_flaw_line_below:
//        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    int status;
//fix_flaw_line_below:
//    if (safe_waitpid(pid, &status, 0) < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""waitpid"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (rmdir(tmp_directory) >= 0)
//fix_flaw_line_below:
//        log_info(""Removed working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//    else if (errno != ENOENT)
//fix_flaw_line_below:
//        perror_msg(""Failed to remove working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* Normal execution should exit here. */
//fix_flaw_line_below:
//    if (WIFEXITED(status))
//fix_flaw_line_below:
//        return WEXITSTATUS(status);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (WIFSIGNALED(status))
//fix_flaw_line_below:
//        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    error_msg_and_die(""Child exit failed"");
 }
",179781,"int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
 }
","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
 }
","The vulnerability in the original code arises from the handling of user privileges and environment variables, which could allow a malicious user to manipulate the environment of a setuid program, potentially leading to privilege escalation or arbitrary code execution. Specifically, the code does not adequately sanitize the environment before executing the `EXECUTABLE`, leaving sensitive variables like `LD_PRELOAD` intact. The fix introduces a temporary directory using `mkdtemp` and ensures that the environment is cleared and only safe variables are retained, thus mitigating the risk of exploitation by controlling the environment in which the `execvp` function is called.","The vulnerability in the original code stems from inadequate handling of user privileges and environment variables, which could allow an attacker to manipulate the execution context of a setuid program. This oversight could lead to privilege escalation or arbitrary code execution, as sensitive environment variables were not properly sanitized before executing a subprocess. The revised code addresses this vulnerability by creating a temporary directory for safe operations and ensuring that the environment is cleared of potentially harmful variables, thereby restricting the execution context and enhancing security against exploitation attempts.","CWE-272, CWE-266, CWE-269, CWE-426, CWE-263, CWE-78, CWE-250, CWE-284, CWE-732, CWE-427",N,-1.0,3,5,4,4
4,4,179897,179897,,Local,Not required,,CVE-2015-1331,https://www.cvedetails.com/cve/CVE-2015-1331/,CWE-59,Low,,Complete,,2015-08-12,4.9,lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.,2019-05-31,,10,https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6,72cf81f6a3404e35028567db2c99a90406e9c6e6,"CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc

This prevents an unprivileged user to use LXC to create arbitrary file
on the filesystem.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
Acked-by: Stéphane Graber <stgraber@ubuntu.com>",36,src/lxc/lxclock.c,"{""sha"": ""e9e95f7a01d924f824c9a127cd624802c6ed5265"", ""filename"": ""src/lxc/lxclock.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 37, ""changes"": 47, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/lxclock.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)\n \tchar *rundir;\n \n \t/* lockfile will be:\n-\t * \""/run\"" + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n+\t * \""/run\"" + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n \t * or\n-\t * $XDG_RUNTIME_DIR + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n+\t * $XDG_RUNTIME_DIR + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n-\t/* length of \""/lock/lxc/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n-\tlen = strlen(\""/lock/lxc/\"") + strlen(n) + strlen(p) + 3;\n+\t/* length of \""/lxc/lock/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n+\tlen = strlen(\""/lxc/lock/\"") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)\n \t\treturn NULL;\n \t}\n \n-\tret = snprintf(dest, len, \""%s/lock/lxc/%s\"", rundir, p);\n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s\"", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n-\t\t/* fall back to \""/tmp/\"" + $(id -u) + \""/lxc\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0'\n-\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n-\t\t * * lxcpath always starts with '/'\n-\t\t */\n-\t\tint l2 = 22 + strlen(n) + strlen(p);\n-\t\tif (l2 > len) {\n-\t\t\tchar *d;\n-\t\t\td = realloc(dest, l2);\n-\t\t\tif (!d) {\n-\t\t\t\tfree(dest);\n-\t\t\t\tfree(rundir);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tlen = l2;\n-\t\t\tdest = d;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s\"", geteuid(), p);\n-\t\tif (ret < 0 || ret >= len) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = mkdir_p(dest, 0755);\n-\t\tif (ret < 0) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s/.%s\"", geteuid(), p, n);\n-\t} else\n-\t\tret = snprintf(dest, len, \""%s/lock/lxc/%s/.%s\"", rundir, p, n);\n+\t\tfree(dest);\n+\t\tfree(rundir);\n+\t\treturn NULL;\n+\t}\n \n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s/.%s\"", rundir, p, n);\n \tfree(rundir);\n-\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;""}<_**next**_>{""sha"": ""233ca127c6dec567e775abbbb0ef9ce0ed417e43"", ""filename"": ""src/tests/locktests.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/locktests.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -122,7 +122,7 @@ int main(int argc, char *argv[])\n \t\texit(1);\n \t}\n \tstruct stat sb;\n-\tchar *pathname = RUNTIME_PATH \""/lock/lxc/var/lib/lxc/\"";\n+\tchar *pathname = RUNTIME_PATH \""/lxc/lock/var/lib/lxc/\"";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \""%d: filename %s not created\\n\"", __LINE__,""}","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
",C,"	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
		free(dest);
		free(rundir);
		return NULL;
	}
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
","	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
",,"@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)
 	char *rundir;
 
 	/* lockfile will be:
-	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
+	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
-	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
+	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
-	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
-	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
+	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
+	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)
 		return NULL;
 	}
 
-	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
-		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
-		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
-		 * * lxcpath always starts with '/'
-		 */
-		int l2 = 22 + strlen(n) + strlen(p);
-		if (l2 > len) {
-			char *d;
-			d = realloc(dest, l2);
-			if (!d) {
-				free(dest);
-				free(rundir);
-				return NULL;
-			}
-			len = l2;
-			dest = d;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
-		if (ret < 0 || ret >= len) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = mkdir_p(dest, 0755);
-		if (ret < 0) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
-	} else
-		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
+		free(dest);
+		free(rundir);
+		return NULL;
+	}
 
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
-
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;",lxc,72cf81f6a3404e35028567db2c99a90406e9c6e6,f52c0d2677e365289e921cfd38033c0c987cefd5,1,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
//flaw_line_below:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
//fix_flaw_line_below:
//	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
//flaw_line_below:
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
//fix_flaw_line_below:
//	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
//flaw_line_below:
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//flaw_line_below:
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
//fix_flaw_line_below:
//	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//fix_flaw_line_below:
//	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
//flaw_line_below:
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
//flaw_line_below:
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
//flaw_line_below:
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
//flaw_line_below:
		 * * lxcpath always starts with '/'
//flaw_line_below:
		 */
//flaw_line_below:
		int l2 = 22 + strlen(n) + strlen(p);
//flaw_line_below:
		if (l2 > len) {
//flaw_line_below:
			char *d;
//flaw_line_below:
			d = realloc(dest, l2);
//flaw_line_below:
			if (!d) {
//flaw_line_below:
				free(dest);
//flaw_line_below:
				free(rundir);
//flaw_line_below:
				return NULL;
//flaw_line_below:
			}
//flaw_line_below:
			len = l2;
//flaw_line_below:
			dest = d;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
//flaw_line_below:
		if (ret < 0 || ret >= len) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = mkdir_p(dest, 0755);
//flaw_line_below:
		if (ret < 0) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
//flaw_line_below:
	} else
//flaw_line_below:
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
//fix_flaw_line_below:
//		free(dest);
//fix_flaw_line_below:
//		free(rundir);
//fix_flaw_line_below:
//		return NULL;
//fix_flaw_line_below:
//	}
 
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
//flaw_line_below:

 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
",179897,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","The vulnerability in the original code lies in the handling of the directory path for lock files, which could lead to a potential directory traversal or improper path construction due to the incorrect concatenation of strings. Specifically, the path was constructed using `""/lock/lxc/""`, which could be misinterpreted or manipulated. In the fixed code, the path was changed to `""/lxc/lock/""`, ensuring a more consistent and secure directory structure. Additionally, the redundant fallback logic was removed, simplifying the code and reducing the risk of errors, while maintaining proper memory management and error handling throughout the function.","The vulnerability in the original code stemmed from improper path construction for lock files, which could lead to directory traversal attacks or the creation of unintended directories. The concatenation of strings in the path could allow an attacker to manipulate the input, potentially gaining access to sensitive areas of the filesystem. In the revised code, the path structure was corrected to ensure a more secure and consistent directory hierarchy. Additionally, the removal of redundant fallback logic streamlined the code, enhancing clarity and reducing the risk of errors while maintaining robust memory management and error handling.","CWE-22,CWE-73,CWE-99,CWE-35,CWE-23,CWE-36,CWE-434,CWE-37,CWE-41,CWE-67",N,-1.0,4,5,5,4
5,5,181450,181450,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/pull/444/commits/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,"Walk the entire DefaultRoot path, checking for symlinks of any component,
when AllowChrootSymlinks is disabled.",13,modules/mod_auth.c,"{""sha"": ""6e535bbb7a66d5babfc08807099ecd7a6d80a5da"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 58, ""deletions"": 15, ""changes"": 73, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache2(path);\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n+\n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n /* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n   config_rec *c = NULL;\n@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache2(path);\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}<_**next**_>{""sha"": ""8872231db18a970369799ece823cc1d8325aafde"", ""filename"": ""tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 9, ""changes"": 23, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/TestSuite/Utils.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -1198,6 +1198,7 @@ sub test_setup {\n   $uid = 500 unless defined($uid);\n   my $gid = shift;\n   $gid = 500 unless defined($gid);\n+  my $home_dir = shift;\n \n   my $config_file = \""$tmpdir/$name.conf\"";\n   my $pid_file = File::Spec->rel2abs(\""$tmpdir/$name.pid\"");\n@@ -1206,17 +1207,21 @@ sub test_setup {\n   my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/$name.passwd\"");\n   my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/$name.group\"");\n \n-  my $home_dir = File::Spec->rel2abs($tmpdir);\n+  # If the caller provides the home directory, it is ASSUMED that they will\n+  # have created it.\n+  unless (defined($home_dir)) {\n+    $home_dir = File::Spec->rel2abs($tmpdir);\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $home_dir)) {\n-      croak(\""Can't set perms on $home_dir to 0755: $!\"");\n-    }\n+    # Make sure that, if we're running as root, that the home directory has\n+    # permissions/privs set for the account we create\n+    if ($< == 0) {\n+      unless (chmod(0755, $home_dir)) {\n+        croak(\""Can't set perms on $home_dir to 0755: $!\"");\n+      }\n \n-    unless (chown($uid, $gid, $home_dir)) {\n-      croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      unless (chown($uid, $gid, $home_dir)) {\n+        croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""88486c3a774b144b863f3ba8bd209c64abb8d0ea"", ""filename"": ""tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 55, ""changes"": 76, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -621,65 +621,39 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   my $self = shift;\n   my $tmpdir = $self->{tmpdir};\n \n-  my $config_file = \""$tmpdir/config.conf\"";\n-  my $pid_file = File::Spec->rel2abs(\""$tmpdir/config.pid\"");\n-  my $scoreboard_file = File::Spec->rel2abs(\""$tmpdir/config.scoreboard\"");\n-\n-  my $log_file = test_get_logfile();\n-\n-  my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/config.passwd\"");\n-  my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/config.group\"");\n-\n   my $user = 'proftpd';\n-  my $passwd = 'test';\n-  my $group = 'ftpd';\n   my $home_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks/$user\"");\n   my $uid = 500;\n   my $gid = 500;\n \n-  my $intermed_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks\"");\n-  mkpath($intermed_dir);\n-\n-  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real/$user\"");\n-  mkpath($symlink_dst);\n+  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real\"");\n \n   my $cwd = getcwd();\n \n-  unless (chdir($intermed_dir)) {\n-    die(\""Can't chdir to $intermed_dir: $!\"");\n+  unless (chdir($tmpdir)) {\n+    die(\""Can't chdir to $tmpdir: $!\"");\n   }\n \n-  unless (symlink(\""../../real/$user\"", \""./$user\"")) {\n-    die(\""Can't symlink '../../real/$user' to './$user': $!\"");\n+  unless (symlink(\""./real\"", \""./home.d\"")) {\n+    die(\""Can't symlink './real' to './home.d': $!\"");\n   }\n \n   unless (chdir($cwd)) {\n     die(\""Can't chdir to $cwd: $!\"");\n   }\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $symlink_dst)) {\n-      die(\""Can't set perms on $symlink_dst to 0755: $!\"");\n-    }\n+  mkpath(File::Spec->rel2abs(\""$tmpdir/real/symlinks/$user\""));\n \n-    unless (chown($uid, $gid, $symlink_dst)) {\n-      die(\""Can't set owner of $symlink_dst to $uid/$gid: $!\"");\n-    }\n-  }\n-\n-  auth_user_write($auth_user_file, $user, $passwd, $uid, $gid, $home_dir,\n-    '/bin/bash');\n-  auth_group_write($auth_group_file, $group, $gid, $user);\n+  my $setup = test_setup($tmpdir, 'config', $user, undef, undef, $uid, $gid,\n+    $home_dir);\n \n   my $config = {\n-    PidFile => $pid_file,\n-    ScoreboardFile => $scoreboard_file,\n-    SystemLog => $log_file,\n+    PidFile => $setup->{pid_file},\n+    ScoreboardFile => $setup->{scoreboard_file},\n+    SystemLog => $setup->{log_file},\n \n-    AuthUserFile => $auth_user_file,\n-    AuthGroupFile => $auth_group_file,\n+    AuthUserFile => $setup->{auth_user_file},\n+    AuthGroupFile => $setup->{auth_group_file},\n \n     AllowChrootSymlinks => 'off',\n     DefaultRoot => '~',\n@@ -691,7 +665,8 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     },\n   };\n \n-  my ($port, $config_user, $config_group) = config_write($config_file, $config);\n+  my ($port, $config_user, $config_group) = config_write($setup->{config_file},\n+    $config);\n \n   # Open pipes, for use between the parent and child processes.  Specifically,\n   # the child will indicate when it's done with its test by writing a message\n@@ -709,7 +684,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   if ($pid) {\n     eval {\n       my $client = ProFTPD::TestSuite::FTP->new('127.0.0.1', $port);\n-      eval { $client->login($user, $passwd) };\n+      eval { $client->login($user, $setup->{passwd}) };\n       unless ($@) {\n         die(\""Login succeeded unexpectedly\"");\n       }\n@@ -721,13 +696,12 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n \n       $expected = 530;\n       $self->assert($expected == $resp_code,\n-        test_msg(\""Expected response code $expected, got $resp_code\""));\n+        \""Expected response code $expected, got $resp_code\"");\n \n       $expected = \""Login incorrect.\"";\n       $self->assert($expected eq $resp_msg,\n-        test_msg(\""Expected response message '$expected', got '$resp_msg'\""));\n+        \""Expected response message '$expected', got '$resp_msg'\"");\n     };\n-\n     if ($@) {\n       $ex = $@;\n     }\n@@ -736,7 +710,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     $wfh->flush();\n \n   } else {\n-    eval { server_wait($config_file, $rfh) };\n+    eval { server_wait($setup->{config_file}, $rfh) };\n     if ($@) {\n       warn($@);\n       exit 1;\n@@ -746,18 +720,10 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   }\n \n   # Stop server\n-  server_stop($pid_file);\n-\n+  server_stop($setup->{pid_file});\n   $self->assert_child_ok($pid);\n \n-  if ($ex) {\n-    test_append_logfile($log_file, $ex);\n-    unlink($log_file);\n-\n-    die($ex);\n-  }\n-\n-  unlink($log_file);\n+  test_cleanup($setup->{log_file}, $ex);\n }\n \n 1;""}"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache2(path);
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
+
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
 /* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache2(path);
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,31ce8400c18c3ac46cbe3f17f3e7f0cc4e712dfc,1," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache2(path);
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",181450," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
","The vulnerability in the original code lies in the handling of symbolic links when `allow_symlinks` is set to `FALSE`. The code uses `pr_fsio_lstat` to check if the path is a symlink, which could inadvertently follow symlinks, leading to potential directory traversal attacks. In the fixed code, this vulnerability is addressed by replacing the `pr_fsio_lstat` call with `is_symlink_path(p, path, pathlen)`, which explicitly checks if the path is a symlink without following it. This change ensures that the application correctly denies access to symlinked directories, enhancing security.","The vulnerability in the original code arises from improper handling of symbolic links, which could allow unauthorized access to restricted directories when symbolic links are present. Specifically, the code checks for symlinks in a way that may inadvertently follow them, potentially leading to directory traversal attacks. The fix addresses this issue by implementing a dedicated function that checks for symlinks without following them, ensuring that the application correctly denies access to any paths that are symbolic links when the configuration disallows them. This change significantly enhances the security of the application by preventing unintended access.","CWE-59,CWE-22,CWE-426,CWE-61,CWE-367,CWE-363,CWE-41,CWE-610,CWE-386,CWE-73",Y,1.0,4,5,4,3
6,6,182086,182086,,Local,Not required,Partial,CVE-2014-4978,https://www.cvedetails.com/cve/CVE-2014-4978/,CWE-59,Low,,Partial,,2017-12-29,3.6,The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.,2018-01-10,,18,https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,Fixes insecure use of temporary file (CVE-2014-4978).,3,librawstudio/rs-filter.c,"{""sha"": ""352b23c51a00b32c4993732b1534ff5a988ee763"", ""filename"": ""librawstudio/rs-filter.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/rawstudio/rawstudio/blob/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""raw_url"": ""https://github.com/rawstudio/rawstudio/raw/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""contents_url"": ""https://api.github.com/repos/rawstudio/rawstudio/contents/librawstudio/rs-filter.c?ref=9c2cd3c93c05d009a91d84eedbb85873b0cb505d"", ""patch"": ""@@ -772,17 +772,32 @@ void\n rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n+\tgchar *dot_filename;\n+\tgchar *png_filename;\n+\tgchar *command_line;\n \tGString *str = g_string_new(\""digraph G {\\n\"");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \""}\\n\"");\n-\tg_file_set_contents(\""/tmp/rs-filter-graph\"", str->str, str->len, NULL);\n \n-\tif (0 != system(\""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\""))\n+\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n+\tdot_filename = g_strdup_printf(\""/tmp/rs-filter-graph.%u\"", g_random_int());\n+\tpng_filename = g_strdup_printf(\""%s.%u.png\"", dot_filename, g_random_int());\n+\n+\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n+\n+\tcommand_line = g_strdup_printf(\""dot -Tpng >%s <%s\"", png_filename, dot_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling dot failed\"");\n-\tif (0 != system(\""gnome-open /tmp/rs-filter-graph.png\""))\n+\tg_free(command_line);\n+\n+\tcommand_line = g_strdup_printf(\""gnome-open %s\"", png_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling gnome-open failed.\"");\n+\tg_free(command_line);\n \n+\tg_free(dot_filename);\n+\tg_free(png_filename);\n \tg_string_free(str, TRUE);\n }""}"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",C,"	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
	g_free(command_line);
	g_free(dot_filename);
	g_free(png_filename);
","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
",,"@@ -772,17 +772,32 @@ void
 rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
+	gchar *dot_filename;
+	gchar *png_filename;
+	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
-	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
-	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
+	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
+	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
+	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
+
+	g_file_set_contents(dot_filename, str->str, str->len, NULL);
+
+	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
-	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
+	g_free(command_line);
+
+	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
+	g_free(command_line);
 
+	g_free(dot_filename);
+	g_free(png_filename);
 	g_string_free(str, TRUE);
 }",rawstudio,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,70f2da78b575ea1105eae865c7e49465b838bdfd,1," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
//fix_flaw_line_below:
//	gchar *dot_filename;
//fix_flaw_line_below:
//	gchar *png_filename;
//fix_flaw_line_below:
//	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
//flaw_line_below:
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
//flaw_line_below:
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
//fix_flaw_line_below:
//	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
//fix_flaw_line_below:
//	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
//fix_flaw_line_below:
//	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	g_file_set_contents(dot_filename, str->str, str->len, NULL);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
//flaw_line_below:
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
//fix_flaw_line_below:
//	g_free(command_line);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
//fix_flaw_line_below:
//	g_free(command_line);
 
//fix_flaw_line_below:
//	g_free(dot_filename);
//fix_flaw_line_below:
//	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
",182086," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
","The vulnerability in the original code arises from the use of fixed filenames (""/tmp/rs-filter-graph"") for both the DOT file and the generated PNG, which can lead to a race condition or file overwrite attacks if multiple instances of the function are executed concurrently. This allows an attacker to manipulate the contents of the files. In the fixed code, unique filenames are generated using `g_random_int()` to create `dot_filename` and `png_filename`, ensuring that each execution of `rs_filter_graph` creates separate files. This mitigates the risk of file collisions and enhances security by preventing unauthorized access to the output files.","The vulnerability in the original code stems from the use of a fixed filename for output files, which can lead to race conditions or file overwrites if multiple instances of the function are executed simultaneously. This allows an attacker to potentially manipulate the contents of the files, leading to unauthorized access or data corruption. The fixed code addresses this issue by generating unique filenames for each execution, ensuring that each instance creates separate output files. This change effectively mitigates the risk of file collisions and enhances overall security by preventing unintended interactions between concurrent executions.","CWE-377, CWE-367, CWE-379, CWE-732, CWE-73, CWE-59, CWE-379, CWE-20, CWE-552, CWE-22",N,-1.0,2,4,3,3
7,7,182606,182606,,Local,Not required,Complete,CVE-2017-7500,https://www.cvedetails.com/cve/CVE-2017-7500/,CWE-59,Low,Complete,Complete,,2018-08-13,7.2,"It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",2019-10-09,+Priv ,12,https://github.com/rpm-software-management/rpm/commit/c815822c8bdb138066ff58c624ae83e3a12ebfa9,c815822c8bdb138066ff58c624ae83e3a12ebfa9,"Make verification match the new restricted directory symlink behavior

Only follow directory symlinks owned by target directory owner or root
during verification to match the behavior of fsmVerify() in the new
CVE-2017-7500 world order.

The code is klunkier than it should and the logic should use common code
with fsmVerify() instead of duplicating it here, but that needs more
changes than is comfortable to backport so starting with this.

Also worth noting that the previous ""follow the link"" logic from
commit 3ccd774255b8215733e0bdfdf5a683da9dd10923 was not quite right,
it'd fail with RPMVERIFY_LSTATFAIL on a broken symlink when it should've
ran verification on the symlink itself. This behavior is fixed here too.

Finally, once again fakechroot gets in the way and forces the related
verify testcase to be changed to be able to create a valid link. Reuse
the replacement testcase for the purpose and add another case for
verifying an invalid link.",3,lib/verify.c,"{""sha"": ""62eec08617fb02a6d8e4fa89e9236e844a277cc7"", ""filename"": ""lib/verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/verify.c?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n     }\n \n     /* If we expected a directory but got a symlink to one, follow the link */\n-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n-\tvfy |= RPMVERIFY_LSTATFAIL;\n-\tgoto exit;\n+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n+\tstruct stat dsb;\n+\t/* ...if it actually points to a directory  */\n+\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n+\t    uid_t fuid;\n+\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n+\t    if (sb.st_uid == 0 ||\n+\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n+\t\t\t sb.st_uid == fuid)) {\n+\t\tsb = dsb; /* struct assignment */\n+\t    }\n+\t}\n     }\n \n     /* Links have no mode, other types have no linkto */""}<_**next**_>{""sha"": ""c5530de69ca263e2e0e6934bb8de61c05155c85e"", ""filename"": ""tests/rpmverify.at"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 9, ""changes"": 56, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/rpmverify.at?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -69,18 +69,56 @@ AT_KEYWORDS([verify])\n AT_CHECK([\n RPMDB_CLEAR\n RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n \n-runroot rpm -U --nodeps --noscripts --ignorearch --ignoreos \\\n-\t/data/RPMS/hello-1.0-1.i386.rpm\n-mv \""${RPMTEST}\""/usr/share/doc/hello-1.0 \""${RPMTEST}\""/usr/share/doc/hello-1.0.orig\n-ln -s hello-1.0.orig \""${RPMTEST}\""/usr/share/doc/hello-1.0\n-runroot rpm -Vva --nodeps --nouser --nogroup\n-rm -rf \""${RPMTEST}\""/usr/share/doc/\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+        --define \""user $(id -u -n)\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv replacetest\n ],\n [0],\n-[.........    /usr/local/bin/hello\n-.........    /usr/share/doc/hello-1.0\n-.........  d /usr/share/doc/hello-1.0/FAQ\n+[.........    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n+],\n+[])\n+AT_CLEANUP\n+\n+AT_SETUP([directory replaced with an invalid directory symlink])\n+AT_KEYWORDS([verify])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv --nouser --nogroup replacetest\n+],\n+[1],\n+[....L....    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n ],\n [])\n AT_CLEANUP""}","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
",C,"    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
","    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
",,"@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
-	vfy |= RPMVERIFY_LSTATFAIL;
-	goto exit;
+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
+	struct stat dsb;
+	/* ...if it actually points to a directory  */
+	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
+	    uid_t fuid;
+	    /* ...and is by a legit user, to match fsmVerify() behavior */
+	    if (sb.st_uid == 0 ||
+			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
+			 sb.st_uid == fuid)) {
+		sb = dsb; /* struct assignment */
+	    }
+	}
     }
 
     /* Links have no mode, other types have no linkto */",rpm,c815822c8bdb138066ff58c624ae83e3a12ebfa9,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,1,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
//flaw_line_below:
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
//flaw_line_below:
	vfy |= RPMVERIFY_LSTATFAIL;
//flaw_line_below:
	goto exit;
//fix_flaw_line_below:
//    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
//fix_flaw_line_below:
//	struct stat dsb;
//fix_flaw_line_below:
//	/* ...if it actually points to a directory  */
//fix_flaw_line_below:
//	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
//fix_flaw_line_below:
//	    uid_t fuid;
//fix_flaw_line_below:
//	    /* ...and is by a legit user, to match fsmVerify() behavior */
//fix_flaw_line_below:
//	    if (sb.st_uid == 0 ||
//fix_flaw_line_below:
//			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
//fix_flaw_line_below:
//			 sb.st_uid == fuid)) {
//fix_flaw_line_below:
//		sb = dsb; /* struct assignment */
//fix_flaw_line_below:
//	    }
//fix_flaw_line_below:
//	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
",182606,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","The vulnerability in the original code lies in the handling of symbolic links, particularly when a directory is expected but a symlink is encountered. The code did not verify if the symlink pointed to an actual directory, potentially leading to incorrect attribute verification and security issues. In the fixed code, an additional check was introduced: after confirming that the symlink points to a directory using `stat(fn, &dsb)`, it verifies the user ID (`sb.st_uid`) against the expected user ID from `rpmfilesFUser(fi, ix)`. This ensures that only legitimate users can affect the verification process, enhancing security.","The vulnerability in the original code arises from inadequate handling of symbolic links, particularly when a directory is expected but a symlink is encountered. This oversight could lead to incorrect attribute verification, potentially allowing unauthorized access or manipulation of files. The fix addresses this issue by adding a check to ensure that if a symlink is present, it must point to an actual directory and be owned by a legitimate user. This additional verification step enhances security by preventing unauthorized users from influencing the verification process, thereby ensuring that only valid attributes are considered.","CWE-59, CWE-61, CWE-367, CWE-362, CWE-299, CWE-266, CWE-732, CWE-275, CWE-284, CWE-269",Y,1.0,2,5,5,4
8,8,183242,183242,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,"Backporting recursive handling of DefaultRoot path, when AllowChrootSymlinks
is off, to 1.3.5 branch.",13,modules/mod_auth.c,"{""sha"": ""410215979a91ad5056eab1d8a301a06312e65be8"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 65, ""deletions"": 18, ""changes"": 83, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=ecff21e0d0e84f35c299ef91d7fda088e516d4ed"", ""patch"": ""@@ -2,7 +2,7 @@\n  * ProFTPD - FTP server daemon\n  * Copyright (c) 1997, 1998 Public Flood Software\n  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n- * Copyright (c) 2001-2016 The ProFTPD Project team\n+ * Copyright (c) 2001-2017 The ProFTPD Project team\n  *\n  * This program is free software; you can redistribute it and/or modify\n  * it under the terms of the GNU General Public License as published by\n@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n-/* Determine if the user (non-anon) needs a default root dir other than /.\n- */\n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache();\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n \n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+\n+    /* Make sure our pointer actually changed position. */\n+    if (new_pathlen == pathlen) {\n+      return 0;\n+    }\n+\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+/* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache();\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -2,7 +2,7 @@
  * ProFTPD - FTP server daemon
  * Copyright (c) 1997, 1998 Public Flood Software
  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
- * Copyright (c) 2001-2016 The ProFTPD Project team
+ * Copyright (c) 2001-2017 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
-/* Determine if the user (non-anon) needs a default root dir other than /.
- */
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache();
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
 
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+
+    /* Make sure our pointer actually changed position. */
+    if (new_pathlen == pathlen) {
+      return 0;
+    }
+
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+/* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache();
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,5a2ca0f12723c6fa9bdaa4faa1c2979335e50b07,1," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache();
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",183242," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
","The vulnerability in the original code stemmed from the use of `pr_fsio_lstat` to check if a directory specified by `dir` was a symlink, which could lead to unintended access if symlinks were present. This was particularly problematic when `allow_symlinks` was set to `FALSE`, as it did not adequately prevent symlink traversal. The fix replaced the `pr_fsio_lstat` call with `is_symlink_path`, which directly checks if the path is a symlink without following it, thus enhancing security by ensuring that symlink checks are performed correctly and consistently, preventing unauthorized access through symlink exploitation.","The vulnerability in the original code arose from inadequate handling of symbolic links, which could allow unauthorized access to restricted directories. Specifically, the code used a method that followed symlinks, potentially exposing sensitive files or directories if a symlink pointed to them. The fix addressed this issue by implementing a new method that checks for symbolic links without following them, ensuring that the application correctly identifies and denies access to any symlinked paths when symlink traversal is not permitted. This change significantly enhances security by preventing exploitation through symlink manipulation.","CWE-59, CWE-61, CWE-363, CWE-362, CWE-367, CWE-384, CWE-386, CWE-610, CWE-66, CWE-426",Y,1.0,4,5,4,4
9,9,183310,183310,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,1,https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7,d6e2f6f128cef4c21cb80941ae674c9842681aa7,"ccpp: open file for dump_fd_info with O_EXCL

To avoid possible races.

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""ece1ecebc00cabdb05bb06a6d80a6289d58968b7"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/abrt/abrt/blob/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=d6e2f6f128cef4c21cb80941ae674c9842681aa7"", ""patch"": ""@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu\n \n static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n-    FILE *fp = fopen(dest_filename, \""w\"");\n+    FILE *fp = fopen(dest_filename, \""wx\"");\n     if (!fp)\n         return false;\n ""}"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
",C,"    FILE *fp = fopen(dest_filename, ""wx"");
","    FILE *fp = fopen(dest_filename, ""w"");
",,"@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
 
 static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
-    FILE *fp = fopen(dest_filename, ""w"");
+    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 ",abrt,d6e2f6f128cef4c21cb80941ae674c9842681aa7,4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,1," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
//flaw_line_below:
    FILE *fp = fopen(dest_filename, ""w"");
//fix_flaw_line_below:
//    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
",183310," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
","The vulnerability in the original code arises from the use of `fopen(dest_filename, ""w"")`, which allows overwriting an existing file, potentially leading to a race condition where an attacker could replace `dest_filename` before it is opened. This could result in unauthorized access or data loss. The fix implemented in the changed code uses `fopen(dest_filename, ""wx"")`, which opens the file for writing only if it does not already exist, thereby preventing overwriting and mitigating the race condition vulnerability. This change enhances the security of the file handling process in the function.","The vulnerability in the original code stems from the use of a file opening mode that allows overwriting an existing file, which can lead to a race condition. This situation enables an attacker to replace the target file before it is opened, potentially resulting in unauthorized access or data corruption. The fix in the modified code changes the file opening mode to one that prevents overwriting, ensuring that the file can only be created if it does not already exist. This adjustment effectively mitigates the risk of race conditions and enhances the overall security of the file handling process.","CWE-367, CWE-732, CWE-379, CWE-362, CWE-378, CWE-377, CWE-363, CWE-374, CWE-675, CWE-666",N,-1.0,4,4,3,4
