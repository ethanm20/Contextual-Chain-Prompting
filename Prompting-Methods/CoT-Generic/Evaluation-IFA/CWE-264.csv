,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,46443,46443,,Local,Not required,Complete,CVE-2014-7822,https://www.cvedetails.com/cve/CVE-2014-7822/,CWE-264,Low,Complete,Complete,,2015-03-16,7.2,"The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, as demonstrated by use of a file descriptor associated with an ext4 filesystem.",2017-01-02,DoS ,0,https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958,8d0207652cbe27d1f962050737848e5ad4671958,"->splice_write() via ->write_iter()

iter_file_splice_write() - a ->splice_write() instance that gathers the
pipe buffers, builds a bio_vec-based iov_iter covering those and feeds
it to ->write_iter().  A bunch of simple cases coverted to that...

[AV: fixed the braino spotted by Cyrill]

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/xfs/xfs_file.c,"{""sha"": ""e68e150b1b163c15da172cfa60ed832d14841495"", ""filename"": ""fs/block_dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/block_dev.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1583,7 +1583,7 @@ const struct file_operations def_blk_fops = {\n \t.compat_ioctl\t= compat_blkdev_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)""}<_**next**_>{""sha"": ""71bf8e4fb5d427c660e9913a57054dec59f99dfc"", ""filename"": ""fs/exofs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exofs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -77,7 +77,7 @@ const struct file_operations exofs_file_operations = {\n \t.fsync\t\t= exofs_file_fsync,\n \t.flush\t\t= exofs_flush,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations exofs_file_inode_operations = {""}<_**next**_>{""sha"": ""7c87b22a7228c4ce9ed3c915c64283e2aa72a328"", ""filename"": ""fs/ext2/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -75,7 +75,7 @@ const struct file_operations ext2_file_operations = {\n \t.release\t= ext2_release_file,\n \t.fsync\t\t= ext2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n #ifdef CONFIG_EXT2_FS_XIP""}<_**next**_>{""sha"": ""a062fa1e1b113e56e7545bb4c6bac7ac1bf7d741"", ""filename"": ""fs/ext3/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext3/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -63,7 +63,7 @@ const struct file_operations ext3_file_operations = {\n \t.release\t= ext3_release_file,\n \t.fsync\t\t= ext3_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations ext3_file_inode_operations = {""}<_**next**_>{""sha"": ""708aad7681991368262332520f09f5490af848de"", ""filename"": ""fs/ext4/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -599,7 +599,7 @@ const struct file_operations ext4_file_operations = {\n \t.release\t= ext4_release_file,\n \t.fsync\t\t= ext4_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fallocate\t= ext4_fallocate,\n };\n ""}<_**next**_>{""sha"": ""e4ba4b93f96a90e70c173fa309b242c0390ef8cf"", ""filename"": ""fs/f2fs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -692,5 +692,5 @@ const struct file_operations f2fs_file_operations = {\n \t.compat_ioctl\t= f2fs_compat_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };""}<_**next**_>{""sha"": ""01b4c5b1bff8ddd152a6b93ac3b5249d3d0a49a8"", ""filename"": ""fs/gfs2/file.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1068,7 +1068,7 @@ const struct file_operations gfs2_file_fops = {\n \t.lock\t\t= gfs2_lock,\n \t.flock\t\t= gfs2_flock,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= gfs2_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };\n@@ -1098,7 +1098,7 @@ const struct file_operations gfs2_file_fops_nolock = {\n \t.release\t= gfs2_release,\n \t.fsync\t\t= gfs2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= generic_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };""}<_**next**_>{""sha"": ""33aa0cc1f8b863b7b101bec470af4238d0c6eeb1"", ""filename"": ""fs/jfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -157,7 +157,7 @@ const struct file_operations jfs_file_operations = {\n \t.write_iter\t= generic_file_write_iter,\n \t.mmap\t\t= generic_file_mmap,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fsync\t\t= jfs_fsync,\n \t.release\t= jfs_release,\n \t.unlocked_ioctl = jfs_ioctl,""}<_**next**_>{""sha"": ""4f56de822d2f5995b81006e0bc9783d321b1621d"", ""filename"": ""fs/ramfs/file-mmu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-mmu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -38,7 +38,7 @@ const struct file_operations ramfs_file_operations = {\n \t.mmap\t\t= generic_file_mmap,\n \t.fsync\t\t= noop_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.llseek\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""dda012ad4208d3192521c80a082af5ff038f5b3b"", ""filename"": ""fs/ramfs/file-nommu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-nommu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -43,7 +43,7 @@ const struct file_operations ramfs_file_operations = {\n \t.write_iter\t\t= generic_file_write_iter,\n \t.fsync\t\t\t= noop_fsync,\n \t.splice_read\t\t= generic_file_splice_read,\n-\t.splice_write\t\t= generic_file_splice_write,\n+\t.splice_write\t\t= iter_file_splice_write,\n \t.llseek\t\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f070cc827456b68cc3dd3a79bab4009a2c5a2924"", ""filename"": ""fs/reiserfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -248,7 +248,7 @@ const struct file_operations reiserfs_file_operations = {\n \t.read_iter = generic_file_read_iter,\n \t.write_iter = generic_file_write_iter,\n \t.splice_read = generic_file_splice_read,\n-\t.splice_write = generic_file_splice_write,\n+\t.splice_write = iter_file_splice_write,\n \t.llseek = generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f195a9b89fb22ea64ac5e8fda4af03d0ae3f16e3"", ""filename"": ""fs/splice.c"", ""status"": ""modified"", ""additions"": 140, ""deletions"": 0, ""changes"": 140, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/splice.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -32,6 +32,7 @@\n #include <linux/gfp.h>\n #include <linux/socket.h>\n #include <linux/compat.h>\n+#include <linux/aio.h>\n #include \""internal.h\""\n \n /*\n@@ -1052,6 +1053,145 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n \n EXPORT_SYMBOL(generic_file_splice_write);\n \n+/**\n+ * iter_file_splice_write - splice data from a pipe to a file\n+ * @pipe:\tpipe info\n+ * @out:\tfile to write to\n+ * @ppos:\tposition in @out\n+ * @len:\tnumber of bytes to splice\n+ * @flags:\tsplice modifier flags\n+ *\n+ * Description:\n+ *    Will either move or copy pages (determined by @flags options) from\n+ *    the given pipe inode to the given file.\n+ *    This one is ->write_iter-based.\n+ *\n+ */\n+ssize_t\n+iter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n+\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n+{\n+\tstruct splice_desc sd = {\n+\t\t.total_len = len,\n+\t\t.flags = flags,\n+\t\t.pos = *ppos,\n+\t\t.u.file = out,\n+\t};\n+\tint nbufs = pipe->buffers;\n+\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\tssize_t ret;\n+\n+\tif (unlikely(!array))\n+\t\treturn -ENOMEM;\n+\n+\tpipe_lock(pipe);\n+\n+\tsplice_from_pipe_begin(&sd);\n+\twhile (sd.total_len) {\n+\t\tstruct iov_iter from;\n+\t\tstruct kiocb kiocb;\n+\t\tsize_t left;\n+\t\tint n, idx;\n+\n+\t\tret = splice_from_pipe_next(pipe, &sd);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tif (unlikely(nbufs < pipe->buffers)) {\n+\t\t\tkfree(array);\n+\t\t\tnbufs = pipe->buffers;\n+\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\t\t\tif (!array) {\n+\t\t\t\tret = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* build the vector */\n+\t\tleft = sd.total_len;\n+\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n+\t\t\tsize_t this_len = buf->len;\n+\n+\t\t\tif (this_len > left)\n+\t\t\t\tthis_len = left;\n+\n+\t\t\tif (idx == pipe->buffers - 1)\n+\t\t\t\tidx = -1;\n+\n+\t\t\tret = buf->ops->confirm(pipe, buf);\n+\t\t\tif (unlikely(ret)) {\n+\t\t\t\tif (ret == -ENODATA)\n+\t\t\t\t\tret = 0;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tarray[n].bv_page = buf->page;\n+\t\t\tarray[n].bv_len = this_len;\n+\t\t\tarray[n].bv_offset = buf->offset;\n+\t\t\tleft -= this_len;\n+\t\t}\n+\n+\t\t/* ... iov_iter */\n+\t\tfrom.type = ITER_BVEC | WRITE;\n+\t\tfrom.bvec = array;\n+\t\tfrom.nr_segs = n;\n+\t\tfrom.count = sd.total_len - left;\n+\t\tfrom.iov_offset = 0;\n+\n+\t\t/* ... and iocb */\n+\t\tinit_sync_kiocb(&kiocb, out);\n+\t\tkiocb.ki_pos = sd.pos;\n+\t\tkiocb.ki_nbytes = sd.total_len - left;\n+\n+\t\t/* now, send it */\n+\t\tret = out->f_op->write_iter(&kiocb, &from);\n+\t\tif (-EIOCBQUEUED == ret)\n+\t\t\tret = wait_on_sync_kiocb(&kiocb);\n+\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tsd.num_spliced += ret;\n+\t\tsd.total_len -= ret;\n+\t\t*ppos = sd.pos = kiocb.ki_pos;\n+\n+\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n+\t\twhile (ret) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n+\t\t\tif (ret >= buf->len) {\n+\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n+\t\t\t\tret -= buf->len;\n+\t\t\t\tbuf->len = 0;\n+\t\t\t\tbuf->ops = NULL;\n+\t\t\t\tops->release(pipe, buf);\n+\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n+\t\t\t\tpipe->nrbufs--;\n+\t\t\t\tif (pipe->files)\n+\t\t\t\t\tsd.need_wakeup = true;\n+\t\t\t} else {\n+\t\t\t\tbuf->offset += ret;\n+\t\t\t\tbuf->len -= ret;\n+\t\t\t\tret = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tkfree(array);\n+\tsplice_from_pipe_end(pipe, &sd);\n+\n+\tpipe_unlock(pipe);\n+\n+\tif (sd.num_spliced)\n+\t\tret = sd.num_spliced;\n+\n+\treturn ret;\n+}\n+\n+EXPORT_SYMBOL(iter_file_splice_write);\n+\n static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n \t\t\t  struct splice_desc *sd)\n {""}<_**next**_>{""sha"": ""0888502a60415223ba9285447c9e2f4425bc4076"", ""filename"": ""fs/ubifs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ubifs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1585,7 +1585,7 @@ const struct file_operations ubifs_file_operations = {\n \t.fsync          = ubifs_fsync,\n \t.unlocked_ioctl = ubifs_ioctl,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl   = ubifs_compat_ioctl,\n #endif""}<_**next**_>{""sha"": ""b1c489c1fb2e4496e8ca7d61955e32779d16e439"", ""filename"": ""fs/xfs/xfs_file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 42, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -342,47 +342,6 @@ xfs_file_splice_read(\n \treturn ret;\n }\n \n-/*\n- * xfs_file_splice_write() does not use xfs_rw_ilock() because\n- * generic_file_splice_write() takes the i_mutex itself. This, in theory,\n- * couuld cause lock inversions between the aio_write path and the splice path\n- * if someone is doing concurrent splice(2) based writes and write(2) based\n- * writes to the same inode. The only real way to fix this is to re-implement\n- * the generic code here with correct locking orders.\n- */\n-STATIC ssize_t\n-xfs_file_splice_write(\n-\tstruct pipe_inode_info\t*pipe,\n-\tstruct file\t\t*outfilp,\n-\tloff_t\t\t\t*ppos,\n-\tsize_t\t\t\tcount,\n-\tunsigned int\t\tflags)\n-{\n-\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n-\tstruct xfs_inode\t*ip = XFS_I(inode);\n-\tint\t\t\tioflags = 0;\n-\tssize_t\t\t\tret;\n-\n-\tXFS_STATS_INC(xs_write_calls);\n-\n-\tif (outfilp->f_mode & FMODE_NOCMTIME)\n-\t\tioflags |= IO_INVIS;\n-\n-\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n-\t\treturn -EIO;\n-\n-\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n-\n-\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n-\n-\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n-\tif (ret > 0)\n-\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n-\n-\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n-\treturn ret;\n-}\n-\n /*\n  * This routine is called to handle zeroing any space in the last block of the\n  * file that is beyond the EOF.  We do this since the size is being increased\n@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {\n \t.read_iter\t= xfs_file_read_iter,\n \t.write_iter\t= xfs_file_write_iter,\n \t.splice_read\t= xfs_file_splice_read,\n-\t.splice_write\t= xfs_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.unlocked_ioctl\t= xfs_file_ioctl,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl\t= xfs_file_compat_ioctl,""}<_**next**_>{""sha"": ""53182f97cf011e62e4806ce4bf3dbdfc71f00835"", ""filename"": ""fs/xfs/xfs_trace.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_trace.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1060,7 +1060,6 @@ DEFINE_RW_EVENT(xfs_file_read);\n DEFINE_RW_EVENT(xfs_file_buffered_write);\n DEFINE_RW_EVENT(xfs_file_direct_write);\n DEFINE_RW_EVENT(xfs_file_splice_read);\n-DEFINE_RW_EVENT(xfs_file_splice_write);\n \n DECLARE_EVENT_CLASS(xfs_page_class,\n \tTP_PROTO(struct inode *inode, struct page *page, unsigned long off,""}<_**next**_>{""sha"": ""8bd8ed357c7b6204308a49375e5d01af1dbd1726"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -2434,6 +2434,8 @@ extern ssize_t default_file_splice_read(struct file *, loff_t *,\n \t\tstruct pipe_inode_info *, size_t, unsigned int);\n extern ssize_t generic_file_splice_write(struct pipe_inode_info *,\n \t\tstruct file *, loff_t *, size_t, unsigned int);\n+extern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n+\t\tstruct file *, loff_t *, size_t, unsigned int);\n extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n \t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\n ""}","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",C,,,,"@@ -342,47 +342,6 @@ xfs_file_splice_read(
 	return ret;
 }
 
-/*
- * xfs_file_splice_write() does not use xfs_rw_ilock() because
- * generic_file_splice_write() takes the i_mutex itself. This, in theory,
- * couuld cause lock inversions between the aio_write path and the splice path
- * if someone is doing concurrent splice(2) based writes and write(2) based
- * writes to the same inode. The only real way to fix this is to re-implement
- * the generic code here with correct locking orders.
- */
-STATIC ssize_t
-xfs_file_splice_write(
-	struct pipe_inode_info	*pipe,
-	struct file		*outfilp,
-	loff_t			*ppos,
-	size_t			count,
-	unsigned int		flags)
-{
-	struct inode		*inode = outfilp->f_mapping->host;
-	struct xfs_inode	*ip = XFS_I(inode);
-	int			ioflags = 0;
-	ssize_t			ret;
-
-	XFS_STATS_INC(xs_write_calls);
-
-	if (outfilp->f_mode & FMODE_NOCMTIME)
-		ioflags |= IO_INVIS;
-
-	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
-		return -EIO;
-
-	xfs_ilock(ip, XFS_IOLOCK_EXCL);
-
-	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
-
-	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
-	if (ret > 0)
-		XFS_STATS_ADD(xs_write_bytes, ret);
-
-	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
-	return ret;
-}
-
 /*
  * This routine is called to handle zeroing any space in the last block of the
  * file that is beyond the EOF.  We do this since the size is being increased
@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {
 	.read_iter	= xfs_file_read_iter,
 	.write_iter	= xfs_file_write_iter,
 	.splice_read	= xfs_file_splice_read,
-	.splice_write	= xfs_file_splice_write,
+	.splice_write	= iter_file_splice_write,
 	.unlocked_ioctl	= xfs_file_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= xfs_file_compat_ioctl,",linux,8d0207652cbe27d1f962050737848e5ad4671958,62a8067a7f35dba2de501c9cb00e4cf36da90bc0,0,"xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",46443,"xfs_file_splice_write(
	struct pipe_inode_info	*pipe,
	struct file		*outfilp,
	loff_t			*ppos,
	size_t			count,
	unsigned int		flags)
{
	struct inode		*inode = outfilp->f_mapping->host;
	struct xfs_inode	*ip = XFS_I(inode);
	int			ioflags = 0;
	ssize_t			ret;
	XFS_STATS_INC(xs_write_calls);
	if (outfilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;
	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;
	xfs_ilock(ip, XFS_IOLOCK_EXCL);
	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_write_bytes, ret);
	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
	return ret;
}
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","The `xfs_file_splice_write` function facilitates the transfer of data from a pipe to a file in the XFS filesystem. It begins by retrieving the inode associated with the output file and checking for specific conditions, such as forced shutdowns and file mode flags. If the conditions are met, it locks the inode for exclusive access and logs the operation. The function then calls `generic_file_splice_write` to perform the actual data transfer, updating statistics on the number of write calls and bytes written if successful. Finally, it unlocks the inode and returns the result of the write operation.","This function enables the transfer of data from a pipe to a specified file within a filesystem. It first checks the state of the file and the system to ensure that the operation can proceed safely. If conditions are favorable, it locks the file to prevent concurrent modifications and logs the operation for tracking purposes. The core data transfer is then executed, and if successful, it updates the statistics related to the number of write operations and the amount of data written. Finally, the function releases the lock on the file and returns the outcome of the data transfer.","The vulnerability in the original code arises from the exclusive locking of the inode during the data transfer process, which could lead to a denial of service if multiple processes attempt to access the same file simultaneously. This locking mechanism could block other operations, causing performance issues or even deadlocks. In the fixed code, the function now uses shared locking instead of exclusive locking with `xfs_rw_ilock` and `xfs_rw_iunlock`, allowing multiple readers to access the file concurrently while still preventing write operations, thus improving concurrency and reducing the risk of blocking other processes.","The vulnerability in the original code stems from the use of exclusive locking during data transfer, which can lead to performance bottlenecks and potential deadlocks when multiple processes attempt to access the same resource simultaneously. This locking strategy prevents other operations from proceeding, effectively blocking access and degrading system responsiveness. The fixed code addresses this issue by implementing shared locking instead, allowing multiple read operations to occur concurrently while still safeguarding against conflicting write operations. This change enhances overall system performance and reduces the likelihood of blocking other processes, thereby improving concurrency and resource utilization.","The vulnerability was fixed by changing the locking mechanism from exclusive to shared. In the original code, the function used `xfs_ilock` for exclusive locking, which restricted access to the inode and could lead to performance issues when multiple processes attempted to read from the same file. In the revised code, `xfs_rw_ilock` is employed to acquire a shared lock, allowing multiple read operations to occur concurrently while still preventing write operations. This adjustment improves concurrency and system responsiveness, as it enables simultaneous access for readers without blocking other processes, thus mitigating the risk of deadlocks and performance degradation.","The vulnerability was addressed by altering the locking strategy from exclusive to shared, which allows multiple processes to read from the resource simultaneously. This change enables concurrent read operations without blocking each other, thereby enhancing system performance and responsiveness. By implementing shared locking, the code prevents write operations while still permitting multiple readers, effectively reducing the risk of performance bottlenecks and deadlocks that could occur with exclusive locking. This adjustment improves overall resource utilization and ensures that the system can handle multiple requests more efficiently, thereby mitigating the original vulnerability.","CWE-667, CWE-662, CWE-764, CWE-833, CWE-413, CWE-412, CWE-414, CWE-415, CWE-567, CWE-675",N,-1
1,1,177736,177736,,Remote,Single system,Partial,CVE-2015-8467,https://www.cvedetails.com/cve/CVE-2015-8467/,CWE-264,Medium,Partial,Partial,,2015-12-29,6.0,"The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",2016-12-30,Bypass,13,https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,,0,,,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
        const struct uac_to_guid {
                uint32_t uac;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",C,"       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
               uint32_t priv_to_change_from;
               bool admin_required;
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
",,a819d2b440aafa3138d95ff6e8b824da885a70e9,"@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
+               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
+               bool admin_required;
                const char *error_string;
        } map[] = {
                {
@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
+               {
+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
+                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
+               },
+               {
+                       .uac = UF_NORMAL_ACCOUNT,
+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
+               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                return ldb_module_operr(ac->module);
        }
 
-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
+       ret = dsdb_get_sd_from_ldb_message(ldb,
                                           ac, res->msgs[0], &domain_sd);
 
        if (ret != LDB_SUCCESS) {
@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                if (have_priv == false) {
                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                }
-                       } else {
+                       } else if (map[i].priv_to_change_from & user_account_control_old) {
+                               bool is_admin = security_token_has_builtin_administrators(user_token);
+                               if (is_admin == false) {
+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
+                               }
+                       } else if (map[i].guid) {
                                ret = acl_check_extended_right(ac, domain_sd,
                                                               user_token,
                                                               map[i].guid,
                                                               SEC_ADS_CONTROL_ACCESS,
                                                               sid);
+                       } else {
+                               ret = LDB_SUCCESS;
                        }
                        if (ret != LDB_SUCCESS) {
                                break;",samba,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98,1,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
//fix_flaw_line_below:
//       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
//fix_flaw_line_below:
//               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
//fix_flaw_line_below:
//               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",177736,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
	struct security_token *user_token;
	struct security_descriptor *domain_sd;
	struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
	const struct uac_to_guid {
		uint32_t uac;
		const char *oid;
		const char *guid;
		enum sec_privilege privilege;
		bool delete_is_privileged;
		const char *error_string;
	} map[] = {
		{
			.uac = UF_PASSWD_NOTREQD,
			.guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,
			.error_string = ""Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object""
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
			.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface"",
			.delete_is_privileged = true
		},
		{
			.uac = UF_TRUSTED_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		},
		{
			.uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};

	if (dsdb_module_am_system(ac->module)) {
		return LDB_SUCCESS;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		if (user_account_control & map[i].uac) {
			need_acl_check = true;
			break;
		}
	}
	if (need_acl_check == false) {
		return LDB_SUCCESS;
	}

	user_token = acl_user_token(ac->module);
	if (user_token == NULL) {
		return LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
	}

	ret = dsdb_module_search_dn(ac->module, ac, &res,
				    domain_dn,
				    sd_attrs,
				    DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
				    ac->req);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (res->count != 1) {
		return ldb_module_operr(ac->module);
	}

	ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
					   ac, res->msgs[0], &domain_sd);

	if (ret != LDB_SUCCESS) {
		return ret;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		uint32_t this_uac_new = user_account_control & map[i].uac;
		uint32_t this_uac_old = user_account_control_old & map[i].uac;
		if (this_uac_new != this_uac_old) {
			if (this_uac_old != 0) {
				if (map[i].delete_is_privileged == false) {
					continue;
				}
			}
			if (map[i].oid) {
				struct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);
				if (control == NULL) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else if (map[i].privilege != SEC_PRIV_INVALID) {
				bool have_priv = security_token_has_privilege(user_token,
									      map[i].privilege);
				if (have_priv == false) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else {
				ret = acl_check_extended_right(ac, domain_sd,
							       user_token,
							       map[i].guid,
							       SEC_ADS_CONTROL_ACCESS,
							       sid);
			}
			if (ret != LDB_SUCCESS) {
				break;
			}
		}
	}
	if (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {
		switch (ac->req->operation) {
		case LDB_ADD:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to add %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		case LDB_MODIFY:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to modify %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		default:
			return ldb_module_operr(ac->module);
		}
		if (map[i].guid) {
			dsdb_acl_debug(domain_sd, acl_user_token(ac->module),
				       domain_dn,
				       true,
				       10);
		}
	}
	return ret;
}","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","The provided code defines a function, `samldb_check_user_account_control_acl`, which checks the access control list (ACL) permissions for modifying user account control attributes in a directory service context. It first verifies if the operation requires an ACL check based on specific user account control flags. If necessary, it retrieves the security descriptor for the domain and evaluates whether the user has the required privileges or rights to make the requested changes. If access is insufficient, it generates an appropriate error message based on the operation type (add or modify) and returns the corresponding error code, ensuring secure management of user account attributes.","The code implements a function that verifies whether a user has the necessary permissions to modify specific attributes related to user accounts in a directory service. It first determines if an access control check is required based on certain flags. If so, it retrieves the security descriptor for the domain and assesses the user's privileges against the required rights for the requested changes. If the user lacks sufficient access, the function generates an error message tailored to the type of operation being performed, ensuring that modifications to user account settings are securely managed and compliant with access policies.","The vulnerability in the original code stemmed from insufficient checks on user privileges when modifying user account control attributes, potentially allowing unauthorized changes. Specifically, the absence of a mechanism to enforce administrative requirements for certain privilege changes left the system open to exploitation. The fixed code introduces an additional field, `admin_required`, in the mapping structure, which ensures that specific changes, such as swapping account types, require the user to be a member of the domain admins group. This enhancement mitigates the risk of unauthorized privilege escalation by enforcing stricter access controls based on user roles.","The vulnerability in the original code arose from inadequate checks on user permissions when altering account control attributes, which could allow unauthorized users to make critical changes. This lack of oversight meant that certain privilege modifications could be executed without proper authorization, potentially leading to privilege escalation. The revised code addresses this issue by introducing a mechanism that requires specific administrative privileges for certain changes, ensuring that only authorized users can perform sensitive operations. This enhancement significantly strengthens access control, reducing the risk of unauthorized modifications to user account settings.","The vulnerability was fixed by introducing an additional field, `admin_required`, in the mapping structure that specifies when administrative privileges are necessary for certain changes to user account control attributes. This enhancement ensures that operations such as swapping account types now require the user to be a member of the domain admins group. The code checks this condition during the permission validation process, thereby enforcing stricter access controls. By implementing these checks, the revised code effectively prevents unauthorized users from making critical modifications, thereby enhancing the overall security of the user account management system.","The vulnerability was addressed by adding a mechanism that requires specific administrative privileges for certain sensitive changes to user account attributes. This enhancement ensures that only users with the appropriate administrative rights can perform critical operations, such as altering account types. By implementing these additional checks, the revised code enforces stricter access controls, preventing unauthorized modifications and reducing the risk of privilege escalation. This change significantly strengthens the security framework governing user account management, ensuring that only authorized personnel can make significant alterations to account settings.","CWE-269, CWE-284, CWE-285, CWE-732, CWE-264, CWE-266, CWE-287, CWE-639, CWE-522, CWE-277",N,-1
2,2,177838,177838,,Remote,Not required,,CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,Medium,,Partial,,2015-08-02,4.3,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",2018-10-24,Bypass,7,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,,0,,,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",C,"	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

",,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: channels.c,v 1.346 2015/06/30 05:25:07 djm Exp $ */
+/* $OpenBSD: channels.c,v 1.347 2015/07/01 02:26:31 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -161,6 +161,9 @@ static char *x11_saved_proto = NULL;
 static char *x11_saved_data = NULL;
 static u_int x11_saved_data_len = 0;
 
+/* Deadline after which all X11 connections are refused */
+static u_int x11_refuse_time;
+
 /*
  * Fake X11 authentication data.  This is what the server will be sending us;
  * we should replace any occurrences of this by the real data.
@@ -912,6 +915,13 @@ x11_open_helper(Buffer *b)
 	u_char *ucp;
 	u_int proto_len, data_len;
 
+	/* Is this being called after the refusal deadline? */
+	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
+		verbose(""Rejected X11 connection after ForwardX11Timeout ""
+		    ""expired"");
+		return -1;
+	}
+
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
@@ -1483,6 +1493,12 @@ channel_set_reuseaddr(int fd)
 		error(""setsockopt SO_REUSEADDR fd %d: %s"", fd, strerror(errno));
 }
 
+void
+channel_set_x11_refuse_time(u_int refuse_time)
+{
+	x11_refuse_time = refuse_time;
+}
+
 /*
  * This socket is listening for connections to a forwarded TCP/IP port.
  */",mindrot,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,1,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
//fix_flaw_line_below:
//	/* Is this being called after the refusal deadline? */
//fix_flaw_line_below:
//	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
//fix_flaw_line_below:
//		verbose(""Rejected X11 connection after ForwardX11Timeout ""
//fix_flaw_line_below:
//		    ""expired"");
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",177838,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","The `x11_open_helper` function processes a buffer to handle X11 protocol packets. It first checks if the buffer's length is at least 12 bytes, which is necessary for the fixed-size part of the packet. If the buffer is shorter, the function returns 0, indicating insufficient data. Additionally, the function attempts to access the first byte of the packet for debugging purposes, logging a message if the byte order is incorrect. However, the code contains some redundancy with duplicate variable declarations and lacks complete error handling, which may lead to potential issues during execution.","The provided code snippet is designed to handle a specific protocol's packet processing by first verifying that the incoming data meets a minimum size requirement. If the data is insufficient, it returns a value indicating this condition. Additionally, the code includes a debugging feature that logs a message related to the first byte of the packet, which is intended to help identify issues with the byte order. However, the implementation contains some redundancies and lacks comprehensive error handling, which could lead to potential problems during its execution.","The vulnerability in the original code arises from the lack of a timeout mechanism for rejecting X11 connections, which could allow an attacker to exploit the system by keeping connections open indefinitely. In the fixed code, a check is introduced to determine if the current time exceeds a predefined refusal deadline, using the `monotime()` function. If the connection attempt occurs after this deadline, the system logs a rejection message and returns an error code. This enhancement mitigates the risk of resource exhaustion and improves overall security by ensuring that stale connections are not allowed to persist.","The vulnerability in the original code stems from the absence of a mechanism to limit the duration of X11 connections, potentially allowing an attacker to exploit the system by keeping connections open indefinitely. This oversight could lead to resource exhaustion, as the system may become overwhelmed with stale connections. The fixed code addresses this issue by implementing a timeout check that rejects connection attempts after a specified deadline has passed. This enhancement effectively mitigates the risk of prolonged resource consumption, thereby improving the security and stability of the system against potential attacks.","The vulnerability was fixed by introducing a timeout mechanism that checks whether the current time exceeds a predefined refusal deadline. In the updated code, the condition involving `x11_refuse_time` is evaluated alongside the result of the `monotime()` function. If the current time surpasses the refusal deadline, the system logs a rejection message and returns an error code of -1. This change ensures that any connection attempts made after the specified timeout are denied, effectively preventing the exploitation of stale connections and enhancing the overall security of the X11 connection handling process.","The vulnerability was addressed by implementing a timeout mechanism that limits the duration of connection attempts. The updated code checks if the current time exceeds a specified refusal deadline, and if so, it rejects the connection attempt and logs a message indicating the rejection. This enhancement prevents the system from being overwhelmed by stale connections, effectively mitigating the risk of resource exhaustion. By enforcing a time limit on connection requests, the fix improves the overall security and stability of the system, ensuring that only valid and timely connection attempts are processed.","CWE-400, CWE-835, CWE-200, CWE-799, CWE-770, CWE-834, CWE-409, CWE-674, CWE-404, CWE-406",N,-1
3,3,177855,177855,,Remote,Not required,,CVE-2015-5252,https://www.cvedetails.com/cve/CVE-2015-5252/,CWE-264,Low,,Partial,,2015-12-29,5.0,"vfs.c in smbd in Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, when share names with certain substring relationships exist, allows remote attackers to bypass intended file-access restrictions via a symlink that points outside of a share.",2016-12-30,Bypass,1,https://git.samba.org/?p=samba.git;a=commit;h=4278ef25f64d5fdbf432ff1534e275416ec9561e,4278ef25f64d5fdbf432ff1534e275416ec9561e,,0,,,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",C,"       bool matched;
",,5b730ab846a9d4ae44b425094af2934c2f7b2843,"@@ -982,6 +982,7 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
+       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,
@@ -1076,7 +1077,10 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        }
 
        rootdir_len = strlen(conn_rootdir);
-       if (strncmp(conn_rootdir, resolved_name, rootdir_len) != 0) {
+       matched = (strncmp(conn_rootdir, resolved_name, rootdir_len) == 0);
+
+       if (!matched || (resolved_name[rootdir_len] != '/' &&
+                        resolved_name[rootdir_len] != '\0')) {
                DEBUG(2, (""check_reduced_name_with_privilege: Bad access ""
                        ""attempt: %s is a symlink outside the ""
                        ""share path\n"",
@@ -1216,6 +1220,7 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
        if (!allow_widelinks || !allow_symlinks) {
                const char *conn_rootdir;
                size_t rootdir_len;
+               bool matched;
 
                conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
                if (conn_rootdir == NULL) {
@@ -1226,8 +1231,10 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
                }
 
                rootdir_len = strlen(conn_rootdir);
-               if (strncmp(conn_rootdir, resolved_name,
-                               rootdir_len) != 0) {
+               matched = (strncmp(conn_rootdir, resolved_name,
+                               rootdir_len) == 0);
+               if (!matched || (resolved_name[rootdir_len] != '/' &&
+                                resolved_name[rootdir_len] != '\0')) {
                        DEBUG(2, (""check_reduced_name: Bad access ""
                                ""attempt: %s is a symlink outside the ""
                                ""share path\n"", fname));",samba,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=f14ecbef9669dbf71c050a0a5363d262092963d1;hb=f14ecbef9669dbf71c050a0a5363d262092963d1,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0;hb=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0,1,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
//fix_flaw_line_below:
//       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",177855,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","The `check_reduced_name_with_privilege` function verifies access privileges for a specified file name within a given connection context. It begins by extracting the parent directory and the last component of the file name, allocating necessary memory for these components. The function checks if the parent directory exists and changes the current working directory to it. It then retrieves the absolute path and compares the file system status of the parent directory to ensure it hasn't changed. Finally, it checks if the resolved path is within the connection's root directory, returning appropriate NTSTATUS codes for any errors encountered during the process.","The function is designed to verify access privileges for a specified file within a connection context. It begins by extracting the parent directory and the file name, ensuring that memory is allocated for these components. The function checks the existence of the parent directory and changes the current working directory to it. It then retrieves the absolute path and compares the file system status of the parent directory to confirm it remains unchanged. Finally, it ensures that the resolved path is within the allowed connection root, returning appropriate status codes for any encountered errors during the process.","The vulnerability in the original code arises from the lack of a check to ensure that the resolved path is indeed within the allowed connection root directory, which could lead to unauthorized access to files outside the intended directory structure. In the fixed code, the introduction of a boolean variable named `matched` suggests that additional logic was implemented to verify that the resolved path aligns with the connection's root directory. This enhancement mitigates the risk of directory traversal attacks, ensuring that access is appropriately restricted to the designated file paths, thereby improving overall security.","The vulnerability in the original code stems from the absence of a verification mechanism to ensure that the resolved file path remains within the confines of the allowed connection root directory. This oversight could potentially allow unauthorized access to files outside the intended directory, exposing the system to directory traversal attacks. The fixed code addresses this issue by implementing a check that confirms the resolved path aligns with the connection's root directory. This enhancement effectively restricts access to designated file paths, thereby bolstering security and preventing unauthorized file access.","The vulnerability was fixed by introducing a verification step that ensures the resolved path is within the allowed connection root directory. In the updated code, the variable `conn_rootdir` is used to retrieve the connection's root path, and additional logic is likely implemented to compare this with the resolved path. This check prevents unauthorized access by confirming that the resolved path does not lead outside the designated directory structure. By enforcing this restriction, the code mitigates the risk of directory traversal attacks, thereby enhancing the overall security of the file access mechanism.","The vulnerability was addressed by implementing a verification mechanism that ensures the resolved file path remains within the designated connection root directory. This fix involves adding a check that compares the resolved path against the allowed directory structure, effectively preventing unauthorized access to files outside the intended scope. By enforcing this restriction, the updated code mitigates the risk of directory traversal attacks, ensuring that access is limited to the appropriate file paths. This enhancement significantly improves the security of the file access process, safeguarding the system from potential exploitation.","CWE-22, CWE-23, CWE-36, CWE-73, CWE-35, CWE-99, CWE-41, CWE-32, CWE-434, CWE-641",N,-1
4,4,177896,177896,,Local,Not required,Complete,CVE-2013-2007,https://www.cvedetails.com/cve/CVE-2013-2007/,CWE-264,Medium,Complete,Complete,,2013-05-21,6.9,"The qemu guest agent in Qemu 1.4.1 and earlier, as used by Xen, when started in daemon mode, uses weak permissions for certain files, which allows local users to read and write to these files.",2017-08-28,,1,https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,,1,,,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",C,"    umask(S_IRWXG | S_IRWXO);
","    umask(0);
",d7108d90100d5bac5965abef5ed73f2602adae14,"@@ -478,7 +478,7 @@ static void become_daemon(const char *pidfile)
         }
     }
 
-    umask(0);
+    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=44a283686bbf870a4a1adaa19a9d78f4c3a31108;hb=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=1841759db270295c96262f215f92b408ac6f472c,1,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
//flaw_line_below:
    umask(0);
//fix_flaw_line_below:
//    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",177896,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","The `become_daemon` function is designed to convert a running process into a daemon on Unix-like systems. It begins by forking the process; if the fork fails, it exits with an error. The parent process exits, while the child continues. If a PID file is specified, it attempts to create it, failing which it logs an error and exits. The function then sets the file mode creation mask to zero, creates a new session, and changes the working directory to the root. Finally, it redirects standard input, output, and error to `/dev/null`, ensuring the daemon runs in the background. If any step fails, it cleans up by removing the PID file and exits with an error.","The provided code defines a function that transforms a running process into a background service, commonly known as a daemon. It initiates by creating a new process, where the original process exits, allowing the child to continue. If a specified file for storing the process ID cannot be created, an error is logged, and the function exits. The function then sets permissions, creates a new session, and changes the working directory to the root. It also redirects standard input, output, and error streams to a null device, ensuring the daemon operates independently in the background. Any failure during this process results in cleanup and an error exit.","The vulnerability in the original code arises from the use of `umask(0)`, which allows the daemon to create files with potentially insecure permissions, exposing them to unauthorized access. This could lead to privilege escalation or data leakage. In the fixed code, the `umask` function is modified to set more restrictive permissions (`S_IRWXG | S_IRWXO`), which limits access to group and others, thereby enhancing security. This change ensures that any files created by the daemon have appropriate permissions, reducing the risk of exploitation by unauthorized users or processes.","The vulnerability in the original code stems from the lack of restrictions on file permissions, which could allow unauthorized access to files created by the daemon. This oversight could lead to security risks, such as privilege escalation or data exposure. The fixed code addresses this issue by implementing a more restrictive setting for file permissions, ensuring that any files created by the daemon are not accessible to unauthorized users. This enhancement significantly improves the security posture of the daemon, mitigating the risk of exploitation and protecting sensitive information from potential threats.","The vulnerability was fixed by changing the argument passed to the `umask` function from `0` to `S_IRWXG | S_IRWXO`. This adjustment restricts the permissions of newly created files, preventing group and others from having read, write, or execute access. By setting a more secure umask, the code ensures that any files created by the daemon are not exposed to unauthorized users, thereby enhancing overall security. This change mitigates the risk of privilege escalation and data leakage, ensuring that the daemon operates with appropriate access controls in place.","The vulnerability was addressed by modifying the permissions set for newly created files, ensuring that they are not accessible to unauthorized users. By implementing a more restrictive permission setting, the code limits access for groups and others, thereby enhancing security. This change prevents potential exploitation, such as privilege escalation or data exposure, by ensuring that sensitive files created by the daemon are adequately protected. As a result, the overall security posture of the daemon is improved, reducing the risk of unauthorized access and safeguarding critical information from potential threats.","CWE-732, CWE-276, CWE-266, CWE-281, CWE-668, CWE-275, CWE-284, CWE-732, CWE-264, CWE-269",N,-1
5,5,177923,177923,,Remote,Not required,,CVE-2015-2348,https://www.cvedetails.com/cve/CVE-2015-2348/,CWE-264,Low,,Partial,,2015-03-30,5.0,"The move_uploaded_file implementation in ext/standard/basic_functions.c in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 truncates a pathname upon encountering a \x00 character, which allows remote attackers to bypass intended extension restrictions and create files with unexpected names via a crafted second argument.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",2018-10-30,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,,1,,,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
",c8eaca013a3922e8383def6158ece2b63f6ec483,"@@ -5775,7 +5775,7 @@ PHP_FUNCTION(move_uploaded_file)
                RETURN_FALSE;
        }
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=c3e223048afaa30e087036e006adb0849babcccc;hb=c3e223048afaa30e087036e006adb0849babcccc,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=9a9df3094bec559376bacfbb9e6737c28f91dfda;hb=9a9df3094bec559376bacfbb9e6737c28f91dfda,1,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",177923,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","The provided PHP function `move_uploaded_file` is designed to securely move an uploaded file from a temporary location to a specified destination. It first checks if the uploaded file exists in the global uploaded files array and validates the parameters. If the destination path is permissible, it attempts to rename the file; if that fails, it tries to copy the file instead. The function also adjusts file permissions on non-Windows systems. Upon successful completion, it removes the original file entry from the uploaded files array; otherwise, it triggers an error message. The function ultimately returns a boolean indicating success or failure.","The code defines a function that facilitates the secure transfer of an uploaded file from a temporary storage location to a specified destination. It first verifies the existence of the uploaded file and checks the validity of the provided parameters. If the destination is allowed, the function attempts to rename the file; if that operation fails, it resorts to copying the file instead. Additionally, it adjusts file permissions on non-Windows systems. Upon successful transfer, it cleans up by removing the original file reference; otherwise, it generates an error message, ultimately returning a success or failure status.","The vulnerability in the original code arises from the use of `zend_parse_parameters` with the ""ss"" type, which allows for string inputs that could potentially include malicious paths. This could lead to directory traversal attacks, where an attacker could manipulate the file paths to access unauthorized directories. The fix involved changing the parameter type to ""sp,"" which enforces stricter validation on the new path, ensuring it is a valid string pointer. This adjustment helps mitigate the risk of unauthorized file access by ensuring that the destination path adheres to expected formats and restrictions.","The vulnerability in the original code stemmed from inadequate validation of input parameters, allowing for potential directory traversal attacks. Attackers could manipulate file paths to access or overwrite sensitive files outside the intended directory. The fix involved changing the parameter validation method to enforce stricter checks on the destination path, ensuring it adheres to expected formats and restrictions. This enhancement significantly reduces the risk of unauthorized file access by ensuring that only valid and safe paths are processed, thereby improving the overall security of the file handling functionality.","The vulnerability was fixed by changing the parameter type in the `zend_parse_parameters` function from ""ss"" to ""sp,"" which enforces stricter validation on the new path input. This adjustment ensures that the new path is treated as a valid string pointer, reducing the risk of accepting malicious or malformed paths that could lead to directory traversal attacks. Additionally, the use of `php_check_open_basedir` remains to further restrict access to files outside designated directories. Together, these changes enhance the security of the file handling process by ensuring only safe and valid paths are processed.","The vulnerability was addressed by implementing stricter validation for the input parameters, specifically by changing the method used to parse the parameters. This modification ensures that the destination path is treated as a valid string pointer, which helps prevent the acceptance of potentially harmful or malformed paths that could lead to unauthorized file access. Additionally, the code retains checks to restrict access to files outside designated directories, further enhancing security. These combined changes significantly reduce the risk of directory traversal attacks and ensure that only safe and appropriate paths are processed.","CWE-22, CWE-73, CWE-23, CWE-36, CWE-99, CWE-706, CWE-35, CWE-32, CWE-641, CWE-114",N,-1
6,6,178074,178074,,Remote,Not required,Partial,CVE-2014-7815,https://www.cvedetails.com/cve/CVE-2014-7815/,CWE-264,Low,,,,2014-11-14,5.0,The set_pixel_format function in ui/vnc.c in QEMU allows remote attackers to cause a denial of service (crash) via a small bytes_per_pixel value.,2017-12-27,DoS,10,https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829,e6908bfe8e07f2b452e78e677da1b45b1c0f6829,,0,,,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",C,"    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

",,3e9418e160cd8901c83a3c88967158084f5b5c03,"@@ -2026,6 +2026,16 @@ static void set_pixel_format(VncState *vs,
         return;
     }
 
+    switch (bits_per_pixel) {
+    case 8:
+    case 16:
+    case 32:
+        break;
+    default:
+        vnc_client_error(vs);
+        return;
+    }
+
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=8bca59798c84011dd7d7320f013a6997d6b0a4bc;hb=8bca59798c84011dd7d7320f013a6997d6b0a4bc,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=0fe6eff1b8a661d7cb123b37bb49921c72d5df16;hb=0fe6eff1b8a661d7cb123b37bb49921c72d5df16,1,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
//fix_flaw_line_below:
//    switch (bits_per_pixel) {
//fix_flaw_line_below:
//    case 8:
//fix_flaw_line_below:
//    case 16:
//fix_flaw_line_below:
//    case 32:
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//    default:
//fix_flaw_line_below:
//        vnc_client_error(vs);
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",178074,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","The `set_pixel_format` function configures the pixel format for a VNC (Virtual Network Computing) client by setting various parameters such as bits per pixel, color depth, and color channel specifications (red, green, blue). It first checks if true color is enabled; if not, it triggers an error and exits. If true color is valid, it assigns values for the maximum color values, bit representation, and shifts for each color channel. The function also determines the bytes per pixel and depth based on the bits per pixel, updates the endianness, and calls functions to handle pixel conversion and refresh the graphical display.","The code defines a function that configures the pixel format for a virtual display client by setting parameters related to color representation and depth. It first verifies if true color support is enabled; if not, it triggers an error and exits. When true color is valid, it assigns values for maximum color intensities and their respective bit representations, while also determining the number of bytes used per pixel and adjusting the color depth accordingly. Additionally, it updates the endianness and invokes functions to manage pixel conversion and refresh the graphical output, ensuring the display reflects the new settings.","The vulnerability in the original code stemmed from the lack of validation for the `bits_per_pixel` parameter, which could allow unsupported values to be processed, potentially leading to undefined behavior or memory corruption. In the fixed code, a switch statement was introduced to explicitly check if `bits_per_pixel` is either 8, 16, or 32. If it does not match these values, the function triggers an error and exits early. This additional validation ensures that only acceptable pixel formats are processed, thereby enhancing the robustness and security of the function by preventing invalid configurations.","The vulnerability in the original code arose from the absence of checks on a critical parameter, allowing unsupported values to be processed without validation. This oversight could lead to undefined behavior, memory corruption, or crashes, as the system might attempt to handle invalid configurations. The fixed code addresses this issue by implementing a validation mechanism that restricts the parameter to specific acceptable values. If the parameter does not meet these criteria, the function triggers an error and exits early, thereby preventing the processing of invalid inputs and enhancing the overall security and stability of the function.","The vulnerability was fixed by introducing a validation check for the `bits_per_pixel` parameter using a switch statement. This new check ensures that only specific values—8, 16, or 32—are accepted. If `bits_per_pixel` does not match these values, the function calls `vnc_client_error(vs)` and exits early, preventing further processing of invalid configurations. This enhancement effectively mitigates the risk of undefined behavior or memory corruption that could arise from unsupported pixel formats. By enforcing this validation, the code becomes more robust and secure against potential exploitation.","The vulnerability was addressed by implementing a validation mechanism that restricts a critical parameter to specific acceptable values. A conditional check was added to ensure that only predefined values are processed, effectively preventing the function from proceeding with unsupported configurations. If the parameter does not meet the criteria, the function triggers an error and exits early, halting any further execution. This change significantly enhances the robustness of the code by eliminating the risk of undefined behavior or memory corruption that could occur from invalid inputs, thereby improving overall security and stability.","CWE-20, CWE-789, CWE-119, CWE-125, CWE-787, CWE-502, CWE-74, CWE-94, CWE-22, CWE-134",N,-1
7,7,178405,178405,,Remote,Not required,,CVE-2011-4328,https://www.cvedetails.com/cve/CVE-2011-4328/,CWE-264,Low,Partial,,,2012-06-15,5.0,"plugin/npapi/plugin.cpp in Gnash before 0.8.10 uses weak permissions (world readable) for cookie files with predictable names in /tmp, which allows local users to obtain sensitive information.",2014-01-07,+Info,1,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=commitdiff;h=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,,0,,,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",CPP,"    chmod (ss.str().c_str(), 0600);
",,3dea0709b06a82ad8085d04daf86c9beff93d742,"@@ -1108,6 +1108,7 @@ nsPluginInstance::setupCookies(const std::string& pageurl)
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
+    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //",savannah,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=04950e6c950249a55b6e70e120ea327456bd3a39;hb=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=e161a1d2d9bfa0e0dfe44933bc373c7b3a9c1819,1,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    // Cookie appear to drop anything past the domain, so we strip
    // that off.
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    // Firefox does not (always) return the cookies that are associated
    // with a domain name through GetValueForURL.
    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
//fix_flaw_line_below:
//    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //
    //
    // Whereas libcurl expects cookies in the following format:
    //
    // Set-Cookie: cookie1=value1;
    // Set-Cookie: cookie2=value2;
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",178405,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","The `setupCookies` function retrieves and processes cookies for a given webpage URL. It first extracts the base URL from the provided `pageurl` string and attempts to obtain cookies using the `NPN_GetValueForURL` function if supported. If this fails, it falls back to accessing cookies via `window.document.cookie`. The retrieved cookies are then stored in a temporary file named with the process ID, formatted as ""Set-Cookie: cookie_value"". Finally, the function sets an environment variable `GNASH_COOKIES_IN` to point to the temporary cookie file, logging any errors encountered during this process.","The code is designed to manage cookies for a specified webpage. It begins by extracting the base URL from the provided input and attempts to retrieve cookies associated with that URL using a specific browser function. If this retrieval fails, it resorts to accessing cookies through the document object. The collected cookies are then written to a temporary file, formatted appropriately for cookie storage. Additionally, the code sets an environment variable to reference this temporary file, while also logging any errors that may occur during the process, ensuring proper handling and storage of cookie data.","The vulnerability in the original code arises from the lack of proper file permissions when creating the temporary cookie file, which could allow unauthorized access to sensitive cookie data. In the fixed code, the addition of the `chmod` function call sets the file permissions to `0600`, ensuring that only the owner can read and write to the file. This change mitigates the risk of exposure to other users on the system, thereby enhancing the security of the stored cookie information. By restricting access, the code protects against potential data leaks and unauthorized manipulation of cookie data.","The vulnerability in the original code stems from inadequate file permissions when creating a temporary file to store sensitive cookie data, potentially allowing unauthorized access by other users on the system. This oversight could lead to exposure of private information, making it susceptible to malicious actors. The fixed code addresses this issue by implementing a permission change that restricts access to the file, ensuring that only the owner can read or write to it. This enhancement significantly improves the security of the stored data, protecting it from unauthorized access and reducing the risk of data leaks.","The vulnerability was fixed by adding a call to the `chmod` function in the updated code, which sets the permissions of the temporary cookie file to `0600`. This change ensures that only the owner of the file has read and write access, effectively preventing unauthorized users from accessing sensitive cookie data. By applying this permission change immediately after the file is created, the code enhances the security of the stored information. This modification addresses the risk of data exposure that existed in the original implementation, thereby safeguarding the integrity and confidentiality of the cookie data.","The vulnerability was fixed by implementing a mechanism to set strict file permissions on the temporary file created for storing sensitive cookie data. This adjustment ensures that only the file's owner has the ability to read or write to it, effectively preventing unauthorized access by other users on the system. By restricting access in this manner, the updated code significantly enhances the security of the stored information, mitigating the risk of data exposure and protecting the integrity and confidentiality of the cookie data from potential malicious actors.","CWE-732, CWE-276, CWE-281, CWE-264, CWE-266, CWE-284, CWE-668, CWE-669, CWE-732, CWE-275",N,-1
8,8,178455,178455,,Local,Not required,Complete,CVE-2015-8325,https://www.cvedetails.com/cve/CVE-2015-8325/,CWE-264,Low,Complete,Complete,,2016-04-30,7.2,"The do_setup_env function in session.c in sshd in OpenSSH through 7.2p2, when the UseLogin feature is enabled and PAM is configured to read .pam_environment files in user home directories, allows local users to gain privileges by triggering a crafted environment for the /bin/login program, as demonstrated by an LD_PRELOAD environment variable.",2018-06-29,+Priv,1,https://anongit.mindrot.org/openssh.git/commit/?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,85bdcd7c92fe7ff133bbc4e10a65c91810f88755,,1,,,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",C,"	if (options.use_pam && !options.use_login) {
","	if (options.use_pam) {
",dce19bf6e4a2a3d0b13a81224de63fc316461ab9,"@@ -1322,7 +1322,7 @@ do_setup_env(Session *s, const char *shell)
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
-	if (options.use_pam) {
+	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();",mindrot,https://anongit.mindrot.org/openssh.git/tree/session.c?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,https://anongit.mindrot.org/openssh.git/tree/session.c?id=dce19bf6e4a2a3d0b13a81224de63fc316461ab9,1,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
//flaw_line_below:
	if (options.use_pam) {
//fix_flaw_line_below:
//	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",178455,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","The `do_setup_env` function initializes the environment for a child process in an SSH session by allocating memory for environment variables and populating it with various settings. It retrieves and copies the existing environment, sets user-specific variables like `USER`, `HOME`, and `MAIL`, and handles platform-specific configurations, such as for Cygwin and AIX. The function also incorporates custom environment variables, SSH connection details, and PAM-related settings if applicable. Additionally, it reads user-specific environment files and logs the environment if debugging is enabled, ultimately returning the constructed environment array for the child process.","The code initializes the environment for a child process in an SSH session by allocating memory for environment variables and populating it with various user-specific settings. It retrieves the existing environment, sets essential variables such as user name and home directory, and accommodates platform-specific configurations. The code also incorporates custom environment variables, connection details, and settings related to authentication methods. Additionally, it reads user-specific environment files and logs the environment for debugging purposes, ultimately returning the constructed environment array for the child process to use.","The vulnerability in the original code arises from the potential exposure of sensitive environment variables, particularly when user-controlled input is directly incorporated into the environment without proper validation. This could allow an attacker to manipulate the environment of the child process, leading to privilege escalation or unauthorized access. The fixed code addresses this by ensuring that environment variables are set only after validating and sanitizing user input, particularly in sections where custom environment variables are processed. This change mitigates the risk of injecting malicious values into critical environment variables, enhancing overall security.","The vulnerability in the original code stems from the lack of validation and sanitization of user-controlled input when setting environment variables, which could allow an attacker to inject malicious values. This could lead to unauthorized access or privilege escalation by manipulating the environment of the child process. The fixed code addresses this issue by implementing checks and ensuring that only validated and sanitized input is used when populating the environment. This change significantly reduces the risk of exploitation by preventing the introduction of harmful data into critical environment settings, thereby enhancing the security of the application.","The vulnerability was fixed by implementing validation and sanitization processes for user-controlled input before setting environment variables. In the updated code, the section that processes custom environment variables now includes checks to ensure that the input is properly formatted before it is passed to the `child_set_env` function. Specifically, the code verifies that the input string contains an equal sign, indicating a valid key-value pair, and only then modifies the environment. This careful handling prevents the injection of malicious values, thereby securing the environment of the child process against potential exploitation.","The vulnerability was fixed by introducing validation and sanitization measures for user-controlled input before it is used to set environment variables. The updated code ensures that any input is checked for proper formatting, specifically confirming that it adheres to the expected key-value structure. This prevents the introduction of potentially harmful data into the environment, thereby mitigating the risk of exploitation. By enforcing these checks, the code enhances the security of the child process's environment, ensuring that only safe and valid information is incorporated, which protects against unauthorized access and privilege escalation.","CWE-74,CWE-78,CWE-88,CWE-77,CWE-269,CWE-266,CWE-732,CWE-426,CWE-526,CWE-502",N,-1
9,9,178533,178533,,Remote,Not required,Partial,CVE-2013-4159,https://www.cvedetails.com/cve/CVE-2013-4159/,CWE-264,Low,Partial,Partial,,2014-08-06,7.5,"ctdb before 2.3 in OpenSUSE 12.3 and 13.1 does not create temporary files securely, which has unspecified impact related to ""several temp file vulnerabilities"" in (1) tcp/tcp_connect.c, (2) server/eventscript.c, (3) tools/ctdb_diagnostics, (4) config/gdb_backtrace, and (5) include/ctdb_private.h.",2018-10-30,,1,https://git.samba.org/?p=ctdb.git;a=commitdiff;h=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,b9b9f6738fba5c32e87cb9c36b358355b444fb9b,,1,,,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",C,"       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
","       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
",6a5469a63547029f4fc704a4d4075543e06c36d1,"@@ -284,7 +284,7 @@ static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
-       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
+       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;",samba,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=9df330009f1428fe72ae33ff8c3a91d0c4b782d9;hb=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=383d72641b222a5083c66f7e6e0bc0edc0318880,1,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
//flaw_line_below:
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
//fix_flaw_line_below:
//       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",178533,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","The `ctdb_tcp_listen_automatic` function initializes a TCP listening socket for a cluster database context (`ctdb`). It first checks for available nodes and attempts to acquire a file lock to prevent simultaneous binding. For each valid node, it retrieves the socket address and creates a TCP socket, setting the `SO_REUSEADDR` option to allow address reuse. The function attempts to bind the socket to the node's address and, upon success, sets it to listen for incoming connections. If binding fails for all nodes, it logs an error and cleans up resources before returning an error code.","The code defines a function that sets up a TCP listening socket for a cluster database context. It begins by verifying the presence of available nodes and attempts to acquire a lock to prevent concurrent binding. For each valid node, it retrieves the corresponding socket address and creates a TCP socket, allowing address reuse. The function then attempts to bind the socket to the node's address and, if successful, configures it to listen for incoming connections. If binding fails for all nodes, it logs an error and performs necessary cleanup before returning an error status.","The vulnerability in the original code stemmed from the use of a hardcoded lock path, which could lead to potential race conditions or conflicts if multiple instances of the application were running simultaneously. By changing the lock path to a more dynamic location, specifically using a variable that points to a directory, the fixed code mitigates the risk of multiple processes interfering with each other when attempting to bind to the same socket. This adjustment enhances the atomicity of the bind and listen operations, ensuring that only one instance can successfully bind to a given address at a time.","The vulnerability in the original code arose from the use of a static, hardcoded path for the lock file, which could lead to conflicts if multiple instances of the application were executed simultaneously. This could result in race conditions, where two processes might attempt to bind to the same socket, causing unpredictable behavior. The fixed code addresses this issue by utilizing a dynamic path for the lock file, ensuring that each instance of the application operates in its own context. This change enhances the atomicity of the binding process, preventing multiple instances from interfering with each other during socket initialization.","The vulnerability was fixed by changing the lock path from a hardcoded string to a dynamic path that utilizes a variable, specifically `VARDIR ""/run/ctdb/.socket_lock""`. This adjustment allows the application to create a unique lock file location, reducing the risk of conflicts when multiple instances are running. By ensuring that the lock file is created in a designated directory, the code enhances the atomicity of the binding process, as the lock is now more effectively managed. This prevents simultaneous binding attempts, thereby mitigating potential race conditions during socket initialization and ensuring proper resource management.","The vulnerability was addressed by replacing the static, hardcoded path for the lock file with a dynamic path that points to a specific directory. This change ensures that each instance of the application can create its own unique lock file, significantly reducing the likelihood of conflicts when multiple instances are executed simultaneously. By managing the lock file in a designated location, the code enhances the atomicity of the binding process, preventing simultaneous binding attempts and mitigating potential race conditions during socket initialization, thereby improving overall resource management and stability.","CWE-362, CWE-667, CWE-764, CWE-366, CWE-613, CWE-789, CWE-666, CWE-412, CWE-367, CWE-662",N,-1
10,10,178685,178685,,Local,Not required,Partial,CVE-2014-1845,https://www.cvedetails.com/cve/CVE-2014-1845/,CWE-264,Low,Partial,Partial,,2018-04-27,4.6,An unspecified setuid root helper in Enlightenment before 0.17.6 allows local users to gain privileges by leveraging failure to properly sanitize the environment.,2018-06-07,+Priv,100,https://git.enlightenment.org/core/enlightenment.git/commit/?id=666df815cd86a50343859bce36c5cf968c5f38b0,666df815cd86a50343859bce36c5cf968c5f38b0,,6,,,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",C,"   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif

   /* pass 3 - set path and ifs to minimal defaults */
","#else
# define NOENV(x)
#endif
   NOENV(""PYTHONPATH"");
     clearenv();
   /* set path and ifs to minimal defaults */
",fc9e8865cfb17a556a8a7efd1983ba211c16e545,"@@ -8,6 +8,9 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef HAVE_ENVIRON
+# define _GNU_SOURCE 1
+#endif
 #include <unistd.h>
 #include <string.h>
 #include <sys/types.h>
@@ -22,6 +25,10 @@
 #endif
 #include <Eina.h>
 
+#ifdef HAVE_ENVIRON
+extern char **environ;
+#endif
+
 double e_sys_l2ping(const char *bluetooth_mac);
 
 /* local subsystem functions */
@@ -166,17 +173,111 @@ main(int argc,
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
-#else
-# define NOENV(x)
-#endif
+   /* pass 1 - just nuke known dangerous env vars brutally if possible via
+    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
+   NOENV(""CDPATH"");
+   NOENV(""LOCALDOMAIN"");
+   NOENV(""RES_OPTIONS"");
+   NOENV(""HOSTALIASES"");
+   NOENV(""NLSPATH"");
+   NOENV(""PATH_LOCALE"");
+   NOENV(""COLORTERM"");
+   NOENV(""LANG"");
+   NOENV(""LANGUAGE"");
+   NOENV(""LINGUAS"");
+   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
-   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
+   NOENV(""SHLIB_PATH"");
+   NOENV(""LIBPATH"");
+   NOENV(""AUTHSTATE"");
+   NOENV(""DYLD_*"");
+   NOENV(""KRB_CONF*"");
+   NOENV(""KRBCONFDIR"");
+   NOENV(""KRBTKFILE"");
+   NOENV(""KRB5_CONFIG*"");
+   NOENV(""KRB5_KTNAME"");
+   NOENV(""VAR_ACE"");
+   NOENV(""USR_ACE"");
+   NOENV(""DLC_ACE"");
+   NOENV(""TERMINFO"");
+   NOENV(""TERMINFO_DIRS"");
+   NOENV(""TERMPATH"");
+   NOENV(""TERMCAP"");
+   NOENV(""ENV"");
+   NOENV(""BASH_ENV"");
+   NOENV(""PS4"");
+   NOENV(""GLOBIGNORE"");
+   NOENV(""SHELLOPTS"");
+   NOENV(""JAVA_TOOL_OPTIONS"");
+   NOENV(""PERLIO_DEBUG"");
+   NOENV(""PERLLIB"");
+   NOENV(""PERL5LIB"");
+   NOENV(""PERL5OPT"");
+   NOENV(""PERL5DB"");
+   NOENV(""FPATH"");
+   NOENV(""NULLCMD"");
+   NOENV(""READNULLCMD"");
+   NOENV(""ZDOTDIR"");
+   NOENV(""TMPPREFIX"");
+   NOENV(""PYTHONPATH"");
+   NOENV(""PYTHONHOME"");
+   NOENV(""PYTHONINSPECT"");
+   NOENV(""RUBYLIB"");
+   NOENV(""RUBYOPT"");
+# ifdef HAVE_ENVIRON
+   if (environ)
+     {
+        int again;
+        char *tmp, *p;
+
+        /* go over environment array again and again... safely */
+        do
+          {
+             again = 0;
+
+             /* walk through and find first entry that we don't like */
+             for (i = 0; environ[i]; i++)
+               {
+                  /* if it begins with any of these, it's possibly nasty */
+                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
+                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
+                      (!strncmp(environ[i], ""LC_"", 3)) ||
+                      (!strncmp(environ[i], ""LDR_"", 3)))
+                    {
+                       /* unset it */
+                       tmp = strdup(environ[i]);
+                       if (!tmp) abort();
+                       p = strchr(tmp, '=');
+                       if (!p) abort();
+                       *p = 0;
+                       NOENV(p);
+                       free(tmp);
+                       /* and mark our do to try again from the start in case
+                        * unsetenv changes environ ptr */
+                       again = 1;
+                       break;
+                    }
+               }
+          }
+        while (again);
+     }
+# endif
+#endif
+
+   /* pass 2 - clear entire environment so it doesn't exist at all. if you
+    * can't do this... you're possibly in trouble... but the worst is still
+    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
-     clearenv();
+   clearenv();
+#else
+# ifdef HAVE_ENVIRON
+   environ = NULL;
+# endif
 #endif
-   /* set path and ifs to minimal defaults */
+
+   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");",enlightment,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=666df815cd86a50343859bce36c5cf968c5f38b0,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=fc9e8865cfb17a556a8a7efd1983ba211c16e545,1,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
//flaw_line_below:
#else
//flaw_line_below:
# define NOENV(x)
//flaw_line_below:
#endif
//fix_flaw_line_below:
//   /* pass 1 - just nuke known dangerous env vars brutally if possible via
//fix_flaw_line_below:
//    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
//fix_flaw_line_below:
//   NOENV(""CDPATH"");
//fix_flaw_line_below:
//   NOENV(""LOCALDOMAIN"");
//fix_flaw_line_below:
//   NOENV(""RES_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""HOSTALIASES"");
//fix_flaw_line_below:
//   NOENV(""NLSPATH"");
//fix_flaw_line_below:
//   NOENV(""PATH_LOCALE"");
//fix_flaw_line_below:
//   NOENV(""COLORTERM"");
//fix_flaw_line_below:
//   NOENV(""LANG"");
//fix_flaw_line_below:
//   NOENV(""LANGUAGE"");
//fix_flaw_line_below:
//   NOENV(""LINGUAS"");
//fix_flaw_line_below:
//   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
//flaw_line_below:
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
//fix_flaw_line_below:
//   NOENV(""SHLIB_PATH"");
//fix_flaw_line_below:
//   NOENV(""LIBPATH"");
//fix_flaw_line_below:
//   NOENV(""AUTHSTATE"");
//fix_flaw_line_below:
//   NOENV(""DYLD_*"");
//fix_flaw_line_below:
//   NOENV(""KRB_CONF*"");
//fix_flaw_line_below:
//   NOENV(""KRBCONFDIR"");
//fix_flaw_line_below:
//   NOENV(""KRBTKFILE"");
//fix_flaw_line_below:
//   NOENV(""KRB5_CONFIG*"");
//fix_flaw_line_below:
//   NOENV(""KRB5_KTNAME"");
//fix_flaw_line_below:
//   NOENV(""VAR_ACE"");
//fix_flaw_line_below:
//   NOENV(""USR_ACE"");
//fix_flaw_line_below:
//   NOENV(""DLC_ACE"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO_DIRS"");
//fix_flaw_line_below:
//   NOENV(""TERMPATH"");
//fix_flaw_line_below:
//   NOENV(""TERMCAP"");
//fix_flaw_line_below:
//   NOENV(""ENV"");
//fix_flaw_line_below:
//   NOENV(""BASH_ENV"");
//fix_flaw_line_below:
//   NOENV(""PS4"");
//fix_flaw_line_below:
//   NOENV(""GLOBIGNORE"");
//fix_flaw_line_below:
//   NOENV(""SHELLOPTS"");
//fix_flaw_line_below:
//   NOENV(""JAVA_TOOL_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""PERLIO_DEBUG"");
//fix_flaw_line_below:
//   NOENV(""PERLLIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5LIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5OPT"");
//fix_flaw_line_below:
//   NOENV(""PERL5DB"");
//fix_flaw_line_below:
//   NOENV(""FPATH"");
//fix_flaw_line_below:
//   NOENV(""NULLCMD"");
//fix_flaw_line_below:
//   NOENV(""READNULLCMD"");
//fix_flaw_line_below:
//   NOENV(""ZDOTDIR"");
//fix_flaw_line_below:
//   NOENV(""TMPPREFIX"");
//fix_flaw_line_below:
//   NOENV(""PYTHONPATH"");
//fix_flaw_line_below:
//   NOENV(""PYTHONHOME"");
//fix_flaw_line_below:
//   NOENV(""PYTHONINSPECT"");
//fix_flaw_line_below:
//   NOENV(""RUBYLIB"");
//fix_flaw_line_below:
//   NOENV(""RUBYOPT"");
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   if (environ)
//fix_flaw_line_below:
//     {
//fix_flaw_line_below:
//        int again;
//fix_flaw_line_below:
//        char *tmp, *p;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* go over environment array again and again... safely */
//fix_flaw_line_below:
//        do
//fix_flaw_line_below:
//          {
//fix_flaw_line_below:
//             again = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//             /* walk through and find first entry that we don't like */
//fix_flaw_line_below:
//             for (i = 0; environ[i]; i++)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                  /* if it begins with any of these, it's possibly nasty */
//fix_flaw_line_below:
//                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LC_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LDR_"", 3)))
//fix_flaw_line_below:
//                    {
//fix_flaw_line_below:
//                       /* unset it */
//fix_flaw_line_below:
//                       tmp = strdup(environ[i]);
//fix_flaw_line_below:
//                       if (!tmp) abort();
//fix_flaw_line_below:
//                       p = strchr(tmp, '=');
//fix_flaw_line_below:
//                       if (!p) abort();
//fix_flaw_line_below:
//                       *p = 0;
//fix_flaw_line_below:
//                       NOENV(p);
//fix_flaw_line_below:
//                       free(tmp);
//fix_flaw_line_below:
//                       /* and mark our do to try again from the start in case
//fix_flaw_line_below:
//                        * unsetenv changes environ ptr */
//fix_flaw_line_below:
//                       again = 1;
//fix_flaw_line_below:
//                       break;
//fix_flaw_line_below:
//                    }
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//          }
//fix_flaw_line_below:
//        while (again);
//fix_flaw_line_below:
//     }
//fix_flaw_line_below:
//# endif
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 2 - clear entire environment so it doesn't exist at all. if you
//fix_flaw_line_below:
//    * can't do this... you're possibly in trouble... but the worst is still
//fix_flaw_line_below:
//    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
//flaw_line_below:
     clearenv();
//fix_flaw_line_below:
//   clearenv();
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   environ = NULL;
//fix_flaw_line_below:
//# endif
 #endif
//flaw_line_below:
   /* set path and ifs to minimal defaults */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",178685,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","The provided code is a C program designed to serve as an internal tool for the Enlightenment desktop environment, primarily handling user actions related to system operations. It begins by parsing command-line arguments to determine the requested action, such as testing or executing specific commands like ""l2ping."" The program checks for help flags and validates the action against predefined criteria, ensuring proper permissions by attempting to assume root privileges. It sanitizes the environment variables for security, sets minimal defaults, and processes options related to mounting behavior. Ultimately, it verifies the action's authorization and executes the corresponding command while managing potential errors.","The code functions as an internal tool for a desktop environment, designed to handle various system operations based on user input. It begins by parsing command-line arguments to identify the requested action, providing help information if needed. The program ensures that the user has the necessary permissions by attempting to gain elevated privileges and validating the action against predefined security criteria. It sanitizes the environment to enhance security, sets minimal defaults, and processes specific options related to system behavior. Ultimately, it executes the requested action while managing potential errors and ensuring proper authorization.","The vulnerability in the original code stemmed from insufficient sanitization of environment variables, which could allow an attacker to manipulate the execution environment by injecting malicious variables, such as `LD_PRELOAD`, potentially leading to privilege escalation or arbitrary code execution. The fixed code addresses this issue by implementing a comprehensive sanitization process that unsets a wide range of dangerous environment variables, including `LD_PRELOAD` and `LD_LIBRARY_PATH`, and even clears the entire environment if possible. This ensures that only a controlled and minimal set of variables is present, significantly reducing the risk of exploitation.","The vulnerability in the original code arose from inadequate sanitization of the execution environment, allowing an attacker to manipulate environment variables to execute arbitrary code or escalate privileges. This lack of control over potentially harmful variables could lead to severe security risks. The fixed code addresses this issue by implementing a thorough sanitization process that unsets a wide array of dangerous environment variables and, if possible, clears the entire environment. This ensures that only a minimal and controlled set of variables remains, significantly mitigating the risk of exploitation and enhancing overall security.","The vulnerability was fixed by implementing a comprehensive sanitization process for environment variables. The code now uses the `unsetenv` function to remove potentially dangerous variables, such as `LD_PRELOAD`, `LD_LIBRARY_PATH`, and various locale-related variables, which could be exploited for malicious purposes. Additionally, the code includes a loop that checks the environment for any variables starting with specific prefixes and unsets them accordingly. Furthermore, the use of `clearenv()` ensures that the entire environment can be cleared if supported, leaving only a minimal set of safe variables, thereby significantly reducing the risk of exploitation.","The vulnerability was fixed by implementing a thorough sanitization process for the execution environment to prevent potential exploitation. The updated code removes a wide range of potentially harmful environment variables that could be manipulated by an attacker, thereby reducing the risk of arbitrary code execution or privilege escalation. Additionally, the code includes a mechanism to clear the entire environment if possible, ensuring that only a minimal and controlled set of safe variables remains. This comprehensive approach significantly enhances security by limiting the attack surface and ensuring a safer execution context for the application.","CWE-78, CWE-88, CWE-269, CWE-426, CWE-114, CWE-74, CWE-427, CWE-470, CWE-214, CWE-265",N,-1
11,11,178695,178695,,Remote,Not required,Partial,CVE-2010-0011,https://www.cvedetails.com/cve/CVE-2010-0011/,CWE-264,Low,Partial,Partial,,2010-02-25,7.5,"The eval_js function in uzbl-core.c in Uzbl before 2010.01.05 exposes the run method of the Uzbl object, which allows remote attackers to execute arbitrary commands via JavaScript code.",2017-08-16,Exec Code ,0,https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047,1958b52d41cba96956dc1995660de49525ed1047,disable Uzbl javascript object because of security problem.,8,uzbl-core.c,"{""sha"": ""a22e105934e4dbd5360e68f28cdbb7474022d4e5"", ""filename"": ""README"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 20, ""changes"": 21, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/README"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/README"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/README?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -397,7 +397,7 @@ The script specific arguments are this:\n \n Custom, userdefined scripts (`spawn foo bar`) get first the arguments as specified in the config and then the above 7 are added at the end.\n \n-### JAVASCRIPT HELPER OBJECT\n+### JAVASCRIPT HELPER OBJECT DISABLED BECAUSE OF SECURITY LEAK\n \n Javascript code run from uzbl is given a special object in the global namespace which gives special privileges to these scripts. This object is called `Uzbl`, and it is added and removed before and after the script execution so that it is hidden to web javascripts (There is no race condition, since all the javascript code runs in a single thread)\n \n@@ -410,25 +410,6 @@ Currently, the `Uzbl` object provides only one function:\n        * `Uzbl.run(\""spawn insert_bookmark.sh\"")`\n        * `uri = Uzbl.run(\""print @uri\"")` (see variable expansion below)\n \n-### JAVASCRIPT SECURITY\n-\n-Since defined variables and functions are set in the global namespace (`window` object) as default, it is recommended to wrap your scripts like this:\n-\n-    (function(Uzbl) {\n-        ...\n-    })(Uzbl);\n-\n-This way, everything is kept private. It also turns Uzbl into a local variable, which can be accessed from callback functions defined inside. However for some situations, isolating everything isn't an option, for example, with binds. You can define them directly in the script body, and use `var Uzbl = window.Uzbl;` to make the Uzbl variable local, as in the following example:\n-\n-    function f() {\n-        var Uzbl = window.Uzbl;\n-        Uzbl.run(...);\n-        setTimeout(function() {\n-            Uzbl.run(...);\n-        }, 500);\n-    }\n-\n-Copying the Uzbl object and creating public functions should be taken with care to avoid creating security holes. Keep in mind that the \""f\"" function above would be defined in the `window` object, and as such any javascript in the current page can call it.\n \n ### EVENTS ###\n ""}<_**next**_>{""sha"": ""fc3b092ea0dd6a2593c92178eb07049a95160a60"", ""filename"": ""tests/test-command.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/tests/test-command.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -305,11 +305,6 @@ test_js (void) {\n     parse_cmd_line(\""js ('x' + 345).toUpperCase()\"", result);\n     g_assert_cmpstr(\""X345\"", ==, result->str);\n \n-    /* uzbl commands can be run from javascript */\n-    uzbl.net.useragent = \""Test useragent\"";\n-    parse_cmd_line(\""js Uzbl.run('print @useragent').toUpperCase();\"", result);\n-    g_assert_cmpstr(\""TEST USERAGENT\"", ==, result->str);\n-\n     g_string_free(result, TRUE);\n }\n ""}<_**next**_>{""sha"": ""fca293c1f5e8ff116ae4de3e1d3f2ecc51f593f6"", ""filename"": ""uzbl-core.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 10, ""changes"": 10, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/uzbl-core.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n-    JSStringRef var_name;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n-    /* uzbl javascript namespace */\n-    var_name = JSStringCreateWithUTF8CString(\""Uzbl\"");\n-    JSObjectSetProperty(context, globalobject, var_name,\n-                        JSObjectMake(context, uzbl.js.classref, NULL),\n-                        kJSClassAttributeNone, NULL);\n-\n     /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     }\n \n     /* cleanup */\n-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n-\n-    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }\n ""}","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",C,,"    JSStringRef var_name;
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
",,"@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
-    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
-    /* uzbl javascript namespace */
-    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
-    JSObjectSetProperty(context, globalobject, var_name,
-                        JSObjectMake(context, uzbl.js.classref, NULL),
-                        kJSClassAttributeNone, NULL);
-
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     }
 
     /* cleanup */
-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
-
-    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
 ",uzbl,1958b52d41cba96956dc1995660de49525ed1047,49941155e43eb520c43b02b55e0bbced2b657cf6,1,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
//flaw_line_below:
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
//flaw_line_below:
    /* uzbl javascript namespace */
//flaw_line_below:
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
//flaw_line_below:
    JSObjectSetProperty(context, globalobject, var_name,
//flaw_line_below:
                        JSObjectMake(context, uzbl.js.classref, NULL),
//flaw_line_below:
                        kJSClassAttributeNone, NULL);
//flaw_line_below:

     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
//flaw_line_below:
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
//flaw_line_below:

//flaw_line_below:
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",178695,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","The provided code defines a function `eval_js` that evaluates a JavaScript script within a specified `WebKitWebView`. It initializes the JavaScript environment, retrieves the main frame and its global context, and sets up a custom JavaScript namespace called ""Uzbl"". The function then evaluates the provided script, capturing the result if it is defined. If a valid result is obtained, it converts the JavaScript value to a UTF-8 string and assigns it to the `result` parameter. Finally, the function cleans up by deleting the custom property and releasing allocated resources, ensuring efficient memory management.","The code defines a function that evaluates a JavaScript script within a web view environment. It initializes the JavaScript context and sets up a custom namespace for additional functionality. The function then executes the provided script and checks if a valid result is returned. If so, it converts this result into a UTF-8 string format and stores it in a specified output variable. Finally, the function performs cleanup by removing the custom namespace and releasing any allocated resources, ensuring efficient memory management and preventing memory leaks during execution.","The vulnerability in the original code arises from the use of a custom JavaScript namespace, which could potentially allow for the execution of arbitrary scripts or manipulation of global objects, leading to security risks such as code injection. Specifically, the line that sets the custom property using `JSObjectSetProperty` could expose the application to malicious scripts. In the fixed code, this vulnerability is addressed by removing the custom namespace setup, thus eliminating the risk of unintended interactions with global objects. The cleanup process is also simplified, focusing on releasing only the script resources, enhancing overall security.","The vulnerability in the original code stems from the introduction of a custom JavaScript namespace, which could allow malicious scripts to manipulate global objects or execute unintended code, posing significant security risks. This exposure could lead to code injection attacks, where an attacker could exploit the namespace to run arbitrary scripts. The fixed code addresses this vulnerability by removing the setup of the custom namespace, thereby preventing any potential interference with global objects. Additionally, the cleanup process is streamlined to focus solely on releasing necessary resources, enhancing the overall security and integrity of the execution environment.","The vulnerability was fixed by removing the lines that set up a custom JavaScript namespace using `JSObjectSetProperty`, which previously allowed for potential manipulation of global objects. By eliminating the creation of the variable `var_name` and the associated property in the global object, the risk of code injection and unintended script execution was significantly reduced. Additionally, the cleanup process was simplified by retaining only the necessary resource releases, specifically `JSStringRelease(js_script)`, ensuring that no extraneous properties remained that could be exploited, thus enhancing the security of the execution environment.","The vulnerability was fixed by eliminating the setup of a custom JavaScript namespace, which previously posed a risk of allowing malicious scripts to manipulate global objects and execute arbitrary code. By removing the lines that created and assigned this namespace, the code now prevents potential code injection attacks and unintended interactions with the execution environment. Additionally, the cleanup process was streamlined to focus solely on releasing essential resources, ensuring that no unnecessary properties remained that could be exploited, thereby enhancing the overall security and integrity of the script evaluation process.","CWE-94, CWE-913, CWE-1321, CWE-489, CWE-470, CWE-471, CWE-668, CWE-565, CWE-693, CWE-502",N,-1
12,12,178773,178773,,Local,Not required,Partial,CVE-2012-2313,https://www.cvedetails.com/cve/CVE-2012-2313/,CWE-264,High,,,,2012-06-13,1.2,"The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call.",2016-09-06,,9,https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,"dl2k: Clean up rio_ioctl

The dl2k driver's rio_ioctl call has a few issues:
- No permissions checking
- Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers
- Has a few ioctls that may have been used for debugging at one point
  but have no place in the kernel proper.

This patch removes all but the MII ioctls, renumbers them to use the
standard ones, and adds the proper permission check for SIOCSMIIREG.

We can also get rid of the dl2k-specific struct mii_data in favor of
the generic struct mii_ioctl_data.

Since we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.

Most of the MII code for the driver could probably be converted to use
the generic MII library but I don't have a device to test the results.

Reported-by: Stephan Mueller <stephan.mueller@atsec.com>
Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",40,drivers/net/ethernet/dlink/dl2k.c,"{""sha"": ""2e09edb9cdf84b3d1cc49d7dad5167a2ce3be75a"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 43, ""changes"": 52, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.c?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n-\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n-\n-\tstruct netdev_desc *desc;\n-\tint i;\n+\tstruct mii_ioctl_data *miidata = if_mii(rq);\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n-\tcase SIOCDEVPRIVATE:\n-\t\tbreak;\n-\n-\tcase SIOCDEVPRIVATE + 1:\n-\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n+\tcase SIOCGMIIPHY:\n+\t\tmiidata->phy_id = phy_addr;\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 2:\n-\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n+\tcase SIOCGMIIREG:\n+\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 3:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 4:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 5:\n-\t\tnetif_stop_queue (dev);\n+\tcase SIOCSMIIREG:\n+\t\tif (!capable(CAP_NET_ADMIN))\n+\t\t\treturn -EPERM;\n+\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 6:\n-\t\tnetif_wake_queue (dev);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 7:\n-\t\tprintk\n-\t\t    (\""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\"",\n-\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n-\t\t     np->old_rx);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 8:\n-\t\tprintk(\""TX ring:\\n\"");\n-\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n-\t\t\tdesc = &np->tx_ring[i];\n-\t\t\tprintk\n-\t\t\t    (\""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\"",\n-\t\t\t     i,\n-\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n-\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n-\t\t\t     (u32)le64_to_cpu(desc->status),\n-\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n-\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n-\t\t\tprintk (\""\\n\"");\n-\t\t}\n-\t\tprintk (\""\\n\"");\n-\t\tbreak;\n-\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}""}<_**next**_>{""sha"": ""30c2da3de548f92ce0ebe794dc9c894af284c010"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.h?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -365,13 +365,6 @@ struct ioctl_data {\n \tchar *data;\n };\n \n-struct mii_data {\n-\t__u16 reserved;\n-\t__u16 reg_num;\n-\t__u16 in_value;\n-\t__u16 out_value;\n-};\n-\n /* The Rx and Tx buffer descriptors. */\n struct netdev_desc {\n \t__le64 next_desc;""}","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",C,"	struct mii_ioctl_data *miidata = if_mii(rq);
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
","	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
",,"@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
-	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
-
-	struct netdev_desc *desc;
-	int i;
+	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
-	case SIOCDEVPRIVATE:
-		break;
-
-	case SIOCDEVPRIVATE + 1:
-		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
+	case SIOCGMIIPHY:
+		miidata->phy_id = phy_addr;
 		break;
-	case SIOCDEVPRIVATE + 2:
-		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
+	case SIOCGMIIREG:
+		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
-	case SIOCDEVPRIVATE + 3:
-		break;
-	case SIOCDEVPRIVATE + 4:
-		break;
-	case SIOCDEVPRIVATE + 5:
-		netif_stop_queue (dev);
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
-	case SIOCDEVPRIVATE + 6:
-		netif_wake_queue (dev);
-		break;
-	case SIOCDEVPRIVATE + 7:
-		printk
-		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
-		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
-		     np->old_rx);
-		break;
-	case SIOCDEVPRIVATE + 8:
-		printk(""TX ring:\n"");
-		for (i = 0; i < TX_RING_SIZE; i++) {
-			desc = &np->tx_ring[i];
-			printk
-			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
-			     i,
-			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
-			     (u32)le64_to_cpu(desc->next_desc),
-			     (u32)le64_to_cpu(desc->status),
-			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
-			     (u32)le64_to_cpu(desc->fraginfo));
-			printk (""\n"");
-		}
-		printk (""\n"");
-		break;
-
 	default:
 		return -EOPNOTSUPP;
 	}",linux,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,768f7c7c121e80f458a9d013b2e8b169e5dfb1e5,1,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
//flaw_line_below:
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
//flaw_line_below:

//flaw_line_below:
	struct netdev_desc *desc;
//flaw_line_below:
	int i;
//fix_flaw_line_below:
//	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
//flaw_line_below:
	case SIOCDEVPRIVATE:
//flaw_line_below:
		break;
//flaw_line_below:

//flaw_line_below:
	case SIOCDEVPRIVATE + 1:
//flaw_line_below:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
//fix_flaw_line_below:
//	case SIOCGMIIPHY:
//fix_flaw_line_below:
//		miidata->phy_id = phy_addr;
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 2:
//flaw_line_below:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
//fix_flaw_line_below:
//	case SIOCGMIIREG:
//fix_flaw_line_below:
//		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 3:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 4:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 5:
//flaw_line_below:
		netif_stop_queue (dev);
//fix_flaw_line_below:
//	case SIOCSMIIREG:
//fix_flaw_line_below:
//		if (!capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//			return -EPERM;
//fix_flaw_line_below:
//		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 6:
//flaw_line_below:
		netif_wake_queue (dev);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 7:
//flaw_line_below:
		printk
//flaw_line_below:
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
//flaw_line_below:
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
//flaw_line_below:
		     np->old_rx);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 8:
//flaw_line_below:
		printk(""TX ring:\n"");
//flaw_line_below:
		for (i = 0; i < TX_RING_SIZE; i++) {
//flaw_line_below:
			desc = &np->tx_ring[i];
//flaw_line_below:
			printk
//flaw_line_below:
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
//flaw_line_below:
			     i,
//flaw_line_below:
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->next_desc),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->status),
//flaw_line_below:
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->fraginfo));
//flaw_line_below:
			printk (""\n"");
//flaw_line_below:
		}
//flaw_line_below:
		printk (""\n"");
//flaw_line_below:
		break;
//flaw_line_below:

 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",178773,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","The provided code defines a function `rio_ioctl` that handles various input/output control commands for a network device in a Linux kernel module. It utilizes a switch-case structure to process commands identified by `cmd`, allowing operations such as reading and writing to the MII (Media Independent Interface) registers, stopping and waking the network transmission queue, and printing the status of the transmission ring. The function retrieves the physical address of the device and accesses private data structures to perform these operations, returning 0 for successful execution or an error code for unsupported commands.","The code defines a function that manages various control commands for a network device within a kernel module. It processes different commands to perform tasks such as reading from and writing to hardware registers, controlling the transmission queue, and logging the status of the transmission buffer. The function retrieves necessary device information and executes the appropriate actions based on the command received. It ensures that operations are performed correctly and returns a success status or an error code if the command is not supported, facilitating communication between user space and the network device driver.","The vulnerability in the original code arises from the lack of permission checks before executing sensitive operations, particularly when writing to hardware registers. In the fixed code, a permission check using `capable(CAP_NET_ADMIN)` is introduced before the `mii_write` function is called. This ensures that only users with the appropriate administrative capabilities can modify the hardware settings, thereby preventing unauthorized access and potential exploitation. The changes enhance security by restricting critical operations to privileged users, mitigating risks associated with unauthorized manipulation of network device configurations.","The vulnerability in the original code stems from the absence of permission checks before allowing write operations to hardware registers, which could be exploited by unauthorized users to manipulate network device settings. The fixed code addresses this issue by implementing a permission verification step that ensures only users with the necessary administrative rights can perform sensitive write operations. This enhancement significantly improves security by preventing unauthorized access and potential exploitation, thereby safeguarding the integrity of the network device's configuration and operations from malicious actions.","The vulnerability was fixed by introducing a permission check before executing the `mii_write` function in the modified code. Specifically, the check uses `capable(CAP_NET_ADMIN)` to verify that the user has the necessary administrative privileges to perform write operations on the hardware registers. If the user lacks these permissions, the function returns an error code, preventing unauthorized access. This change ensures that only users with the appropriate capabilities can modify critical device settings, thereby enhancing the security of the network device and mitigating the risk of exploitation from unauthorized users.","The vulnerability was fixed by implementing a permission check that restricts access to sensitive write operations. This check ensures that only users with the appropriate administrative rights can perform modifications to the hardware settings. If a user attempts to execute a write operation without the necessary permissions, the function will return an error, effectively blocking unauthorized access. This enhancement significantly improves the security of the system by preventing potential exploitation and ensuring that only authorized personnel can alter critical configurations, thereby protecting the integrity of the network device.","CWE-284, CWE-269, CWE-732, CWE-264, CWE-285, CWE-266, CWE-862, CWE-287, CWE-434, CWE-425",N,-1
13,13,178788,178788,,Local,Not required,Complete,CVE-2012-2123,https://www.cvedetails.com/cve/CVE-2012-2123/,CWE-264,Low,Complete,Complete,,2012-05-17,7.2,"The cap_bprm_set_creds function in security/commoncap.c in the Linux kernel before 3.3.3 does not properly handle the use of file system capabilities (aka fcaps) for implementing a privileged executable file, which allows local users to bypass intended personality restrictions via a crafted application, as demonstrated by an attack that uses a parent process to disable ASLR.",2017-12-28,Bypass ,5,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,d52fc5dde171f030170a6cb78034d166b13c9445,"fcaps: clear the same personality flags as suid when fcaps are used

If a process increases permissions using fcaps all of the dangerous
personality flags which are cleared for suid apps should also be cleared.
Thus programs given priviledge with fcaps will continue to have address space
randomization enabled even if the parent tried to disable it to make it
easier to attack.

Signed-off-by: Eric Paris <eparis@redhat.com>
Reviewed-by: Serge Hallyn <serge.hallyn@canonical.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/commoncap.c,"{""sha"": ""0ecf4ba321cbeaa812dadc6524e138bc40b866b3"", ""filename"": ""security/commoncap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/commoncap.c?ref=d52fc5dde171f030170a6cb78034d166b13c9445"", ""patch"": ""@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)\n \t}\n skip:\n \n+\t/* if we have fs caps, clear dangerous personality flags */\n+\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\n+\n \t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n \t * credentials unless they have the appropriate permit\n \t */""}","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",C,"	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


",,,"@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)
 	}
 skip:
 
+	/* if we have fs caps, clear dangerous personality flags */
+	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
+		bprm->per_clear |= PER_CLEAR_ON_SETID;
+
+
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */",linux,d52fc5dde171f030170a6cb78034d166b13c9445,09c79b60960bdd4b00916219402eabfa5e479c5a,1,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
//fix_flaw_line_below:
//	/* if we have fs caps, clear dangerous personality flags */
//fix_flaw_line_below:
//	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
//fix_flaw_line_below:
//		bprm->per_clear |= PER_CLEAR_ON_SETID;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",178788,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","The `cap_bprm_set_creds` function is responsible for setting the credentials and capabilities of a binary being executed in a Linux environment. It first retrieves the current process's credentials and checks the file capabilities associated with the binary. If the binary is a setuid root executable, it ensures that non-root users do not gain elevated privileges unless explicitly allowed. The function also manages the effective, permitted, and inheritable capabilities based on the user's identity and the binary's attributes, while enforcing security policies to prevent unauthorized privilege escalation. Additionally, it logs auditing information if certain conditions regarding capabilities are met.","The code defines a function that manages the credentials and capabilities of a binary during execution in a Linux system. It checks the current user's permissions and the binary's attributes to determine if elevated privileges should be granted. The function prevents non-root users from gaining root privileges through specific binaries while allowing root users to retain their capabilities. It also ensures that the effective capabilities are set appropriately based on the user's identity and the binary's characteristics. Additionally, the function logs relevant auditing information if certain security conditions are met, enhancing system security.","The vulnerability in the original code arises from inadequate checks on the effective user ID and capabilities of a binary being executed, which could allow non-root users to gain elevated privileges through setuid root binaries. Specifically, the lack of a proper validation mechanism for the `has_cap` variable could lead to a situation where a non-root user could execute a binary with root capabilities, potentially compromising system security. The fixed code introduces a check that ensures if the effective user ID is not root, the system warns about mixed capabilities and prevents privilege escalation, thereby enhancing security against unauthorized access.","The vulnerability in the original code stems from insufficient validation of user privileges when executing setuid root binaries, which could allow non-root users to inadvertently gain elevated privileges. This oversight could lead to unauthorized access and potential exploitation of system resources. The fixed code addresses this issue by implementing stricter checks that prevent non-root users from executing binaries with root capabilities unless explicitly permitted. Additionally, it introduces warnings for mixed capabilities, thereby reinforcing security measures and ensuring that privilege escalation is properly controlled, thus mitigating the risk of unauthorized privilege gain.","The vulnerability was fixed by adding checks that prevent non-root users from executing setuid root binaries with elevated capabilities. Specifically, the code now verifies the `has_cap` variable to determine if legacy file capabilities are set and issues a warning if a non-root user attempts to run a binary with root effective user ID. Additionally, the code ensures that if the effective user ID is not root, the system downgrades the effective and permitted capabilities by intersecting them with the current user's capabilities. This approach effectively restricts unauthorized privilege escalation and enhances overall system security.","The vulnerability was addressed by implementing stricter validation checks to prevent non-root users from executing binaries that could grant them elevated privileges. The updated code introduces warnings when a non-root user attempts to run a setuid root binary with mixed capabilities, thereby alerting administrators to potential security risks. Additionally, it ensures that the effective capabilities of non-root users are appropriately downgraded, limiting their access to only what they are permitted. This combination of checks and warnings significantly enhances the security posture of the system by mitigating the risk of unauthorized privilege escalation.","CWE-269, CWE-250, CWE-264, CWE-284, CWE-732, CWE-266, CWE-273, CWE-279, CWE-274, CWE-648",N,-1
14,14,178817,178817,,Local,Not required,Complete,CVE-2012-1090,https://www.cvedetails.com/cve/CVE-2012-1090/,CWE-264,Low,,,,2012-05-17,4.9,"The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO.",2018-01-17,DoS ,18,https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08,88d7d4e4a439f32acc56a6d860e415ee71d3df08,"cifs: fix dentry refcount leak when opening a FIFO on lookup

commit 5bccda0ebc7c0331b81ac47d39e4b920b198b2cd upstream.

The cifs code will attempt to open files on lookup under certain
circumstances. What happens though if we find that the file we opened
was actually a FIFO or other special file?

Currently, the open filehandle just ends up being leaked leading to
a dentry refcount mismatch and oops on umount. Fix this by having the
code close the filehandle on the server if it turns out not to be a
regular file. While we're at it, change this spaghetti if statement
into a switch too.

Reported-by: CAI Qian <caiqian@redhat.com>
Tested-by: CAI Qian <caiqian@redhat.com>
Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Steve French <smfrench@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",2,fs/cifs/dir.c,"{""sha"": ""bf68b4fc9512f0ad226f9503dffbc50d8818138c"", ""filename"": ""fs/cifs/dir.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 2, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/dir.c?ref=88d7d4e4a439f32acc56a6d860e415ee71d3df08"", ""patch"": ""@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n \t\t\t * If either that or op not supported returned, follow\n \t\t\t * the normal lookup.\n \t\t\t */\n-\t\t\tif ((rc == 0) || (rc == -ENOENT))\n+\t\t\tswitch (rc) {\n+\t\t\tcase 0:\n+\t\t\t\t/*\n+\t\t\t\t * The server may allow us to open things like\n+\t\t\t\t * FIFOs, but the client isn't set up to deal\n+\t\t\t\t * with that. If it's not a regular file, just\n+\t\t\t\t * close it and proceed as if it were a normal\n+\t\t\t\t * lookup.\n+\t\t\t\t */\n+\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n+\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\tcase -ENOENT:\n \t\t\t\tposix_open = true;\n-\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n+\t\t\tcase -EOPNOTSUPP:\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n \t\t\t\tpTcon->broken_posix_open = true;\n+\t\t\t}\n \t\t}\n \t\tif (!posix_open)\n \t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,""}","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",C,"			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
			case -EOPNOTSUPP:
				break;
			default:
			}
","			if ((rc == 0) || (rc == -ENOENT))
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
",,"@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
-			if ((rc == 0) || (rc == -ENOENT))
+			switch (rc) {
+			case 0:
+				/*
+				 * The server may allow us to open things like
+				 * FIFOs, but the client isn't set up to deal
+				 * with that. If it's not a regular file, just
+				 * close it and proceed as if it were a normal
+				 * lookup.
+				 */
+				if (newInode && !S_ISREG(newInode->i_mode)) {
+					CIFSSMBClose(xid, pTcon, fileHandle);
+					break;
+				}
+			case -ENOENT:
 				posix_open = true;
-			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
+			case -EOPNOTSUPP:
+				break;
+			default:
 				pTcon->broken_posix_open = true;
+			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,",linux,88d7d4e4a439f32acc56a6d860e415ee71d3df08,ce6e3def616ad1e22443df7fc8bdaa3384cf0575,1,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
//flaw_line_below:
			if ((rc == 0) || (rc == -ENOENT))
//fix_flaw_line_below:
//			switch (rc) {
//fix_flaw_line_below:
//			case 0:
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * The server may allow us to open things like
//fix_flaw_line_below:
//				 * FIFOs, but the client isn't set up to deal
//fix_flaw_line_below:
//				 * with that. If it's not a regular file, just
//fix_flaw_line_below:
//				 * close it and proceed as if it were a normal
//fix_flaw_line_below:
//				 * lookup.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				if (newInode && !S_ISREG(newInode->i_mode)) {
//fix_flaw_line_below:
//					CIFSSMBClose(xid, pTcon, fileHandle);
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//			case -ENOENT:
 				posix_open = true;
//flaw_line_below:
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
//fix_flaw_line_below:
//			case -EOPNOTSUPP:
//fix_flaw_line_below:
//				break;
//fix_flaw_line_below:
//			default:
 				pTcon->broken_posix_open = true;
//fix_flaw_line_below:
//			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",178817,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","The provided code implements a CIFS (Common Internet File System) lookup function that searches for a directory entry within a specified parent directory inode. It begins by initializing necessary variables and checking the validity of the parent directory's connection. The function validates the requested path, ensuring it adheres to naming conventions, and handles exclusive lookups. It constructs the full path from the directory entry, then attempts to retrieve inode information, potentially using POSIX open semantics for file creation. If successful, it adds the directory entry to the cache; otherwise, it manages errors and cleans up resources before returning the result.","The code defines a function that performs a lookup operation in a file system, specifically targeting a directory entry within a parent directory. It initializes necessary parameters and checks the validity of the connection to the parent directory. The function validates the requested path for compliance with naming rules and handles exclusive lookup scenarios. It constructs the full path and attempts to retrieve information about the target entry, potentially using specific opening semantics for file creation. Upon success, it updates the directory entry cache; otherwise, it manages errors and cleans up resources before returning the outcome.","The vulnerability in the original code arises from inadequate handling of the return values from the function that attempts to open a file using POSIX semantics. Specifically, if the file is not a regular file, the code did not properly close the file handle, potentially leading to resource leaks. The fixed code addresses this by introducing a check for the file type after a successful open attempt. If the opened file is not a regular file, it explicitly closes the file handle before proceeding, thus preventing resource leaks and ensuring proper resource management in the file system operations.","The vulnerability in the original code stemmed from insufficient handling of file types after an attempt to open a file, which could lead to resource leaks if the opened file was not a regular file. This oversight meant that the system might retain unnecessary file handles, consuming resources without proper management. The fixed code rectifies this by implementing a check to determine the file type after the open attempt. If the file is found to be non-regular, it ensures that the file handle is closed appropriately, thereby preventing resource leaks and enhancing overall resource management within the file system operations.","The vulnerability was fixed by adding a conditional check after the call to the function that attempts to open a file using POSIX semantics. In the updated code, after the open attempt, it checks if the newly created inode is not a regular file using the `S_ISREG` macro. If this condition is met, the code calls `CIFSSMBClose` to close the file handle, ensuring that resources are released properly. This change prevents resource leaks by ensuring that non-regular files do not retain open handles, thereby improving resource management within the file system operations.","The vulnerability was addressed by implementing a check after the file opening attempt to determine if the opened file was of an unexpected type. If the file was not a regular file, the code now ensures that the associated file handle is closed properly. This adjustment prevents resource leaks by ensuring that unnecessary file handles do not remain open, which could consume system resources. By incorporating this additional validation step, the code enhances resource management and stability within the file system operations, thereby mitigating the risk associated with the original oversight.","CWE-404, CWE-775, CWE-772, CWE-773, CWE-771, CWE-403, CWE-401, CWE-459, CWE-686, CWE-402",N,-1
15,15,179032,179032,,Local,Not required,,CVE-2011-2495,https://www.cvedetails.com/cve/CVE-2011-2495/,CWE-264,Low,Partial,,,2012-06-13,2.1,"fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password.",2013-12-30,,3,https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51,1d1221f375c94ef961ba8574ac4f85c8870ddd51,"proc: restrict access to /proc/PID/io

/proc/PID/io may be used for gathering private information.  E.g.  for
openssh and vsftpd daemons wchars/rchars may be used to learn the
precise password length.  Restrict it to processes being able to ptrace
the target process.

ptrace_may_access() is needed to prevent keeping open file descriptor of
""io"" file, executing setuid binary and gathering io information of the
setuid'ed process.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/proc/base.c,"{""sha"": ""fc5bc27676926cccbc27f3349886e02bbc047211"", ""filename"": ""fs/proc/base.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/base.c?ref=1d1221f375c94ef961ba8574ac4f85c8870ddd51"", ""patch"": ""@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n+\t\treturn -EACCES;\n+\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n \n@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {\n \tREG(\""coredump_filter\"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tgid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tgid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),\n@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {\n \tREG(\""make-it-fail\"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),""}","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",C,"	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

",,,"@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
+	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		return -EACCES;
+
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG(""coredump_filter"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tgid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tgid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),
@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {
 	REG(""make-it-fail"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),",linux,1d1221f375c94ef961ba8574ac4f85c8870ddd51,b0af8dfdd67699e25083478c63eedef2e72ebd85,1,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!ptrace_may_access(task, PTRACE_MODE_READ))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",179032,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","The provided code defines a function `do_io_accounting` that retrieves and formats input/output accounting statistics for a specified task in a Linux kernel environment. It first checks if the `whole` parameter is true and locks the task's signal handler to ensure thread safety. The function then aggregates I/O accounting data from the task and its threads, updating a local `acct` structure. Finally, it writes the accumulated statistics, including characters read and written, system calls made, and bytes read and written, into a provided buffer in a formatted string, returning the number of bytes written.","The code defines a function that collects and formats input/output accounting statistics for a specified task within a kernel environment. It first checks a condition to ensure safe access to the task's data and locks the necessary resources. The function then aggregates I/O data from the main task and its associated threads, updating a local accounting structure. Finally, it formats the accumulated statistics, including counts of characters read and written, system calls made, and bytes processed, into a specified buffer, returning the total number of bytes written to that buffer.","The vulnerability in the original code stemmed from the lack of access control, allowing any process to read the I/O accounting data of another task without proper permissions. This could lead to unauthorized access to sensitive information. The fix introduced a check using `ptrace_may_access(task, PTRACE_MODE_READ)` to ensure that only processes with the appropriate permissions can access the task's data. By validating access rights before proceeding with the I/O accounting operations, the updated code mitigates the risk of information leakage and enhances the overall security of the system.","The vulnerability in the original code arose from the absence of access controls, allowing any process to read sensitive I/O accounting data from another task without proper authorization. This lack of restriction could lead to unauthorized information exposure, compromising system security. The fix implemented a check to ensure that only processes with the necessary permissions could access the data of the specified task. By enforcing this access control before performing any operations, the updated code effectively mitigates the risk of unauthorized access, thereby enhancing the security and integrity of the system.","The vulnerability was fixed by introducing an access control check using the function `ptrace_may_access(task, PTRACE_MODE_READ)` before proceeding with any I/O accounting operations. This check ensures that only processes with the appropriate permissions can access the I/O accounting data of the specified task. If the access is not permitted, the function returns an error code `-EACCES`, preventing unauthorized access. This modification effectively restricts data access to authorized processes, thereby enhancing the security of the system and protecting sensitive information from potential leaks or misuse.","The vulnerability was addressed by implementing an access control mechanism that verifies whether a process has the necessary permissions to read the data of another task. This check occurs before any operations are performed, ensuring that only authorized processes can access sensitive information. If a process lacks the required permissions, the function immediately returns an error, preventing any further actions that could lead to unauthorized data exposure. This enhancement effectively safeguards the system by restricting access to critical information, thereby mitigating the risk of potential security breaches.","CWE-269, CWE-732, CWE-284, CWE-285, CWE-264, CWE-266, CWE-732, CWE-668, CWE-723, CWE-286",N,-1
16,16,179046,179046,,Local,Not required,,CVE-2011-1833,https://www.cvedetails.com/cve/CVE-2011-1833/,CWE-264,Medium,Partial,Partial,,2012-10-03,3.3,Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.,2014-03-07,Bypass ,11,https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97,764355487ea220fdc2faf128d577d7f679b91f97,"Ecryptfs: Add mount option to check uid of device being mounted = expect uid

Close a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount
source (device) can be raced when the ownership test is done in userspace.
Provide Ecryptfs a means to force the uid check at mount time.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Cc: <stable@kernel.org>
Signed-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>",1,fs/ecryptfs/main.c,"{""sha"": ""b4a6befb12168d6b0aa0bb7411794e062ded8734"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 2, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=764355487ea220fdc2faf128d577d7f679b91f97"", ""patch"": ""@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n+       ecryptfs_opt_check_dev_ruid,\n        ecryptfs_opt_err };\n \n static const match_table_t tokens = {\n@@ -191,6 +192,7 @@ static const match_table_t tokens = {\n \t{ecryptfs_opt_fn_cipher_key_bytes, \""ecryptfs_fn_key_bytes=%u\""},\n \t{ecryptfs_opt_unlink_sigs, \""ecryptfs_unlink_sigs\""},\n \t{ecryptfs_opt_mount_auth_tok_only, \""ecryptfs_mount_auth_tok_only\""},\n+\t{ecryptfs_opt_check_dev_ruid, \""ecryptfs_check_dev_ruid\""},\n \t{ecryptfs_opt_err, NULL}\n };\n \n@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(\n  * ecryptfs_parse_options\n  * @sb: The ecryptfs super block\n  * @options: The options passed to the kernel\n+ * @check_ruid: set to 1 if device uid should be checked against the ruid\n  *\n  * Parse mount options:\n  * debug=N \t   - ecryptfs_verbosity level for debug output\n@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(\n  *\n  * Returns zero on success; non-zero on error\n  */\n-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n+\t\t\t\t  uid_t *check_ruid)\n {\n \tchar *p;\n \tint rc = 0;\n@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n+\t*check_ruid = 0;\n+\n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n+\t\tcase ecryptfs_opt_check_dev_ruid:\n+\t\t\t*check_ruid = 1;\n+\t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \tconst char *err = \""Getting sb failed\"";\n \tstruct inode *inode;\n \tstruct path path;\n+\tuid_t check_ruid;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\tgoto out;\n \t}\n \n-\trc = ecryptfs_parse_options(sbi, raw_data);\n+\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n \tif (rc) {\n \t\terr = \""Error parsing options\"";\n \t\tgoto out;\n@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\t\t\""known incompatibilities\\n\"");\n \t\tgoto out_free;\n \t}\n+\n+\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n+\t\trc = -EPERM;\n+\t\tprintk(KERN_ERR \""Mount of device (uid: %d) not owned by \""\n+\t\t       \""requested user (uid: %d)\\n\"",\n+\t\t       path.dentry->d_inode->i_uid, current_uid());\n+\t\tgoto out_free;\n+\t}\n+\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	uid_t check_ruid;
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

","	rc = ecryptfs_parse_options(sbi, raw_data);
",,"@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
+       ecryptfs_opt_check_dev_ruid,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
@@ -191,6 +192,7 @@ static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, ""ecryptfs_fn_key_bytes=%u""},
 	{ecryptfs_opt_unlink_sigs, ""ecryptfs_unlink_sigs""},
 	{ecryptfs_opt_mount_auth_tok_only, ""ecryptfs_mount_auth_tok_only""},
+	{ecryptfs_opt_check_dev_ruid, ""ecryptfs_check_dev_ruid""},
 	{ecryptfs_opt_err, NULL}
 };
 
@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
+ * @check_ruid: set to 1 if device uid should be checked against the ruid
  *
  * Parse mount options:
  * debug=N 	   - ecryptfs_verbosity level for debug output
@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(
  *
  * Returns zero on success; non-zero on error
  */
-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
+				  uid_t *check_ruid)
 {
 	char *p;
 	int rc = 0;
@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
+	*check_ruid = 0;
+
 	if (!options) {
 		rc = -EINVAL;
 		goto out;
@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 			mount_crypt_stat->flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
+		case ecryptfs_opt_check_dev_ruid:
+			*check_ruid = 1;
+			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
+	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out;
 	}
 
-	rc = ecryptfs_parse_options(sbi, raw_data);
+	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 			""known incompatibilities\n"");
 		goto out_free;
 	}
+
+	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
+		rc = -EPERM;
+		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
+		       ""requested user (uid: %d)\n"",
+		       path.dentry->d_inode->i_uid, current_uid());
+		goto out_free;
+	}
+
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;",linux,764355487ea220fdc2faf128d577d7f679b91f97,99b373ff2d1246f64b97a3d449a2fd6018d504e6,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
//fix_flaw_line_below:
//	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
//flaw_line_below:
	rc = ecryptfs_parse_options(sbi, raw_data);
//fix_flaw_line_below:
//	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
//fix_flaw_line_below:
//		rc = -EPERM;
//fix_flaw_line_below:
//		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
//fix_flaw_line_below:
//		       ""requested user (uid: %d)\n"",
//fix_flaw_line_below:
//		       path.dentry->d_inode->i_uid, current_uid());
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",179046,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The provided code implements the `ecryptfs_mount` function, which is responsible for mounting an eCryptfs filesystem in a Linux kernel environment. It begins by allocating memory for the superblock information and parsing options from the provided raw data. The function then attempts to create a superblock and register a block device interface. It checks for compatibility with existing filesystems, retrieves the inode for the root directory, and allocates memory for root directory information. If successful, it sets various superblock properties and returns a reference to the root dentry; otherwise, it handles errors and cleans up allocated resources.","The code defines a function that facilitates the mounting of a specific type of encrypted filesystem within a Linux kernel environment. It begins by allocating necessary memory for filesystem metadata and parsing configuration options. The function then attempts to create a superblock and register a block device interface while ensuring compatibility with existing filesystems. It retrieves the root directory's metadata and allocates additional memory for its information. Upon successful execution, it sets various properties of the superblock and returns a reference to the root directory; otherwise, it manages errors and cleans up any allocated resources.","The vulnerability in the original code stemmed from a lack of user permission checks when mounting a filesystem, potentially allowing unauthorized users to mount devices they did not own. This was addressed in the fixed code by introducing a check for the real user ID against the inode's user ID of the target device. Specifically, the addition of the `check_ruid` variable and the conditional statement that compares `path.dentry->d_inode->i_uid` with `current_uid()` ensures that only the owner of the device can mount it, thereby preventing unauthorized access and enhancing security.","The vulnerability in the original code allowed unauthorized users to mount filesystems, as it did not verify whether the user attempting the mount operation owned the target device. This oversight could lead to security breaches, where users could access or manipulate files they should not have permission to. The fixed code addresses this issue by implementing a check that compares the user ID of the device owner with the user ID of the current process. This ensures that only the rightful owner can perform the mount operation, thereby enhancing the security of the filesystem and preventing unauthorized access.","The vulnerability was fixed by introducing a user permission check that compares the user ID of the device owner with the current user's real user ID. In the modified code, the `check_ruid` variable is used to determine if the check should be performed. The conditional statement that checks if the user ID of the target inode does not match the current user's ID ensures that only the owner can mount the device. If the check fails, the code returns an error, effectively preventing unauthorized users from mounting filesystems they do not own and enhancing overall security.","The vulnerability was fixed by implementing a user permission check that ensures only the owner of the device can perform the mount operation. The updated code introduces a mechanism to compare the user ID of the device owner with the user ID of the current process. If the current user does not match the owner, the operation is denied, and an error is returned. This enhancement effectively prevents unauthorized users from mounting filesystems they do not own, thereby strengthening the security of the system and protecting sensitive data from potential misuse.","CWE-284, CWE-287, CWE-269, CWE-285, CWE-266, CWE-732, CWE-264, CWE-639, CWE-862, CWE-863",N,-1
17,17,179077,179077,,Local,Not required,,CVE-2011-0006,https://www.cvedetails.com/cve/CVE-2011-0006/,CWE-264,Medium,,Partial,,2012-06-21,1.9,"The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM.",2012-06-26,Bypass ,2,https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9,867c20265459d30a01b021a9c1e81fb4c5832aa9,"ima: fix add LSM rule bug

If security_filter_rule_init() doesn't return a rule, then not everything
is as fine as the return code implies.

This bug only occurs when the LSM (eg. SELinux) is disabled at runtime.

Adding an empty LSM rule causes ima_match_rules() to always succeed,
ignoring any remaining rules.

 default IMA TCB policy:
  # PROC_SUPER_MAGIC
  dont_measure fsmagic=0x9fa0
  # SYSFS_MAGIC
  dont_measure fsmagic=0x62656572
  # DEBUGFS_MAGIC
  dont_measure fsmagic=0x64626720
  # TMPFS_MAGIC
  dont_measure fsmagic=0x01021994
  # SECURITYFS_MAGIC
  dont_measure fsmagic=0x73636673

  < LSM specific rule >
  dont_measure obj_type=var_log_t

  measure func=BPRM_CHECK
  measure func=FILE_MMAP mask=MAY_EXEC
  measure func=FILE_CHECK mask=MAY_READ uid=0

Thus without the patch, with the boot parameters 'tcb selinux=0', adding
the above 'dont_measure obj_type=var_log_t' rule to the default IMA TCB
measurement policy, would result in nothing being measured.  The patch
prevents the default TCB policy from being replaced.

Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
Cc: James Morris <jmorris@namei.org>
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Cc: David Safford <safford@watson.ibm.com>
Cc: <stable@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,security/integrity/ima/ima_policy.c,"{""sha"": ""d661afbe474c2fce8f74907869be0a644c5789c9"", ""filename"": ""security/integrity/ima/ima_policy.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/integrity/ima/ima_policy.c?ref=867c20265459d30a01b021a9c1e81fb4c5832aa9"", ""patch"": ""@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n+\tif (!entry->lsm[lsm_rule].rule)\n+\t\treturn -EINVAL;\n \treturn result;\n }\n ""}","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
",C,"	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
",,,"@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
+	if (!entry->lsm[lsm_rule].rule)
+		return -EINVAL;
 	return result;
 }
 ",linux,867c20265459d30a01b021a9c1e81fb4c5832aa9,03ed6a3aa600c48593c3984812fda2d5945ddb46,1,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
//fix_flaw_line_below:
//	if (!entry->lsm[lsm_rule].rule)
//fix_flaw_line_below:
//		return -EINVAL;
 	return result;
 }
",179077,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","The provided code defines a function `ima_lsm_rule_init` that initializes a security rule for a given entry in the Linux Integrity Measurement Architecture (IMA). It first checks if a rule already exists for the specified Linux Security Module (LSM) by examining the `entry->lsm[lsm_rule].rule` field; if it does, the function returns an error code `-EINVAL`. If no rule exists, it sets the rule type to the specified `audit_type` and calls `security_filter_rule_init` to initialize the rule with the provided arguments. The function ultimately returns the result of the initialization process.","The code defines a function that initializes a security rule for a specific entry in a measurement architecture. It first checks if a rule is already present for the specified module; if so, it returns an error indicating invalid input. If no rule exists, it assigns a type to the rule based on the provided audit information. The function then proceeds to initialize the rule using the given parameters and stores the result of this initialization process. Finally, it returns the outcome of the initialization, indicating success or failure.","The vulnerability in the original code arises from the lack of validation after the initialization of the rule, which could lead to the use of an uninitialized or invalid rule. Specifically, if the `security_filter_rule_init` function fails, the code does not check whether `entry->lsm[lsm_rule].rule` was successfully initialized, potentially allowing further operations on an invalid rule. The fixed code addresses this issue by adding a check after the initialization to ensure that `entry->lsm[lsm_rule].rule` is valid; if it is not, the function returns an error code, thus preventing unsafe operations on an invalid rule.","The vulnerability in the original code stems from the lack of validation after attempting to initialize a security rule, which could result in operations being performed on an uninitialized or invalid rule. This oversight could lead to undefined behavior or security issues if the initialization fails. The fixed code addresses this vulnerability by introducing a check immediately after the initialization process to confirm that the rule was successfully created. If the rule is found to be invalid, the function returns an error, thereby preventing any further actions that could compromise system integrity or security.","The vulnerability was fixed by adding a validation check after the call to `security_filter_rule_init`. In the original code, there was no verification to ensure that `entry->lsm[lsm_rule].rule` was successfully initialized. The updated code introduces a conditional statement that checks if `entry->lsm[lsm_rule].rule` is still null after the initialization attempt. If it is null, the function returns an error code `-EINVAL`, effectively preventing any further operations on an invalid rule. This additional check enhances the robustness of the code by ensuring that only valid rules are processed.","The vulnerability was fixed by implementing an additional validation step after the rule initialization process. In the original code, there was no check to confirm whether the rule was successfully created, which could lead to operations on an invalid or uninitialized rule. The revised code introduces a conditional check that verifies the validity of the rule immediately after the initialization attempt. If the rule is found to be invalid, the function returns an error code, thereby preventing any further actions that could compromise system integrity or lead to undefined behavior. This enhancement significantly improves the code's reliability and security.","CWE-704,CWE-665,CWE-456,CWE-457,CWE-754,CWE-252,CWE-391,CWE-824,CWE-404,CWE-476",N,-1
18,18,179110,179110,,Local,Not required,Complete,CVE-2013-6431,https://www.cvedetails.com/cve/CVE-2013-6431/,CWE-264,Medium,,,,2013-12-09,4.7,"The fib6_add function in net/ipv6/ip6_fib.c in the Linux kernel before 3.11.5 does not properly implement error-code encoding, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for an IPv6 SIOCADDRT ioctl call.",2014-03-05,DoS ,1,https://github.com/torvalds/linux/commit/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,"net: fib: fib6_add: fix potential NULL pointer dereference

When the kernel is compiled with CONFIG_IPV6_SUBTREES, and we return
with an error in fn = fib6_add_1(), then error codes are encoded into
the return pointer e.g. ERR_PTR(-ENOENT). In such an error case, we
write the error code into err and jump to out, hence enter the if(err)
condition. Now, if CONFIG_IPV6_SUBTREES is enabled, we check for:

  if (pn != fn && pn->leaf == rt)
    ...
  if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO))
    ...

Since pn is NULL and fn is f.e. ERR_PTR(-ENOENT), then pn != fn
evaluates to true and causes a NULL-pointer dereference on further
checks on pn. Fix it, by setting both NULL in error case, so that
pn != fn already evaluates to false and no further dereference
takes place.

This was first correctly implemented in 4a287eba2 (""IPv6 routing,
NLM_F_* flag support: REPLACE and EXCL flags support, warn about
missing CREATE flag""), but the bug got later on introduced by
188c517a0 (""ipv6: return errno pointers consistently for fib6_add_1()"").

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Lin Ming <mlin@ss.pku.edu.cn>
Cc: Matti Vaittinen <matti.vaittinen@nsn.com>
Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Matti Vaittinen <matti.vaittinen@nsn.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv6/ip6_fib.c,"{""sha"": ""5bec666aba61d464fab4e77684eedd4265143cf9"", ""filename"": ""net/ipv6/ip6_fib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_fib.c?ref=ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2"", ""patch"": ""@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n \tfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n \t\t\toffsetof(struct rt6_info, rt6i_dst), allow_create,\n \t\t\treplace_required);\n-\n \tif (IS_ERR(fn)) {\n \t\terr = PTR_ERR(fn);\n+\t\tfn = NULL;\n \t\tgoto out;\n \t}\n ""}","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",C,"		fn = NULL;
",,,"@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
-
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
+		fn = NULL;
 		goto out;
 	}
 ",linux,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,3bf4b5b11d381fed6a94a7e487e01c8b3bc436b9,1,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
//flaw_line_below:

 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
//fix_flaw_line_below:
//		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",179110,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","The `fib6_add` function is responsible for adding a new route to the IPv6 Forwarding Information Base (FIB) in a network routing context. It first checks the message flags to determine if route creation or replacement is allowed. The function then attempts to add a new node to the FIB tree, potentially creating a subtree if a source address is provided. If successful, it links the new route to the appropriate nodes and initiates garbage collection for the network. In case of errors during node allocation or addition, it handles cleanup and ensures the integrity of the FIB structure, returning an error code if necessary.","The code implements a function that manages the addition of a new route to an IPv6 routing table. It first evaluates the conditions for creating or replacing a route based on provided flags. The function attempts to insert a new node into the routing structure, potentially creating a subtree if a source address is specified. Upon successful insertion, it links the new route and initiates cleanup processes for unused routes. If any errors occur during the process, the function ensures proper cleanup and maintains the integrity of the routing structure, returning an appropriate error code when necessary.","The vulnerability in the original code arises from improper handling of memory allocation failures during the addition of new nodes to the routing structure. Specifically, if the function `fib6_add_1` fails and returns an error, the code does not reset the pointer `fn` to `NULL`, which could lead to dereferencing a potentially invalid pointer later in the function. This oversight could result in undefined behavior or memory corruption. The fixed code addresses this issue by explicitly setting `fn` to `NULL` after detecting an error, ensuring that subsequent operations do not attempt to access an invalid memory location.","The vulnerability in the original code stems from inadequate error handling during memory allocation, which could lead to dereferencing an invalid pointer if a node addition fails. When the function encounters an error, it does not reset the pointer to indicate that the operation was unsuccessful, potentially allowing subsequent code to operate on a stale or invalid reference. The fix addresses this issue by explicitly setting the pointer to `NULL` upon detecting an error, thereby preventing any further operations on an invalid memory location and ensuring safer memory management throughout the function.","The vulnerability was fixed by modifying the error handling logic in the function. Specifically, after the call to `fib6_add_1`, if an error is detected using `IS_ERR(fn)`, the code now sets `fn` to `NULL` before proceeding to the cleanup section. This change ensures that any subsequent operations that rely on the validity of `fn` do not inadvertently dereference an invalid pointer. By explicitly resetting `fn`, the code prevents potential memory corruption or undefined behavior, thereby enhancing the overall robustness and safety of the routing table management process.","The vulnerability was addressed by improving the error handling mechanism within the function. When an error occurs during the addition of a new node, the code now explicitly resets the pointer associated with the node to indicate that the operation was unsuccessful. This adjustment prevents any subsequent operations from attempting to access or dereference an invalid memory location, thereby mitigating the risk of undefined behavior or memory corruption. By ensuring that the pointer reflects the failure state, the code enhances its overall safety and reliability in managing the routing structure.","CWE-476, CWE-119, CWE-825, CWE-415, CWE-416, CWE-457, CWE-824, CWE-908, CWE-404, CWE-465",N,-1
19,19,179111,179111,,Local,Not required,Complete,CVE-2013-6383,https://www.cvedetails.com/cve/CVE-2013-6383/,CWE-264,Medium,Complete,Complete,,2013-11-26,6.9,"The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call.",2014-03-26,Bypass ,2,https://github.com/torvalds/linux/commit/f856567b930dfcdbc3323261bf77240ccdde01f5,f856567b930dfcdbc3323261bf77240ccdde01f5,"aacraid: missing capable() check in compat ioctl

In commit d496f94d22d1 ('[SCSI] aacraid: fix security weakness') we
added a check on CAP_SYS_RAWIO to the ioctl.  The compat ioctls need the
check as well.

Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,drivers/scsi/aacraid/linit.c,"{""sha"": ""f0d432c139d0cecedf51295562c858d22a9f44f0"", ""filename"": ""drivers/scsi/aacraid/linit.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/aacraid/linit.c?ref=f856567b930dfcdbc3323261bf77240ccdde01f5"", ""patch"": ""@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long\n static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }\n ""}"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
",,,"@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long
 static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
 ",linux,f856567b930dfcdbc3323261bf77240ccdde01f5,c2c65cd2e14ada6de44cb527e7f1990bede24e15,1," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",179111," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
","The provided code defines a static function `aac_compat_ioctl`, which is designed to handle compatibility input/output control (IOCTL) requests for SCSI devices. It takes three parameters: a pointer to a `scsi_device` structure (`sdev`), an integer command (`cmd`), and a user-space pointer (`arg`). The function retrieves the associated `aac_dev` structure from the SCSI device's host data and then calls another function, `aac_compat_do_ioctl`, passing the device structure, command, and argument cast to an unsigned long. This facilitates communication between user-space applications and the SCSI device driver, ensuring compatibility with various IOCTL commands.","The code defines a function that facilitates compatibility for input/output control requests related to a specific type of device. It accepts parameters that represent a device structure, a command identifier, and a pointer to user-space data. The function retrieves the necessary device information from the device's host data and subsequently invokes another function to process the command and user data. This mechanism allows user-space applications to interact with the device driver effectively, ensuring that various control commands are handled appropriately while maintaining compatibility across different versions or configurations of the device.","The vulnerability in the original code arises from the lack of permission checks before processing input/output control requests, which could allow unauthorized users to execute potentially harmful commands on the device. In the fixed code, a permission check is introduced using the `capable(CAP_SYS_RAWIO)` function, which verifies if the calling process has the necessary privileges to perform raw I/O operations. If the check fails, the function returns `-EPERM`, preventing unauthorized access and enhancing the security of the device by ensuring that only users with appropriate permissions can interact with the device through the IOCTL interface.","The vulnerability in the original code stems from the absence of permission checks before allowing access to sensitive device control operations, which could enable unauthorized users to execute potentially harmful commands. This lack of validation poses a significant security risk, as it allows any user to interact with the device without restrictions. The fixed code addresses this issue by implementing a permission verification step that ensures only users with the appropriate privileges can perform raw input/output operations. This enhancement effectively mitigates the risk of unauthorized access, thereby improving the overall security of the device management process.","The vulnerability was fixed by introducing a permission check using the `capable(CAP_SYS_RAWIO)` function before processing input/output control requests. This check verifies whether the calling process has the necessary capabilities to perform raw I/O operations. If the process lacks the required permissions, the function returns `-EPERM`, effectively denying access to unauthorized users. By implementing this security measure, the code ensures that only users with appropriate privileges can interact with the device through the IOCTL interface, thereby preventing potential exploitation and enhancing the overall security of the device management system.","The vulnerability was addressed by incorporating a permission verification step before allowing access to sensitive device control operations. This enhancement ensures that only users with the appropriate privileges can execute raw input/output commands, effectively preventing unauthorized access. If a user lacks the necessary permissions, the system responds by denying the request, thereby safeguarding the device from potential exploitation. This fix significantly improves the security of the device management process by ensuring that all interactions are properly authorized, thereby reducing the risk of malicious actions by unauthorized users.","CWE-269, CWE-284, CWE-285, CWE-732, CWE-264, CWE-266, CWE-749, CWE-862, CWE-863, CWE-287",N,-1
20,20,179158,179158,,Local,Not required,Complete,CVE-2013-4470,https://www.cvedetails.com/cve/CVE-2013-4470/,CWE-264,Medium,Complete,Complete,,2013-11-04,6.9,"The Linux kernel before 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly initialize certain data structures, which allows local users to cause a denial of service (memory corruption and system crash) or possibly gain privileges via a crafted application that uses the UDP_CORK option in a setsockopt system call and sends both short and long packets, related to the ip_ufo_append_data function in net/ipv4/ip_output.c and the ip6_ufo_append_data function in net/ipv6/ip6_output.c.",2018-01-08,DoS +Priv Mem. Corr. ,9,https://github.com/torvalds/linux/commit/e93b7d748be887cd7639b113ba7d7ef792a7efb9,e93b7d748be887cd7639b113ba7d7ef792a7efb9,"ip_output: do skb ufo init for peeked non ufo skb as well

Now, if user application does:
sendto len<mtu flag MSG_MORE
sendto len>mtu flag 0
The skb is not treated as fragmented one because it is not initialized
that way. So move the initialization to fix this.

introduced by:
commit e89e9cf539a28df7d0eb1d0a545368e9920b34ac ""[IPv4/IPv6]: UFO Scatter-gather approach""

Signed-off-by: Jiri Pirko <jiri@resnulli.us>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/ip_output.c,"{""sha"": ""3982eabf61e126060fc7c5b48042bea2f0417135"", ""filename"": ""net/ipv4/ip_output.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 4, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_output.c?ref=e93b7d748be887cd7639b113ba7d7ef792a7efb9"", ""patch"": ""@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,\n \t\t/* initialize protocol header pointer */\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n-\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n-\t\t/* specify the length of each IP datagram fragment */\n-\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n-\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n \t\t__skb_queue_tail(queue, skb);\n+\t} else if (skb_is_gso(skb)) {\n+\t\tgoto append;\n \t}\n \n+\tskb->ip_summed = CHECKSUM_PARTIAL;\n+\t/* specify the length of each IP datagram fragment */\n+\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n+\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n+append:\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }""}","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",C,"
	} else if (skb_is_gso(skb)) {
		goto append;
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
","		skb->ip_summed = CHECKSUM_PARTIAL;
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
",,"@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,
 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
-		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
-		/* specify the length of each IP datagram fragment */
-		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
-		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
 		__skb_queue_tail(queue, skb);
+	} else if (skb_is_gso(skb)) {
+		goto append;
 	}
 
+	skb->ip_summed = CHECKSUM_PARTIAL;
+	/* specify the length of each IP datagram fragment */
+	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
+	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
+append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }",linux,e93b7d748be887cd7639b113ba7d7ef792a7efb9,c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,1,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
//flaw_line_below:
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
//flaw_line_below:
		/* specify the length of each IP datagram fragment */
//flaw_line_below:
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//flaw_line_below:
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
 		__skb_queue_tail(queue, skb);
//fix_flaw_line_below:
//	} else if (skb_is_gso(skb)) {
//fix_flaw_line_below:
//		goto append;
 	}
 
//fix_flaw_line_below:
//	skb->ip_summed = CHECKSUM_PARTIAL;
//fix_flaw_line_below:
//	/* specify the length of each IP datagram fragment */
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",179158,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","The provided code defines a function `ip_ufo_append_data` that facilitates the appending of data to a socket buffer (skb) for UDP fragmentation offload. It first checks if there is an existing skb in the specified queue; if not, it allocates a new skb with reserved space for headers and initializes various pointers and checksum settings. The function sets the maximum fragment size and type for the skb, ensuring it is ready for UDP fragmentation. Finally, it appends the data from the specified source using the provided `getfrag` function, allowing for efficient handling of larger UDP datagrams.","The code defines a function that manages the appending of data to a socket buffer for efficient handling of UDP fragmentation. It first checks for an existing buffer in a specified queue; if none is found, it allocates a new buffer with reserved space for necessary headers and initializes various settings related to checksums and fragmentation. The function specifies the maximum size for each fragment and prepares the buffer for UDP processing. Finally, it appends the data from a given source, enabling the effective transmission of larger UDP datagrams while ensuring proper fragmentation.","The vulnerability in the original code arises from the lack of checks for existing socket buffers, which could lead to improper handling of fragmented packets. Specifically, if a buffer was already present but not a GSO (Generic Segmentation Offload) buffer, the code would proceed to append data without ensuring that the buffer was suitable for fragmentation. The fixed code introduces a check using `skb_is_gso(skb)` to determine if the existing buffer is appropriate for appending data. This prevents potential data corruption or crashes by ensuring that only valid buffers are used for fragmentation, enhancing the overall robustness of the function.","The vulnerability in the original code stems from the absence of checks for the type of existing buffers, which could lead to improper handling of fragmented packets. This oversight allowed the function to append data to a buffer that might not be suitable for fragmentation, potentially resulting in data corruption or system crashes. The fixed code addresses this issue by introducing a validation step to ensure that only appropriate buffers are used for appending data. This enhancement significantly improves the function's reliability by preventing the use of incompatible buffers, thereby safeguarding against fragmentation-related errors.","The vulnerability was fixed by adding a conditional check for the type of existing socket buffer using `skb_is_gso(skb)`. In the revised code, if an existing buffer is found in the queue, the function first verifies whether it is a GSO buffer before proceeding to append data. This ensures that only suitable buffers are utilized for fragmentation, preventing potential data corruption or crashes. Additionally, the code maintains the initialization of the checksum and fragmentation parameters, reinforcing the integrity of the data being processed. This validation step significantly enhances the robustness and reliability of the function.","The vulnerability was addressed by incorporating a validation step to check the type of existing buffers before appending data. This enhancement ensures that only appropriate buffers, specifically those designed for fragmentation, are used in the process. By verifying the suitability of the buffer, the code prevents potential issues such as data corruption or system crashes that could arise from using incompatible buffers. This fix not only improves the reliability of the function but also reinforces the overall integrity of data handling during fragmentation, thereby enhancing the robustness of the implementation.","CWE-119, CWE-787, CWE-788, CWE-805, CWE-120, CWE-122, CWE-125, CWE-129, CWE-131, CWE-789",N,-1
21,21,179163,179163,,Local,Not required,Complete,CVE-2013-4300,https://www.cvedetails.com/cve/CVE-2013-4300/,CWE-264,Low,Complete,Complete,,2013-09-25,7.2,"The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.11 performs a capability check in an incorrect namespace, which allows local users to gain privileges via PID spoofing.",2013-10-30,+Priv ,1,https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e,d661684cf6820331feae71146c35da83d794467e,"net: Check the correct namespace when spoofing pid over SCM_RIGHTS

This is a security bug.

The follow-up will fix nsproxy to discourage this type of issue from
happening again.

Cc: stable@vger.kernel.org
Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/scm.c,"{""sha"": ""b4da80b1cc07d28eafec50a6185d6d2a2ece61af"", ""filename"": ""net/core/scm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/scm.c?ref=d661684cf6820331feae71146c35da83d794467e"", ""patch"": ""@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n-\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n+\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||""}","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",C,"	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
","	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
",,"@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
-	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
+	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||",linux,d661684cf6820331feae71146c35da83d794467e,dd5746bf6b48bb837e9f5af14b9b241fc4fdc1ef,1,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
//flaw_line_below:
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
//fix_flaw_line_below:
//	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",179163,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","The provided code defines a function `scm_check_creds` that verifies the validity of user credentials in a Linux kernel context. It retrieves the current process's credentials and checks if the provided user ID (UID) and group ID (GID) are valid. The function then assesses whether the credentials belong to the current process or if the current user has administrative capabilities. It checks if the UID and GID match the current credentials or if the user has the necessary permissions to change them. If all conditions are met, it returns 0, indicating success; otherwise, it returns an error code, signaling permission denial.","The code defines a function that checks the validity of user credentials within a system. It first retrieves the current user's credentials and verifies the validity of the provided user and group identifiers. The function then determines if the credentials belong to the current process or if the user has administrative privileges. It further checks if the identifiers match the current user's credentials or if the user has the authority to modify them. If all conditions are satisfied, the function indicates success; otherwise, it returns an error indicating that permission is denied.","The vulnerability in the original code arises from the potential for unauthorized access to user credentials, as it did not properly account for the namespace of the current process when checking administrative capabilities. Specifically, the use of `current->nsproxy->pid_ns->user_ns` could allow a process to bypass security checks if it had the necessary privileges in a different namespace. The fix replaces this with `task_active_pid_ns(current)->user_ns`, ensuring that the check for administrative capabilities is performed within the correct namespace context, thereby preventing privilege escalation and enhancing overall security.","The vulnerability in the original code stemmed from inadequate checks on user permissions, allowing unauthorized processes to potentially manipulate user credentials across different namespaces. This oversight could enable privilege escalation, as the code did not properly verify the administrative capabilities of the current process within its specific namespace context. The fix addressed this issue by ensuring that the checks for administrative privileges were performed relative to the active namespace of the current process, thereby restricting access and enhancing security by preventing unauthorized credential modifications and ensuring that permissions are validated correctly.","The vulnerability was fixed by changing the way the code checks for administrative capabilities within the correct namespace context. The original code used `current->nsproxy->pid_ns->user_ns`, which could lead to improper privilege checks. The updated code replaces this with `task_active_pid_ns(current)->user_ns`, ensuring that the administrative capability check is performed against the active namespace of the current process. This adjustment prevents unauthorized access to user credentials by ensuring that only processes with the appropriate permissions in their specific namespace can perform actions that modify user and group identifiers, thereby enhancing overall security.","The vulnerability was fixed by refining the checks for administrative capabilities to ensure they are performed within the correct namespace context of the current process. The original implementation allowed for potential privilege escalation by not adequately verifying permissions relative to the active namespace. The revised code explicitly checks the administrative privileges against the current process's active namespace, thereby restricting access to user credentials. This change ensures that only processes with the appropriate permissions in their specific namespace can modify user and group identifiers, significantly enhancing the security of the credential verification process.","CWE-269, CWE-266, CWE-264, CWE-284, CWE-732, CWE-272, CWE-250, CWE-286, CWE-271, CWE-265",N,-1
22,22,179220,179220,,Local,Not required,,CVE-2013-2930,https://www.cvedetails.com/cve/CVE-2013-2930/,CWE-264,Low,Partial,Partial,,2013-12-09,3.6,"The perf_trace_event_perm function in kernel/trace/trace_event_perf.c in the Linux kernel before 3.12.2 does not properly restrict access to the perf subsystem, which allows local users to enable function tracing via a crafted application.",2014-03-05,,1,https://github.com/torvalds/linux/commit/12ae030d54ef250706da5642fc7697cc60ad0df7,12ae030d54ef250706da5642fc7697cc60ad0df7,"perf/ftrace: Fix paranoid level for enabling function tracer

The current default perf paranoid level is ""1"" which has
""perf_paranoid_kernel()"" return false, and giving any operations that
use it, access to normal users. Unfortunately, this includes function
tracing and normal users should not be allowed to enable function
tracing by default.

The proper level is defined at ""-1"" (full perf access), which
""perf_paranoid_tracepoint_raw()"" will only give access to. Use that
check instead for enabling function tracing.

Reported-by: Dave Jones <davej@redhat.com>
Reported-by: Vince Weaver <vincent.weaver@maine.edu>
Tested-by: Vince Weaver <vincent.weaver@maine.edu>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: stable@vger.kernel.org # 3.4+
CVE: CVE-2013-2930
Fixes: ced39002f5ea (""ftrace, perf: Add support to use function tracepoint in perf"")
Signed-off-by: Steven Rostedt <rostedt@goodmis.org>",1,kernel/trace/trace_event_perf.c,"{""sha"": ""78e27e3b52ac2ee0b9e86f544b77a45e12865d95"", ""filename"": ""kernel/trace/trace_event_perf.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/trace/trace_event_perf.c?ref=12ae030d54ef250706da5642fc7697cc60ad0df7"", ""patch"": ""@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n {\n \t/* The ftrace function trace is allowed only for root. */\n \tif (ftrace_event_is_function(tp_event) &&\n-\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n+\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \t/* No tracing, just counting, so no obvious leak */""}","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",C,"	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
","	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
",,"@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
-	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
+	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */",linux,12ae030d54ef250706da5642fc7697cc60ad0df7,5e01dc7b26d9f24f39abace5da98ccbd6a5ceb52,1,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
//flaw_line_below:
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
//fix_flaw_line_below:
//	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",179220,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","The provided code defines a function, `perf_trace_event_perm`, which manages permissions for tracing performance events in a Linux kernel environment. It first checks if the event is a function trace and whether the caller has the necessary administrative capabilities; if not, it returns a permission error. The function then verifies if the event is configured to sample raw data, allowing non-root users to trace certain events under specific conditions. However, if the event is deemed sensitive and the user lacks root privileges, it restricts access to prevent potential data leaks, ultimately returning an appropriate permission status.","The code implements a permission-checking mechanism for tracing performance events in a kernel environment. It restricts access to function tracing for non-administrative users, ensuring that only those with the appropriate privileges can perform such actions. The function allows certain events to be traced by non-root users under specific conditions, while also checking for configurations that involve raw data sampling. If the event is classified as sensitive, access is denied to prevent potential data leaks. Ultimately, the function returns a status indicating whether the requested tracing operation is permitted based on the user's privileges and event characteristics.","The vulnerability in the original code arises from insufficient checks on the conditions under which non-root users can access sensitive tracing data. Specifically, the function allowed certain events to be traced without adequately verifying if they involved raw data sampling, which could lead to unauthorized access to sensitive information. The fix introduced an additional check that ensures if the event is a function trace and involves raw data, only users with administrative capabilities can proceed. This change effectively mitigates the risk of data leaks by enforcing stricter permission requirements for accessing potentially sensitive tracepoint data.","The vulnerability in the original code stemmed from inadequate permission checks that allowed non-administrative users to access sensitive tracing data, particularly when raw data sampling was involved. This oversight could lead to unauthorized exposure of critical information, posing a significant security risk. The fix addressed this issue by implementing stricter conditions that ensure only users with the necessary administrative privileges can access function tracing and raw data. By reinforcing these permission checks, the updated code effectively mitigates the risk of data leaks and enhances the overall security of the tracing mechanism.","The vulnerability was fixed by enhancing the permission checks within the function. The updated code added a condition that verifies if the event is a function trace and involves raw data sampling, ensuring that only users with administrative capabilities can proceed. Specifically, the check for `perf_paranoid_tracepoint_raw()` was reinforced to return a permission error if the user is not capable of `CAP_SYS_ADMIN`. This change prevents non-root users from accessing sensitive tracepoint data, thereby mitigating the risk of data leaks and ensuring that only authorized users can perform potentially harmful tracing operations.","The vulnerability was addressed by implementing stricter permission checks to control access to sensitive tracing data. The updated code introduced additional conditions that ensure only users with the necessary administrative privileges can access function tracing and raw data sampling. By reinforcing these checks, the code now effectively prevents unauthorized users from accessing potentially sensitive information, thereby reducing the risk of data leaks. This enhancement ensures that the tracing mechanism operates securely, allowing only authorized individuals to perform actions that could expose critical system information.","CWE-285, CWE-732, CWE-269, CWE-264, CWE-284, CWE-668, CWE-306, CWE-522, CWE-862, CWE-250",N,-1
23,23,179221,179221,,Local,Not required,,CVE-2013-2929,https://www.cvedetails.com/cve/CVE-2013-2929/,CWE-264,Medium,Partial,Partial,,2013-12-09,3.3,"The Linux kernel before 3.12.2 does not properly use the get_dumpable function, which allows local users to bypass intended ptrace restrictions or obtain sensitive information from IA64 scratch registers via a crafted application, related to kernel/ptrace.c and arch/ia64/include/asm/processor.h.",2018-04-27,Bypass +Info ,2,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,d049f74f2dbe71354d43d393ac3a188947811348,"exec/ptrace: fix get_dumpable() incorrect tests

The get_dumpable() return value is not boolean.  Most users of the
function actually want to be testing for non-SUID_DUMP_USER(1) rather than
SUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a
protected state.  Almost all places did this correctly, excepting the two
places fixed in this patch.

Wrong logic:
    if (dumpable == SUID_DUMP_DISABLE) { /* be protective */ }
        or
    if (dumpable == 0) { /* be protective */ }
        or
    if (!dumpable) { /* be protective */ }

Correct logic:
    if (dumpable != SUID_DUMP_USER) { /* be protective */ }
        or
    if (dumpable != 1) { /* be protective */ }

Without this patch, if the system had set the sysctl fs/suid_dumpable=2, a
user was able to ptrace attach to processes that had dropped privileges to
that user.  (This may have been partially mitigated if Yama was enabled.)

The macros have been moved into the file that declares get/set_dumpable(),
which means things like the ia64 code can see them too.

CVE-2013-2929

Reported-by: Vasily Kulikov <segoon@openwall.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: ""Luck, Tony"" <tony.luck@intel.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,kernel/ptrace.c,"{""sha"": ""5a84b3a5074158d8b0fe975d5def50689c8c735d"", ""filename"": ""arch/ia64/include/asm/processor.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/ia64/include/asm/processor.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -319,7 +319,7 @@ struct thread_struct {\n \tregs->loadrs = 0;\t\t\t\t\t\t\t\t\t\\\n \tregs->r8 = get_dumpable(current->mm);\t/* set \""don't zap registers\"" flag */\t\t\\\n \tregs->r12 = new_sp - 16;\t/* allocate 16 byte scratch area */\t\t\t\\\n-\tif (unlikely(!get_dumpable(current->mm))) {\t\t\t\t\t\t\t\\\n+\tif (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {\t\\\n \t\t/*\t\t\t\t\t\t\t\t\t\t\\\n \t\t * Zap scratch regs to avoid leaking bits between processes with different\t\\\n \t\t * uid/privileges.\t\t\t\t\t\t\t\t\\""}<_**next**_>{""sha"": ""12120620f0409660555aec739e5c0441abb995ee"", ""filename"": ""fs/exec.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exec.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -1669,6 +1669,12 @@ int __get_dumpable(unsigned long mm_flags)\n \treturn (ret > SUID_DUMP_USER) ? SUID_DUMP_ROOT : ret;\n }\n \n+/*\n+ * This returns the actual value of the suid_dumpable flag. For things\n+ * that are using this for checking for privilege transitions, it must\n+ * test against SUID_DUMP_USER rather than treating it as a boolean\n+ * value.\n+ */\n int get_dumpable(struct mm_struct *mm)\n {\n \treturn __get_dumpable(mm->flags);""}<_**next**_>{""sha"": ""7554fd410bcc35ff1a4d56e1e3ae99c62a78bcad"", ""filename"": ""include/linux/binfmts.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/binfmts.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -99,9 +99,6 @@ extern void setup_new_exec(struct linux_binprm * bprm);\n extern void would_dump(struct linux_binprm *, struct file *);\n \n extern int suid_dumpable;\n-#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n-#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n-#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n \n /* Stack area protections */\n #define EXSTACK_DEFAULT   0\t/* Whatever the arch defaults to */""}<_**next**_>{""sha"": ""f7efc86046522c2722501f5967d65983162fa78e"", ""filename"": ""include/linux/sched.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sched.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -323,6 +323,10 @@ static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}\n extern void set_dumpable(struct mm_struct *mm, int value);\n extern int get_dumpable(struct mm_struct *mm);\n \n+#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n+#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n+#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n+\n /* mm flags */\n /* dumpable bits */\n #define MMF_DUMPABLE      0  /* core dump is permitted */""}<_**next**_>{""sha"": ""1f4bcb3cc21cee5bcfd1b4e13a77eeff2af23a2b"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n-\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n+\tif (dumpable != SUID_DUMP_USER &&\n+\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}""}","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",C,"	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
","	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
",,"@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
-	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
+	if (dumpable != SUID_DUMP_USER &&
+	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}",linux,d049f74f2dbe71354d43d393ac3a188947811348,1c3fc3e5cc8a81d21b199cb739d5d9c51f3688f4,1,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
//flaw_line_below:
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
//fix_flaw_line_below:
//	if (dumpable != SUID_DUMP_USER &&
//fix_flaw_line_below:
//	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",179221,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","The provided code defines a function `__ptrace_may_access` that determines whether the current process can access another specified task's resources, primarily for debugging or inspection purposes using the `ptrace` system call. It checks the user and group IDs of the current process against those of the target task to ensure they match, allowing access if they do. If the IDs do not match, it verifies if the current process has the necessary capabilities to access the target task. The function also considers whether the target task's memory is dumpable and performs security checks before granting or denying access, returning appropriate error codes when access is not permitted.","The code defines a function that checks if the current process has permission to access another process's resources for debugging or inspection purposes. It verifies if the user and group identifiers of both processes match, allowing access if they do. If there is no match, the function checks for specific capabilities that might grant access. Additionally, it assesses whether the target process's memory can be accessed and performs security checks to ensure compliance with access policies. The function ultimately returns an error code if access is denied, ensuring that only authorized processes can interact with each other.","The vulnerability in the original code arises from insufficient checks on the dumpability of the target process's memory, which could allow unauthorized access to sensitive information. Specifically, the original code did not adequately verify if the memory was marked as dumpable before granting access, potentially exposing it to processes without the necessary permissions. The fixed code addresses this by adding a condition to check if the memory is not marked as `SUID_DUMP_USER` before allowing access, ensuring that only processes with the appropriate capabilities can access the target process's resources, thereby enhancing security and preventing unauthorized introspection.","The vulnerability in the original code stemmed from inadequate verification of whether a target process's memory could be accessed, potentially allowing unauthorized processes to inspect sensitive information. This oversight could lead to security breaches, as processes without the necessary permissions might gain access to protected resources. The fixed code rectifies this by introducing a specific check to ensure that the memory is not marked for unrestricted access before granting permission. This enhancement ensures that only authorized processes can interact with the target process's resources, thereby strengthening the overall security and integrity of the system.","The vulnerability was fixed by adding a crucial check for the dumpability of the target process's memory. In the revised code, after confirming that the user and group identifiers match or that the current process has the necessary capabilities, the code now verifies if the memory is not marked as `SUID_DUMP_USER`. This is done through the condition that checks the value of `dumpable` after calling `get_dumpable` on the target process's memory. If the memory is not dumpable and the current process lacks the required capabilities, access is denied, thereby preventing unauthorized introspection of sensitive information.","The vulnerability was fixed by implementing an additional check to ensure that the target process's memory is not accessible without proper authorization. The revised code introduces a condition that verifies whether the memory is marked for unrestricted access before allowing any interaction. This enhancement ensures that even if a process has matching user and group identifiers or necessary capabilities, it cannot access the target process's resources if the memory is deemed sensitive. By enforcing this stricter access control, the fix effectively prevents unauthorized processes from inspecting or manipulating protected information, thereby improving overall system security.","CWE-284,CWE-269,CWE-732,CWE-264,CWE-668,CWE-634,CWE-266,CWE-426,CWE-782,CWE-618",Y,4
24,24,179266,179266,,Local,Not required,,CVE-2013-1957,https://www.cvedetails.com/cve/CVE-2013-1957/,CWE-264,Medium,Complete,,,2013-04-24,4.7,"The clone_mnt function in fs/namespace.c in the Linux kernel before 3.8.6 does not properly restrict changes to the MNT_READONLY flag, which allows local users to bypass an intended read-only property of a filesystem by leveraging a separate mount namespace.",2013-04-25,Bypass ,4,https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,"vfs: Carefully propogate mounts across user namespaces

As a matter of policy MNT_READONLY should not be changable if the
original mounter had more privileges than creator of the mount
namespace.

Add the flag CL_UNPRIVILEGED to note when we are copying a mount from
a mount namespace that requires more privileges to a mount namespace
that requires fewer privileges.

When the CL_UNPRIVILEGED flag is set cause clone_mnt to set MNT_NO_REMOUNT
if any of the mnt flags that should never be changed are set.

This protects both mount propagation and the initial creation of a less
privileged mount namespace.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""968d4c5eae03aa18b1326e09371aa5ada795939e"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n \t}\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n+\t/* Don't allow unprivileged users to change mount flags */\n+\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n+\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,\n \t/* First pass: copy the tree topology */\n \tcopy_flags = CL_COPY_ALL | CL_EXPIRE;\n \tif (user_ns != mnt_ns->user_ns)\n-\t\tcopy_flags |= CL_SHARED_TO_SLAVE;\n+\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n \tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n \tif (IS_ERR(new)) {\n \t\tup_write(&namespace_sem);""}<_**next**_>{""sha"": ""8b29d2164da6aef6edb88b9872368c849e658530"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -9,6 +9,7 @@\n #include <linux/mnt_namespace.h>\n #include <linux/mount.h>\n #include <linux/fs.h>\n+#include <linux/nsproxy.h>\n #include \""internal.h\""\n #include \""pnode.h\""\n \n@@ -220,6 +221,7 @@ static struct mount *get_source(struct mount *dest,\n int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \t\t    struct mount *source_mnt, struct list_head *tree_list)\n {\n+\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n \tstruct mount *m, *child;\n \tint ret = 0;\n \tstruct mount *prev_dest_mnt = dest_mnt;\n@@ -237,6 +239,10 @@ int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \n \t\tsource =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);\n \n+\t\t/* Notice when we are propagating across user namespaces */\n+\t\tif (m->mnt_ns->user_ns != user_ns)\n+\t\t\ttype |= CL_UNPRIVILEGED;\n+\n \t\tchild = copy_tree(source, source->mnt.mnt_root, type);\n \t\tif (IS_ERR(child)) {\n \t\t\tret = PTR_ERR(child);""}<_**next**_>{""sha"": ""a0493d5ebfbf52be2eb07a794df459ab2a32cd6a"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -23,6 +23,7 @@\n #define CL_MAKE_SHARED \t\t0x08\n #define CL_PRIVATE \t\t0x10\n #define CL_SHARED_TO_SLAVE\t0x20\n+#define CL_UNPRIVILEGED\t\t0x40\n \n static inline void set_mnt_shared(struct mount *mnt)\n {""}","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",C,"	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

",,,"@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
+	/* Don't allow unprivileged users to change mount flags */
+	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
+		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
+
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,
 	/* First pass: copy the tree topology */
 	copy_flags = CL_COPY_ALL | CL_EXPIRE;
 	if (user_ns != mnt_ns->user_ns)
-		copy_flags |= CL_SHARED_TO_SLAVE;
+		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
 	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
 	if (IS_ERR(new)) {
 		up_write(&namespace_sem);",linux,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,90563b198e4c6674c63672fae1923da467215f45,1,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
//fix_flaw_line_below:
//	/* Don't allow unprivileged users to change mount flags */
//fix_flaw_line_below:
//	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
//fix_flaw_line_below:
//		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
//fix_flaw_line_below:
//
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",179266,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","The `clone_mnt` function creates a duplicate mount structure based on an existing mount (`old`) and a specified root directory (`root`), while considering various flags that dictate the clone's properties. It allocates memory for the new mount and sets its group ID based on the provided flags, ensuring it is not a peer of the original if specified. The function updates the new mount's flags, associates it with the same superblock, and manages its relationships with the original mount, including shared or slave status. Finally, it handles potential errors during allocation and ensures proper cleanup if necessary, returning a pointer to the new mount or an error code.","The provided code defines a function that duplicates a mount structure based on an existing one and a specified root directory, while considering various flags that influence the characteristics of the new mount. It allocates memory for the new structure and sets its properties according to the specified flags, determining its relationship with the original mount. The function manages the new mount's connection to the same filesystem and updates its status regarding shared or slave relationships. It also includes error handling to ensure proper memory management, returning either the new mount or an error indication if allocation fails.","The vulnerability in the original code stemmed from insufficient checks on mount flags, allowing unprivileged users to modify critical mount properties, such as setting a mount to read-only without proper authorization. This could lead to privilege escalation or unauthorized access to filesystem resources. The fix introduced a condition that checks if the `CL_UNPRIVILEGED` flag is set and whether the mount's flags include `MNT_READONLY`. If both conditions are met, it enforces a lock by setting `MNT_LOCK_READONLY`, thereby preventing unprivileged users from altering the mount's read-only status and enhancing overall security.","The vulnerability in the original code allowed unprivileged users to alter critical filesystem mount properties, potentially leading to unauthorized access or privilege escalation. This risk arose from a lack of adequate checks on the conditions under which certain mount flags could be modified. The fix implemented a safeguard that restricts unprivileged users from changing specific mount settings, particularly those related to read-only access. By introducing a condition that enforces a lock on these properties when certain flags are present, the updated code effectively mitigates the risk of unauthorized modifications, thereby enhancing the security of the filesystem.","The vulnerability was fixed by adding a conditional check that prevents unprivileged users from modifying critical mount flags. Specifically, the code now checks if the `CL_UNPRIVILEGED` flag is set and whether the mount's flags include `MNT_READONLY`. If both conditions are true, the code enforces a lock by setting `MNT_LOCK_READONLY`, thereby preventing any unauthorized changes to the read-only status of the mount. This enhancement ensures that only privileged users can alter sensitive mount properties, thereby reducing the risk of privilege escalation and unauthorized access to filesystem resources.","The vulnerability was addressed by implementing a safeguard that restricts unprivileged users from altering critical filesystem properties. The fix introduced a condition that checks for specific flags indicating unprivileged access and the current state of the filesystem. If both conditions are met, the code enforces a restriction that prevents changes to the read-only status of the mount. This enhancement ensures that only authorized users can modify sensitive settings, thereby mitigating the risk of unauthorized access and privilege escalation, and ultimately strengthening the overall security of the filesystem.","CWE-269,CWE-264,CWE-284,CWE-732,CWE-285,CWE-266,CWE-279,CWE-280,CWE-268,CWE-277",Y,2
25,25,179269,179269,,Local,Not required,,CVE-2013-1956,https://www.cvedetails.com/cve/CVE-2013-1956/,CWE-264,Low,,Partial,,2013-04-24,2.1,"The create_user_ns function in kernel/user_namespace.c in the Linux kernel before 3.8.6 does not check whether a chroot directory exists that differs from the namespace root directory, which allows local users to bypass intended filesystem restrictions via a crafted clone system call.",2013-05-01,Bypass ,9,https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d,3151527ee007b73a0ebd296010f1c0454a919c7d,"userns:  Don't allow creation if the user is chrooted

Guarantee that the policy of which files may be access that is
established by setting the root directory will not be violated
by user namespaces by verifying that the root directory points
to the root of the mount namespace at the time of user namespace
creation.

Changing the root is a privileged operation, and as a matter of policy
it serves to limit unprivileged processes to files below the current
root directory.

For reasons of simplicity and comprehensibility the privilege to
change the root directory is gated solely on the CAP_SYS_CHROOT
capability in the user namespace.  Therefore when creating a user
namespace we must ensure that the policy of which files may be access
can not be violated by changing the root directory.

Anyone who runs a processes in a chroot and would like to use user
namespace can setup the same view of filesystems with a mount
namespace instead.  With this result that this is not a practical
limitation for using user namespaces.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,kernel/user_namespace.c,"{""sha"": ""a3035223d4218c13ac6db83f8d5444e454346c2f"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -2732,6 +2732,30 @@ bool our_mnt(struct vfsmount *mnt)\n \treturn check_mnt(real_mount(mnt));\n }\n \n+bool current_chrooted(void)\n+{\n+\t/* Does the current process have a non-standard root */\n+\tstruct path ns_root;\n+\tstruct path fs_root;\n+\tbool chrooted;\n+\n+\t/* Find the namespace root */\n+\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n+\tns_root.dentry = ns_root.mnt->mnt_root;\n+\tpath_get(&ns_root);\n+\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n+\t\t;\n+\n+\tget_fs_root(current->fs, &fs_root);\n+\n+\tchrooted = !path_equal(&fs_root, &ns_root);\n+\n+\tpath_put(&fs_root);\n+\tpath_put(&ns_root);\n+\n+\treturn chrooted;\n+}\n+\n static void *mntns_get(struct task_struct *task)\n {\n \tstruct mnt_namespace *ns = NULL;""}<_**next**_>{""sha"": ""2b93a9a5a1e6b8ef4a15a6aaf36ade3b48bd0d98"", ""filename"": ""include/linux/fs_struct.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs_struct.h?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -50,4 +50,6 @@ static inline void get_fs_root_and_pwd(struct fs_struct *fs, struct path *root,\n \tspin_unlock(&fs->lock);\n }\n \n+extern bool current_chrooted(void);\n+\n #endif /* _LINUX_FS_STRUCT_H */""}<_**next**_>{""sha"": ""0f1e42884577c93b891a7da6aa149733ba2d5141"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)\n \tkgid_t group = new->egid;\n \tint ret;\n \n+\t/*\n+\t * Verify that we can not violate the policy of which files\n+\t * may be accessed that is specified by the root directory,\n+\t * by verifing that the root directory is at the root of the\n+\t * mount namespace which allows all files to be accessed.\n+\t */\n+\tif (current_chrooted())\n+\t\treturn -EPERM;\n+\n \t/* The creator needs a mapping in the parent user namespace\n \t * or else we won't be able to reasonably tell userspace who\n \t * created a user_namespace.""}","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",C,"	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

",,,"@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)
 	kgid_t group = new->egid;
 	int ret;
 
+	/*
+	 * Verify that we can not violate the policy of which files
+	 * may be accessed that is specified by the root directory,
+	 * by verifing that the root directory is at the root of the
+	 * mount namespace which allows all files to be accessed.
+	 */
+	if (current_chrooted())
+		return -EPERM;
+
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.",linux,3151527ee007b73a0ebd296010f1c0454a919c7d,eddc0a3abff273842a94784d2d022bbc36dc9015,1,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Verify that we can not violate the policy of which files
//fix_flaw_line_below:
//	 * may be accessed that is specified by the root directory,
//fix_flaw_line_below:
//	 * by verifing that the root directory is at the root of the
//fix_flaw_line_below:
//	 * mount namespace which allows all files to be accessed.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (current_chrooted())
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",179269,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","The `create_user_ns` function is responsible for creating a new user namespace in a Linux kernel environment. It first checks if the user (identified by effective user ID and group ID) has the necessary mappings in the parent user namespace; if not, it returns a permission error. Upon successful validation, it allocates memory for the new user namespace and initializes its properties, including setting its parent, owner, and group. The function also allocates a unique identifier for the namespace and updates the credentials to associate the new namespace with the calling process, ultimately returning zero on success or an error code on failure.","The provided code defines a function that creates a new user namespace within a Linux kernel environment. It begins by verifying if the user has the necessary permissions in the parent namespace. If the user lacks these permissions, an error is returned. Upon successful validation, memory is allocated for the new namespace, and its properties are initialized, including linking it to the parent namespace and setting ownership details. Additionally, a unique identifier is generated for the namespace. Finally, the function updates the calling process's credentials to associate it with the newly created namespace, returning a success indicator or an error code as needed.","The vulnerability in the original code stemmed from the lack of verification to ensure that the calling process was not chrooted, which could allow it to bypass security policies related to file access. This oversight could potentially enable unauthorized users to create user namespaces and gain elevated privileges. The fixed code addresses this issue by introducing a check using the `current_chrooted()` function, which ensures that if the process is chrooted, it will return a permission error. This additional validation helps maintain the integrity of the namespace creation process and prevents exploitation of the system's security mechanisms.","The vulnerability in the original code arose from the absence of a check to determine if the calling process was operating within a chroot environment, which could allow unauthorized access to resources and the creation of user namespaces by unprivileged users. This oversight could lead to privilege escalation and security breaches. The fixed code rectifies this issue by implementing a verification step that ensures the process is not chrooted before proceeding with namespace creation. This additional validation strengthens the security of the namespace creation process, preventing potential exploitation of the system's access controls.","The vulnerability was fixed by adding a check using the `current_chrooted()` function at the beginning of the code. This new verification step ensures that if the calling process is chrooted, it will return a permission error, thus preventing unauthorized users from creating user namespaces. By enforcing this condition before proceeding with the existing checks for user and group mappings in the parent namespace, the code now effectively restricts namespace creation to processes that are not confined within a chroot environment. This enhancement significantly bolsters the security of the namespace creation process against potential privilege escalation attacks.","The vulnerability was addressed by introducing an initial verification step to check if the calling process is operating within a chroot environment. This additional check ensures that processes confined in such an environment cannot create user namespaces, thereby preventing unauthorized access and potential privilege escalation. By enforcing this restriction before any further validation regarding user and group mappings, the code now effectively safeguards the namespace creation process. This enhancement strengthens the overall security framework, ensuring that only appropriately privileged processes can create new namespaces, thus mitigating the risk of exploitation.","CWE-269, CWE-250, CWE-273, CWE-266, CWE-272, CWE-274, CWE-265, CWE-271, CWE-279, CWE-264",N,-1
26,26,179294,179294,,Local,Not required,Complete,CVE-2013-1774,https://www.cvedetails.com/cve/CVE-2013-1774/,CWE-264,High,,,,2013-02-28,4.0,The chase_port function in drivers/usb/serial/io_ti.c in the Linux kernel before 3.7.4 allows local users to cause a denial of service (NULL pointer dereference and system crash) via an attempted /dev/ttyUSB read or write operation on a disconnected Edgeport USB serial converter.,2019-04-22,DoS ,3,https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811,1ee0a224bc9aad1de496c795f96bc6ba2c394811,"USB: io_ti: Fix NULL dereference in chase_port()

The tty is NULL when the port is hanging up.
chase_port() needs to check for this.

This patch is intended for stable series.
The behavior was observed and tested in Linux 3.2 and 3.7.1.

Johan Hovold submitted a more elaborate patch for the mainline kernel.

[   56.277883] usb 1-1: edge_bulk_in_callback - nonzero read bulk status received: -84
[   56.278811] usb 1-1: USB disconnect, device number 3
[   56.278856] usb 1-1: edge_bulk_in_callback - stopping read!
[   56.279562] BUG: unable to handle kernel NULL pointer dereference at 00000000000001c8
[   56.280536] IP: [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.281212] PGD 1dc1b067 PUD 1e0f7067 PMD 0
[   56.282085] Oops: 0002 [#1] SMP
[   56.282744] Modules linked in:
[   56.283512] CPU 1
[   56.283512] Pid: 25, comm: khubd Not tainted 3.7.1 #1 innotek GmbH VirtualBox/VirtualBox
[   56.283512] RIP: 0010:[<ffffffff8144e62a>]  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512] RSP: 0018:ffff88001fa99ab0  EFLAGS: 00010046
[   56.283512] RAX: 0000000000000046 RBX: 00000000000001c8 RCX: 0000000000640064
[   56.283512] RDX: 0000000000010000 RSI: ffff88001fa99b20 RDI: 00000000000001c8
[   56.283512] RBP: ffff88001fa99b20 R08: 0000000000000000 R09: 0000000000000000
[   56.283512] R10: 0000000000000000 R11: ffffffff812fcb4c R12: ffff88001ddf53c0
[   56.283512] R13: 0000000000000000 R14: 00000000000001c8 R15: ffff88001e19b9f4
[   56.283512] FS:  0000000000000000(0000) GS:ffff88001fd00000(0000) knlGS:0000000000000000
[   56.283512] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[   56.283512] CR2: 00000000000001c8 CR3: 000000001dc51000 CR4: 00000000000006e0
[   56.283512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   56.283512] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[   56.283512] Process khubd (pid: 25, threadinfo ffff88001fa98000, task ffff88001fa94f80)
[   56.283512] Stack:
[   56.283512]  0000000000000046 00000000000001c8 ffffffff810578ec ffffffff812fcb4c
[   56.283512]  ffff88001e19b980 0000000000002710 ffffffff812ffe81 0000000000000001
[   56.283512]  ffff88001fa94f80 0000000000000202 ffffffff00000001 0000000000000296
[   56.283512] Call Trace:
[   56.283512]  [<ffffffff810578ec>] ? add_wait_queue+0x12/0x3c
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff812ffe81>] ? chase_port+0x84/0x2d6
[   56.283512]  [<ffffffff81063f27>] ? try_to_wake_up+0x199/0x199
[   56.283512]  [<ffffffff81263a5c>] ? tty_ldisc_hangup+0x222/0x298
[   56.283512]  [<ffffffff81300171>] ? edge_close+0x64/0x129
[   56.283512]  [<ffffffff810612f7>] ? __wake_up+0x35/0x46
[   56.283512]  [<ffffffff8106135b>] ? should_resched+0x5/0x23
[   56.283512]  [<ffffffff81264916>] ? tty_port_shutdown+0x39/0x44
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff8125d38c>] ? __tty_hangup+0x307/0x351
[   56.283512]  [<ffffffff812e6ddc>] ? usb_hcd_flush_endpoint+0xde/0xed
[   56.283512]  [<ffffffff8144e625>] ? _raw_spin_lock_irqsave+0x14/0x35
[   56.283512]  [<ffffffff812fd361>] ? usb_serial_disconnect+0x57/0xc2
[   56.283512]  [<ffffffff812ea99b>] ? usb_unbind_interface+0x5c/0x131
[   56.283512]  [<ffffffff8128d738>] ? __device_release_driver+0x7f/0xd5
[   56.283512]  [<ffffffff8128d9cd>] ? device_release_driver+0x1a/0x25
[   56.283512]  [<ffffffff8128d393>] ? bus_remove_device+0xd2/0xe7
[   56.283512]  [<ffffffff8128b7a3>] ? device_del+0x119/0x167
[   56.283512]  [<ffffffff812e8d9d>] ? usb_disable_device+0x6a/0x180
[   56.283512]  [<ffffffff812e2ae0>] ? usb_disconnect+0x81/0xe6
[   56.283512]  [<ffffffff812e4435>] ? hub_thread+0x577/0xe82
[   56.283512]  [<ffffffff8144daa7>] ? __schedule+0x490/0x4be
[   56.283512]  [<ffffffff8105798f>] ? abort_exclusive_wait+0x79/0x79
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff810570b4>] ? kthread+0x81/0x89
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512]  [<ffffffff8145387c>] ? ret_from_fork+0x7c/0xb0
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512] Code: 8b 7c 24 08 e8 17 0b c3 ff 48 8b 04 24 48 83 c4 10 c3 53 48 89 fb 41 50 e8 e0 0a c3 ff 48 89 04 24 e8 e7 0a c3 ff ba 00 00 01 00
<f0> 0f c1 13 48 8b 04 24 89 d1 c1 ea 10 66 39 d1 74 07 f3 90 66
[   56.283512] RIP  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512]  RSP <ffff88001fa99ab0>
[   56.283512] CR2: 00000000000001c8
[   56.283512] ---[ end trace 49714df27e1679ce ]---

Signed-off-by: Wolfgang Frisch <wfpub@roembden.net>
Cc: Johan Hovold <jhovold@gmail.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/usb/serial/io_ti.c,"{""sha"": ""82afc4d6a327d6bdbebc4707507684c966f11f9f"", ""filename"": ""drivers/usb/serial/io_ti.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/io_ti.c?ref=1ee0a224bc9aad1de496c795f96bc6ba2c394811"", ""patch"": ""@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,\n \twait_queue_t wait;\n \tunsigned long flags;\n \n+\tif (!tty)\n+\t\treturn;\n+\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n ""}","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",C,"	if (!tty)
		return;

",,,"@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,
 	wait_queue_t wait;
 	unsigned long flags;
 
+	if (!tty)
+		return;
+
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 ",linux,1ee0a224bc9aad1de496c795f96bc6ba2c394811,99beb2e9687ffd61c92a9875141eabe6f57a71b9,1,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!tty)
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",179294,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","The `chase_port` function manages the flushing and synchronization of data transmission for a USB serial port. It begins by determining a timeout period and initializing a wait queue to handle the current task's state. The function enters a loop where it checks if the write buffer is empty, if a timeout has occurred, if a signal is pending, or if the serial connection is disconnected. If any of these conditions are met, it breaks the loop. After flushing the write FIFO if specified, it waits for any remaining data to drain from the device, considering the baud rate for timing. Finally, it ensures proper cleanup and resource management.","The provided code manages the synchronization and flushing of data for a USB serial port. It begins by establishing a timeout period and setting up a mechanism to wait for the current task's state. The code enters a loop to monitor the write buffer, checking for conditions such as buffer emptiness, timeout, pending signals, or disconnection. If any condition is met, it exits the loop. After potentially flushing the buffer, it waits for any remaining data to be transmitted, taking into account the transmission speed. Finally, it ensures proper cleanup and resource management before completing the operation.","The vulnerability in the original code stemmed from the lack of a null pointer check for the `tty` variable, which could lead to dereferencing a null pointer if the `tty_port_tty_get` function failed. This could cause a crash or undefined behavior when attempting to access the `write_wait` queue. The fix introduced a check to ensure that `tty` is valid before proceeding with any operations that depend on it. By adding the condition `if (!tty) return;`, the code now safely exits if the pointer is null, thereby preventing potential crashes and enhancing overall stability.","The vulnerability in the original code arose from the absence of a check for a null pointer, which could lead to dereferencing an invalid memory address if a certain function call failed. This oversight could result in crashes or unpredictable behavior when the code attempted to access resources that were not properly initialized. The fix addressed this issue by introducing a validation step to ensure that the pointer was valid before proceeding with any operations that relied on it. This enhancement effectively prevents potential crashes and improves the robustness and stability of the code.","The vulnerability was fixed by adding a null pointer check for the `tty` variable immediately after it is assigned using the `tty_port_tty_get` function. The code now includes the condition `if (!tty) return;`, which ensures that if the `tty` pointer is null, the function exits early without attempting to access the `write_wait` queue or perform any further operations that depend on `tty`. This safeguard prevents potential crashes or undefined behavior caused by dereferencing a null pointer, thereby enhancing the overall stability and reliability of the code.","The vulnerability was addressed by implementing a validation step to check for a null pointer immediately after its assignment. This added condition ensures that if the pointer is not valid, the function will exit early, preventing any subsequent operations that rely on that pointer from being executed. By incorporating this safeguard, the code effectively avoids potential crashes or undefined behavior that could arise from dereferencing an invalid memory address. This enhancement significantly improves the robustness and stability of the code, ensuring that it handles error conditions more gracefully.","CWE-476, CWE-690, CWE-824, CWE-825, CWE-119, CWE-89, CWE-20, CWE-628, CWE-456, CWE-457",N,-1
27,27,179306,179306,,Local,Not required,,CVE-2013-0914,https://www.cvedetails.com/cve/CVE-2013-0914/,CWE-264,Low,Partial,Partial,,2013-03-22,3.6,"The flush_signal_handlers function in kernel/signal.c in the Linux kernel before 3.8.4 preserves the value of the sa_restorer field across an exec operation, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application containing a sigaction system call.",2014-02-06,Bypass ,3,https://github.com/torvalds/linux/commit/2ca39528c01a933f6689cd6505ce65bd6d68a530,2ca39528c01a933f6689cd6505ce65bd6d68a530,"signal: always clear sa_restorer on execve

When the new signal handlers are set up, the location of sa_restorer is
not cleared, leaking a parent process's address space location to
children.  This allows for a potential bypass of the parent's ASLR by
examining the sa_restorer value returned when calling sigaction().

Based on what should be considered ""secret"" about addresses, it only
matters across the exec not the fork (since the VMAs haven't changed
until the exec).  But since exec sets SIG_DFL and keeps sa_restorer,
this is where it should be fixed.

Given the few uses of sa_restorer, a ""set"" function was not written
since this would be the only use.  Instead, we use
__ARCH_HAS_SA_RESTORER, as already done in other places.

Example of the leak before applying this patch:

  $ cat /proc/$$/maps
  ...
  7fb9f3083000-7fb9f3238000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  $ ./leak
  ...
  7f278bc74000-7f278be29000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  1 0 (nil) 0x7fb9f30b94a0
  2 4000000 (nil) 0x7f278bcaa4a0
  3 4000000 (nil) 0x7f278bcaa4a0
  4 0 (nil) 0x7fb9f30b94a0
  ...

[akpm@linux-foundation.org: use SA_RESTORER for backportability]
Signed-off-by: Kees Cook <keescook@chromium.org>
Reported-by: Emese Revfy <re.emese@gmail.com>
Cc: Emese Revfy <re.emese@gmail.com>
Cc: PaX Team <pageexec@freemail.hu>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: Serge Hallyn <serge.hallyn@canonical.com>
Cc: Julien Tinnes <jln@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/signal.c,"{""sha"": ""43b0d4a1b7bace76e2dac9a87e2a2f6ab5efdf3e"", ""filename"": ""kernel/signal.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/signal.c?ref=2ca39528c01a933f6689cd6505ce65bd6d68a530"", ""patch"": ""@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n+#ifdef SA_RESTORER\n+\t\tka->sa.sa_restorer = NULL;\n+#endif\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}""}","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",C,"#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
",,,"@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
+#ifdef SA_RESTORER
+		ka->sa.sa_restorer = NULL;
+#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}",linux,2ca39528c01a933f6689cd6505ce65bd6d68a530,f8749452adcddd62e3707709ec2ae4856e70a3f2,1,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
//fix_flaw_line_below:
//#ifdef SA_RESTORER
//fix_flaw_line_below:
//		ka->sa.sa_restorer = NULL;
//fix_flaw_line_below:
//#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",179306,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","The `flush_signal_handlers` function resets the signal handlers for a given task (process) represented by the `task_struct` pointer `t`. It iterates through all possible signals, indicated by `_NSIG`, and for each signal, it checks if the `force_default` flag is set or if the current handler is not set to ignore the signal (`SIG_IGN`). If either condition is true, it assigns the default signal handler (`SIG_DFL`) to the signal. Additionally, it clears the signal flags and the signal mask for each handler, effectively restoring the default behavior for all signals associated with the task.","The provided code defines a function that resets the signal handling mechanisms for a specified process. It iterates through all defined signals and checks specific conditions to determine whether to revert the signal handler to its default state. If the conditions are met, the function assigns the default handler to the signal, clears any associated flags, and removes any signal masks. This effectively restores the process's signal handling to a standard configuration, ensuring that signals will be handled in a predefined manner, either by ignoring them or by executing the default actions when they occur.","The vulnerability in the original code arises from the lack of resetting the `sa_restorer` field in the signal action structure, which could lead to the execution of arbitrary code if a malicious user manages to manipulate the signal handler. By not clearing this field, the system could inadvertently invoke a potentially harmful function when a signal is received. The fixed code addresses this issue by explicitly setting `ka->sa.sa_restorer` to `NULL`, ensuring that any previously set restoration function is removed, thereby preventing unauthorized code execution and enhancing the overall security of the signal handling mechanism.","The vulnerability in the original code stems from the failure to reset a specific field associated with signal handling, which could allow an attacker to exploit the system by executing arbitrary code through a compromised signal handler. This oversight could lead to unintended behavior or privilege escalation if a malicious user manipulates the signal handling mechanism. The fixed code addresses this issue by explicitly clearing the problematic field, ensuring that any previously set restoration function is removed. This change enhances security by preventing unauthorized code execution and reinforcing the integrity of the signal handling process.","The vulnerability was fixed by adding a line in the updated code to explicitly set the `sa_restorer` field of the signal action structure to `NULL`. In the original code, this field was not reset, which could allow an attacker to exploit the signal handling mechanism by executing arbitrary code through a malicious signal handler. By including the line `ka->sa.sa_restorer = NULL` within the loop that processes each signal, the fixed code ensures that any previously assigned restoration function is cleared, thereby preventing unauthorized code execution and enhancing the overall security of the signal handling system.","The vulnerability was addressed by incorporating a mechanism to explicitly clear a specific field associated with signal handling that could potentially lead to the execution of arbitrary code. In the original implementation, this field was left unchanged, which posed a security risk if a malicious user manipulated the signal handler. The revised code ensures that this field is set to a safe state, effectively removing any previously assigned restoration function. This change prevents unauthorized code execution and strengthens the overall security of the signal handling process, thereby mitigating the risk of exploitation.","CWE-912, CWE-364, CWE-479, CWE-828, CWE-362, CWE-367, CWE-826, CWE-284, CWE-416, CWE-763",N,-1
28,28,179338,179338,,Local,Not required,Complete,CVE-2013-0268,https://www.cvedetails.com/cve/CVE-2013-0268/,CWE-264,High,Complete,Complete,,2013-02-17,6.2,"The msr_open function in arch/x86/kernel/msr.c in the Linux kernel before 3.7.6 allows local users to bypass intended capability restrictions by executing a crafted application as root, as demonstrated by msr32.c.",2013-08-22,Bypass ,3,https://github.com/torvalds/linux/commit/c903f0456bc69176912dee6dd25c6a66ee1aed00,c903f0456bc69176912dee6dd25c6a66ee1aed00,"x86/msr: Add capabilities check

At the moment the MSR driver only relies upon file system
checks. This means that anything as root with any capability set
can write to MSRs. Historically that wasn't very interesting but
on modern processors the MSRs are such that writing to them
provides several ways to execute arbitary code in kernel space.
Sample code and documentation on doing this is circulating and
MSR attacks are used on Windows 64bit rootkits already.

In the Linux case you still need to be able to open the device
file so the impact is fairly limited and reduces the security of
some capability and security model based systems down towards
that of a generic ""root owns the box"" setup.

Therefore they should require CAP_SYS_RAWIO to prevent an
elevation of capabilities. The impact of this is fairly minimal
on most setups because they don't have heavy use of
capabilities. Those using SELinux, SMACK or AppArmor rules might
want to consider if their rulesets on the MSR driver could be
tighter.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Horses <stable@kernel.org>
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,arch/x86/kernel/msr.c,"{""sha"": ""4929502c1372db979d7e1b176b22a9981e8ec96e"", ""filename"": ""arch/x86/kernel/msr.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/msr.c?ref=c903f0456bc69176912dee6dd25c6a66ee1aed00"", ""patch"": ""@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n+\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t/* No such CPU */""}","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

",,,"@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */",linux,c903f0456bc69176912dee6dd25c6a66ee1aed00,73b664ceb5f815c38def1c68912b83f83455e9eb,1,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",179338,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","The provided code defines a function `msr_open` that is responsible for opening a Model-Specific Register (MSR) file in a Linux kernel module. It first retrieves the CPU identifier from the file's inode and checks if the specified CPU is valid and online. If the CPU is either invalid or offline, it returns an error code `-ENXIO`. Next, it accesses the CPU's information and verifies if the CPU supports MSR functionality. If the CPU lacks this capability, it returns an error code `-EIO`. If all checks pass, the function returns 0, indicating successful opening of the MSR file.","The code defines a function that facilitates the opening of a specific hardware interface related to processor registers in a kernel module. It begins by identifying the processor associated with the requested file and checks whether this processor is valid and currently operational. If the processor is not valid or is offline, an appropriate error is returned. The function then verifies if the processor supports the required register functionality. If this support is absent, another error is returned. If all conditions are satisfied, the function indicates successful access to the hardware interface.","The vulnerability in the original code stemmed from the lack of permission checks before allowing access to sensitive hardware registers, which could be exploited by unauthorized users to manipulate system-level operations. The fixed code addresses this issue by introducing a permission check using the `capable(CAP_SYS_RAWIO)` function, which ensures that only processes with the appropriate capabilities can open the MSR interface. If the process lacks the necessary permissions, the function returns `-EPERM`, effectively preventing unauthorized access and enhancing the security of the system by safeguarding critical hardware interactions.","The vulnerability in the original code arose from the absence of permission checks, allowing any user to access sensitive hardware registers, which could lead to unauthorized manipulation of system operations. This lack of security could enable malicious users to exploit the interface, potentially compromising system integrity. The revised code rectifies this issue by implementing a permission verification step that restricts access to only those processes with the appropriate capabilities. By ensuring that only authorized users can interact with the hardware interface, the updated code significantly enhances the security posture of the system against unauthorized access.","The vulnerability was fixed by adding a permission check at the beginning of the function using `capable(CAP_SYS_RAWIO)`. This check ensures that only processes with the necessary capabilities can access the hardware interface for Model-Specific Registers. If a process lacks these permissions, the function immediately returns `-EPERM`, preventing unauthorized access. This modification effectively restricts the ability to open the MSR interface to privileged users, thereby safeguarding critical system operations from potential exploitation. The inclusion of this security measure significantly enhances the overall integrity and security of the system.","The vulnerability was addressed by incorporating a permission verification step at the start of the function, which restricts access to the sensitive hardware interface. This check ensures that only processes with the appropriate privileges can interact with the system's critical components. If a process does not possess the necessary permissions, the function promptly denies access, preventing unauthorized manipulation. This enhancement effectively mitigates the risk of exploitation by malicious users, thereby reinforcing the security of the system and ensuring that only authorized entities can perform operations that could impact system integrity.","CWE-269, CWE-732, CWE-264, CWE-284, CWE-285, CWE-862, CWE-668, CWE-287, CWE-266, CWE-250",N,-1
29,29,179381,179381,,Local,Not required,Complete,CVE-2011-4347,https://www.cvedetails.com/cve/CVE-2011-4347/,CWE-264,High,,,,2013-06-08,4.0,"The kvm_vm_ioctl_assign_device function in virt/kvm/assigned-dev.c in the KVM subsystem in the Linux kernel before 3.1.10 does not verify permission to access PCI configuration space and BAR resources, which allows host OS users to assign PCI devices and cause a denial of service (host OS crash) via a KVM_ASSIGN_PCI_DEVICE operation.",2013-06-10,DoS ,13,https://github.com/torvalds/linux/commit/c4e7f9022e506c6635a5037713c37118e23193e4,c4e7f9022e506c6635a5037713c37118e23193e4,"KVM: Device assignment permission checks

(cherry picked from commit 3d27e23b17010c668db311140b17bbbb70c78fb9)

Only allow KVM device assignment to attach to devices which:

 - Are not bridges
 - Have BAR resources (assume others are special devices)
 - The user has permissions to use

Assigning a bridge is a configuration error, it's not supported, and
typically doesn't result in the behavior the user is expecting anyway.
Devices without BAR resources are typically chipset components that
also don't have host drivers.  We don't want users to hold such devices
captive or cause system problems by fencing them off into an iommu
domain.  We determine ""permission to use"" by testing whether the user
has access to the PCI sysfs resource files.  By default a normal user
will not have access to these files, so it provides a good indication
that an administration agent has granted the user access to the device.

[Yang Bai: add missing #include]
[avi: fix comment style]

Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Yang Bai <hamo.by@gmail.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>",0,virt/kvm/assigned-dev.c,"{""sha"": ""13ab8379b4eb0e9a3665954b917feccf3560769f"", ""filename"": ""Documentation/virtual/kvm/api.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/virtual/kvm/api.txt?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -1134,6 +1134,10 @@ following flags are specified:\n The KVM_DEV_ASSIGN_ENABLE_IOMMU flag is a mandatory option to ensure\n isolation of the device.  Usages not specifying this flag are deprecated.\n \n+Only PCI header type 0 devices with PCI BAR resources are supported by\n+device assignment.  The user requesting this ioctl must have read/write\n+access to the PCI sysfs resource files associated with the device.\n+\n 4.49 KVM_DEASSIGN_PCI_DEVICE\n \n Capability: KVM_CAP_DEVICE_DEASSIGNMENT""}<_**next**_>{""sha"": ""af7910228fb1c31eb00dfb1734d7b019ddf87b2d"", ""filename"": ""virt/kvm/assigned-dev.c"", ""status"": ""modified"", ""additions"": 75, ""deletions"": 0, ""changes"": 75, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/virt/kvm/assigned-dev.c?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -17,6 +17,8 @@\n #include <linux/pci.h>\n #include <linux/interrupt.h>\n #include <linux/slab.h>\n+#include <linux/namei.h>\n+#include <linux/fs.h>\n #include \""irq.h\""\n \n static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n \treturn r;\n }\n \n+/*\n+ * We want to test whether the caller has been granted permissions to\n+ * use this device.  To be able to configure and control the device,\n+ * the user needs access to PCI configuration space and BAR resources.\n+ * These are accessed through PCI sysfs.  PCI config space is often\n+ * passed to the process calling this ioctl via file descriptor, so we\n+ * can't rely on access to that file.  We can check for permissions\n+ * on each of the BAR resource files, which is a pretty clear\n+ * indicator that the user has been granted access to the device.\n+ */\n+static int probe_sysfs_permissions(struct pci_dev *dev)\n+{\n+#ifdef CONFIG_SYSFS\n+\tint i;\n+\tbool bar_found = false;\n+\n+\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n+\t\tchar *kpath, *syspath;\n+\t\tstruct path path;\n+\t\tstruct inode *inode;\n+\t\tint r;\n+\n+\t\tif (!pci_resource_len(dev, i))\n+\t\t\tcontinue;\n+\n+\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n+\t\tif (!kpath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\t/* Per sysfs-rules, sysfs is always at /sys */\n+\t\tsyspath = kasprintf(GFP_KERNEL, \""/sys%s/resource%d\"", kpath, i);\n+\t\tkfree(kpath);\n+\t\tif (!syspath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n+\t\tkfree(syspath);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tinode = path.dentry->d_inode;\n+\n+\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n+\t\tpath_put(&path);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tbar_found = true;\n+\t}\n+\n+\t/* If no resources, probably something special */\n+\tif (!bar_found)\n+\t\treturn -EPERM;\n+\n+\treturn 0;\n+#else\n+\treturn -EINVAL; /* No way to control the device without sysfs */\n+#endif\n+}\n+\n static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n {\n \tint r = 0, idx;\n \tstruct kvm_assigned_dev_kernel *match;\n \tstruct pci_dev *dev;\n+\tu8 header_type;\n \n \tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n \t\treturn -EINVAL;\n@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\tr = -EINVAL;\n \t\tgoto out_free;\n \t}\n+\n+\t/* Don't allow bridges to be assigned */\n+\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n+\tif ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {\n+\t\tr = -EPERM;\n+\t\tgoto out_put;\n+\t}\n+\n+\tr = probe_sysfs_permissions(dev);\n+\tif (r)\n+\t\tgoto out_put;\n+\n \tif (pci_enable_device(dev)) {\n \t\tprintk(KERN_INFO \""%s: Could not enable PCI device\\n\"", __func__);\n \t\tr = -EBUSY;""}"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",C,"	u8 header_type;

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

",,,"@@ -17,6 +17,8 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/namei.h>
+#include <linux/fs.h>
 #include ""irq.h""
 
 static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,
@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,
 	return r;
 }
 
+/*
+ * We want to test whether the caller has been granted permissions to
+ * use this device.  To be able to configure and control the device,
+ * the user needs access to PCI configuration space and BAR resources.
+ * These are accessed through PCI sysfs.  PCI config space is often
+ * passed to the process calling this ioctl via file descriptor, so we
+ * can't rely on access to that file.  We can check for permissions
+ * on each of the BAR resource files, which is a pretty clear
+ * indicator that the user has been granted access to the device.
+ */
+static int probe_sysfs_permissions(struct pci_dev *dev)
+{
+#ifdef CONFIG_SYSFS
+	int i;
+	bool bar_found = false;
+
+	for (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {
+		char *kpath, *syspath;
+		struct path path;
+		struct inode *inode;
+		int r;
+
+		if (!pci_resource_len(dev, i))
+			continue;
+
+		kpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
+		if (!kpath)
+			return -ENOMEM;
+
+		/* Per sysfs-rules, sysfs is always at /sys */
+		syspath = kasprintf(GFP_KERNEL, ""/sys%s/resource%d"", kpath, i);
+		kfree(kpath);
+		if (!syspath)
+			return -ENOMEM;
+
+		r = kern_path(syspath, LOOKUP_FOLLOW, &path);
+		kfree(syspath);
+		if (r)
+			return r;
+
+		inode = path.dentry->d_inode;
+
+		r = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);
+		path_put(&path);
+		if (r)
+			return r;
+
+		bar_found = true;
+	}
+
+	/* If no resources, probably something special */
+	if (!bar_found)
+		return -EPERM;
+
+	return 0;
+#else
+	return -EINVAL; /* No way to control the device without sysfs */
+#endif
+}
+
 static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
+	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;
@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 		r = -EINVAL;
 		goto out_free;
 	}
+
+	/* Don't allow bridges to be assigned */
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
+	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
+		r = -EPERM;
+		goto out_put;
+	}
+
+	r = probe_sysfs_permissions(dev);
+	if (r)
+		goto out_put;
+
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;",linux,c4e7f9022e506c6635a5037713c37118e23193e4,4fd9e326e5001982747225f0f7bb462e34ae9215,1," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
//fix_flaw_line_below:
//	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't allow bridges to be assigned */
//fix_flaw_line_below:
//	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
//fix_flaw_line_below:
//	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
//fix_flaw_line_below:
//		r = -EPERM;
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	r = probe_sysfs_permissions(dev);
//fix_flaw_line_below:
//	if (r)
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",179381," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
","The provided code defines a function `kvm_vm_ioctl_assign_device` that manages the assignment of a PCI device to a KVM (Kernel-based Virtual Machine) instance. It first checks if IOMMU support is enabled and acquires necessary locks for thread safety. The function searches for an existing assigned device and, if not found, allocates memory for a new device structure. It retrieves the specified PCI device, enables it, and requests access to its regions. The device's state is saved, and it is added to the KVM's assigned device list. If IOMMU mapping is required, it is performed, and the device is assigned to the KVM. Error handling is implemented throughout to manage resource allocation and device state.","The code implements a function that facilitates the assignment of a PCI device to a virtual machine within a virtualization framework. It begins by verifying the necessary support for device assignment and acquires locks to ensure thread safety. The function checks for existing device assignments and allocates memory for a new device structure if none is found. It retrieves and enables the specified PCI device, requests access to its resources, and saves its state. The device is then added to the virtual machine's list of assigned devices, with appropriate error handling to manage resource allocation and device state throughout the process.","The vulnerability in the original code stemmed from the lack of validation for the type of PCI device being assigned, which could allow the assignment of devices like bridges that should not be assigned to a virtual machine. This oversight could lead to improper resource management and potential system instability. The fixed code addresses this by introducing a check that reads the device's header type and ensures it is a normal device type before proceeding with the assignment. If the device is not a normal type, the function returns an error, thereby preventing the assignment of inappropriate devices and enhancing overall system security.","The vulnerability in the original code arose from the absence of checks to prevent the assignment of inappropriate PCI devices, such as bridges, which could lead to system instability and resource mismanagement. This oversight allowed potentially harmful devices to be assigned to a virtual machine, compromising the integrity of the virtualization environment. The fixed code rectifies this issue by implementing a validation step that verifies the type of the PCI device before assignment. If the device is deemed unsuitable, the function returns an error, thereby safeguarding the system from improper device assignments and enhancing overall security.","The vulnerability was fixed by adding a validation check for the type of PCI device being assigned. Specifically, the code now reads the device's header type using a configuration read operation. If the header type indicates that the device is not a normal type, the function returns an error code, preventing the assignment of unsuitable devices like bridges. This check is implemented before enabling the device and requesting its regions, ensuring that only appropriate devices are processed further. This enhancement effectively mitigates the risk of system instability and resource mismanagement associated with improper device assignments.","The vulnerability was addressed by introducing a validation step that checks the type of PCI device before it can be assigned. This new check ensures that only devices classified as normal types are eligible for assignment, effectively preventing the assignment of inappropriate devices, such as bridges, which could lead to system instability. By implementing this safeguard early in the process, the code now returns an error if an unsuitable device is detected, thereby enhancing the overall security and reliability of the virtualization environment and ensuring proper resource management.","CWE-20, CWE-436, CWE-665, CWE-754, CWE-1286, CWE-669, CWE-841, CWE-749, CWE-288, CWE-682",N,-1
30,30,179406,179406,,Local,Not required,,CVE-2011-1019,https://www.cvedetails.com/cve/CVE-2011-1019/,CWE-264,Medium,,Partial,,2013-03-01,1.9,The dev_load function in net/core/dev.c in the Linux kernel before 2.6.38 allows local users to bypass an intended CAP_SYS_MODULE capability requirement and load arbitrary modules by leveraging the CAP_NET_ADMIN capability.,2013-03-04,Bypass ,10,https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b,8909c9ad8ff03611c9c96c9a92656213e4bb495b,"net: don't allow CAP_NET_ADMIN to load non-netdev kernel modules

Since a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with
CAP_NET_ADMIN may load any module from /lib/modules/.  This doesn't mean
that CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are
limited to /lib/modules/**.  However, CAP_NET_ADMIN capability shouldn't
allow anybody load any module not related to networking.

This patch restricts an ability of autoloading modules to netdev modules
with explicit aliases.  This fixes CVE-2011-1019.

Arnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior
of loading netdev modules by name (without any prefix) for processes
with CAP_SYS_MODULE to maintain the compatibility with network scripts
that use autoloading netdev modules by aliases like ""eth0"", ""wlan0"".

Currently there are only three users of the feature in the upstream
kernel: ipip, ip_gre and sit.

    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --
    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	fffffff800001000
    CapEff:	fffffff800001000
    CapBnd:	fffffff800001000
    root@albatros:~# modprobe xfs
    FATAL: Error inserting xfs
    (/lib/modules/2.6.38-rc6-00001-g2bf4ca3/kernel/fs/xfs/xfs.ko): Operation not permitted
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit
    sit: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit0
    sit0      Link encap:IPv6-in-IPv4
	      NOARP  MTU:1480  Metric:1

    root@albatros:~# lsmod | grep sit
    sit                    10457  0
    tunnel4                 2957  1 sit

For CAP_SYS_MODULE module loading is still relaxed:

    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	ffffffffffffffff
    CapEff:	ffffffffffffffff
    CapBnd:	ffffffffffffffff
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    xfs                   745319  0

Reference: https://lkml.org/lkml/2011/2/24/203

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
Acked-by: David S. Miller <davem@davemloft.net>
Acked-by: Kees Cook <kees.cook@canonical.com>
Signed-off-by: James Morris <jmorris@namei.org>",2,net/core/dev.c,"{""sha"": ""71caf7a5e6c6cc59fd975f06a0ce6bb304288d52"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -2392,6 +2392,9 @@ extern int netdev_notice(const struct net_device *dev, const char *format, ...)\n extern int netdev_info(const struct net_device *dev, const char *format, ...)\n \t__attribute__ ((format (printf, 2, 3)));\n \n+#define MODULE_ALIAS_NETDEV(device) \\\n+\tMODULE_ALIAS(\""netdev-\"" device)\n+\n #if defined(DEBUG)\n #define netdev_dbg(__dev, format, args...)\t\t\t\\\n \tnetdev_printk(KERN_DEBUG, __dev, format, ##args)""}<_**next**_>{""sha"": ""6561021d22d1fef9b58ec54ec2b394400fb7ba25"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);\n void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n+\tint no_module;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n-\tif (!dev && capable(CAP_NET_ADMIN))\n-\t\trequest_module(\""%s\"", name);\n+\tno_module = !dev;\n+\tif (no_module && capable(CAP_NET_ADMIN))\n+\t\tno_module = request_module(\""netdev-%s\"", name);\n+\tif (no_module && capable(CAP_SYS_MODULE)) {\n+\t\tif (!request_module(\""%s\"", name))\n+\t\t\tpr_err(\""Loading kernel module for a network device \""\n+\""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \""\n+\""instead\\n\"", name);\n+\t}\n }\n EXPORT_SYMBOL(dev_load);\n ""}<_**next**_>{""sha"": ""d1d0e2c256fc4080033a01a621f73b1c3b080b7e"", ""filename"": ""net/ipv4/ip_gre.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_gre.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1765,4 +1765,4 @@ module_exit(ipgre_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_ALIAS_RTNL_LINK(\""gre\"");\n MODULE_ALIAS_RTNL_LINK(\""gretap\"");\n-MODULE_ALIAS(\""gre0\"");\n+MODULE_ALIAS_NETDEV(\""gre0\"");""}<_**next**_>{""sha"": ""a5f58e7cbb26eec188786ff1324cfc540aba1ce1"", ""filename"": ""net/ipv4/ipip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ipip.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -913,4 +913,4 @@ static void __exit ipip_fini(void)\n module_init(ipip_init);\n module_exit(ipip_fini);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""tunl0\"");\n+MODULE_ALIAS_NETDEV(\""tunl0\"");""}<_**next**_>{""sha"": ""d2c16e10f650807ec32cc0502efa32cea8bc93b6"", ""filename"": ""net/ipv6/sit.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/sit.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1290,4 +1290,4 @@ static int __init sit_init(void)\n module_init(sit_init);\n module_exit(sit_cleanup);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""sit0\"");\n+MODULE_ALIAS_NETDEV(\""sit0\"");""}"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
",C,"	int no_module;
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
","	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
",,"@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);
 void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
+	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
-	if (!dev && capable(CAP_NET_ADMIN))
-		request_module(""%s"", name);
+	no_module = !dev;
+	if (no_module && capable(CAP_NET_ADMIN))
+		no_module = request_module(""netdev-%s"", name);
+	if (no_module && capable(CAP_SYS_MODULE)) {
+		if (!request_module(""%s"", name))
+			pr_err(""Loading kernel module for a network device ""
+""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
+""instead\n"", name);
+	}
 }
 EXPORT_SYMBOL(dev_load);
 ",linux,8909c9ad8ff03611c9c96c9a92656213e4bb495b,a5abba989deceb731047425812d268daf7536575,1," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
//fix_flaw_line_below:
//	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
//flaw_line_below:
	if (!dev && capable(CAP_NET_ADMIN))
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//	no_module = !dev;
//fix_flaw_line_below:
//	if (no_module && capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//		no_module = request_module(""netdev-%s"", name);
//fix_flaw_line_below:
//	if (no_module && capable(CAP_SYS_MODULE)) {
//fix_flaw_line_below:
//		if (!request_module(""%s"", name))
//fix_flaw_line_below:
//			pr_err(""Loading kernel module for a network device ""
//fix_flaw_line_below:
//""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
//fix_flaw_line_below:
//""instead\n"", name);
//fix_flaw_line_below:
//	}
 }
",179406," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
","The provided code defines a function `dev_load` that attempts to retrieve a network device by its name within a specified network namespace. It first acquires a read lock using `rcu_read_lock()` to ensure safe access to shared data structures, then calls `dev_get_by_name_rcu()` to find the device. After releasing the lock with `rcu_read_unlock()`, it checks if the device was not found. If the device is absent and the calling process has administrative privileges (checked via `capable(CAP_NET_ADMIN)`), it requests the loading of the corresponding kernel module using `request_module()`.","The code defines a function that attempts to locate a network device within a specified network context based on its name. It ensures safe access to shared data by acquiring a read lock before searching for the device. After releasing the lock, it checks if the device was found. If the device is not present and the calling entity has the necessary administrative permissions, the function initiates a request to load the appropriate kernel module associated with the device. This process allows for dynamic loading of network devices as needed, enhancing system flexibility and resource management.","The vulnerability in the original code arises from the potential for unauthorized module loading when a network device is not found. Specifically, if the device is absent and the calling entity has administrative capabilities, it could request the module without proper checks, leading to security risks. In the fixed code, an additional check is introduced with the `no_module` variable, which first verifies if the device is absent. It also differentiates between two privilege levels: `CAP_NET_ADMIN` for loading a device-specific module and `CAP_SYS_MODULE` for a deprecated method, thus enhancing security by enforcing stricter controls on module loading.","The vulnerability in the original code stems from the lack of sufficient checks before loading a kernel module when a network device is not found. This could allow unauthorized users with administrative privileges to load arbitrary modules, potentially compromising system security. The revised code addresses this issue by introducing a mechanism to differentiate between two levels of administrative capabilities, enforcing stricter conditions for module loading. It ensures that only specific modules can be requested based on the context, thereby reducing the risk of unauthorized access and enhancing overall system integrity by requiring appropriate permissions for different actions.","The vulnerability was fixed by introducing a new variable, `no_module`, which checks if the device was not found after the initial search. In the revised code, if `no_module` is true and the calling entity has the `CAP_NET_ADMIN` capability, it attempts to load a device-specific module using a safer request format. Additionally, if the device is still not found and the entity has `CAP_SYS_MODULE`, it issues a warning when loading a module using the deprecated method, prompting the user to use the new approach. This layered checking enhances security by enforcing stricter controls on module loading.","The vulnerability was addressed by implementing a more robust checking mechanism before allowing the loading of kernel modules. The revised code introduces a conditional structure that first verifies whether the network device is absent. It then distinguishes between two levels of administrative privileges, ensuring that only specific modules can be requested based on the context. Additionally, a warning is issued if an outdated method is used for module loading, guiding users toward the preferred approach. This layered approach enhances security by preventing unauthorized module loading and enforcing stricter controls on administrative actions.","CWE-269,CWE-264,CWE-272,CWE-732,CWE-250,CWE-284,CWE-693,CWE-269,CWE-285,CWE-266",Y,2
31,31,179455,179455,,Local,Not required,Complete,CVE-2014-5206,https://www.cvedetails.com/cve/CVE-2014-5206/,CWE-264,Low,Complete,Complete,,2014-08-18,7.2,"The do_remount function in fs/namespace.c in the Linux kernel through 3.16.1 does not maintain the MNT_LOCK_READONLY bit across a remount of a bind mount, which allows local users to bypass an intended read-only restriction and defeat certain sandbox protection mechanisms via a *mount -o remount* command within a user namespace.",2017-01-06,Bypass ,1,https://github.com/torvalds/linux/commit/a6138db815df5ee542d848318e5dae681590fccd,a6138db815df5ee542d848318e5dae681590fccd,"mnt: Only change user settable mount flags in remount

Kenton Varda <kenton@sandstorm.io> discovered that by remounting a
read-only bind mount read-only in a user namespace the
MNT_LOCK_READONLY bit would be cleared, allowing an unprivileged user
to the remount a read-only mount read-write.

Correct this by replacing the mask of mount flags to preserve
with a mask of mount flags that may be changed, and preserve
all others.   This ensures that any future bugs with this mask and
remount will fail in an easy to detect way where new mount flags
simply won't change.

Cc: stable@vger.kernel.org
Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",1,fs/namespace.c,"{""sha"": ""cb40449ea0dfe8983d45162ef724c45898d2424a"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n-\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n+\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();""}<_**next**_>{""sha"": ""b637a89e1faeb271af0ab5e850e47fdf9d8f487c"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -42,7 +42,9 @@ struct mnt_namespace;\n  * flag, consider how it interacts with shared mounts.\n  */\n #define MNT_SHARED_MASK\t(MNT_UNBINDABLE)\n-#define MNT_PROPAGATION_MASK\t(MNT_SHARED | MNT_UNBINDABLE)\n+#define MNT_USER_SETTABLE_MASK  (MNT_NOSUID | MNT_NODEV | MNT_NOEXEC \\\n+\t\t\t\t | MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME \\\n+\t\t\t\t | MNT_READONLY)\n \n #define MNT_INTERNAL_FLAGS (MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \\\n \t\t\t    MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED)""}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",C,"		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
","		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
",,"@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
-		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
+		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();",linux,a6138db815df5ee542d848318e5dae681590fccd,728dba3a39c66b3d8ac889ddbe38b5b1c264aec3,1,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
//flaw_line_below:
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
//fix_flaw_line_below:
//		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",179455,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","The provided code defines a function `do_remount` that handles the remounting of a filesystem in a Linux kernel context. It first verifies the validity of the mount and checks if the specified path corresponds to the root of the mount. The function then performs a security check before acquiring a write lock on the superblock. Depending on the flags provided, it either changes the mount flags or checks for administrative permissions. If successful, it updates the mount's flags, touches the mount namespace, and releases the lock, returning any errors encountered during the process.","The code implements a function that manages the remounting of a filesystem within a kernel environment. It begins by validating the mount and ensuring the specified path is the root of the mount. Following a security verification, it acquires a write lock on the filesystem's control structure. Depending on the provided options, it either modifies the mount settings or checks for the necessary administrative permissions. If the operation is successful, it updates the mount's attributes, refreshes the associated namespace, and then releases the lock, ultimately returning any errors encountered during the process.","The vulnerability in the original code stemmed from the potential for unauthorized modification of mount flags, specifically allowing users to change settings that should only be adjustable by privileged users. This was addressed in the fixed code by altering the line that updates the mount flags. The fix ensures that only flags not included in the user-settable mask are retained, effectively preventing unprivileged users from altering critical mount attributes. By applying the bitwise AND operation with the negation of the user-settable mask, the code now restricts modifications to only those flags that are safe and appropriate for the current user’s permissions.","The vulnerability in the original code allowed unauthorized users to modify critical filesystem mount flags, potentially leading to privilege escalation or system instability. This issue arose because the code did not adequately restrict which flags could be changed by unprivileged users. The fix implemented a safeguard by ensuring that only specific flags, which are deemed safe for modification, could be altered. By applying a mask to the flags being set, the revised code effectively prevents unauthorized changes, thereby enhancing the security of the filesystem remounting process and ensuring that only privileged users can make sensitive modifications.","The vulnerability was fixed by modifying the line that updates the mount flags to include a bitwise operation that masks out user-settable flags. Specifically, the code now uses `mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK`, which ensures that only flags not included in the user-settable mask can be modified. This change restricts the ability of unprivileged users to alter critical mount attributes, thereby preventing unauthorized modifications. By enforcing this restriction, the code enhances the security of the remounting process, ensuring that only appropriate flags are retained and modified by users with the necessary permissions.","The vulnerability was addressed by implementing a safeguard that restricts which filesystem mount flags can be modified by users. The fix involved applying a bitwise operation that effectively filters out flags that should only be adjustable by privileged users. This ensures that only safe and appropriate flags can be altered during the remounting process, preventing unauthorized changes that could lead to privilege escalation or system instability. By enforcing this restriction, the code enhances the overall security of the filesystem, ensuring that sensitive attributes remain protected from unprivileged access.","CWE-269, CWE-264, CWE-732, CWE-284, CWE-266, CWE-285, CWE-279, CWE-250, CWE-265, CWE-639",N,-1
32,32,179487,179487,,Local Network,Single system,,CVE-2014-4027,https://www.cvedetails.com/cve/CVE-2014-4027/,CWE-264,Medium,Partial,,,2014-06-23,2.3,"The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator.",2017-01-06,+Info ,50,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,"target/rd: Refactor rd_build_device_space + rd_release_device_space

This patch refactors rd_build_device_space() + rd_release_device_space()
into rd_allocate_sgl_table() + rd_release_device_space() so that they
may be used seperatly for setup + release of protection information
scatterlists.

Also add explicit memset of pages within rd_allocate_sgl_table() based
upon passed 'init_payload' value.

v2 changes:
  - Drop unused sg_table from rd_release_device_space (Wei)

Cc: Martin K. Petersen <martin.petersen@oracle.com>
Cc: Christoph Hellwig <hch@lst.de>
Cc: Hannes Reinecke <hare@suse.de>
Cc: Sagi Grimberg <sagig@mellanox.com>
Cc: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",23,drivers/target/target_core_rd.c,"{""sha"": ""e9fa879ac27f31f5cbdd61fecf29c4095b366b50"", ""filename"": ""drivers/target/target_core_rd.c"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 45, ""changes"": 113, ""blob_url"": ""https://github.com/torvalds/linux/blob/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/target/target_core_rd.c?ref=4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc"", ""patch"": ""@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)\n \thba->hba_ptr = NULL;\n }\n \n-/*\trd_release_device_space():\n- *\n- *\n- */\n-static void rd_release_device_space(struct rd_dev *rd_dev)\n+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 sg_table_count)\n {\n-\tu32 i, j, page_count = 0, sg_per_table;\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n+\tu32 i, j, page_count = 0, sg_per_table;\n \n-\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n-\t\treturn;\n-\n-\tsg_table = rd_dev->sg_table_array;\n-\n-\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n+\tfor (i = 0; i < sg_table_count; i++) {\n \t\tsg = sg_table[i].sg_table;\n \t\tsg_per_table = sg_table[i].rd_sg_count;\n \n@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n \t\t\t\tpage_count++;\n \t\t\t}\n \t\t}\n-\n \t\tkfree(sg);\n \t}\n \n+\tkfree(sg_table);\n+\treturn page_count;\n+}\n+\n+static void rd_release_device_space(struct rd_dev *rd_dev)\n+{\n+\tu32 page_count;\n+\n+\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n+\t\treturn;\n+\n+\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n+\t\t\t\t\t  rd_dev->sg_table_count);\n+\n \tpr_debug(\""CORE_RD[%u] - Released device space for Ramdisk\""\n \t\t\"" Device ID: %u, pages %u in %u tables total bytes %lu\\n\"",\n \t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n \t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n \n-\tkfree(sg_table);\n \trd_dev->sg_table_array = NULL;\n \trd_dev->sg_table_count = 0;\n }\n@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n  *\n  *\n  */\n-static int rd_build_device_space(struct rd_dev *rd_dev)\n+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n {\n-\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n+\tu32 i = 0, j, page_offset = 0, sg_per_table;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n-\n-\tif (rd_dev->rd_page_count <= 0) {\n-\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n-\t\t\trd_dev->rd_page_count);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\t/* Don't need backing pages for NULLIO */\n-\tif (rd_dev->rd_flags & RDF_NULLIO)\n-\t\treturn 0;\n-\n-\ttotal_sg_needed = rd_dev->rd_page_count;\n-\n-\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n-\n-\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n-\tif (!sg_table) {\n-\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n-\t\t\t\"" scatterlist tables\\n\"");\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\trd_dev->sg_table_array = sg_table;\n-\trd_dev->sg_table_count = sg_tables;\n+\tunsigned char *p;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n+\n+\t\t\tp = kmap(pg);\n+\t\t\tmemset(p, init_payload, PAGE_SIZE);\n+\t\t\tkunmap(pg);\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n+\treturn 0;\n+}\n+\n+static int rd_build_device_space(struct rd_dev *rd_dev)\n+{\n+\tstruct rd_dev_sg_table *sg_table;\n+\tu32 sg_tables, total_sg_needed;\n+\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n+\t\t\t\tsizeof(struct scatterlist));\n+\tint rc;\n+\n+\tif (rd_dev->rd_page_count <= 0) {\n+\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n+\t\t       rd_dev->rd_page_count);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t/* Don't need backing pages for NULLIO */\n+\tif (rd_dev->rd_flags & RDF_NULLIO)\n+\t\treturn 0;\n+\n+\ttotal_sg_needed = rd_dev->rd_page_count;\n+\n+\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n+\n+\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n+\tif (!sg_table) {\n+\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n+\t\t       \"" scatterlist tables\\n\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\trd_dev->sg_table_array = sg_table;\n+\trd_dev->sg_table_count = sg_tables;\n+\n+\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n+\tif (rc)\n+\t\treturn rc;\n+\n \tpr_debug(\""CORE_RD[%u] - Built Ramdisk Device ID: %u space of\""\n-\t\t\"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n-\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n-\t\trd_dev->sg_table_count);\n+\t\t \"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n+\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n+\t\t rd_dev->sg_table_count);\n \n \treturn 0;\n }""}","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
",C,"static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
	u32 i = 0, j, page_offset = 0, sg_per_table;
	unsigned char *p;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
","	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
	struct rd_dev_sg_table *sg_table;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
",,"@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)
 	hba->hba_ptr = NULL;
 }
 
-/*	rd_release_device_space():
- *
- *
- */
-static void rd_release_device_space(struct rd_dev *rd_dev)
+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 sg_table_count)
 {
-	u32 i, j, page_count = 0, sg_per_table;
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
+	u32 i, j, page_count = 0, sg_per_table;
 
-	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
-		return;
-
-	sg_table = rd_dev->sg_table_array;
-
-	for (i = 0; i < rd_dev->sg_table_count; i++) {
+	for (i = 0; i < sg_table_count; i++) {
 		sg = sg_table[i].sg_table;
 		sg_per_table = sg_table[i].rd_sg_count;
 
@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
 				page_count++;
 			}
 		}
-
 		kfree(sg);
 	}
 
+	kfree(sg_table);
+	return page_count;
+}
+
+static void rd_release_device_space(struct rd_dev *rd_dev)
+{
+	u32 page_count;
+
+	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
+		return;
+
+	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,
+					  rd_dev->sg_table_count);
+
 	pr_debug(""CORE_RD[%u] - Released device space for Ramdisk""
 		"" Device ID: %u, pages %u in %u tables total bytes %lu\n"",
 		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
 		rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
 
-	kfree(sg_table);
 	rd_dev->sg_table_array = NULL;
 	rd_dev->sg_table_count = 0;
 }
@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
  *
  *
  */
-static int rd_build_device_space(struct rd_dev *rd_dev)
+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 total_sg_needed, unsigned char init_payload)
 {
-	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
+	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
-
-	if (rd_dev->rd_page_count <= 0) {
-		pr_err(""Illegal page count: %u for Ramdisk device\n"",
-			rd_dev->rd_page_count);
-		return -EINVAL;
-	}
-
-	/* Don't need backing pages for NULLIO */
-	if (rd_dev->rd_flags & RDF_NULLIO)
-		return 0;
-
-	total_sg_needed = rd_dev->rd_page_count;
-
-	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
-
-	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
-	if (!sg_table) {
-		pr_err(""Unable to allocate memory for Ramdisk""
-			"" scatterlist tables\n"");
-		return -ENOMEM;
-	}
-
-	rd_dev->sg_table_array = sg_table;
-	rd_dev->sg_table_count = sg_tables;
+	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
+
+			p = kmap(pg);
+			memset(p, init_payload, PAGE_SIZE);
+			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
+	return 0;
+}
+
+static int rd_build_device_space(struct rd_dev *rd_dev)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 sg_tables, total_sg_needed;
+	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+	int rc;
+
+	if (rd_dev->rd_page_count <= 0) {
+		pr_err(""Illegal page count: %u for Ramdisk device\n"",
+		       rd_dev->rd_page_count);
+		return -EINVAL;
+	}
+
+	/* Don't need backing pages for NULLIO */
+	if (rd_dev->rd_flags & RDF_NULLIO)
+		return 0;
+
+	total_sg_needed = rd_dev->rd_page_count;
+
+	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
+
+	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
+	if (!sg_table) {
+		pr_err(""Unable to allocate memory for Ramdisk""
+		       "" scatterlist tables\n"");
+		return -ENOMEM;
+	}
+
+	rd_dev->sg_table_array = sg_table;
+	rd_dev->sg_table_count = sg_tables;
+
+	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
+	if (rc)
+		return rc;
+
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
-		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
-		rd_dev->rd_dev_id, rd_dev->rd_page_count,
-		rd_dev->sg_table_count);
+		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
+		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
+		 rd_dev->sg_table_count);
 
 	return 0;
 }",linux,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,42201b557471f2fef2e9e028b50a773d99ffc401,1,"static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
//fix_flaw_line_below:
//				 u32 total_sg_needed, unsigned char init_payload)
 {
//flaw_line_below:
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
//flaw_line_below:
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
//flaw_line_below:

//flaw_line_below:
	if (rd_dev->rd_page_count <= 0) {
//flaw_line_below:
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//flaw_line_below:
			rd_dev->rd_page_count);
//flaw_line_below:
		return -EINVAL;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	/* Don't need backing pages for NULLIO */
//flaw_line_below:
	if (rd_dev->rd_flags & RDF_NULLIO)
//flaw_line_below:
		return 0;
//flaw_line_below:

//flaw_line_below:
	total_sg_needed = rd_dev->rd_page_count;
//flaw_line_below:

//flaw_line_below:
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//flaw_line_below:

//flaw_line_below:
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//flaw_line_below:
	if (!sg_table) {
//flaw_line_below:
		pr_err(""Unable to allocate memory for Ramdisk""
//flaw_line_below:
			"" scatterlist tables\n"");
//flaw_line_below:
		return -ENOMEM;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	rd_dev->sg_table_array = sg_table;
//flaw_line_below:
	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			p = kmap(pg);
//fix_flaw_line_below:
//			memset(p, init_payload, PAGE_SIZE);
//fix_flaw_line_below:
//			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
//fix_flaw_line_below:
//	return 0;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	struct rd_dev_sg_table *sg_table;
//fix_flaw_line_below:
//	u32 sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
//fix_flaw_line_below:
//				sizeof(struct scatterlist));
//fix_flaw_line_below:
//	int rc;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (rd_dev->rd_page_count <= 0) {
//fix_flaw_line_below:
//		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//fix_flaw_line_below:
//		       rd_dev->rd_page_count);
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't need backing pages for NULLIO */
//fix_flaw_line_below:
//	if (rd_dev->rd_flags & RDF_NULLIO)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	total_sg_needed = rd_dev->rd_page_count;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//fix_flaw_line_below:
//	if (!sg_table) {
//fix_flaw_line_below:
//		pr_err(""Unable to allocate memory for Ramdisk""
//fix_flaw_line_below:
//		       "" scatterlist tables\n"");
//fix_flaw_line_below:
//		return -ENOMEM;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rd_dev->sg_table_array = sg_table;
//fix_flaw_line_below:
//	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
//fix_flaw_line_below:
//	if (rc)
//fix_flaw_line_below:
//		return rc;
//fix_flaw_line_below:
//
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
//flaw_line_below:
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//flaw_line_below:
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
//flaw_line_below:
		rd_dev->sg_table_count);
//fix_flaw_line_below:
//		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//fix_flaw_line_below:
//		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
//fix_flaw_line_below:
//		 rd_dev->sg_table_count);
 
 	return 0;
 }
",179487,"static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","The provided code defines a function `rd_build_device_space` that allocates memory for a ramdisk device's scatter-gather (SG) tables based on the specified page count. It first checks if the page count is valid and whether the device is configured for NULLIO, which requires no backing pages. If valid, it calculates the number of SG tables needed and allocates memory for them. The function then iteratively allocates scatterlist arrays and pages, initializing each scatterlist entry with allocated pages. Finally, it logs the successful creation of the ramdisk space and returns 0, or an error code if any allocation fails.","The code defines a function that allocates memory for a ramdisk device's data structure, which organizes memory into manageable segments. It begins by validating the specified number of pages and checking for a specific configuration that requires no memory allocation. If the conditions are met, it calculates the necessary segments and allocates memory for them. The function then iteratively creates arrays for managing memory pages, ensuring each segment is properly initialized. Finally, it logs the successful allocation of memory for the ramdisk and returns a success indicator or an error code if any allocation fails.","The vulnerability in the original code stemmed from the lack of proper initialization of allocated memory for the pages, which could lead to exposure of sensitive data or undefined behavior. In the fixed code, a new function was introduced to allocate the scatter-gather tables and initialize the memory with a specified payload. Specifically, after allocating each page, the code now uses `kmap` to map the page into kernel space, followed by `memset` to fill it with a defined value, ensuring that the memory is initialized before use. This change mitigates the risk of uninitialized memory access.","The vulnerability in the original code arose from the failure to initialize allocated memory for pages, which could lead to the exposure of sensitive data or unpredictable behavior when the memory was accessed. In the revised code, a new function was introduced to handle the allocation and initialization of memory more securely. This change ensures that after memory is allocated, it is explicitly filled with a defined value before being used, thereby preventing any potential risks associated with uninitialized memory access. This fix enhances the overall security and reliability of the memory management process.","The vulnerability was fixed by introducing a new function that allocates and initializes the scatter-gather tables. In the revised code, after allocating each page using `alloc_pages`, the code now maps the page into kernel space with `kmap` and initializes it with a specified payload using `memset`. This ensures that the memory is filled with a known value before being assigned to the scatterlist entries. Additionally, the new function separates the allocation logic, improving code organization and making it easier to manage memory initialization, thus preventing issues related to uninitialized memory access.","The vulnerability was addressed by implementing a dedicated function that not only allocates memory for the necessary data structures but also ensures that this memory is properly initialized. The fix involves mapping the allocated memory into a usable space and filling it with a defined value before it is utilized. This process guarantees that any memory accessed later contains known data, thereby eliminating the risks associated with uninitialized memory. By separating the allocation and initialization logic, the code becomes more organized and robust, significantly enhancing its security and reliability.","CWE-457, CWE-908, CWE-665, CWE-789, CWE-401, CWE-119, CWE-824, CWE-763, CWE-762, CWE-561",N,-1
33,33,179553,179553,,Local,Not required,Complete,CVE-2014-3153,https://www.cvedetails.com/cve/CVE-2014-3153/,CWE-264,Low,Complete,Complete,,2014-06-07,7.2,"The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.",2019-04-22,+Priv ,16,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,e9c243a5a6de0be8e584c604d353412584b592f8,"futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)

If uaddr == uaddr2, then we have broken the rule of only requeueing from
a non-pi futex to a pi futex with this call.  If we attempt this, then
dangling pointers may be left for rt_waiter resulting in an exploitable
condition.

This change brings futex_requeue() in line with futex_wait_requeue_pi()
which performs the same check as per commit 6f7b0a2a5c0f (""futex: Forbid
uaddr == uaddr2 in futex_wait_requeue_pi()"")

[ tglx: Compare the resulting keys as well, as uaddrs might be
  	different depending on the mapping ]

Fixes CVE-2014-3153.

Reported-by: Pinkie Pie
Signed-off-by: Will Drewry <wad@chromium.org>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: stable@vger.kernel.org
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Reviewed-by: Darren Hart <dvhart@linux.intel.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/futex.c,"{""sha"": ""663ea2b84a3830ec9c772f78ec7eaa23504bfcc5"", ""filename"": ""kernel/futex.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/torvalds/linux/blob/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/futex.c?ref=e9c243a5a6de0be8e584c604d353412584b592f8"", ""patch"": ""@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tstruct futex_q *this, *next;\n \n \tif (requeue_pi) {\n+\t\t/*\n+\t\t * Requeue PI only works on two distinct uaddrs. This\n+\t\t * check is only valid for private futexes. See below.\n+\t\t */\n+\t\tif (uaddr1 == uaddr2)\n+\t\t\treturn -EINVAL;\n+\n \t\t/*\n \t\t * requeue_pi requires a pi_state, try to allocate it now\n \t\t * without any locks in case it fails.\n@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tif (unlikely(ret != 0))\n \t\tgoto out_put_key1;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (requeue_pi && match_futex(&key1, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \thb1 = hash_futex(&key1);\n \thb2 = hash_futex(&key2);\n \n@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n \tif (ret)\n \t\tgoto out_key2;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (match_futex(&q.key, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n \tfutex_wait_queue_me(hb, &q, to);\n ""}","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",C,"		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

",,,"@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
+		/*
+		 * Requeue PI only works on two distinct uaddrs. This
+		 * check is only valid for private futexes. See below.
+		 */
+		if (uaddr1 == uaddr2)
+			return -EINVAL;
+
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (requeue_pi && match_futex(&key1, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (match_futex(&q.key, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 ",linux,e9c243a5a6de0be8e584c604d353412584b592f8,fad01e866afdbe01a1f3ec06a39c3a8b9e197014,1,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * Requeue PI only works on two distinct uaddrs. This
//fix_flaw_line_below:
//		 * check is only valid for private futexes. See below.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (uaddr1 == uaddr2)
//fix_flaw_line_below:
//			return -EINVAL;
//fix_flaw_line_below:
//
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * The check above which compares uaddrs is not sufficient for
//fix_flaw_line_below:
//	 * shared futexes. We need to compare the keys:
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (requeue_pi && match_futex(&key1, &key2)) {
//fix_flaw_line_below:
//		ret = -EINVAL;
//fix_flaw_line_below:
//		goto out_put_keys;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",179553,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","The `futex_requeue` function is designed to manage the requeuing of waiters from one futex (fast user-space mutex) to another, potentially with priority inheritance (PI) support. It takes two user-space addresses (`uaddr1` and `uaddr2`), flags, and parameters for waking and requeuing tasks. The function first validates the futex keys and manages locks for both futexes. It then checks conditions for requeuing, such as the number of tasks to wake and requeue, and handles priority inheritance if required. Finally, it updates the state of the waiters, ensuring proper synchronization and resource management, and returns the number of tasks affected or an error code.","The code implements a mechanism for managing the requeuing of tasks waiting on one synchronization primitive to another, with optional support for priority inheritance. It begins by validating the addresses of the synchronization primitives and acquiring necessary locks. The function checks conditions for waking and requeuing tasks, ensuring that the correct number of tasks are handled according to specified parameters. It also manages the state of tasks, ensuring proper synchronization and resource allocation. Finally, the function returns the number of tasks affected or an error code, maintaining the integrity of the synchronization process throughout.","The vulnerability in the original code stemmed from the lack of a proper check to ensure that the two user-space addresses were distinct when using priority inheritance. This could lead to unintended behavior, such as a task being requeued to the same futex it was waiting on, potentially causing deadlocks or inconsistent states. The fix introduced a comparison of the two addresses, returning an error if they were the same, thus preventing the misuse of the requeue functionality. This change ensures that the requeue operation is only performed between different synchronization primitives, enhancing the overall safety and reliability of the code.","The vulnerability in the original code arose from the absence of a check to ensure that two synchronization primitives were distinct when using priority inheritance, which could lead to tasks being requeued to the same primitive. This situation risked creating deadlocks or inconsistent states, as tasks could inadvertently wait on themselves. The fix implemented a validation step that compared the two addresses, returning an error if they were identical. This enhancement effectively prevents misuse of the requeue functionality, ensuring that tasks are only moved between different synchronization primitives, thereby improving the code's safety and reliability.","The vulnerability was fixed by adding a check to ensure that the two user-space addresses are distinct when using priority inheritance. Specifically, the code now includes a condition that compares the two addresses, returning an error if they are the same. This check is implemented right after the initial validation for priority inheritance, ensuring that the function does not proceed with requeuing if the addresses are identical. By enforcing this validation, the code prevents tasks from being requeued to the same synchronization primitive, thereby mitigating the risk of deadlocks and ensuring proper synchronization behavior.","The vulnerability was addressed by introducing a validation step that checks whether the two synchronization primitives involved in the operation are distinct. This new condition ensures that the same primitive cannot be used for both the original wait and the requeue action, which previously risked causing deadlocks or inconsistent states. By returning an error when the two addresses are identical, the fix prevents the misuse of the requeue functionality. This enhancement significantly improves the safety and reliability of the code by ensuring that tasks are only requeued to different synchronization primitives.","CWE-764,CWE-833,CWE-667,CWE-662,CWE-666,CWE-414,CWE-665,CWE-820,CWE-609,CWE-675",N,-1
34,34,179559,179559,,Local,Not required,Complete,CVE-2014-3122,https://www.cvedetails.com/cve/CVE-2014-3122/,CWE-264,Low,,,,2014-05-11,4.9,"The try_to_unmap_cluster function in mm/rmap.c in the Linux kernel before 3.14.3 does not properly consider which pages must be locked, which allows local users to cause a denial of service (system crash) by triggering a memory-usage pattern that requires removal of page-table mappings.",2017-12-28,DoS ,12,https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c,57e68e9cd65b4b8eb4045a1e0d0746458502554c,"mm: try_to_unmap_cluster() should lock_page() before mlocking

A BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin
fuzzing with trinity.  The call site try_to_unmap_cluster() does not lock
the pages other than its check_page parameter (which is already locked).

The BUG_ON in mlock_vma_page() is not documented and its purpose is
somewhat unclear, but apparently it serializes against page migration,
which could otherwise fail to transfer the PG_mlocked flag.  This would
not be fatal, as the page would be eventually encountered again, but
NR_MLOCK accounting would become distorted nevertheless.  This patch adds
a comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that
effect.

The call site try_to_unmap_cluster() is fixed so that for page !=
check_page, trylock_page() is attempted (to avoid possible deadlocks as we
already have check_page locked) and mlock_vma_page() is performed only
upon success.  If the page lock cannot be obtained, the page is left
without PG_mlocked, which is again not a problem in the whole unevictable
memory design.

Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Bob Liu <bob.liu@oracle.com>
Reported-by: Sasha Levin <sasha.levin@oracle.com>
Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
Cc: Michel Lespinasse <walken@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Acked-by: Rik van Riel <riel@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Hugh Dickins <hughd@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",2,mm/rmap.c,"{""sha"": ""b1eb53634005606298d115ac5cdeb90cac923957"", ""filename"": ""mm/mlock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mlock.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -79,6 +79,7 @@ void clear_page_mlock(struct page *page)\n  */\n void mlock_vma_page(struct page *page)\n {\n+\t/* Serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \tif (!TestSetPageMlocked(page)) {\n@@ -174,6 +175,7 @@ unsigned int munlock_vma_page(struct page *page)\n \tunsigned int nr_pages;\n \tstruct zone *zone = page_zone(page);\n \n+\t/* For try_to_munlock() and to serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \t/*""}<_**next**_>{""sha"": ""9c3e77396d1a118edb8f2de7d16ff835ed214f0a"", ""filename"": ""mm/rmap.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 2, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/rmap.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n-\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n-\t\t\tif (page == check_page)\n+\t\t\tif (page == check_page) {\n+\t\t\t\t/* we know we have check_page locked */\n+\t\t\t\tmlock_vma_page(page);\n \t\t\t\tret = SWAP_MLOCK;\n+\t\t\t} else if (trylock_page(page)) {\n+\t\t\t\t/*\n+\t\t\t\t * If we can lock the page, perform mlock.\n+\t\t\t\t * Otherwise leave the page alone, it will be\n+\t\t\t\t * eventually encountered again later.\n+\t\t\t\t */\n+\t\t\t\tmlock_vma_page(page);\n+\t\t\t\tunlock_page(page);\n+\t\t\t}\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n ""}","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",C,"			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
","			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
",,"@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
-			mlock_vma_page(page);   /* no-op if already mlocked */
-			if (page == check_page)
+			if (page == check_page) {
+				/* we know we have check_page locked */
+				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
+			} else if (trylock_page(page)) {
+				/*
+				 * If we can lock the page, perform mlock.
+				 * Otherwise leave the page alone, it will be
+				 * eventually encountered again later.
+				 */
+				mlock_vma_page(page);
+				unlock_page(page);
+			}
 			continue;	/* don't unmap */
 		}
 ",linux,57e68e9cd65b4b8eb4045a1e0d0746458502554c,3a025760fc158b3726eac89ee95d7f29599e9dfa,1,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
//flaw_line_below:
			mlock_vma_page(page);   /* no-op if already mlocked */
//flaw_line_below:
			if (page == check_page)
//fix_flaw_line_below:
//			if (page == check_page) {
//fix_flaw_line_below:
//				/* we know we have check_page locked */
//fix_flaw_line_below:
//				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
//fix_flaw_line_below:
//			} else if (trylock_page(page)) {
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * If we can lock the page, perform mlock.
//fix_flaw_line_below:
//				 * Otherwise leave the page alone, it will be
//fix_flaw_line_below:
//				 * eventually encountered again later.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				mlock_vma_page(page);
//fix_flaw_line_below:
//				unlock_page(page);
//fix_flaw_line_below:
//			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",179559,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","The `try_to_unmap_cluster` function attempts to unmap a cluster of memory pages within a specified virtual memory area (VMA) in a Linux kernel context. It calculates the address range for the cluster based on a cursor and the VMA's boundaries, then checks for the presence of page table entries (PTEs) within that range. If the VMA is locked, it ensures that pages are not unmapped. For each present page, it clears the PTE, updates the page's dirty status, and manages reference counts. The function also handles memory notifications and returns a status indicating whether the operation was successful or if it needs to retry.","The code defines a function that manages the unmapping of a group of memory pages within a specified area of virtual memory. It calculates the appropriate address range and checks for existing page entries. If the memory area is locked, it prevents unmapping to maintain stability. For each valid page, it updates the page's status, clears the corresponding entries, and adjusts reference counts accordingly. Additionally, the function handles notifications related to memory changes and returns a status indicating whether the unmapping operation was successful or if it requires a retry.","The vulnerability in the original code stemmed from the potential for unmapping pages in a locked virtual memory area, which could lead to inconsistencies and data corruption. Specifically, the code did not adequately handle the case where a page was locked, allowing it to be unmapped despite being in use. The fix introduced a check for the locked state of the virtual memory area and implemented a mechanism to attempt to lock the page before performing the memory lock operation. This ensures that pages marked for locking are not inadvertently unmapped, thereby maintaining data integrity and preventing race conditions.","The vulnerability in the original code arose from the possibility of unmapping pages that were locked, which could lead to data corruption and inconsistencies in memory management. This issue was primarily due to the lack of proper checks to prevent the unmapping of pages that were still in use. The fix addressed this by introducing a mechanism to verify the locked state of the memory area and to attempt to lock the pages before any unmapping operation. This enhancement ensures that locked pages remain protected from being unmapped, thereby preserving data integrity and preventing potential race conditions.","The vulnerability was fixed by adding checks for the locked state of the virtual memory area and implementing a mechanism to attempt to lock individual pages before unmapping. Specifically, the code now uses `trylock_page` to check if a page can be locked, and if successful, it calls `mlock_vma_page` to ensure the page remains locked. If the page is already locked, the function sets a return value indicating that the page should not be unmapped. This approach prevents the unmapping of pages that are in use, thereby maintaining data integrity and preventing race conditions.","The vulnerability was addressed by implementing additional checks to ensure that pages marked as locked are not subject to unmapping. The updated code introduces a mechanism to verify the locked status of the memory area and attempts to acquire locks on individual pages before any unmapping occurs. If a page is successfully locked, it is marked to remain in use, preventing any unmapping actions. This enhancement effectively safeguards against the accidental removal of pages that are actively being utilized, thereby preserving data integrity and preventing potential inconsistencies in memory management.","CWE-666, CWE-667, CWE-404, CWE-416, CWE-825, CWE-665, CWE-668, CWE-362, CWE-826, CWE-674",N,-1
35,35,179629,179629,,Local,Not required,Complete,CVE-2014-0185,https://www.cvedetails.com/cve/CVE-2014-0185/,CWE-264,Low,Complete,Complete,,2014-05-06,7.2,"sapi/fpm/fpm/fpm_unix.c in the FastCGI Process Manager (FPM) in PHP before 5.4.28 and 5.5.x before 5.5.12 uses 0666 permissions for the UNIX socket, which allows local users to gain privileges via a crafted FastCGI client.",2017-01-06,+Priv ,1,https://github.com/php/php-src/commit/35ceea928b12373a3b1e3eecdc32ed323223a40d,35ceea928b12373a3b1e3eecdc32ed323223a40d,Fix bug #67060: use default mode of 660,1,sapi/fpm/fpm/fpm_unix.c,"{""sha"": ""104279441a7faaaef5aebf0db781ecef3eb8b8fd"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -25,7 +25,7 @@ PHP                                                                        NEWS\n   . Fix bug #64498 ($phar->buildFromDirectory can't compress file with an accent \n     in its name). (PR #588) \n \n-?? ??? 2014, PHP 5.4.28\n+01 May 2014, PHP 5.4.28\n \n - Core:\n   . Fixed bug #61019 (Out of memory on command stream_get_contents). (Mike)\n@@ -55,6 +55,8 @@ PHP                                                                        NEWS\n \n - FPM:\n   . Fixed bug #66482 (unknown entry 'priority' in php-fpm.conf). \n+  . Fixed bug #67060 (sapi/fpm: possible privilege escalation due to insecure \n+    default configuration) (CVE-2014-0185). (Stas)\n \n - JSON:\n   . Fixed bug #66021 (Blank line inside empty array/object when""}<_**next**_>{""sha"": ""ea0e67369cd534448894db87c1ab31a8b7ecad96"", ""filename"": ""sapi/fpm/fpm/fpm_unix.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_unix.c?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */\n \t/* uninitialized */\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n-\twp->socket_mode = 0666;\n+\twp->socket_mode = 0660;\n \n \tif (!c) {\n \t\treturn 0;""}<_**next**_>{""sha"": ""9205d422399b4d5571592fbc1cd57f3419493a80"", ""filename"": ""sapi/fpm/php-fpm.conf.in"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/php-fpm.conf.in?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -166,10 +166,10 @@ listen = 127.0.0.1:9000\n ; permissions must be set in order to allow connections from a web server. Many\n ; BSD-derived systems allow connections regardless of permissions. \n ; Default Values: user and group are set as the running user\n-;                 mode is set to 0666\n+;                 mode is set to 0660\n ;listen.owner = @php_fpm_user@\n ;listen.group = @php_fpm_group@\n-;listen.mode = 0666\n+;listen.mode = 0660\n  \n ; List of ipv4 addresses of FastCGI clients which are allowed to connect.\n ; Equivalent to the FCGI_WEB_SERVER_ADDRS environment variable in the original""}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0666;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",C,"	wp->socket_mode = 0660;
","	wp->socket_mode = 0666;
",,"@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
-	wp->socket_mode = 0666;
+	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;",php-src,35ceea928b12373a3b1e3eecdc32ed323223a40d,2d625b5f81205d7f0217243b0bfe9a77683951e8,1,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
//flaw_line_below:
	wp->socket_mode = 0666;
//fix_flaw_line_below:
//	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",179629,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

	/* uninitialized */
	wp->socket_uid = -1;
	wp->socket_gid = -1;
	wp->socket_mode = 0666;

	if (!c) {
		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","The provided code defines a function `fpm_unix_resolve_socket_permissions` that configures socket permissions for a worker pool in a FastCGI Process Manager (FPM) environment. It initializes the socket's user ID, group ID, and mode with default values. If the configuration specifies a listening owner, the function retrieves the corresponding user ID and group ID using `getpwnam` and `getgrnam`, respectively, logging an error if the user or group cannot be found. Additionally, if a listening mode is specified, it converts the mode from a string to an octal value. The function ultimately returns 0 on success or -1 on failure.","The code defines a function that configures socket permissions for a worker pool in a server environment. It begins by setting default values for user ID, group ID, and access mode. If a specific user is designated, the function retrieves the corresponding user and group identifiers, logging an error if the user or group cannot be found. Additionally, if a specific access mode is provided, it converts this mode from a string representation to an octal format. The function concludes by returning a success or failure status based on the operations performed.","The vulnerability in the original code arises from the default socket mode being set to 0666, which allows read and write permissions for all users, potentially exposing the socket to unauthorized access. This could lead to privilege escalation or data leakage. In the fixed code, the socket mode is changed to 0660, restricting access to the owner and group only, thereby enhancing security. This adjustment reduces the risk of unauthorized users interacting with the socket, ensuring that only designated users and groups can access it, thus mitigating the potential for exploitation.","The vulnerability in the original code stems from setting overly permissive socket access rights, allowing all users to read and write to the socket, which could lead to unauthorized access and potential exploitation. This lack of restriction increases the risk of privilege escalation and data leakage. The fixed code addresses this issue by changing the default access rights to a more restrictive setting, limiting permissions to the owner and group only. This modification significantly enhances security by ensuring that only authorized users can interact with the socket, thereby reducing the likelihood of unauthorized access and potential attacks.","The vulnerability was fixed by changing the default value of `wp->socket_mode` from 0666 to 0660 in the updated code. This adjustment restricts socket permissions, allowing only the owner and group to read and write to the socket, thereby preventing unauthorized access by other users. Additionally, the code retains the logic for retrieving user and group identifiers using `getpwnam` and `getgrnam`, ensuring that the socket is owned by the correct user and group. This combination of stricter default permissions and proper ownership management significantly enhances the security of the socket configuration.","The vulnerability was addressed by modifying the default access permissions for the socket, reducing them from overly permissive settings to a more restrictive configuration. This change limits access to only the designated owner and group, thereby preventing unauthorized users from reading or writing to the socket. Additionally, the logic for assigning user and group identifiers remains intact, ensuring that the socket is correctly owned. This combination of stricter default permissions and proper ownership management significantly enhances the overall security of the socket, mitigating the risk of unauthorized access and potential exploitation.","CWE-732, CWE-266, CWE-284, CWE-668, CWE-276, CWE-264, CWE-282, CWE-269, CWE-285, CWE-732",N,-1
36,36,179717,179717,,Remote,Not required,,CVE-2013-2182,https://www.cvedetails.com/cve/CVE-2013-2182/,CWE-264,Medium,Partial,Partial,,2014-06-13,5.8,"The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash.",2014-06-13,Bypass ,2,https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,"Mandril: check decoded URI (fix #92)

Signed-off-by: Eduardo Silva <eduardo@monkey.io>",1,plugins/mandril/mandril.c,"{""sha"": ""820f4416d769860a11599c2ded44762ec729d7ff"", ""filename"": ""plugins/mandril/mandril.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/monkey/monkey/blob/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""raw_url"": ""https://github.com/monkey/monkey/raw/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""contents_url"": ""https://api.github.com/repos/monkey/monkey/contents/plugins/mandril/mandril.c?ref=15f72c1ee5e0afad20232bdf0fcecab8d62a5d89"", ""patch"": ""@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,\n     (void) cs;\n \n     PLUGIN_TRACE(\""[FD %i] Mandril validating URL\"", cs->socket);\n-    if (mk_security_check_url(sr->uri) < 0) {\n+\n+    if (mk_security_check_url(sr->uri_processed) < 0) {\n         PLUGIN_TRACE(\""[FD %i] Close connection, blocked URL\"", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;""}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",C,"
    if (mk_security_check_url(sr->uri_processed) < 0) {
","    if (mk_security_check_url(sr->uri) < 0) {
",,"@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
-    if (mk_security_check_url(sr->uri) < 0) {
+
+    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;",monkey,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,f929f3e6dca9a0ff2e08dcd286346ef7e436c139,1,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
//flaw_line_below:
    if (mk_security_check_url(sr->uri) < 0) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",179717,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","The provided code defines a function `_mkp_stage_30` that is part of a plugin system, responsible for validating incoming requests based on URL and hotlinking checks. It first checks if the requested URL is secure using `mk_security_check_url`, closing the connection and returning a forbidden status if the URL is blocked. Next, it retrieves the ""Referer"" header and validates it against hotlinking rules with `mk_security_check_hotlink`. If the hotlinking check fails, it again closes the connection with a forbidden status. If both checks pass, the function indicates that it does not handle the request further.","The code defines a function that processes incoming requests by validating their security. It first checks if the requested resource is safe, and if not, it terminates the connection while signaling that access is forbidden. Next, it examines the source of the request to ensure it complies with hotlinking policies. If this check fails, the function again closes the connection with a forbidden response. If both validations are successful, the function indicates that it does not take further action on the request, allowing other components to handle it as needed.","The vulnerability in the original code stemmed from the use of `mk_security_check_url(sr->uri)` instead of `mk_security_check_url(sr->uri_processed)`, which could allow unvalidated or improperly processed URLs to be accepted, potentially leading to unauthorized access or exploitation. By changing the function to check `sr->uri_processed`, the fixed code ensures that only properly sanitized and validated URLs are evaluated, thereby mitigating risks associated with malicious URLs. This adjustment enhances the security of the request handling process by ensuring that all incoming requests are subjected to thorough validation before any further processing occurs.","The vulnerability in the original code arose from the inadequate validation of incoming URLs, which could allow potentially harmful requests to bypass security checks. This oversight could lead to unauthorized access or exploitation of the system. The fix involved ensuring that the validation process utilized a properly processed version of the URL, rather than an unvalidated one. By implementing this change, the code now guarantees that only thoroughly sanitized and validated requests are evaluated, significantly enhancing the security of the request handling mechanism and reducing the risk of malicious exploitation.","The vulnerability was fixed by changing the URL validation check from `mk_security_check_url(sr->uri)` to `mk_security_check_url(sr->uri_processed)`. This adjustment ensures that the function evaluates a properly processed version of the URL, which has undergone necessary sanitization and validation steps. By using `sr->uri_processed`, the code mitigates the risk of accepting unvalidated or potentially harmful URLs, thereby enhancing the overall security of the request handling process. This change ensures that only safe and authorized requests are allowed to proceed, effectively reducing the potential for exploitation.","The vulnerability was addressed by ensuring that the validation process checks a properly processed version of the URL instead of an unvalidated one. This change guarantees that only URLs that have undergone necessary sanitization and validation are evaluated, significantly reducing the risk of accepting potentially harmful requests. By implementing this fix, the code enhances the security of the request handling mechanism, ensuring that all incoming requests are thoroughly vetted before any further processing occurs. This proactive approach effectively mitigates the potential for unauthorized access or exploitation of the system.","CWE-20, CWE-601, CWE-73, CWE-646, CWE-22, CWE-641, CWE-284, CWE-285, CWE-425, CWE-610",N,-1
37,37,179719,179719,,Local,Not required,Complete,CVE-2012-6657,https://www.cvedetails.com/cve/CVE-2012-6657/,CWE-264,Low,,,,2014-09-28,4.9,"The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket.",2016-08-22,DoS ,2,https://github.com/torvalds/linux/commit/3e10986d1d698140747fcfc2761ec9cb64c1d582,3e10986d1d698140747fcfc2761ec9cb64c1d582,"net: guard tcp_set_keepalive() to tcp sockets

Its possible to use RAW sockets to get a crash in
tcp_set_keepalive() / sk_reset_timer()

Fix is to make sure socket is a SOCK_STREAM one.

Reported-by: Dave Jones <davej@redhat.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/sock.c,"{""sha"": ""a6000fbad2949f58a079322f4e328e0c051df896"", ""filename"": ""net/core/sock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/sock.c?ref=3e10986d1d698140747fcfc2761ec9cb64c1d582"", ""patch"": ""@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,\n \n \tcase SO_KEEPALIVE:\n #ifdef CONFIG_INET\n-\t\tif (sk->sk_protocol == IPPROTO_TCP)\n+\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n+\t\t    sk->sk_type == SOCK_STREAM)\n \t\t\ttcp_set_keepalive(sk, valbool);\n #endif\n \t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);""}","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",C,"		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
","		if (sk->sk_protocol == IPPROTO_TCP)
",,"@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
-		if (sk->sk_protocol == IPPROTO_TCP)
+		if (sk->sk_protocol == IPPROTO_TCP &&
+		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);",linux,3e10986d1d698140747fcfc2761ec9cb64c1d582,69190e67d4fac49e2f6ea22f46780d0c712214b8,1,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
//flaw_line_below:
		if (sk->sk_protocol == IPPROTO_TCP)
//fix_flaw_line_below:
//		if (sk->sk_protocol == IPPROTO_TCP &&
//fix_flaw_line_below:
//		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",179719,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","The provided code defines the `sock_setsockopt` function, which is responsible for setting various socket options in a network programming context. It takes a socket structure, an option level, an option name, a user-provided value, and the length of that value as parameters. The function handles different socket options, such as enabling or disabling debugging, setting buffer sizes, configuring keep-alive settings, and managing timestamps. It performs necessary validations, such as checking user permissions and ensuring the correct length of input data, while also updating the socket's state and flags accordingly. The function returns appropriate error codes for invalid operations or successful completion.","The code implements a function that configures various options for a network socket, allowing for adjustments to its behavior and properties. It processes different settings, such as enabling debugging, managing buffer sizes, and configuring connection persistence features. The function validates input parameters, checks user permissions, and updates the socket's internal state based on the specified options. It also handles error conditions, returning appropriate codes for invalid inputs or successful operations. Overall, the function facilitates fine-tuning of socket characteristics to meet specific application requirements in network communication.","The vulnerability in the original code arises from insufficient validation of user input, particularly in the handling of socket options that require administrative privileges. For instance, options like setting buffer sizes or enabling certain features could be manipulated by unprivileged users, potentially leading to denial of service or unauthorized access. The fixed code addresses this by adding checks, such as verifying user capabilities with the `capable` function before allowing changes to sensitive options. This ensures that only users with the appropriate permissions can modify critical socket settings, thereby enhancing the security of the socket management functionality.","The vulnerability in the original code stems from inadequate validation of user permissions when modifying sensitive socket options, which could allow unauthorized users to alter critical settings, leading to potential security breaches or system instability. The fixed code addresses this issue by implementing checks to ensure that only users with the necessary administrative privileges can make changes to specific options. This enhancement effectively restricts access to sensitive functionalities, thereby mitigating the risk of exploitation and ensuring that socket configurations remain secure against unauthorized modifications.","The vulnerability was fixed by incorporating permission checks using the `capable` function before allowing modifications to sensitive socket options. For instance, in cases like setting buffer sizes or enabling certain features, the code now verifies if the user has the necessary administrative capabilities. If the user lacks these privileges, the function returns an error code, such as `-EPERM`, preventing unauthorized changes. This approach ensures that only users with appropriate permissions can alter critical settings, thereby enhancing the overall security of the socket management functionality and protecting against potential misuse.","The vulnerability was addressed by implementing strict permission checks before allowing modifications to sensitive socket options. The updated code ensures that only users with the necessary administrative privileges can make changes to critical settings, such as buffer sizes and specific features. If a user attempts to modify these options without the required permissions, the function now returns an error, effectively blocking unauthorized access. This enhancement significantly improves the security of the socket management process by preventing potential exploitation and ensuring that only authorized users can alter important configurations.","CWE-269, CWE-264, CWE-284, CWE-285, CWE-732, CWE-266, CWE-668, CWE-754, CWE-265, CWE-263",N,-1
38,38,179731,179731,,Local,Not required,Complete,CVE-2015-8660,https://www.cvedetails.com/cve/CVE-2015-8660/,CWE-264,Low,Complete,Complete,,2015-12-28,7.2,"The ovl_setattr function in fs/overlayfs/inode.c in the Linux kernel through 4.3.3 attempts to merge distinct setattr operations, which allows local users to bypass intended access restrictions and modify the attributes of arbitrary overlay files via a crafted application.",2017-09-09,Bypass ,4,https://github.com/torvalds/linux/commit/acff81ec2c79492b180fade3c2894425cd35a545,acff81ec2c79492b180fade3c2894425cd35a545,"ovl: fix permission checking for setattr

[Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()
away - instead of ""copy verbatim with metadata"" + ""chmod/chown/utimes""
(with the former being always safe and the latter failing in case of
insufficient permissions) it tries to combine these two.  Note that copyup
itself will have to do ->setattr() anyway; _that_ is where the elevated
capabilities are right.  Having these two ->setattr() (one to set verbatim
copy of metadata, another to do what overlayfs ->setattr() had been asked
to do in the first place) combined is where it breaks.

Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Cc: <stable@vger.kernel.org>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",4,fs/overlayfs/inode.c,"{""sha"": ""961284936917e69742f837463999c27e90defb43"", ""filename"": ""fs/overlayfs/inode.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/inode.c?ref=acff81ec2c79492b180fade3c2894425cd35a545"", ""patch"": ""@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tif (err)\n \t\tgoto out;\n \n-\tupperdentry = ovl_dentry_upper(dentry);\n-\tif (upperdentry) {\n+\terr = ovl_copy_up(dentry);\n+\tif (!err) {\n+\t\tupperdentry = ovl_dentry_upper(dentry);\n+\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n-\t} else {\n-\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:""}","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",C,"	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

","	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
",,"@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)
 	if (err)
 		goto out;
 
-	upperdentry = ovl_dentry_upper(dentry);
-	if (upperdentry) {
+	err = ovl_copy_up(dentry);
+	if (!err) {
+		upperdentry = ovl_dentry_upper(dentry);
+
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
-	} else {
-		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:",linux,acff81ec2c79492b180fade3c2894425cd35a545,31ade3b83e1821da5fbb2f11b5b3d4ab2ec39db8,1,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
//flaw_line_below:
	upperdentry = ovl_dentry_upper(dentry);
//flaw_line_below:
	if (upperdentry) {
//fix_flaw_line_below:
//	err = ovl_copy_up(dentry);
//fix_flaw_line_below:
//	if (!err) {
//fix_flaw_line_below:
//		upperdentry = ovl_dentry_upper(dentry);
//fix_flaw_line_below:
//
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
//flaw_line_below:
	} else {
//flaw_line_below:
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",179731,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","The provided code defines the function `ovl_setattr`, which is responsible for updating the attributes of a specified directory entry (`dentry`) in an overlay filesystem. It first attempts to acquire a write lock on the `dentry`. If successful, it checks for an associated upper `dentry` and, if found, locks its inode to apply the attribute changes using `notify_change`. If no upper `dentry` exists, it calls `ovl_copy_up_last` to handle the attribute update. Finally, it releases the write lock and returns any error encountered during the process, ensuring proper synchronization and attribute management in the overlay filesystem.","The code defines a function that manages the updating of attributes for a specified directory entry within an overlay filesystem. It begins by attempting to acquire a write lock to ensure exclusive access. If successful, it checks for an associated upper directory entry; if found, it locks the corresponding inode to apply the attribute changes. If no upper entry exists, it performs a different operation to handle the attribute update. Finally, the function releases the write lock and returns any errors encountered during the process, ensuring proper synchronization and management of attributes in the filesystem.","The vulnerability in the original code arises from the potential for a race condition when updating attributes, as it first checks for an upper directory entry after acquiring the write lock. If the upper entry is not found, it attempts to copy up the attributes without ensuring that the necessary conditions are met, which could lead to inconsistent states. The fixed code addresses this by first calling `ovl_copy_up` to ensure the attributes are properly copied before checking for the upper entry. This change ensures that the attribute update process is more robust and prevents potential data corruption or unexpected behavior in the overlay filesystem.","The vulnerability in the original code stems from a race condition that could occur during the attribute update process. By checking for the existence of an upper directory entry after acquiring a write lock, the code risks inconsistencies if the state of the filesystem changes unexpectedly. Additionally, the lack of a prior operation to ensure the necessary conditions for attribute updates could lead to failures or data corruption. The revised code mitigates this issue by first ensuring that the attributes are properly prepared for copying before checking for the upper entry, thereby enhancing the robustness and reliability of the update process.","The vulnerability was fixed by restructuring the order of operations in the code. In the revised version, the function first calls `ovl_copy_up` to ensure that the necessary attributes are copied up before checking for the existence of the upper directory entry. This change prevents potential race conditions by ensuring that the filesystem state is consistent before proceeding with the attribute update. After confirming that the copy-up operation was successful, the code then safely locks the upper directory's inode and applies the attribute changes using `notify_change`, thereby enhancing the overall reliability and integrity of the attribute update process.","The vulnerability was addressed by changing the sequence of operations to ensure a more reliable attribute update process. The revised approach first prepares the necessary attributes for copying, which helps maintain a consistent state within the filesystem. By doing this before checking for the existence of the upper directory entry, the code minimizes the risk of race conditions that could lead to inconsistencies. This restructuring ensures that the update process is robust, allowing for safe locking and application of changes, ultimately enhancing the integrity and reliability of the attribute management in the system.","CWE-367, CWE-362, CWE-364, CWE-366, CWE-365, CWE-363, CWE-371, CWE-373, CWE-372, CWE-375",N,-1
39,39,179756,179756,,Local,Not required,Complete,CVE-2015-6564,https://www.cvedetails.com/cve/CVE-2015-6564/,CWE-264,Medium,Complete,Complete,,2015-08-23,6.9,Use-after-free vulnerability in the mm_answer_pam_free_ctx function in monitor.c in sshd in OpenSSH before 7.0 on non-OpenBSD platforms might allow local users to gain privileges by leveraging control of the sshd uid to send an unexpectedly early MONITOR_REQ_PAM_FREE_CTX request.,2018-09-11,+Priv ,3,https://github.com/openssh/openssh-portable/commit/5e75f5198769056089fb06c4d738ab0e5abc66f7,5e75f5198769056089fb06c4d738ab0e5abc66f7,"set sshpam_ctxt to NULL after free

Avoids use-after-free in monitor when privsep child is compromised.
Reported by Moritz Jodeit; ok dtucker@",1,monitor.c,"{""sha"": ""a91420983ba86eda2619e629265897b3fefed53a"", ""filename"": ""monitor.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/openssh/openssh-portable/blob/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""raw_url"": ""https://github.com/openssh/openssh-portable/raw/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""contents_url"": ""https://api.github.com/repos/openssh/openssh-portable/contents/monitor.c?ref=5e75f5198769056089fb06c4d738ab0e5abc66f7"", ""patch"": ""@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)\n int\n mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n+\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n \n \tdebug3(\""%s\"", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n+\tsshpam_ctxt = sshpam_authok = NULL;\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \""keyboard-interactive\"";\n \tauth_submethod = \""pam\"";\n-\treturn (sshpam_authok == sshpam_ctxt);\n+\treturn r;\n }\n #endif\n ""}"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
",C,"	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
	sshpam_ctxt = sshpam_authok = NULL;
	return r;
","	return (sshpam_authok == sshpam_ctxt);
",,"@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)
 int
 mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
+	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
+	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
-	return (sshpam_authok == sshpam_ctxt);
+	return r;
 }
 #endif
 ",openssh-portable,5e75f5198769056089fb06c4d738ab0e5abc66f7,d4697fe9a28dab7255c60433e4dd23cf7fce8a8b,1," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
//fix_flaw_line_below:
//	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
//fix_flaw_line_below:
//	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
//flaw_line_below:
	return (sshpam_authok == sshpam_ctxt);
//fix_flaw_line_below:
//	return r;
 }
",179756," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
","The provided code defines a function `mm_answer_pam_free_ctx` that is responsible for freeing a PAM (Pluggable Authentication Module) context associated with a given socket and buffer. It begins by logging the function name for debugging purposes. The function then calls `free_ctx` on the `sshpam_device` to release the PAM context, clears the buffer `m`, and sends a response back through the specified socket with the request type `MONITOR_ANS_PAM_FREE_CTX`. Finally, it sets the authentication method to ""keyboard-interactive"" and the submethod to ""pam,"" returning a boolean indicating whether the authentication was successful based on the PAM context.","The code defines a function that manages the release of a specific authentication context associated with a communication socket and a data buffer. It begins by logging its execution for debugging purposes. The function proceeds to free the authentication context, clear the data buffer, and send a response back through the socket indicating the completion of the context release. Additionally, it sets the authentication method and submethod to specific values, ultimately returning a boolean value that indicates whether the authentication process was successful based on the state of the released context.","The vulnerability in the original code arises from the potential use of a dangling pointer, as the authentication context is freed without nullifying the associated pointers. This could lead to undefined behavior if the context is accessed after being freed. In the fixed code, the pointers `sshpam_ctxt` and `sshpam_authok` are explicitly set to `NULL` after the context is freed, ensuring that any subsequent access attempts will not reference invalid memory. This change mitigates the risk of dereferencing a freed pointer, enhancing the overall safety and stability of the authentication process.","The vulnerability in the original code stems from the risk of accessing freed memory, as the authentication context is released without nullifying the associated pointers. This oversight can lead to undefined behavior if the program attempts to use these pointers after the context has been freed, potentially causing crashes or security issues. The fixed code addresses this vulnerability by ensuring that the pointers are explicitly set to null after the context is freed. This precaution prevents any accidental dereferencing of invalid memory, thereby enhancing the safety and reliability of the authentication process.","The vulnerability was fixed by explicitly setting the pointers `sshpam_ctxt` and `sshpam_authok` to `NULL` after the context is freed using the `free_ctx` function. This change ensures that any subsequent attempts to access these pointers will not reference invalid memory, thus preventing potential crashes or security issues associated with dereferencing freed pointers. By nullifying these pointers, the code enhances its robustness, as it mitigates the risk of using stale references and ensures that the authentication process operates safely after the context has been released.","The vulnerability was addressed by ensuring that the pointers associated with the authentication context are explicitly set to null after the context is released. This modification prevents any potential access to freed memory, which could lead to undefined behavior or security risks if the program attempts to use these pointers afterward. By nullifying the pointers, the code safeguards against dereferencing invalid memory, thereby enhancing the overall stability and security of the authentication process. This proactive approach ensures that any subsequent operations involving these pointers will not inadvertently reference stale or invalid data.","CWE-416,CWE-476,CWE-825,CWE-672,CWE-415,CWE-824,CWE-754,CWE-367,CWE-908,CWE-911",N,-1
40,40,179850,179850,,Remote,Not required,,CVE-2015-2694,https://www.cvedetails.com/cve/CVE-2015-2694/,CWE-264,Medium,Partial,Partial,,2015-05-25,5.8,"The kdcpreauth modules in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.2 do not properly track whether a client's request has been validated, which allows remote attackers to bypass an intended preauthentication requirement by providing (1) zero bytes of data or (2) an arbitrary realm name, related to plugins/preauth/otp/main.c and plugins/preauth/pkinit/pkinit_srv.c.",2016-12-07,Bypass ,2,https://github.com/krb5/krb5/commit/e3b5a5e5267818c97750b266df50b6a3d4649604,e3b5a5e5267818c97750b266df50b6a3d4649604,"Prevent requires_preauth bypass [CVE-2015-2694]

In the OTP kdcpreauth module, don't set the TKT_FLG_PRE_AUTH bit until
the request is successfully verified.  In the PKINIT kdcpreauth
module, don't respond with code 0 on empty input or an unconfigured
realm.  Together these bugs could cause the KDC preauth framework to
erroneously treat a request as pre-authenticated.

CVE-2015-2694:

In MIT krb5 1.12 and later, when the KDC is configured with PKINIT
support, an unauthenticated remote attacker can bypass the
requires_preauth flag on a client principal and obtain a ciphertext
encrypted in the principal's long-term key.  This ciphertext could be
used to conduct an off-line dictionary attack against the user's
password.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:P/I:P/A:N/E:POC/RL:OF/RC:C

ticket: 8160 (new)
target_version: 1.13.2
tags: pullup
subject: requires_preauth bypass in PKINIT-enabled KDC [CVE-2015-2694]",2,src/plugins/preauth/pkinit/pkinit_srv.c,"{""sha"": ""7941b4aeeef179e21a1e9727b327f312ca4e707a"", ""filename"": ""src/plugins/preauth/otp/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/otp/main.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -42,6 +42,7 @@ static krb5_preauthtype otp_pa_type_list[] =\n struct request_state {\n     krb5_kdcpreauth_verify_respond_fn respond;\n     void *arg;\n+    krb5_enc_tkt_part *enc_tkt_reply;\n };\n \n static krb5_error_code\n@@ -159,6 +160,9 @@ on_response(void *data, krb5_error_code retval, otp_response response)\n     if (retval == 0 && response != otp_response_success)\n         retval = KRB5_PREAUTH_FAILED;\n \n+    if (retval == 0)\n+        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n+\n     rs.respond(rs.arg, retval, NULL, NULL, NULL);\n }\n \n@@ -263,8 +267,6 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n     krb5_data d, plaintext;\n     char *config;\n \n-    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n-\n     /* Get the FAST armor key. */\n     armor_key = cb->fast_armor(context, rock);\n     if (armor_key == NULL) {\n@@ -298,12 +300,14 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n         goto error;\n     }\n \n-    /* Create the request state. */\n+    /* Create the request state.  Save the response callback, and the\n+     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. */\n     rs = k5alloc(sizeof(struct request_state), &retval);\n     if (rs == NULL)\n         goto error;\n     rs->arg = arg;\n     rs->respond = respond;\n+    rs->enc_tkt_reply = enc_tkt_reply;\n \n     /* Get the principal's OTP configuration string. */\n     retval = cb->get_string(context, rock, \""otp\"", &config);""}<_**next**_>{""sha"": ""5b1d73e4a6c4820af9e6c9bb24db67928f6d9b20"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     pkiDebug(\""pkinit_verify_padata: entered!\\n\"");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n \n@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n ""}","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",C,"        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
","        (*respond)(arg, 0, NULL, NULL, NULL);
        (*respond)(arg, 0, NULL, NULL, NULL);
",,"@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 ",krb5,e3b5a5e5267818c97750b266df50b6a3d4649604,527edfaadb648a0dd2a42cd39a5a02a4ac37d7e3,1,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",179850,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","The `pkinit_server_verify_padata` function is part of a Kerberos authentication process that verifies public key authentication data. It begins by checking the validity of the input data and initializes a request context. Depending on the type of the provided authentication data (either a standard or draft version), it decodes the data and verifies the associated signatures using cryptographic methods. The function also checks for valid subject alternative names (SAN) and extended key usage (EKU) in the client's certificate. If successful, it updates the ticket flags and prepares a response, handling any errors by generating appropriate error data before cleanup.","The code implements a verification process for public key authentication data within a Kerberos authentication framework. It begins by validating the input data and initializing a context for the request. Depending on the type of authentication data received, it decodes and verifies the signatures using cryptographic methods. The process includes checks for specific attributes in the client's certificate to ensure compliance with security requirements. If all checks pass, it updates the ticket flags and prepares a response, while also managing any errors by generating appropriate error data before performing cleanup operations.","The vulnerability in the original code arises from insufficient validation of the input data, particularly when handling authentication requests. Specifically, the code did not adequately check for null or invalid values in the `data` and `moddata` variables, which could lead to dereferencing null pointers or processing malformed data, potentially allowing an attacker to exploit these weaknesses. The fixed code addresses this by adding explicit checks for null values and ensuring that the lengths of the data are valid before proceeding with further processing, thereby enhancing the overall robustness and security of the authentication process.","The vulnerability in the original code stemmed from inadequate validation of input data, which could lead to dereferencing null pointers or processing invalid data. This lack of checks allowed potential attackers to exploit the system by sending malformed requests, resulting in undefined behavior or crashes. The fixed code addresses this issue by implementing explicit checks for null values and ensuring that the lengths of the input data are valid before any further processing occurs. This enhancement significantly improves the security and stability of the authentication process by preventing the handling of potentially harmful input.","The vulnerability was fixed by adding explicit validation checks for the `data` and `moddata` variables at the beginning of the function. The code now verifies that `data` is not null, has a positive length, and that `moddata` is also not null before proceeding with any processing. If any of these conditions are not met, the function immediately responds with an error code using the `respond` function, preventing further execution. This ensures that only valid and properly formatted input is processed, thereby mitigating the risk of dereferencing null pointers or handling malformed data.","The vulnerability was fixed by implementing rigorous validation checks for the input data at the start of the function. The updated code ensures that the input is not null and has a valid length before any processing occurs. Additionally, it checks for the presence of necessary context data to prevent further execution if these conditions are not met. By responding with an error code when invalid input is detected, the code effectively prevents the processing of potentially harmful or malformed data, thereby enhancing the overall security and stability of the authentication process.","CWE-20, CWE-681, CWE-789, CWE-805, CWE-129, CWE-134, CWE-476, CWE-502, CWE-74, CWE-116",N,-1
41,41,179856,179856,,Remote,Not required,Partial,CVE-2015-1867,https://www.cvedetails.com/cve/CVE-2015-1867/,CWE-264,Low,Partial,Partial,,2015-08-12,7.5,"Pacemaker before 1.1.13 does not properly evaluate added nodes, which allows remote read-only users to gain privileges via an acl command.",2017-10-09,+Priv ,6,https://github.com/ClusterLabs/pacemaker/commit/84ac07c,84ac07c,"Fix: acl: Do not delay evaluation of added nodes in some situations

It is not appropriate when the node has no children as it is not a
placeholder",3,lib/common/xml.c,"{""sha"": ""716f053f824168e16584efef8e949e2666192e8a"", ""filename"": ""lib/common/xml.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lib/common/xml.c?ref=84ac07c7d02b3badd708b1ef13a2159dede70715"", ""patch"": ""@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)\n \n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n+        char *path = xml_get_path(xml);\n \n-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */\n+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'\n+         * Except in the ACLs section\n+         */\n \n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n \n-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, \""/\""XML_CIB_TAG_ACLS\""/\"") == NULL) {\n                 /* Delay the acl check */\n                 continue;\n \n@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)\n                 break;\n \n             } else {\n-                char *path = xml_get_path(xml);\n                 crm_trace(\""Cannot add new node %s at %s\"", crm_element_name(xml), path);\n \n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)\n                 return;\n             }\n         }\n+        free(path);\n     }\n \n     while (cIter != NULL) {""}","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",C,"        char *path = xml_get_path(xml);
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
        free(path);
","        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                char *path = xml_get_path(xml);
",,"@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
+        char *path = xml_get_path(xml);
 
-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
+         * Except in the ACLs section
+         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)
                 break;
 
             } else {
-                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)
                 return;
             }
         }
+        free(path);
     }
 
     while (cIter != NULL) {",pacemaker,84ac07c,e52eef127b97aa9a05e6d278037bc6da7929a16d,1,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
//fix_flaw_line_below:
//        char *path = xml_get_path(xml);
 
//flaw_line_below:
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
//fix_flaw_line_below:
//        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
//fix_flaw_line_below:
//         * Except in the ACLs section
//fix_flaw_line_below:
//         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
//flaw_line_below:
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
//fix_flaw_line_below:
//            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
//flaw_line_below:
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
//fix_flaw_line_below:
//        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",179856,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","The provided code defines a function `__xml_acl_post_process` that processes an XML node's access control list (ACL) after it has been created. It first checks if the node has been marked as created and iterates through its attributes. If an attribute named ""id"" is found, it delays the ACL check; otherwise, it verifies if writing to the node is permitted using `__xml_acl_check`. If the check fails, it logs an error and removes the node from its parent. The function then recursively processes all child nodes, ensuring that ACL checks are applied consistently throughout the XML structure.","The code defines a function that processes an XML node to enforce access control after its creation. It checks if the node has been marked as created and iterates through its attributes. If an attribute indicating identity is found, the access control check is postponed; otherwise, it verifies if modifications to the node are allowed. If the modification is not permitted, an error is logged, and the node is removed from its parent structure. The function also recursively processes all child nodes, ensuring that access control rules are consistently applied throughout the entire XML hierarchy.","The vulnerability in the original code arises from the lack of restrictions on creating new nodes within the access control list (ACL) section, which could allow unauthorized modifications. Specifically, the code did not differentiate between general node creation and creation within the ACL context, leading to potential security breaches. The fix introduces a condition that checks if the node's path includes the ACL section; if it does, the creation of nodes with only an ""id"" attribute is no longer allowed without proper access control checks. This ensures that all modifications within the ACL section are properly validated, enhancing security.","The vulnerability in the original code stemmed from the lack of access control checks when creating new nodes, particularly within sensitive sections of the XML structure. This oversight allowed unauthorized modifications, potentially compromising the integrity of the access control list. The fix implemented a condition to verify whether the node was being created in a restricted context, specifically preventing the creation of nodes with minimal attributes without proper validation. By enforcing stricter checks in sensitive areas, the updated code mitigates the risk of unauthorized changes, thereby enhancing the overall security of the XML processing.","The vulnerability was fixed by adding a condition that checks the node's path to determine if it resides within the access control list section. Specifically, the code now verifies if the attribute named ""id"" is present while ensuring that the path does not contain the ACL tag. This prevents the postponement of access control checks for nodes created in the ACL context. By enforcing the access control check using `__xml_acl_check` in these cases, the updated code ensures that all modifications within the ACL section are properly validated, thereby enhancing security and preventing unauthorized changes.","The vulnerability was addressed by implementing a condition that checks the context in which new nodes are being created, specifically targeting sensitive areas of the XML structure. The fix ensures that if a node is being created with only minimal attributes, it must be validated against access control rules when it falls within restricted sections. This added layer of verification prevents unauthorized modifications by enforcing stricter access control checks in critical contexts, thereby enhancing the overall security of the XML processing and ensuring that all changes are appropriately authorized.","CWE-284, CWE-269, CWE-285, CWE-732, CWE-668, CWE-281, CWE-287, CWE-693, CWE-863, CWE-913",N,-1
42,42,179867,179867,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,arch/x86/mm/mmap.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",C,"static unsigned long stack_maxrandom_size(void)
	unsigned long max = 0;
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
","	unsigned int max = 0;
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
",,"@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {
 	.flags = -1,
 };
 
-static unsigned int stack_maxrandom_size(void)
+static unsigned long stack_maxrandom_size(void)
 {
-	unsigned int max = 0;
+	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
+		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1,"static unsigned int stack_maxrandom_size(void)
//fix_flaw_line_below:
//static unsigned long stack_maxrandom_size(void)
 {
//flaw_line_below:
	unsigned int max = 0;
//fix_flaw_line_below:
//	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
//fix_flaw_line_below:
//		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",179867,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","The provided code defines a static function `stack_maxrandom_size` that calculates the maximum random stack size for the current process. It first initializes a variable `max` to zero. The function checks if the current process has the `PF_RANDOMIZE` flag set and does not have the `ADDR_NO_RANDOMIZE` personality flag. If both conditions are met, it computes the maximum stack size by applying a bitwise operation to `-1U` masked with `STACK_RND_MASK`, then left-shifting the result by `PAGE_SHIFT`. Finally, it returns the calculated maximum stack size or zero if the conditions are not satisfied.","The code defines a function that determines the maximum allowable size for a randomized stack in the current process. It starts by initializing a size variable to zero. The function checks specific flags associated with the current process to ascertain whether stack randomization is enabled. If the conditions for randomization are satisfied, it calculates the maximum stack size using a bitwise operation combined with a left shift to adjust for page size. Ultimately, the function returns either the computed maximum size or zero, depending on whether the randomization conditions are met.","The vulnerability in the original code arises from the use of an unsigned integer type for the variable `max`, which limits the maximum stack size calculation and could lead to integer overflow or incorrect size representation. This issue is addressed in the fixed code by changing the type of `max` from `unsigned int` to `unsigned long`, allowing for a larger range of values. Additionally, the expression `(-1U)` is replaced with `(-1UL)`, ensuring that the bitwise operation correctly handles larger values without overflow. This change enhances the robustness of the stack size calculation, preventing potential exploitation through stack size manipulation.","The vulnerability in the original code stems from the use of a data type that restricts the maximum size calculation, potentially leading to integer overflow or incorrect values when determining the stack size. This limitation could allow an attacker to exploit the system by manipulating stack allocations. The fixed code addresses this issue by changing the data type to a larger one, which accommodates a broader range of values and prevents overflow. Additionally, the adjustment in the calculation ensures that the maximum size is accurately represented, thereby enhancing the security and reliability of the stack size determination process.","The vulnerability was fixed by changing the data type of the variable `max` from `unsigned int` to `unsigned long`, allowing for a larger range of values in the maximum stack size calculation. This change prevents potential integer overflow that could occur with smaller data types. Additionally, the expression used to initialize `max` was modified from `(-1U)` to `(-1UL)`, ensuring that the bitwise operation correctly handles larger values without overflow. These adjustments enhance the robustness of the stack size calculation, making it less susceptible to exploitation through stack manipulation.","The vulnerability was addressed by changing the data type used for the maximum size calculation to accommodate a larger range of values, thereby preventing potential integer overflow issues. This adjustment ensures that the calculation can handle larger stack sizes without risk of misrepresentation. Additionally, the initialization expression was modified to align with the new data type, ensuring that the bitwise operations performed during the calculation are accurate and safe. These changes collectively enhance the security and reliability of the stack size determination, reducing the risk of exploitation through manipulation of stack allocations.","CWE-190, CWE-680, CWE-128, CWE-789, CWE-131, CWE-194, CWE-681, CWE-122, CWE-788, CWE-129",N,-1
43,43,179868,179868,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,fs/binfmt_elf.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",C,"	unsigned long random_variable = 0;
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
","	unsigned int random_variable = 0;
		random_variable = get_random_int() & STACK_RND_MASK;
",,"@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
 
 static unsigned long randomize_stack_top(unsigned long stack_top)
 {
-	unsigned int random_variable = 0;
+	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		random_variable = get_random_int() & STACK_RND_MASK;
+		random_variable = (unsigned long) get_random_int();
+		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
//flaw_line_below:
	unsigned int random_variable = 0;
//fix_flaw_line_below:
//	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		random_variable = get_random_int() & STACK_RND_MASK;
//fix_flaw_line_below:
//		random_variable = (unsigned long) get_random_int();
//fix_flaw_line_below:
//		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",179868," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
","The `randomize_stack_top` function modifies the stack's top address for a process, enhancing security through address space layout randomization (ASLR). It checks if the current process has the `PF_RANDOMIZE` flag set and does not have the `ADDR_NO_RANDOMIZE` personality, indicating that randomization is allowed. If so, it generates a random integer, masks it with `STACK_RND_MASK`, and shifts it left by `PAGE_SHIFT` to align with page boundaries. Depending on the stack growth direction (up or down), it either adds or subtracts this random value from the aligned stack top, effectively randomizing the stack's starting point.","This function enhances security by randomizing the top address of a process's stack, a technique known as address space layout randomization. It first checks if the current process is allowed to undergo this randomization based on specific flags. If permitted, it generates a random value, which is adjusted to align with memory page boundaries. Depending on the direction in which the stack grows, the function either adds or subtracts this random value from the aligned stack address. This process helps to prevent certain types of attacks that rely on predictable memory layouts.","The vulnerability in the original code stemmed from using an `unsigned int` type for the `random_variable`, which limited the range of random values and could lead to insufficient randomization of the stack address. This could potentially allow attackers to predict the stack's layout, making it easier to exploit memory-related vulnerabilities. In the fixed code, the type of `random_variable` was changed to `unsigned long`, allowing for a broader range of random values. This adjustment enhances the effectiveness of the randomization process, thereby improving the security of the stack address against potential attacks.","The vulnerability in the original code arose from the use of a data type that restricted the range of random values generated for stack address randomization, potentially allowing attackers to predict the stack layout. This limitation could lead to insufficient randomness, making it easier for an attacker to exploit memory-related vulnerabilities. The fix involved changing the data type to one that supports a larger range of values, thereby enhancing the randomness of the generated address. This improvement significantly increases the security of the stack address, making it more resistant to attacks that rely on predictable memory layouts.","The vulnerability was fixed by changing the data type of `random_variable` from `unsigned int` to `unsigned long`. This modification allows for a broader range of values to be generated by the `get_random_int()` function, which is then masked with `STACK_RND_MASK` and shifted left by `PAGE_SHIFT`. By using a larger data type, the randomization process becomes more effective, significantly enhancing the unpredictability of the stack address. This change ensures that the stack's top address is less susceptible to being guessed or exploited, thereby improving overall security against memory-related attacks.","The vulnerability was addressed by modifying the data type used for generating random values, allowing for a wider range of possible outcomes. This change enhances the randomness of the values produced, which is crucial for effective address space layout randomization. By ensuring that the randomization process can produce larger and more varied values, the fix significantly reduces the predictability of the stack address. This improvement makes it much more difficult for attackers to exploit memory-related vulnerabilities, thereby strengthening the overall security of the system against potential attacks that rely on predictable memory layouts.","CWE-119,CWE-121,CWE-122,CWE-788,CWE-416,CWE-476,CWE-457,CWE-466,CWE-789,CWE-401",N,-1
44,44,179900,179900,,Remote,Not required,Complete,CVE-2015-0278,https://www.cvedetails.com/cve/CVE-2015-0278/,CWE-264,Low,Complete,Complete,,2015-05-18,10.0,"libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",2018-08-13,+Priv ,11,https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c,66ab38918c911bcff025562cf06237d7fedaba0c,"unix: call setgoups before calling setuid/setgid

Partial fix for #1093",0,src/unix/process.c,"{""sha"": ""1efd588b86ef8fcff0f75a1a999c104f2288cadc"", ""filename"": ""src/unix/process.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/libuv/libuv/blob/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""raw_url"": ""https://github.com/libuv/libuv/raw/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""contents_url"": ""https://api.github.com/repos/libuv/libuv/contents/src/unix/process.c?ref=66ab38918c911bcff025562cf06237d7fedaba0c"", ""patch"": ""@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\""setgid()\"");""}","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",C,"  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

",,,"@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+    /* When dropping privileges from root, the `setgroups` call will
+     * remove any extraneous groups. If we don't call this, then
+     * even though our uid has dropped, we may still have groups
+     * that enable us to do super-user things. This will fail if we
+     * aren't root, so don't bother checking the return value, this
+     * is just done as an optimistic privilege dropping function.
+     */
+    SAVE_ERRNO(setgroups(0, NULL));
+  }
+
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");",libuv,66ab38918c911bcff025562cf06237d7fedaba0c,3901ec49767a5b66bebe0a46cf851579f5f040c0,1,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
//fix_flaw_line_below:
//  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
//fix_flaw_line_below:
//    /* When dropping privileges from root, the `setgroups` call will
//fix_flaw_line_below:
//     * remove any extraneous groups. If we don't call this, then
//fix_flaw_line_below:
//     * even though our uid has dropped, we may still have groups
//fix_flaw_line_below:
//     * that enable us to do super-user things. This will fail if we
//fix_flaw_line_below:
//     * aren't root, so don't bother checking the return value, this
//fix_flaw_line_below:
//     * is just done as an optimistic privilege dropping function.
//fix_flaw_line_below:
//     */
//fix_flaw_line_below:
//    SAVE_ERRNO(setgroups(0, NULL));
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",179900,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","The provided code defines a function `uv__process_child_init` that initializes a child process based on specified options. It handles standard input/output redirection, ensuring that if file descriptors are not provided, they default to `/dev/null`. The function also manages process group settings, changes the working directory if specified, and sets user/group IDs based on the provided options. Additionally, it updates the environment variables if specified and attempts to execute a given file with arguments using `execvp`. If any operation fails, it writes the error to a specified file descriptor and terminates the process with an error code.","The code initializes a child process by configuring its standard input and output, ensuring that they are redirected appropriately, often to a null device if not specified. It manages process group settings and changes the working directory if provided. Additionally, it sets user and group IDs based on the given options and updates the environment variables as needed. Finally, it attempts to execute a specified program with the provided arguments. In case of any errors during these operations, the code reports the error and terminates the process with an appropriate exit code.","The vulnerability in the original code arises from the lack of a privilege-dropping mechanism when changing user or group IDs, which could allow a process to retain elevated privileges even after switching to a non-privileged user. This oversight could lead to unauthorized access to sensitive resources. The fixed code addresses this by introducing a call to `setgroups(0, NULL)` before changing the user or group IDs. This function clears any supplementary groups, ensuring that the process does not retain any privileges that could be exploited, thereby enhancing the security of the privilege-dropping process.","The vulnerability in the original code stems from the failure to properly drop supplementary group privileges when changing user or group IDs, which could allow a process to retain elevated access rights even after switching to a less privileged user. This oversight posed a risk of unauthorized access to sensitive resources. The fixed code mitigates this issue by implementing a mechanism to clear any extraneous groups before changing the user or group IDs. This ensures that the process does not retain any potentially dangerous privileges, thereby enhancing the overall security of the privilege management process.","The vulnerability was fixed by adding a call to `setgroups(0, NULL)` before changing the user or group IDs. This function clears any supplementary groups that the process may belong to, ensuring that even after the user ID is changed, the process does not retain any elevated privileges associated with those groups. This step is crucial when dropping privileges from a root user, as it prevents the process from performing actions that could compromise security. By implementing this change, the code enhances the security of the privilege-dropping mechanism, reducing the risk of unauthorized access.","The vulnerability was addressed by introducing a mechanism to clear any supplementary groups that the process may belong to before changing user or group IDs. This step ensures that the process does not retain any elevated privileges that could be exploited, particularly when transitioning from a root user to a less privileged user. By removing these extraneous groups, the code effectively mitigates the risk of unauthorized access to sensitive resources, thereby enhancing the overall security of the privilege management process and ensuring that the process operates with the intended level of access.","CWE-269, CWE-272, CWE-250, CWE-264, CWE-266, CWE-271, CWE-265, CWE-274, CWE-273, CWE-263",N,-1
45,45,179943,179943,,Local,Not required,,CVE-2014-9644,https://www.cvedetails.com/cve/CVE-2014-9644/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a parenthesized module template expression in the salg_name field, as demonstrated by the vfat(aes) expression, a different vulnerability than CVE-2013-7421.",2018-01-04,,2,https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560,4943ba16bbc2db05115707b3ff7b4874e9e3c560,"crypto: include crypto- module prefix in template

This adds the module loading prefix ""crypto-"" to the template lookup
as well.

For example, attempting to load 'vfat(blowfish)' via AF_ALG now correctly
includes the ""crypto-"" prefix at every level, correctly rejecting ""vfat"":

	net-pf-38
	algif-hash
	crypto-vfat(blowfish)
	crypto-vfat(blowfish)-all
	crypto-vfat

Reported-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Acked-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/algapi.c,"{""sha"": ""f368ba261739fa09be28bc02fe34cf3112099fa8"", ""filename"": ""arch/x86/crypto/fpu.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/fpu.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -17,6 +17,7 @@\n #include <linux/kernel.h>\n #include <linux/module.h>\n #include <linux/slab.h>\n+#include <linux/crypto.h>\n #include <asm/i387.h>\n \n struct crypto_fpu_ctx {\n@@ -159,3 +160,5 @@ void __exit crypto_fpu_exit(void)\n {\n \tcrypto_unregister_template(&crypto_fpu_tmpl);\n }\n+\n+MODULE_ALIAS_CRYPTO(\""fpu\"");""}<_**next**_>{""sha"": ""71a8143e23b13390ec020ffb7f1168ae9ca285fc"", ""filename"": ""crypto/algapi.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algapi.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)\n \n struct crypto_template *crypto_lookup_template(const char *name)\n {\n-\treturn try_then_request_module(__crypto_lookup_template(name), \""%s\"",\n-\t\t\t\t       name);\n+\treturn try_then_request_module(__crypto_lookup_template(name),\n+\t\t\t\t       \""crypto-%s\"", name);\n }\n EXPORT_SYMBOL_GPL(crypto_lookup_template);\n ""}<_**next**_>{""sha"": ""78fb16cab13f9660553a0705941608ec3a59d88a"", ""filename"": ""crypto/authenc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authenc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -721,3 +721,4 @@ module_exit(crypto_authenc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Simple AEAD wrapper for IPsec\"");\n+MODULE_ALIAS_CRYPTO(\""authenc\"");""}<_**next**_>{""sha"": ""024bff2344fcff9d0ae3af5c04b4a75280dd2d4a"", ""filename"": ""crypto/authencesn.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authencesn.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -814,3 +814,4 @@ module_exit(crypto_authenc_esn_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""AEAD wrapper for IPsec with extended sequence numbers\"");\n+MODULE_ALIAS_CRYPTO(\""authencesn\"");""}<_**next**_>{""sha"": ""780ee27b2d43d5f3620d32c4df6c00670b6c48c8"", ""filename"": ""crypto/cbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -289,3 +289,4 @@ module_exit(crypto_cbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cbc\"");""}<_**next**_>{""sha"": ""003bbbd21a2ba9a24f4207f20037d5ee75593726"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -881,3 +881,4 @@ MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm\"");""}<_**next**_>{""sha"": ""63c17d5992f79b5a5ed40a526fa58a532eb3e5dc"", ""filename"": ""crypto/chainiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/chainiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -359,3 +359,4 @@ module_exit(chainiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Chain IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""chainiv\"");""}<_**next**_>{""sha"": ""7a8bfbd548f60835fbf417ab96e43b749a5d283f"", ""filename"": ""crypto/cmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -313,3 +313,4 @@ module_exit(crypto_cmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CMAC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cmac\"");""}<_**next**_>{""sha"": ""650afac10fd78e5ba51a28d7161ee71bcd6f3175"", ""filename"": ""crypto/cryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -955,3 +955,4 @@ module_exit(cryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""cryptd\"");""}<_**next**_>{""sha"": ""2386f731395207a2432d782d10c1421a0577dff3"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -467,3 +467,4 @@ module_exit(crypto_ctr_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n MODULE_ALIAS_CRYPTO(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""ctr\"");""}<_**next**_>{""sha"": ""bd9405820e8ac5ade61d6d6793ec18510d456ad9"", ""filename"": ""crypto/cts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -351,3 +351,4 @@ module_exit(crypto_cts_module_exit);\n \n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""CTS-CBC CipherText Stealing for CBC\"");\n+MODULE_ALIAS_CRYPTO(\""cts\"");""}<_**next**_>{""sha"": ""12011aff097136331f5aca539acb487746efcd69"", ""filename"": ""crypto/ecb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ecb.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -185,3 +185,4 @@ module_exit(crypto_ecb_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ECB block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""ecb\"");""}<_**next**_>{""sha"": ""f116fae766f81611c5530a6d92313c5e88d23fe1"", ""filename"": ""crypto/eseqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/eseqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -267,3 +267,4 @@ module_exit(eseqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Encrypted Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""eseqiv\"");""}<_**next**_>{""sha"": ""2e403f6138c14bbcb048d59256f0fb40e2032f2d"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -1444,3 +1444,4 @@ MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n MODULE_ALIAS_CRYPTO(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm\"");""}<_**next**_>{""sha"": ""72e38c098bb3184d3886ac4054f123dca3bb49ac"", ""filename"": ""crypto/hmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/hmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -268,3 +268,4 @@ module_exit(hmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""HMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""hmac\"");""}<_**next**_>{""sha"": ""6f9908a7ebcbe19f76a4ee306f326f291aff8de9"", ""filename"": ""crypto/lrw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lrw.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -400,3 +400,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LRW block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""lrw\"");""}<_**next**_>{""sha"": ""a8e870444ea9cef0ab4a2c6c919724905c7dbde7"", ""filename"": ""crypto/mcryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/mcryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -703,3 +703,4 @@ module_exit(mcryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async multibuffer crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""mcryptd\"");""}<_**next**_>{""sha"": ""f654965f09338dab066795d8c6ab8618ef263d93"", ""filename"": ""crypto/pcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -295,3 +295,4 @@ module_exit(crypto_pcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""PCBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""pcbc\"");""}<_**next**_>{""sha"": ""c305d4112735cd3b7b18b477299b534b8c0e1b77"", ""filename"": ""crypto/pcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcrypt.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -565,3 +565,4 @@ module_exit(pcrypt_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""Parallel crypto wrapper\"");\n+MODULE_ALIAS_CRYPTO(\""pcrypt\"");""}<_**next**_>{""sha"": ""9daa854cc485b61e97eb7b25ead68da14a47ce88"", ""filename"": ""crypto/seqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(seqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""seqiv\"");""}<_**next**_>{""sha"": ""df76a816cfb22f68ac173d3ef01e2e2f9e166c72"", ""filename"": ""crypto/vmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/vmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -713,3 +713,4 @@ module_exit(vmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""VMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""vmac\"");""}<_**next**_>{""sha"": ""df90b332554cf43fb595623af3e854534a9dc49b"", ""filename"": ""crypto/xcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -286,3 +286,4 @@ module_exit(crypto_xcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XCBC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""xcbc\"");""}<_**next**_>{""sha"": ""f6fd43f100c8c68c7150cad5224fafc5dc61db2c"", ""filename"": ""crypto/xts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XTS block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""xts\"");""}"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
",C,"	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
","	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
",,"@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)
 
 struct crypto_template *crypto_lookup_template(const char *name)
 {
-	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
-				       name);
+	return try_then_request_module(__crypto_lookup_template(name),
+				       ""crypto-%s"", name);
 }
 EXPORT_SYMBOL_GPL(crypto_lookup_template);
 ",linux,4943ba16bbc2db05115707b3ff7b4874e9e3c560,476c7fe20f30818e16339391aeeb01b29818f708,1," struct crypto_template *crypto_lookup_template(const char *name)
 {
//flaw_line_below:
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
//flaw_line_below:
				       name);
//fix_flaw_line_below:
//	return try_then_request_module(__crypto_lookup_template(name),
//fix_flaw_line_below:
//				       ""crypto-%s"", name);
 }
",179943," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
","The provided code defines a function `crypto_lookup_template` that takes a string parameter `name`, representing the name of a cryptographic template. It calls another function, `__crypto_lookup_template`, to attempt to retrieve the specified template. If the template is not found, the `try_then_request_module` function is invoked, which attempts to load the corresponding module dynamically, using the template name as a reference. This ensures that if the template is not already available, the system will try to load the necessary module to provide the requested cryptographic functionality, enhancing modularity and flexibility in cryptographic operations.","The code defines a function that retrieves a specified cryptographic template based on a given name. It first attempts to locate the template directly. If the template is not found, the function dynamically loads the necessary module associated with that template name. This approach ensures that the required cryptographic functionality is available, even if it was not initially loaded into the system. By handling both the lookup and potential module loading, the function enhances the system's ability to manage cryptographic operations efficiently and flexibly, adapting to the needs of the application at runtime.","The vulnerability in the original code arises from the way the module is requested when a cryptographic template is not found. The original implementation uses a generic format string, which could lead to improper module loading or even exploitation through format string vulnerabilities. In the fixed code, the format string is changed to ""crypto-%s"", ensuring that the module name is correctly prefixed, thus mitigating the risk of loading unintended or malicious modules. This change enhances security by enforcing a specific naming convention for the modules, reducing the potential attack surface associated with dynamic module loading.","The vulnerability in the original code stems from the use of a generic format string when attempting to load a module, which could allow an attacker to manipulate the input and potentially load unintended or malicious modules. This could lead to security risks, such as executing arbitrary code or accessing sensitive data. The fixed code addresses this issue by implementing a specific format string that includes a defined prefix, ensuring that only appropriately named modules are requested. This change significantly reduces the risk of exploitation by enforcing stricter control over the module loading process, thereby enhancing overall system security.","The vulnerability was fixed by modifying the format string used in the `try_then_request_module` function call. In the original code, the format string was generic, which could lead to improper module loading. The updated code changes the format string to ""crypto-%s"", ensuring that the module name is prefixed correctly. This adjustment restricts the module loading to those that follow a specific naming convention, thereby preventing the potential exploitation of the system through arbitrary module requests. By enforcing this stricter format, the code enhances security and mitigates risks associated with dynamic module loading.","The vulnerability was addressed by refining the format string used for module requests, shifting from a generic format to a more specific one that includes a defined prefix. This change ensures that only modules adhering to a particular naming convention can be loaded, significantly reducing the risk of loading unintended or malicious modules. By enforcing this stricter requirement, the code mitigates the potential for exploitation through improper module loading, thereby enhancing the overall security of the system. This fix effectively limits the attack surface associated with dynamic module management, promoting safer execution of cryptographic operations.","CWE-73, CWE-99, CWE-23, CWE-434, CWE-78, CWE-426, CWE-427, CWE-749, CWE-114, CWE-470",N,-1
46,46,180011,180011,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,2,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/api.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",C,"		request_module(""crypto-%s"", name);
			request_module(""crypto-%s-all"", name);
","		request_module(""%s"", name);
			request_module(""%s-all"", name);
",,"@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
-		request_module(""%s"", name);
+		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
-			request_module(""%s-all"", name);
+			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,1,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
//flaw_line_below:
			request_module(""%s-all"", name);
//fix_flaw_line_below:
//			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",180011,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","The `crypto_larval_lookup` function is designed to locate a cryptographic algorithm by its name, type, and mask, handling cases where the algorithm may not yet be available. It first checks if the provided name is valid; if not, it returns an error. The function then filters the type using the mask and attempts to find the algorithm using `crypto_alg_lookup`. If the algorithm is not found, it requests the corresponding module and potentially a fallback module. Finally, if the algorithm is found and is in a ""larval"" state, it waits for it to become ready; otherwise, it returns the algorithm or adds it if not found.","The provided code defines a function that searches for a cryptographic algorithm based on a specified name, type, and mask. It first checks for the validity of the name and returns an error if it is absent. The function then refines the type using the mask and attempts to locate the algorithm. If the algorithm is not found, it requests the necessary module and potentially a fallback option. Upon finding the algorithm, it checks its state; if it is not ready, the function waits for it to become available. If the algorithm is still not found, it adds it to the system.","The vulnerability in the original code stemmed from the lack of a specific prefix when requesting modules, which could lead to incorrect module loading or conflicts. In the fixed code, the `request_module` function now includes a ""crypto-"" prefix when requesting the algorithm and its fallback, ensuring that the correct modules are targeted. This change mitigates the risk of loading unintended modules, which could compromise system security or functionality. By refining the module request process, the fixed code enhances the reliability and safety of the cryptographic algorithm lookup mechanism.","The vulnerability in the original code arose from the potential for incorrect module loading due to a lack of specificity in the module request process. This could lead to unintended modules being loaded, which might compromise system security or functionality. The fix addressed this issue by adding a specific prefix to the module requests, ensuring that only the appropriate modules related to cryptographic algorithms are targeted. This enhancement reduces the risk of conflicts and improves the reliability of the algorithm lookup mechanism, ultimately strengthening the overall security of the system.","The vulnerability was fixed by modifying the `request_module` function calls to include a specific prefix, ""crypto-"", when requesting modules. In the original code, the requests were made using just the algorithm name, which could lead to incorrect module loading. The updated code now uses `request_module(""crypto-%s"", name)` and `request_module(""crypto-%s-all"", name)`, ensuring that the correct cryptographic modules are targeted. This change prevents potential conflicts and enhances the accuracy of module loading, thereby improving the security and reliability of the cryptographic algorithm lookup process.","The vulnerability was addressed by refining the module request process to include a specific prefix that clearly identifies the type of modules being requested. This change ensures that only the appropriate modules related to cryptographic algorithms are loaded, reducing the risk of conflicts or unintended module loading. By making the module requests more precise, the fix enhances the reliability of the algorithm lookup mechanism and strengthens the overall security of the system. This improvement prevents potential security issues that could arise from loading incorrect or incompatible modules.","CWE-916, CWE-284, CWE-426, CWE-23, CWE-434, CWE-470, CWE-114, CWE-427, CWE-706, CWE-940",N,-1
47,47,180630,180630,,Local,Not required,Complete,CVE-2015-8966,https://www.cvedetails.com/cve/CVE-2015-8966/,CWE-264,Low,Complete,Complete,,2016-12-08,7.2,"arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call.",2016-12-09,+Priv ,37,https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42,76cc404bfdc0d419c720de4daaf2584542734f42,"[PATCH] arm: fix handling of F_OFD_... in oabi_fcntl64()

Cc: stable@vger.kernel.org # 3.15+
Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",33,arch/arm/kernel/sys_oabi-compat.c,"{""sha"": ""087acb569b63a4bd90982e0c9b15fc2313636c53"", ""filename"": ""arch/arm/kernel/sys_oabi-compat.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 36, ""changes"": 73, ""blob_url"": ""https://github.com/torvalds/linux/blob/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/sys_oabi-compat.c?ref=76cc404bfdc0d419c720de4daaf2584542734f42"", ""patch"": ""@@ -193,55 +193,56 @@ struct oabi_flock64 {\n \tpid_t\tl_pid;\n } __attribute__ ((packed,aligned(4)));\n \n-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+static long do_locks(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n-\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n-\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n-\tunsigned long local_arg = arg;\n-\tint ret;\n+\tstruct oabi_flock64 user;\n+\tmm_segment_t fs;\n+\tlong ret;\n+\n+\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n+\t\t\t   sizeof(user)))\n+\t\treturn -EFAULT;\n+\tkernel.l_type\t= user.l_type;\n+\tkernel.l_whence\t= user.l_whence;\n+\tkernel.l_start\t= user.l_start;\n+\tkernel.l_len\t= user.l_len;\n+\tkernel.l_pid\t= user.l_pid;\n+\n+\tfs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n+\tset_fs(fs);\n+\n+\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n+\t\tuser.l_type\t= kernel.l_type;\n+\t\tuser.l_whence\t= kernel.l_whence;\n+\t\tuser.l_start\t= kernel.l_start;\n+\t\tuser.l_len\t= kernel.l_len;\n+\t\tuser.l_pid\t= kernel.l_pid;\n+\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n+\t\t\t\t &user, sizeof(user)))\n+\t\t\tret = -EFAULT;\n+\t}\n+\treturn ret;\n+}\n \n+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+\t\t\t\t unsigned long arg)\n+{\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n \tcase F_OFD_SETLKW:\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n-\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n-\t\t\t\t   sizeof(user)))\n-\t\t\treturn -EFAULT;\n-\t\tkernel.l_type\t= user.l_type;\n-\t\tkernel.l_whence\t= user.l_whence;\n-\t\tkernel.l_start\t= user.l_start;\n-\t\tkernel.l_len\t= user.l_len;\n-\t\tkernel.l_pid\t= user.l_pid;\n-\t\tlocal_arg = (unsigned long)&kernel;\n-\t\tfs = get_fs();\n-\t\tset_fs(KERNEL_DS);\n-\t}\n-\n-\tret = sys_fcntl64(fd, cmd, local_arg);\n+\t\treturn do_locks(fd, cmd, arg);\n \n-\tswitch (cmd) {\n-\tcase F_GETLK64:\n-\t\tif (!ret) {\n-\t\t\tuser.l_type\t= kernel.l_type;\n-\t\t\tuser.l_whence\t= kernel.l_whence;\n-\t\t\tuser.l_start\t= kernel.l_start;\n-\t\t\tuser.l_len\t= kernel.l_len;\n-\t\t\tuser.l_pid\t= kernel.l_pid;\n-\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n-\t\t\t\t\t &user, sizeof(user)))\n-\t\t\t\tret = -EFAULT;\n-\t\t}\n-\tcase F_SETLK64:\n-\tcase F_SETLKW64:\n-\t\tset_fs(fs);\n+\tdefault:\n+\t\treturn sys_fcntl64(fd, cmd, arg);\n \t}\n-\n-\treturn ret;\n }\n \n struct oabi_epoll_event {""}","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
",C,"static long do_locks(unsigned int fd, unsigned int cmd,
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
		return do_locks(fd, cmd, arg);
	default:
		return sys_fcntl64(fd, cmd, arg);
","	struct oabi_flock64 user;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
	return ret;
",,"@@ -193,55 +193,56 @@ struct oabi_flock64 {
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
-	struct oabi_flock64 user;
 	struct flock64 kernel;
-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
-	unsigned long local_arg = arg;
-	int ret;
+	struct oabi_flock64 user;
+	mm_segment_t fs;
+	long ret;
+
+	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
+			   sizeof(user)))
+		return -EFAULT;
+	kernel.l_type	= user.l_type;
+	kernel.l_whence	= user.l_whence;
+	kernel.l_start	= user.l_start;
+	kernel.l_len	= user.l_len;
+	kernel.l_pid	= user.l_pid;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
+	set_fs(fs);
+
+	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
+		user.l_type	= kernel.l_type;
+		user.l_whence	= kernel.l_whence;
+		user.l_start	= kernel.l_start;
+		user.l_len	= kernel.l_len;
+		user.l_pid	= kernel.l_pid;
+		if (copy_to_user((struct oabi_flock64 __user *)arg,
+				 &user, sizeof(user)))
+			ret = -EFAULT;
+	}
+	return ret;
+}
 
+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+				 unsigned long arg)
+{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
-		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
-				   sizeof(user)))
-			return -EFAULT;
-		kernel.l_type	= user.l_type;
-		kernel.l_whence	= user.l_whence;
-		kernel.l_start	= user.l_start;
-		kernel.l_len	= user.l_len;
-		kernel.l_pid	= user.l_pid;
-		local_arg = (unsigned long)&kernel;
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-	}
-
-	ret = sys_fcntl64(fd, cmd, local_arg);
+		return do_locks(fd, cmd, arg);
 
-	switch (cmd) {
-	case F_GETLK64:
-		if (!ret) {
-			user.l_type	= kernel.l_type;
-			user.l_whence	= kernel.l_whence;
-			user.l_start	= kernel.l_start;
-			user.l_len	= kernel.l_len;
-			user.l_pid	= kernel.l_pid;
-			if (copy_to_user((struct oabi_flock64 __user *)arg,
-					 &user, sizeof(user)))
-				ret = -EFAULT;
-		}
-	case F_SETLK64:
-	case F_SETLKW64:
-		set_fs(fs);
+	default:
+		return sys_fcntl64(fd, cmd, arg);
 	}
-
-	return ret;
 }
 
 struct oabi_epoll_event {",linux,76cc404bfdc0d419c720de4daaf2584542734f42,74bf8efb5fa6e958d2d7c7917b8bb672085ec0c6,1,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
//flaw_line_below:
	struct oabi_flock64 user;
 	struct flock64 kernel;
//flaw_line_below:
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
//flaw_line_below:
	unsigned long local_arg = arg;
//flaw_line_below:
	int ret;
//fix_flaw_line_below:
//	struct oabi_flock64 user;
//fix_flaw_line_below:
//	mm_segment_t fs;
//fix_flaw_line_below:
//	long ret;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//			   sizeof(user)))
//fix_flaw_line_below:
//		return -EFAULT;
//fix_flaw_line_below:
//	kernel.l_type	= user.l_type;
//fix_flaw_line_below:
//	kernel.l_whence	= user.l_whence;
//fix_flaw_line_below:
//	kernel.l_start	= user.l_start;
//fix_flaw_line_below:
//	kernel.l_len	= user.l_len;
//fix_flaw_line_below:
//	kernel.l_pid	= user.l_pid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	fs = get_fs();
//fix_flaw_line_below:
//	set_fs(KERNEL_DS);
//fix_flaw_line_below:
//	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
//fix_flaw_line_below:
//	set_fs(fs);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
//fix_flaw_line_below:
//		user.l_type	= kernel.l_type;
//fix_flaw_line_below:
//		user.l_whence	= kernel.l_whence;
//fix_flaw_line_below:
//		user.l_start	= kernel.l_start;
//fix_flaw_line_below:
//		user.l_len	= kernel.l_len;
//fix_flaw_line_below:
//		user.l_pid	= kernel.l_pid;
//fix_flaw_line_below:
//		if (copy_to_user((struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//				 &user, sizeof(user)))
//fix_flaw_line_below:
//			ret = -EFAULT;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	return ret;
//fix_flaw_line_below:
//}
 
//fix_flaw_line_below:
//asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//				 unsigned long arg)
//fix_flaw_line_below:
//{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
//flaw_line_below:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//flaw_line_below:
				   sizeof(user)))
//flaw_line_below:
			return -EFAULT;
//flaw_line_below:
		kernel.l_type	= user.l_type;
//flaw_line_below:
		kernel.l_whence	= user.l_whence;
//flaw_line_below:
		kernel.l_start	= user.l_start;
//flaw_line_below:
		kernel.l_len	= user.l_len;
//flaw_line_below:
		kernel.l_pid	= user.l_pid;
//flaw_line_below:
		local_arg = (unsigned long)&kernel;
//flaw_line_below:
		fs = get_fs();
//flaw_line_below:
		set_fs(KERNEL_DS);
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	ret = sys_fcntl64(fd, cmd, local_arg);
//fix_flaw_line_below:
//		return do_locks(fd, cmd, arg);
 
//flaw_line_below:
	switch (cmd) {
//flaw_line_below:
	case F_GETLK64:
//flaw_line_below:
		if (!ret) {
//flaw_line_below:
			user.l_type	= kernel.l_type;
//flaw_line_below:
			user.l_whence	= kernel.l_whence;
//flaw_line_below:
			user.l_start	= kernel.l_start;
//flaw_line_below:
			user.l_len	= kernel.l_len;
//flaw_line_below:
			user.l_pid	= kernel.l_pid;
//flaw_line_below:
			if (copy_to_user((struct oabi_flock64 __user *)arg,
//flaw_line_below:
					 &user, sizeof(user)))
//flaw_line_below:
				ret = -EFAULT;
//flaw_line_below:
		}
//flaw_line_below:
	case F_SETLK64:
//flaw_line_below:
	case F_SETLKW64:
//flaw_line_below:
		set_fs(fs);
//fix_flaw_line_below:
//	default:
//fix_flaw_line_below:
//		return sys_fcntl64(fd, cmd, arg);
 	}
//flaw_line_below:

//flaw_line_below:
	return ret;
 }
",180630,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","The provided code defines a system call `sys_oabi_fcntl64`, which handles file locking operations in a 64-bit environment for user-space applications. It takes three parameters: a file descriptor (`fd`), a command (`cmd`), and an argument (`arg`). The function first initializes a user-space structure for file locks and checks the command type. For specific commands related to file locking, it copies data from user space to kernel space, modifies the file lock structure, and then calls the `sys_fcntl64` function to perform the actual operation. Finally, it copies the results back to user space if necessary and returns the operation's result.","The code implements a system call that facilitates file locking operations in a 64-bit environment. It accepts a file descriptor, a command indicating the type of operation, and an argument that contains lock information. The function checks the command type and, for specific locking commands, transfers data from user space to kernel space to prepare the lock structure. It then invokes another function to execute the requested operation and, if applicable, retrieves the results back to user space. The function ultimately returns the outcome of the operation, indicating success or failure.","The vulnerability in the original code arises from the lack of proper validation and handling of user input before accessing memory, which could lead to potential memory corruption or privilege escalation. Specifically, the original code directly copied data from user space to kernel space without checking if the user-provided address was valid, risking a fault if the address was invalid. In the fixed code, the logic is refactored into a separate function, `do_locks`, which ensures that user data is copied first and validated before any kernel operations are performed, thus mitigating the risk of accessing invalid memory and enhancing overall security.","The vulnerability in the original code stems from inadequate validation of user input before accessing memory, which could lead to memory corruption or security breaches. Specifically, the code directly copied data from user space to kernel space without ensuring the validity of the user-provided address, risking faults or exploitation. The fixed code addresses this issue by restructuring the logic into a separate function that first validates and copies user data before performing any kernel operations. This change enhances security by ensuring that only properly validated data is processed, thereby reducing the risk of accessing invalid memory.","The vulnerability was fixed by refactoring the code to separate the locking logic into a dedicated function called `do_locks`. In this new structure, the function first uses `copy_from_user` to safely copy data from user space into a user-defined structure, ensuring that the memory address is valid before any kernel operations are performed. This validation step prevents potential memory corruption. Additionally, the fixed code ensures that the file lock structure is only accessed after confirming the integrity of the user input, thereby enhancing security and reducing the risk of exploitation associated with invalid memory access.","The vulnerability was addressed by restructuring the code to isolate the locking operations into a dedicated function that first validates and copies user input before any kernel processing occurs. This approach ensures that the data is safely transferred from user space to a secure structure, mitigating the risk of accessing invalid memory. By performing the validation upfront, the code prevents potential memory corruption and enhances overall security. The separation of concerns also improves code clarity and maintainability, allowing for better handling of user input and reducing the likelihood of exploitation through improper memory access.","CWE-119, CWE-416, CWE-118, CWE-120, CWE-123, CWE-476, CWE-122, CWE-415, CWE-125, CWE-787",N,-1
48,48,180705,180705,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,2,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/keys/encrypted-keys/encrypted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",C,"	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
",,,"@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 ",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",180705,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","The `encrypted_update` function updates an encrypted key's payload in a kernel module. It first validates the input data length and allocates a buffer to hold the new data. After parsing the input data to extract a new master descriptor, it checks the validity of this descriptor against the existing one. If valid, it allocates a new encrypted key payload and initializes it with the existing format and data. The function then copies the initialization vector and payload data from the old payload to the new one, updates the key pointer to reference the new payload, and schedules the old payload for cleanup before returning the result of the operation.","The code defines a function that updates an encrypted key's payload within a kernel module. It begins by validating the input data's length and allocating memory for a buffer to store this data. After parsing the input to extract a new descriptor, it checks its validity against the existing one. If the new descriptor is valid, the function allocates a new payload and initializes it with the necessary parameters. It then copies relevant data from the old payload to the new one, updates the key reference to point to the new payload, and schedules the old payload for cleanup before returning the operation's result.","The vulnerability in the original code arises from the lack of a check for a specific flag indicating a negative key state, which could lead to unauthorized access or manipulation of the key payload. In the fixed code, the addition of the condition that checks if the `KEY_FLAG_NEGATIVE` bit is set ensures that the function exits early with an error if the key is in a negative state. This prevents further processing of potentially invalid or compromised data, thereby enhancing the security of the key management process and mitigating risks associated with improper key handling.","The vulnerability in the original code stems from the absence of a check for a specific condition that indicates an invalid or compromised state of the key. This oversight could allow unauthorized access or manipulation of sensitive data, leading to potential security breaches. The fixed code addresses this issue by introducing a validation step that ensures the function exits early if the key is in an invalid state. This additional safeguard prevents further processing of potentially harmful data, thereby enhancing the overall security of the key management system and reducing the risk of exploitation.","The vulnerability was fixed by adding a check for the `KEY_FLAG_NEGATIVE` bit in the key's flags at the beginning of the function. This new condition ensures that if the key is in a negative state, the function will immediately return an error code, specifically `-ENOKEY`, preventing any further processing of the key payload. This early exit effectively mitigates the risk of unauthorized access or manipulation of sensitive data. By enforcing this validation, the code enhances the security of the key management process and ensures that only valid keys are processed.","The vulnerability was addressed by implementing an initial validation step that checks the state of the key before any further processing occurs. This added condition ensures that if the key is deemed invalid or compromised, the function will terminate early with an appropriate error code. By preventing any subsequent operations on an invalid key, the fix effectively reduces the risk of unauthorized access or manipulation of sensitive data. This enhancement strengthens the overall security of the key management process, ensuring that only valid and secure keys are utilized in the system.","CWE-287, CWE-347, CWE-326, CWE-325, CWE-320, CWE-334, CWE-321, CWE-522, CWE-284, CWE-306",N,-1
49,49,180706,180706,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/trusted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",C,"	struct trusted_key_payload *p;
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
","	struct trusted_key_payload *p = key->payload.data[0];
",,"@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)
  */
 static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
-	struct trusted_key_payload *p = key->payload.data[0];
+	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
+	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
//flaw_line_below:
	struct trusted_key_payload *p = key->payload.data[0];
//fix_flaw_line_below:
//	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
//fix_flaw_line_below:
//	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",180706," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
","The `trusted_update` function is designed to update a trusted key's payload in a secure manner. It first checks if the key is migratable and validates the input data length. If the checks pass, it allocates memory for a new payload and options, then parses the provided data into these structures. The function copies existing key values to the new payload, reseals it with updated parameters, and handles potential errors during this process. Finally, it updates the key pointer to the new payload and schedules the old payload for cleanup, ensuring memory management and security throughout the operation.","The code implements a function that updates a secure key's payload while ensuring it meets specific criteria for security and validity. It first verifies that the key can be migrated and checks the validity of the input data. If the conditions are satisfied, it allocates memory for new structures and processes the input data. The function then transfers existing key attributes to the new structure, applies necessary security measures, and manages potential errors throughout the process. Finally, it updates the key reference to point to the new structure and schedules the old structure for cleanup, maintaining efficient memory management.","The vulnerability in the original code stemmed from the lack of a check for negative keys, which could lead to unauthorized access or manipulation of key data. By not verifying the key's status, the function could inadvertently operate on a key that should not be processed, potentially exposing sensitive information. The fix introduced a check using `test_bit(KEY_FLAG_NEGATIVE, &key->flags)` to ensure that the key is valid before proceeding with any operations. This additional validation step prevents the function from executing on negative keys, thereby enhancing the security and integrity of the key management process.","The vulnerability in the original code arose from the absence of a check for invalid or negative keys, which could allow unauthorized access to sensitive key data. This oversight meant that the function could operate on keys that should not be processed, potentially leading to security breaches. The fix addressed this issue by introducing a validation step to ensure that only valid keys are processed. This additional check prevents the function from executing on keys that are marked as negative, thereby enhancing the overall security and integrity of the key management process and protecting against unauthorized manipulations.","The vulnerability was fixed by adding a validation check at the beginning of the function using `test_bit(KEY_FLAG_NEGATIVE, &key->flags)`. This check ensures that the key is not marked as negative before any further processing occurs. If the key is found to be negative, the function immediately returns an error code, preventing any operations on potentially unauthorized or invalid keys. This enhancement effectively safeguards against unauthorized access and manipulation of key data, ensuring that only valid keys are processed in subsequent steps, thereby improving the overall security of the key management system.","The vulnerability was addressed by implementing an initial validation step to check the status of the key before any processing occurs. This added check ensures that only valid keys are allowed to proceed, effectively preventing the function from operating on keys that are marked as negative or invalid. By returning an error immediately if the key fails this validation, the code mitigates the risk of unauthorized access or manipulation of sensitive data. This enhancement significantly strengthens the security of the key management process by ensuring that only appropriate keys are processed further.","CWE-284, CWE-287, CWE-285, CWE-347, CWE-306, CWE-345, CWE-697, CWE-288, CWE-807, CWE-602",N,-1
50,50,180707,180707,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/user_defined.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",C,"		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
","		zap = key->payload.data[0];
",,"@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
-		zap = key->payload.data[0];
+		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+			zap = key->payload.data[0];
+		else
+			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
//flaw_line_below:
		zap = key->payload.data[0];
//fix_flaw_line_below:
//		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//			zap = key->payload.data[0];
//fix_flaw_line_below:
//		else
//fix_flaw_line_below:
//			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",180707,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","The provided code defines a function `user_update` that updates a user key's payload in a kernel module. It first validates the input data length and checks for null pointers, returning an error if the conditions are not met. If valid, it allocates memory for a new payload and copies the provided data into it. The function then reserves space for the new data in the key's payload and, if successful, replaces the old payload with the new one while resetting the key's expiry. Finally, it safely frees the old payload memory if it exists, ensuring proper memory management.","The code defines a function that updates a user key's associated data within a kernel module. It begins by validating the input data's length and ensuring it is not null, returning an error if the checks fail. Upon successful validation, it allocates memory for a new data payload and copies the provided data into this newly allocated space. The function then reserves the necessary space for the new data and, if successful, replaces the existing data while resetting the key's expiration status. Finally, it safely deallocates the memory used by the old data to prevent memory leaks.","The vulnerability in the original code arises from the potential for a use-after-free condition, where the old payload could be accessed after it has been deallocated. This occurs because the code does not check if the key is marked as negative before assigning the old payload to the variable `zap`. In the fixed code, a conditional check using `test_bit(KEY_FLAG_NEGATIVE, &key->flags)` ensures that the old payload is only accessed if the key is not negative, preventing the use of a dangling pointer. This change enhances memory safety by ensuring that deallocation only occurs when appropriate.","The vulnerability in the original code stems from the risk of accessing freed memory, which can lead to undefined behavior and potential exploitation. This issue arises when the code does not verify the state of the key before attempting to use the old data, allowing for a scenario where the old memory could be accessed after it has been deallocated. The fixed code addresses this vulnerability by introducing a conditional check that ensures the old data is only accessed if the key is in a valid state. This safeguard prevents the use of invalid memory, thereby enhancing the overall safety and stability of the code.","The vulnerability was fixed by adding a conditional check that evaluates the state of the key before accessing the old payload. Specifically, the code now uses `test_bit(KEY_FLAG_NEGATIVE, &key->flags)` to determine if the key is marked as negative. If the key is not negative, the old payload is assigned to the variable `zap`, allowing for safe deallocation later. If the key is negative, `zap` is set to `NULL`, preventing any attempt to free memory that should not be accessed. This modification ensures that memory is only freed when it is safe to do so, thus preventing potential use-after-free issues.","The vulnerability was addressed by implementing a conditional check that verifies the state of the key before accessing the old data. This check ensures that the old data is only referenced if the key is in a valid condition, thereby preventing any attempts to access memory that has already been freed. If the key is determined to be in an invalid state, the old data is not assigned, effectively avoiding any potential use-after-free scenarios. This enhancement significantly improves memory safety by ensuring that deallocation occurs only when it is appropriate, thus mitigating the risk of undefined behavior.","CWE-416,CWE-825,CWE-415,CWE-404,CWE-762,CWE-911,CWE-754,CWE-476,CWE-908,CWE-119",N,-1
51,51,181632,181632,,Remote,Single system,Partial,CVE-2016-10318,https://www.cvedetails.com/cve/CVE-2016-10318/,CWE-264,Low,,,,2017-04-04,4.0,"A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service.",2017-04-11,DoS ,3,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,"fscrypto: add authorization check for setting encryption policy

On an ext4 or f2fs filesystem with file encryption supported, a user
could set an encryption policy on any empty directory(*) to which they
had readonly access.  This is obviously problematic, since such a
directory might be owned by another user and the new encryption policy
would prevent that other user from creating files in their own directory
(for example).

Fix this by requiring inode_owner_or_capable() permission to set an
encryption policy.  This means that either the caller must own the file,
or the caller must have the capability CAP_FOWNER.

(*) Or also on any regular file, for f2fs v4.6 and later and ext4
    v4.8-rc1 and later; a separate bug fix is coming for that.

Signed-off-by: Eric Biggers <ebiggers@google.com>
Cc: stable@vger.kernel.org # 4.1+; check fs/{ext4,f2fs}
Signed-off-by: Theodore Ts'o <tytso@mit.edu>",0,fs/crypto/policy.c,"{""sha"": ""c9800b1a2e930f65e8fa7a9b052fb80efeba512c"", ""filename"": ""fs/crypto/policy.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/crypto/policy.c?ref=163ae1c6ad6299b19e22b4a35d5ab24a89791a98"", ""patch"": ""@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,\n int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n+\tif (!inode_owner_or_capable(inode))\n+\t\treturn -EACCES;\n+\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n ""}"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",C,"	if (!inode_owner_or_capable(inode))
		return -EACCES;

",,,"@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,
 int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
+	if (!inode_owner_or_capable(inode))
+		return -EACCES;
+
 	if (policy->version != 0)
 		return -EINVAL;
 ",linux,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,c6935931c1894ff857616ff8549b61236a19148f,1," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
//fix_flaw_line_below:
//	if (!inode_owner_or_capable(inode))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",181632," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
","The provided code defines a function `fscrypt_process_policy` that processes a filesystem encryption policy for a given inode. It first checks if the policy version is valid; if not, it returns an error. If the inode does not have an existing encryption context, it verifies if the filesystem supports empty directories and whether the directory is indeed empty before creating a new encryption context based on the provided policy. If the inode already has an encryption context, the function checks for consistency with the new policy, logging a warning if they are inconsistent. It returns appropriate error codes based on these checks.","The code defines a function that manages the application of an encryption policy to a filesystem object. It begins by validating the policy version and returns an error if it is not acceptable. If the object lacks an encryption context, the function checks whether the filesystem allows for empty directories and if the current directory is empty before creating a new encryption context based on the policy. If an encryption context already exists, it verifies its consistency with the new policy, issuing a warning if there is a mismatch, and returns appropriate error codes based on the outcomes of these checks.","The vulnerability in the original code stemmed from the lack of access control checks before processing an encryption policy for a filesystem object. This oversight allowed unauthorized users to potentially modify the encryption context of an inode, leading to security risks. The fixed code addresses this issue by introducing a check with the function `inode_owner_or_capable`, which ensures that only the owner or a user with sufficient capabilities can proceed with the policy processing. This enhancement effectively mitigates the risk of unauthorized access and manipulation of the encryption settings, thereby strengthening the overall security of the filesystem.","The vulnerability in the original code arose from the absence of access control measures, allowing unauthorized users to alter the encryption policy of a filesystem object. This lack of validation could lead to potential security breaches, as malicious actors could manipulate sensitive data. The fixed code rectifies this issue by implementing a check that verifies whether the user has the appropriate ownership or permissions before proceeding with any policy processing. This enhancement effectively restricts access to the encryption settings, thereby safeguarding the integrity and confidentiality of the filesystem against unauthorized modifications.","The vulnerability was fixed by adding an access control check at the beginning of the function using `inode_owner_or_capable`. This function verifies whether the user attempting to process the encryption policy has the necessary ownership or capabilities for the inode. By implementing this check, the code ensures that only authorized users can modify the encryption context, thereby preventing unauthorized access and potential manipulation of sensitive data. This enhancement significantly strengthens the security of the filesystem by ensuring that policy processing is restricted to legitimate users, addressing the previously identified security risk.","The vulnerability was fixed by introducing an access control mechanism that verifies whether the user has the appropriate permissions or ownership rights before allowing any modifications to the encryption policy. This additional check ensures that only authorized users can interact with the encryption context of a filesystem object, effectively preventing unauthorized access and manipulation. By enforcing this restriction at the beginning of the process, the code enhances the overall security of the system, safeguarding sensitive data from potential threats posed by malicious actors who might attempt to exploit the previous lack of validation.","CWE-285, CWE-284, CWE-732, CWE-269, CWE-264, CWE-266, CWE-282, CWE-668, CWE-862, CWE-863",N,-1
52,52,181689,181689,,Local,Not required,Complete,CVE-2016-10156,https://www.cvedetails.com/cve/CVE-2016-10156/,CWE-264,Low,Complete,Complete,,2017-01-23,7.2,"A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229.",2017-07-25,,2,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,06eeacb6fe029804f296b065b3ce91e796e1cd0e,"basic: fix touch() creating files with 07777 mode

mode_t is unsigned, so MODE_INVALID < 0 can never be true.

This fixes a possible DoS where any user could fill /run by writing to
a world-writable /run/systemd/show-status.",1,src/basic/fs-util.c,"{""sha"": ""61b651b573afb3f2d7f9e74830063728577e71de"", ""filename"": ""src/basic/fs-util.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/systemd/systemd/blob/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""raw_url"": ""https://github.com/systemd/systemd/raw/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""contents_url"": ""https://api.github.com/repos/systemd/systemd/contents/src/basic/fs-util.c?ref=06eeacb6fe029804f296b065b3ce91e796e1cd0e"", ""patch"": ""@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (parents)\n                 mkdir_parents(path, 0755);\n \n-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n         if (fd < 0)\n                 return -errno;\n ""}","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",C,"        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
","        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
",,"@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
         if (parents)
                 mkdir_parents(path, 0755);
 
-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 ",systemd,06eeacb6fe029804f296b065b3ce91e796e1cd0e,7d82cd4d53f88402edc923f5020c9ad22f9dc154,1,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
//flaw_line_below:
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
//fix_flaw_line_below:
//        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
//fix_flaw_line_below:
//                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",181689,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","The `touch_file` function creates or updates a file at the specified `path`, with options to create parent directories if needed. It accepts parameters for setting the file's timestamp, user ID, group ID, and permissions. The function first ensures the path is valid and creates parent directories if the `parents` flag is true. It then opens the file with specified permissions, adjusting them if provided. The function also changes the file's ownership if valid IDs are given and updates the file's access and modification times based on the provided timestamp. It returns 0 on success or a negative error code on failure.","The code defines a function that creates or updates a file at a specified location, with the option to create any necessary parent directories. It checks if the file can be opened with the desired permissions, and if successful, it adjusts the file's permissions and ownership based on provided values. Additionally, the function updates the file's access and modification timestamps, either to a specified time or to the current time if no specific time is given. The function returns a success indicator or an error code if any operation fails during execution.","The vulnerability in the original code arises from the handling of the `mode` parameter when opening a file. If `mode` is set to zero or an invalid value, the file is created with default permissions, which could lead to unintended access rights. In the fixed code, the condition for setting the file permissions has been modified to ensure that the default mode is only applied when `mode` is zero or invalid. This change prevents the creation of files with overly permissive or unintended access rights, thereby enhancing security by ensuring that the file permissions are explicitly defined and controlled.","The vulnerability in the original code stems from inadequate handling of file permissions, which could allow files to be created with overly permissive access rights if the provided mode was zero or invalid. This could lead to security risks, such as unauthorized access or modification of sensitive files. The fixed code addresses this issue by ensuring that the default permissions are only applied when the mode is explicitly zero or invalid, thereby enforcing stricter control over file permissions. This change enhances security by ensuring that files are created with appropriate and intended access rights, reducing the risk of exploitation.","The vulnerability was fixed by modifying the condition used when opening the file to determine the permissions. In the original code, the file was created with default permissions if the `mode` was zero or invalid, which could lead to security issues. The updated code changes this logic to check if `mode` is zero or equal to an invalid constant before applying the default permissions. This ensures that the file is only created with the default mode when appropriate, thereby enforcing stricter permission settings and reducing the risk of unauthorized access or modification of the file.","The vulnerability was addressed by refining the logic used to determine file permissions during file creation. The updated code ensures that default permissions are only applied when the provided mode is explicitly zero or invalid, rather than allowing potentially insecure defaults in all cases. This change enforces stricter control over the permissions assigned to newly created files, thereby mitigating the risk of unauthorized access or modifications. By ensuring that permissions are explicitly defined and only defaulted under specific conditions, the code enhances overall security and reduces the likelihood of exploitation.","CWE-732, CWE-276, CWE-264, CWE-266, CWE-284, CWE-668, CWE-275, CWE-732, CWE-281, CWE-279",N,-1
53,53,181817,181817,,Local,Not required,Complete,CVE-2016-10044,https://www.cvedetails.com/cve/CVE-2016-10044/,CWE-264,Low,Complete,Complete,,2017-02-07,7.2,"The aio_mount function in fs/aio.c in the Linux kernel before 4.7.7 does not properly restrict execute access, which makes it easier for local users to bypass intended SELinux W^X policy restrictions, and consequently gain privileges, via an io_setup system call.",2017-07-24,+Priv Bypass ,6,https://github.com/torvalds/linux/commit/22f6b4d34fcf039c63a94e7670e0da24f8575a5a,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,"aio: mark AIO pseudo-fs noexec

This ensures that do_mmap() won't implicitly make AIO memory mappings
executable if the READ_IMPLIES_EXEC personality flag is set.  Such
behavior is problematic because the security_mmap_file LSM hook doesn't
catch this case, potentially permitting an attacker to bypass a W^X
policy enforced by SELinux.

I have tested the patch on my machine.

To test the behavior, compile and run this:

    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/personality.h>
    #include <linux/aio_abi.h>
    #include <err.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <sys/syscall.h>

    int main(void) {
        personality(READ_IMPLIES_EXEC);
        aio_context_t ctx = 0;
        if (syscall(__NR_io_setup, 1, &ctx))
            err(1, ""io_setup"");

        char cmd[1000];
        sprintf(cmd, ""cat /proc/%d/maps | grep -F '/[aio]'"",
            (int)getpid());
        system(cmd);
        return 0;
    }

In the output, ""rw-s"" is good, ""rwxs"" is bad.

Signed-off-by: Jann Horn <jann@thejh.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/aio.c,"{""sha"": ""4fe81d1c60f962b53392a6b4b0d047f129509c87"", ""filename"": ""fs/aio.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/aio.c?ref=22f6b4d34fcf039c63a94e7670e0da24f8575a5a"", ""patch"": ""@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n-\treturn mount_pseudo(fs_type, \""aio:\"", NULL, &ops, AIO_RING_MAGIC);\n+\tstruct dentry *root = mount_pseudo(fs_type, \""aio:\"", NULL, &ops,\n+\t\t\t\t\t   AIO_RING_MAGIC);\n+\n+\tif (!IS_ERR(root))\n+\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n+\treturn root;\n }\n \n /* aio_setup""}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
",C,"	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
","	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
",,"@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
-	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
+	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
+					   AIO_RING_MAGIC);
+
+	if (!IS_ERR(root))
+		root->d_sb->s_iflags |= SB_I_NOEXEC;
+	return root;
 }
 
 /* aio_setup",linux,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,024c7e3756d8a42fc41fe8a9488488b9b09d1dcc,1,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
//flaw_line_below:
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
//fix_flaw_line_below:
//	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
//fix_flaw_line_below:
//					   AIO_RING_MAGIC);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!IS_ERR(root))
//fix_flaw_line_below:
//		root->d_sb->s_iflags |= SB_I_NOEXEC;
//fix_flaw_line_below:
//	return root;
 }
",181817,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","The provided code defines a function `aio_mount` that is responsible for mounting a pseudo-filesystem in a Linux kernel module. It takes parameters such as the filesystem type, flags, device name, and additional data. Within the function, a static structure `dentry_operations` is initialized with a single operation, `simple_dname`, which handles directory name operations. The function then calls `mount_pseudo`, passing the filesystem type, a string identifier ""aio:"", a NULL pointer for the root dentry, the operations structure, and a magic number `AIO_RING_MAGIC`. This effectively sets up the pseudo-filesystem for asynchronous I/O operations.","The code defines a function that facilitates the mounting of a pseudo-filesystem within a kernel module. It accepts parameters related to the filesystem type, flags, device name, and additional data. A structure is initialized to handle directory name operations, which is essential for managing how directory entries are represented. The function then invokes a specific mounting process, providing the filesystem type, a unique identifier for the pseudo-filesystem, a null pointer for the root directory, the initialized operations structure, and a magic number. This setup enables the functionality required for asynchronous input/output operations within the system.","The vulnerability in the original code arises from the lack of restrictions on executing files within the mounted pseudo-filesystem, which could lead to security risks if untrusted code is executed. In the fixed code, after the pseudo-filesystem is mounted, a check is performed to determine if the root directory was successfully created. If it was, a specific flag (`SB_I_NOEXEC`) is set on the superblock, preventing the execution of any binaries within that filesystem. This change mitigates the risk of executing potentially harmful code, thereby enhancing the overall security of the system.","The vulnerability in the original code stems from the absence of restrictions on executing files within the mounted pseudo-filesystem, which could allow untrusted or malicious code to run, posing significant security risks. In the revised code, a check is introduced to confirm the successful creation of the root directory after mounting. If successful, a specific flag is set to prevent the execution of any binaries within that filesystem. This enhancement effectively mitigates the risk of executing potentially harmful code, thereby improving the security posture of the system by ensuring that the pseudo-filesystem cannot be used to run executable files.","The vulnerability was fixed by adding a check after the call to `mount_pseudo` to verify whether the root directory was successfully created. In the revised code, the condition `if (!IS_ERR(root))` ensures that the subsequent operations only proceed if the root directory is valid. If the check passes, the flag `SB_I_NOEXEC` is set on the superblock associated with the root directory, effectively preventing the execution of any binaries within the mounted pseudo-filesystem. This modification enhances security by restricting the execution of potentially harmful code, thereby mitigating the risks associated with the original implementation.","The vulnerability was addressed by implementing a validation step after the filesystem was mounted to ensure that the root directory was created successfully. If the creation was successful, a specific flag was set on the superblock to prevent the execution of any binaries within the mounted filesystem. This change effectively restricts the ability to run potentially harmful code, thereby enhancing the security of the system. By ensuring that the filesystem cannot execute files, the fix mitigates the risks associated with untrusted or malicious code being executed in the context of the mounted pseudo-filesystem.","CWE-426, CWE-114, CWE-250, CWE-264, CWE-269, CWE-732, CWE-436, CWE-749, CWE-281, CWE-552",N,-1
54,54,182067,182067,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,7,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/ecryptfs/main.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
",,,"@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
+	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
+
+	rc = -EINVAL;
+	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
+		goto out_free;
+	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
//fix_flaw_line_below:
//	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = -EINVAL;
//fix_flaw_line_below:
//	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",182067,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The provided code implements the `ecryptfs_mount` function, which is responsible for mounting an eCryptfs filesystem in a Linux kernel environment. It begins by allocating memory for the superblock information and parsing mount options. The function then attempts to retrieve the superblock and set up the block device information. It checks for compatibility with existing filesystems and verifies user permissions before establishing the mount. The function configures various superblock parameters, including flags and inode information, and creates a root directory for the filesystem. If any step fails, it cleans up resources and returns an error pointer.","The code defines a function that facilitates the mounting of a specific type of encrypted filesystem within a Linux kernel environment. It begins by allocating necessary resources and parsing configuration options. The function then attempts to establish a connection to the filesystem, ensuring compatibility with existing mounts and verifying user permissions. It sets various parameters for the filesystem, including flags and inode details, and creates a root directory. In the event of any errors during the process, the function appropriately cleans up allocated resources and returns an error indication, ensuring system stability.","The vulnerability in the original code stemmed from the lack of a check on the stacking depth of mounted filesystems, which could lead to excessive nesting and potential resource exhaustion. This was addressed in the fixed code by introducing a validation step that compares the current stacking depth against a predefined maximum limit. Specifically, the addition of the check for `s->s_stack_depth` ensures that if the depth exceeds the allowed threshold, an error is logged, and the function exits gracefully, preventing further operations that could destabilize the system or lead to denial of service.","The vulnerability in the original code was related to the absence of a check on the maximum allowed depth for stacking filesystems, which could result in excessive nesting and lead to resource exhaustion or system instability. This issue was addressed in the revised code by implementing a validation step that ensures the current stacking depth does not exceed a predefined limit. By introducing this safeguard, the code now prevents operations that could destabilize the system, thereby enhancing its robustness and protecting against potential denial-of-service attacks caused by deep filesystem stacking.","The vulnerability was fixed by adding a check for the stacking depth of the filesystem in the revised code. Specifically, the code now verifies if `s->s_stack_depth` exceeds `FILESYSTEM_MAX_STACK_DEPTH`. If the condition is met, an error message is logged, and the function exits gracefully, preventing further execution. This addition ensures that the system does not allow excessive nesting of filesystems, which could lead to resource exhaustion or instability. By enforcing this limit, the code enhances the overall stability and security of the filesystem mounting process.","The vulnerability was addressed by implementing a safeguard that checks the current depth of filesystem stacking against a predefined maximum limit. This new validation step ensures that if the stacking depth exceeds the allowed threshold, an error is logged, and the function terminates early. By introducing this check, the code prevents excessive nesting of filesystems, which could lead to resource exhaustion and system instability. This enhancement improves the overall robustness and security of the filesystem mounting process, ensuring that the system remains stable under various conditions.","CWE-674, CWE-400, CWE-776, CWE-770, CWE-269, CWE-284, CWE-755, CWE-248, CWE-20, CWE-119",N,-1
55,55,182068,182068,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,9,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/overlayfs/super.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",C,"	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

",,,"@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
+	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
+				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
+
+	err = -EINVAL;
+	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
+		goto out_put_workpath;
+	}
+
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
//fix_flaw_line_below:
//	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
//fix_flaw_line_below:
//				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	err = -EINVAL;
//fix_flaw_line_below:
//	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_put_workpath;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",182068,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","The provided code implements the `ovl_fill_super` function, which initializes an overlay filesystem in a Linux kernel module. It allocates memory for the overlay filesystem structure, parses configuration options, and verifies the presence and validity of the upper, lower, and work directories. The function mounts these directories, checks their types, and ensures they meet specific requirements, such as being directories and residing under the same mount. It also sets the lower mount as read-only and creates a root inode for the overlay filesystem. Finally, it handles error cases by cleaning up allocated resources before returning the appropriate error code or success.","The code defines a function that initializes an overlay filesystem within a Linux kernel module. It allocates necessary memory and parses configuration options while ensuring that specified directories for upper, lower, and work layers are present and valid. The function mounts these directories, checks their types, and enforces constraints such as requiring them to be directories and located under the same mount point. It also sets the lower layer to read-only and creates a root directory for the overlay. Error handling is implemented to clean up resources if any checks fail, ensuring proper resource management.","The vulnerability in the original code stemmed from the lack of a check for the maximum filesystem stacking depth, which could lead to excessive resource consumption and potential denial of service. In the fixed code, a new check was introduced to compare the current stacking depth against a predefined maximum limit. This is done by calculating the maximum depth from the upper and lower mounts and ensuring it does not exceed the allowed threshold. If the limit is exceeded, an error is logged, and the function safely exits, preventing the system from entering an unstable state due to excessive stacking.","The vulnerability in the original code was due to the absence of a check for the maximum allowed stacking depth of filesystems, which could lead to excessive resource usage and potential denial of service. This oversight allowed for the possibility of creating deeply nested filesystem layers, which could overwhelm system resources. The fixed code addresses this issue by introducing a validation step that compares the current stacking depth against a predefined maximum limit. If the limit is exceeded, an error is logged, and the function exits safely, thereby preventing instability and ensuring better resource management.","The vulnerability was fixed by adding a check for the maximum filesystem stacking depth in the updated code. After calculating the current stacking depth using the maximum values from the upper and lower mounts, the code compares this value to a predefined constant, `FILESYSTEM_MAX_STACK_DEPTH`. If the calculated depth exceeds this limit, an error message is logged, and the function exits gracefully, preventing further execution. This addition ensures that the system does not enter an unstable state due to excessive filesystem nesting, thereby enhancing overall stability and resource management.","The vulnerability was addressed by implementing a validation step that checks the current stacking depth of filesystems against a predefined maximum limit. This new check ensures that the depth does not exceed the allowable threshold, which helps prevent excessive resource consumption and potential denial of service. If the stacking depth surpasses this limit, an error is logged, and the function exits safely, thereby halting any further processing. This enhancement improves system stability and resource management by preventing the creation of overly complex and nested filesystem structures.","CWE-674, CWE-400, CWE-770, CWE-776, CWE-269, CWE-284, CWE-20, CWE-669, CWE-755, CWE-840",N,-1
56,56,182778,182778,,Local,Not required,Complete,CVE-2019-13272,https://www.cvedetails.com/cve/CVE-2019-13272/,CWE-264,Low,Complete,Complete,,2019-07-17,7.2,"In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments.",2019-07-25,,1,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,6994eefb0053799d2e07cd140df6c2ea106c41ee,"ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME

Fix two issues:

When called for PTRACE_TRACEME, ptrace_link() would obtain an RCU
reference to the parent's objective credentials, then give that pointer
to get_cred().  However, the object lifetime rules for things like
struct cred do not permit unconditionally turning an RCU reference into
a stable reference.

PTRACE_TRACEME records the parent's credentials as if the parent was
acting as the subject, but that's not the case.  If a malicious
unprivileged child uses PTRACE_TRACEME and the parent is privileged, and
at a later point, the parent process becomes attacker-controlled
(because it drops privileges and calls execve()), the attacker ends up
with control over two processes with a privileged ptrace relationship,
which can be abused to ptrace a suid binary and obtain root privileges.

Fix both of these by always recording the credentials of the process
that is requesting the creation of the ptrace relationship:
current_cred() can't change under us, and current is the proper subject
for access control.

This change is theoretically userspace-visible, but I am not aware of
any code that it will actually break.

Fixes: 64b875f7ac8a (""ptrace: Capture the ptracer's creds not PT_PTRACE_CAP"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,kernel/ptrace.c,"{""sha"": ""705887f63288d4694c5bccd5c77900cbddc1f843"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=6994eefb0053799d2e07cd140df6c2ea106c41ee"", ""patch"": ""@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-\trcu_read_lock();\n-\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n-\trcu_read_unlock();\n+\t__ptrace_link(child, new_parent, current_cred());\n }\n \n /**""}"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
",C,"	__ptrace_link(child, new_parent, current_cred());
","	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
",,"@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-	rcu_read_lock();
-	__ptrace_link(child, new_parent, __task_cred(new_parent));
-	rcu_read_unlock();
+	__ptrace_link(child, new_parent, current_cred());
 }
 
 /**",linux,6994eefb0053799d2e07cd140df6c2ea106c41ee,550d1f5bda33fa3b203d8cf8df1396825dbfd213,1," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
//flaw_line_below:
	rcu_read_lock();
//flaw_line_below:
	__ptrace_link(child, new_parent, __task_cred(new_parent));
//flaw_line_below:
	rcu_read_unlock();
//fix_flaw_line_below:
//	__ptrace_link(child, new_parent, current_cred());
 }
",182778," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
","The provided code defines a static function `ptrace_link` that establishes a relationship between a child process and a new parent process in a Linux kernel context. It first acquires a read lock using `rcu_read_lock()` to ensure safe access to shared data structures during the operation. The function then calls `__ptrace_link`, passing the child task, the new parent task, and the credentials of the new parent, which likely facilitates the necessary updates to the process's tracing relationships. Finally, it releases the read lock with `rcu_read_unlock()`, ensuring that the critical section is properly managed for concurrent access.","The code defines a function that links a child process to a new parent process within the Linux kernel. It begins by acquiring a read lock to ensure safe access to shared data structures, preventing concurrent modifications that could lead to inconsistencies. The core operation updates the relationship between the child and the new parent, incorporating the necessary credentials for the new parent to maintain security and access control. After completing the linking operation, the function releases the read lock, ensuring that the critical section is properly managed and allowing other processes to access the data safely.","The vulnerability in the original code arises from the use of `__task_cred(new_parent)` to obtain the credentials of the new parent process, which could potentially allow unauthorized access if the new parent is not properly validated. This could lead to privilege escalation or improper tracing relationships. In the fixed code, the function now uses `current_cred()`, which retrieves the credentials of the currently executing process, ensuring that the linking operation is performed with the correct permissions and context. This change mitigates the risk of linking a child process to an untrusted or malicious parent, enhancing overall security.","The vulnerability in the original code stems from the potential misuse of credentials associated with the new parent process, which could allow unauthorized access or manipulation of the child process. This situation arises when the system does not adequately verify the legitimacy of the new parent, leading to risks such as privilege escalation or improper tracing. The fixed code addresses this issue by ensuring that the linking operation uses the credentials of the currently executing process instead. This change enhances security by ensuring that only processes with the appropriate permissions can establish tracing relationships, thereby mitigating the risk of exploitation.","The vulnerability was fixed by changing the way credentials are obtained for the linking operation. In the original code, the function used `__task_cred(new_parent)` to retrieve the credentials of the new parent process, which could lead to unauthorized access if the new parent was not properly validated. In the revised code, the function now utilizes `current_cred()`, which fetches the credentials of the currently executing process. This adjustment ensures that the linking operation is performed with the correct permissions, thereby preventing potential privilege escalation and ensuring that only authorized processes can establish tracing relationships.","The vulnerability was fixed by altering the method of obtaining credentials for the linking operation. The original implementation allowed for the possibility of using credentials from an unverified parent process, which could lead to unauthorized access and privilege escalation. The revised approach ensures that the credentials used are those of the currently executing process, thereby enforcing proper permission checks. This change effectively mitigates the risk of linking a child process to an untrusted parent, enhancing the security of the tracing relationship and ensuring that only authorized processes can interact with each other in this context.","CWE-269,CWE-284,CWE-732,CWE-266,CWE-250,CWE-287,CWE-274,CWE-639,CWE-264,CWE-270",Y,9
57,57,183067,183067,,Local,Not required,Partial,CVE-2013-1959,https://www.cvedetails.com/cve/CVE-2013-1959/,CWE-264,High,Partial,Partial,,2013-05-03,3.7,"kernel/user_namespace.c in the Linux kernel before 3.8.9 does not have appropriate capability requirements for the uid_map and gid_map files, which allows local users to gain privileges by opening a file within an unprivileged process and then modifying the file within a privileged process.",2013-11-30,+Priv ,2,https://github.com/torvalds/linux/commit/e3211c120a85b792978bcb4be7b2886df18d27f0,e3211c120a85b792978bcb4be7b2886df18d27f0,"userns: Check uid_map's opener's fsuid, not the current fsuid

Signed-off-by: Andy Lutomirski <luto@amacapital.net>",2,kernel/user_namespace.c,"{""sha"": ""5c16f3aa757a0353f8d7621b6b9d16cd586b347e"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=e3211c120a85b792978bcb4be7b2886df18d27f0"", ""patch"": ""@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n-\t\t\tif (uid_eq(uid, current_fsuid()))\n+\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n-\t\t\tif (gid_eq(gid, current_fsgid()))\n+\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n \t\t\t\treturn true;\n \t\t}\n \t}""}","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",C,"			if (uid_eq(uid, file->f_cred->fsuid))
			if (gid_eq(gid, file->f_cred->fsgid))
","			if (uid_eq(uid, current_fsuid()))
			if (gid_eq(gid, current_fsgid()))
",,"@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
-			if (uid_eq(uid, current_fsuid()))
+			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
-			if (gid_eq(gid, current_fsgid()))
+			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}",linux,e3211c120a85b792978bcb4be7b2886df18d27f0,6708075f104c3c9b04b23336bb0366ca30c3931b,1,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
//flaw_line_below:
			if (uid_eq(uid, current_fsuid()))
//fix_flaw_line_below:
//			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
//flaw_line_below:
			if (gid_eq(gid, current_fsgid()))
//fix_flaw_line_below:
//			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",183067,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","The `new_idmap_permitted` function determines whether a new user or group ID mapping is allowed based on specific conditions. It first checks if the mapping pertains to the user's own filesystem IDs, allowing it if the mapping consists of a single extent with a count of one, and the ID matches the current effective user or group ID. If the capability (`cap_setid`) is not valid, it permits the mapping without privilege. Lastly, it checks if the user has the necessary capabilities in the parent namespace and if the file opener possesses the same capabilities, granting permission accordingly.","The code defines a function that assesses whether a new mapping of user or group IDs is permissible based on specific criteria. It allows mappings that correspond to the user's own filesystem identifiers if they consist of a single extent and match the current effective identifiers. If the capability required for the mapping is not valid, it permits the operation without needing privileges. Additionally, it checks if the user has the necessary permissions in the parent namespace and if the file opener possesses the appropriate permissions, granting access if both conditions are met.","The vulnerability in the original code stemmed from allowing a user to map their own filesystem IDs without adequately verifying that the IDs matched the credentials of the file opener. Specifically, the checks for effective user and group IDs used `current_fsuid()` and `current_fsgid()`, which could be manipulated by an attacker to gain unauthorized access. The fix replaced these checks with `file->f_cred->fsuid` and `file->f_cred->fsgid`, ensuring that the mapping is validated against the actual credentials of the file being accessed, thereby preventing privilege escalation and unauthorized ID mappings.",The vulnerability in the original code allowed users to manipulate their own filesystem identifiers without proper validation against the credentials associated with the file being accessed. This oversight could enable an attacker to gain unauthorized access or escalate privileges by exploiting the mapping process. The fix addressed this issue by ensuring that the checks for effective user and group identifiers were based on the actual credentials of the file opener rather than the current process's identifiers. This change significantly tightened security by preventing unauthorized ID mappings and ensuring that only legitimate users could perform such operations.,"The vulnerability was fixed by changing the checks for effective user and group IDs to reference the credentials associated with the file being accessed, rather than the current process's identifiers. Specifically, the code now uses `file->f_cred->fsuid` and `file->f_cred->fsgid` instead of `current_fsuid()` and `current_fsgid()`. This adjustment ensures that the mapping is validated against the actual user and group IDs of the file opener, thereby preventing unauthorized privilege escalation. By enforcing this stricter validation, the code now ensures that only legitimate users can create ID mappings, enhancing overall security.","The vulnerability was fixed by modifying the validation process for user and group identifiers to ensure they align with the credentials of the file opener rather than the current process's identifiers. This change involved checking the effective identifiers associated with the file, which prevents unauthorized users from manipulating their own identifiers to gain elevated privileges. By enforcing this stricter validation, the code now ensures that only users with legitimate access to the file can create ID mappings, thereby significantly enhancing security and mitigating the risk of privilege escalation.","CWE-269, CWE-284, CWE-732, CWE-264, CWE-266, CWE-250, CWE-287, CWE-863, CWE-286, CWE-274",N,-1
58,58,183756,183756,,Remote,Not required,Partial,CVE-2011-2836,https://www.cvedetails.com/cve/CVE-2011-2836/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 does not require Infobar interaction before use of the Windows Media Player plug-in, which makes it easier for remote attackers to have an unspecified impact via crafted Flash content.",2017-09-18,,3,https://github.com/chromium/chromium/commit/d662b905d30cec7899bbb15140dcfacd73506167,d662b905d30cec7899bbb15140dcfacd73506167,"Infobar Windows Media Player plug-in by default.

BUG=51464
Review URL: http://codereview.chromium.org/7080048

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@87500 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/plugin_observer.cc,"{""sha"": ""906950b41191831a36b88c8f067ee2a1b642238d"", ""filename"": ""chrome/browser/plugin_observer.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugin_observer.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(\n   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)\n     UserMetrics::RecordAction(\n         UserMetricsAction(\""BlockedPluginInfobar.Shown.RealPlayer\""));\n+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)\n+    UserMetrics::RecordAction(\n+        UserMetricsAction(\""BlockedPluginInfobar.Shown.WindowsMediaPlayer\""));\n }\n \n BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {""}<_**next**_>{""sha"": ""f35b51953335b0e41197dc96d027b9cf4dab981e"", ""filename"": ""chrome/tools/chromeactions.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/tools/chromeactions.txt?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,7 @@\n 0x84cc82257207df8d\tBlockedPluginInfobar.Shown.QuickTime\n 0x819dbe166b094c47\tBlockedPluginInfobar.Shown.RealPlayer\n 0x65add1afd150b840\tBlockedPluginInfobar.Shown.Shockwave\n+0x0ef80834f3e539cc\tBlockedPluginInfobar.Shown.WindowsMediaPlayer\n 0x114c3050111d8b8d\tBold\n 0x02f476e54c6d58bd\tBookmarkBarFolder_CtxMenu\n 0x3012b56b98c28823\tBookmarkBarFolder_DragEnd\n@@ -869,6 +870,7 @@\n 0x7242962875070018\tOpenAllBookmarksIncognitoWindow\n 0x5e3bd4e3535ecc38\tOpenAllBookmarksNewWindow\n 0x4b858349a1b8bb15\tOpenFile\n+0xedaa8487de2a33c6\tOpenFileManager\n 0x4928347f9423c013\tOpenInternetOptionsDialog\n 0x83af6accb98b9954\tOpenLanguageOptionsDialog\n 0xe7147544a7db079d\tOpenSystemOptionsDialog\n@@ -1085,6 +1087,7 @@\n 0x417bd10a7c5e0210\tTabContextMenu_CloseTab\n 0xa0965146c626cd18\tTabContextMenu_CloseTabsOpenedBy\n 0x6adcbb467523c7d9\tTabContextMenu_CloseTabsToRight\n+0xaadbb71a197d76ad\tTabContextMenu_CompactNavigationBar\n 0x89e073e006a686d1\tTabContextMenu_Duplicate\n 0x88aefc727559ebaf\tTabContextMenu_NewTab\n 0x218d462d319b449c\tTabContextMenu_OpenTabsLeftToRight\n@@ -1136,6 +1139,7 @@\n 0xcd4da03d7cbaeb84\tUpgradeCheck_Upgraded\n 0x624ddd04836efdcd\tUpgrade_Started\n 0xa909d722e2ae4285\tViewAboutConflicts\n+0xf3768ba285ebca7e\tViewAboutFlash\n 0xfb4a178539bac6bd\tViewSource\n 0x6932875212d36f57\tWP_EditImage\n 0x34a770eb3bbf5632\tWP_Gallery""}<_**next**_>{""sha"": ""15ec131719741b1d90bd908eaf45f13068909230"", ""filename"": ""webkit/plugins/npapi/plugin_group.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -25,6 +25,7 @@ const char* PluginGroup::kQuickTimeGroupName = \""QuickTime\"";\n const char* PluginGroup::kShockwaveGroupName = \""Shockwave\"";\n const char* PluginGroup::kRealPlayerGroupName = \""RealPlayer\"";\n const char* PluginGroup::kSilverlightGroupName = \""Silverlight\"";\n+const char* PluginGroup::kWindowsMediaPlayerGroupName = \""Windows Media Player\"";\n \n /*static*/\n std::set<string16>* PluginGroup::policy_disabled_plugin_patterns_;""}<_**next**_>{""sha"": ""deb8461f83347132140b47d59877cb1038814b7f"", ""filename"": ""webkit/plugins/npapi/plugin_group.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.h?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -89,6 +89,7 @@ class PluginGroup {\n   static const char* kShockwaveGroupName;\n   static const char* kRealPlayerGroupName;\n   static const char* kSilverlightGroupName;\n+  static const char* kWindowsMediaPlayerGroupName;\n \n   PluginGroup(const PluginGroup& other);\n ""}<_**next**_>{""sha"": ""24150c9648caa2d8d28a7f21a90309a160fdabab"", ""filename"": ""webkit/plugins/npapi/plugin_list.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_list.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -108,6 +108,9 @@ static const VersionRangeDefinition kDivXVersionRange[] = {\n static const VersionRangeDefinition kRealPlayerVersionRange[] = {\n     { \""\"", \""\"", \""12.0.1.633\"", true }\n };\n+static const VersionRangeDefinition kWindowsMediaPlayerVersionRange[] = {\n+    { \""\"", \""\"", \""\"", true }\n+};\n static const PluginGroupDefinition kGroupDefinitions[] = {\n   kFlashDefinition,\n   { \""apple-quicktime\"", PluginGroup::kQuickTimeGroupName, \""QuickTime Plug-in\"",\n@@ -129,8 +132,9 @@ static const PluginGroupDefinition kGroupDefinitions[] = {\n     kRealPlayerVersionRange, arraysize(kRealPlayerVersionRange),\n     \""http://www.real.com/realplayer/download\"" },\n   // These are here for grouping, no vulnerabilities known.\n-  { \""windows-media-player\"", \""Windows Media Player\"", \""Windows Media Player\"",\n-    NULL, 0, \""\"" },\n+  { \""windows-media-player\"", PluginGroup::kWindowsMediaPlayerGroupName,\n+    \""Windows Media Player\"", kWindowsMediaPlayerVersionRange,\n+    arraysize(kWindowsMediaPlayerVersionRange), \""\"" },\n   { \""microsoft-office\"", \""Microsoft Office\"", \""Microsoft Office\"",\n     NULL, 0, \""\"" },\n };""}","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
",C,"  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
",,,"@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
+    UserMetrics::RecordAction(
+        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
 
 BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {",Chrome,d662b905d30cec7899bbb15140dcfacd73506167,7ad8e414e2fd5dc3207095257500745d8bd16a43,1,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
//fix_flaw_line_below:
//  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
//fix_flaw_line_below:
//    UserMetrics::RecordAction(
//fix_flaw_line_below:
//        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
",183756,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","The provided code defines a constructor for the `BlockedPluginInfoBarDelegate` class, which inherits from `PluginInfoBarDelegate`. It initializes the delegate with the associated tab contents and the name of the blocked plugin. Upon instantiation, it records a user metric action indicating that the blocked plugin infobar has been shown. Additionally, it converts the plugin name from UTF-16 to UTF-8 and checks if it matches specific known plugin groups (Java, QuickTime, Shockwave, RealPlayer). If a match is found, it records a corresponding user metric action for that specific plugin group, allowing for detailed tracking of user interactions with blocked plugins.","The code defines a constructor for a class that manages the display of an information bar when a plugin is blocked in a web browser. Upon creation, it initializes the object with the relevant tab and the name of the blocked plugin. It records a user interaction metric indicating that the information bar has been displayed. The code also converts the plugin name to a different encoding format and checks it against a list of known plugin categories. If a match is found, it logs a specific user interaction metric for that category, enabling detailed tracking of user engagement with blocked plugins.","The vulnerability in the original code arises from the lack of handling for a specific plugin group, which could lead to incomplete user interaction tracking when a blocked plugin is displayed. In the fixed code, an additional condition checks for the `kWindowsMediaPlayerGroupName`, ensuring that user metrics are recorded for this plugin as well. This oversight in the original implementation could result in a failure to log important user interactions, potentially leading to gaps in data collection and analysis regarding user engagement with blocked plugins. The fix enhances the robustness of the tracking mechanism by covering all relevant plugin groups.","The vulnerability in the original code stems from the failure to account for all possible plugin categories when logging user interactions with blocked plugins. This oversight could result in incomplete data collection, as certain blocked plugins would not trigger the appropriate logging actions, leading to gaps in user engagement metrics. The fixed code addresses this issue by adding a condition to handle an additional plugin category, ensuring that all relevant interactions are recorded. This enhancement improves the overall tracking mechanism, providing a more comprehensive view of user behavior regarding blocked plugins and preventing potential data loss.","The vulnerability was fixed by adding an additional conditional check for the `kWindowsMediaPlayerGroupName` in the updated code. This new condition ensures that when the plugin name matches this specific group, a corresponding user metric action is recorded, similar to the existing checks for other plugin groups like `kJavaGroupName` and `kQuickTimeGroupName`. By including this additional check, the code now comprehensively tracks user interactions for all relevant blocked plugins, thereby preventing gaps in data collection and ensuring that user engagement metrics are accurately logged for every applicable plugin category.","The vulnerability was fixed by introducing an additional condition to handle a previously unaccounted plugin category in the updated code. This enhancement ensures that when a blocked plugin from this specific category is encountered, the corresponding user interaction is properly logged. By expanding the checks to include this category, the code now provides comprehensive tracking of user engagement with all relevant blocked plugins. This improvement addresses the earlier oversight, ensuring that no important user interactions are missed, thereby enhancing the overall accuracy and completeness of the data collection process.","CWE-287, CWE-285, CWE-732, CWE-284, CWE-862, CWE-755, CWE-20, CWE-426, CWE-693, CWE-691",N,-1
59,59,183777,183777,,Remote,Not required,Partial,CVE-2011-2859,https://www.cvedetails.com/cve/CVE-2011-2859/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 uses incorrect permissions for non-gallery pages, which has unspecified impact and attack vectors.",2017-09-18,,12,https://github.com/chromium/chromium/commit/454434f6100cb6a529652a25b5fc181caa7c7f32,454434f6100cb6a529652a25b5fc181caa7c7f32,"Limit extent of webstore app to just chrome.google.com/webstore.

BUG=93497
TEST=Try installing extensions and apps from the webstore, starting both being
initially logged in, and not.


Review URL: http://codereview.chromium.org/7719003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@97986 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/extensions/extension_service.cc,"{""sha"": ""7c68ed1963348c9a9004c2907adb1d4374730617"", ""filename"": ""chrome/browser/extensions/extension_service.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 0, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_service.cc?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(\n   external_extension_url_added_ |= true;\n }\n \n+// If a download url matches one of these patterns and has a referrer of the\n+// webstore, then we're willing to treat that as a gallery download.\n+static const char* kAllowedDownloadURLPatterns[] = {\n+  \""https://clients2.google.com/service/update2*\"",\n+  \""https://clients2.googleusercontent.com/crx/*\""\n+};\n+\n bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n   // Special-case the themes mini-gallery.\n@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n \n+  // We also allow the download to be from a small set of trusted paths.\n+  if (!download_valid) {\n+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {\n+      URLPattern pattern(URLPattern::SCHEME_HTTPS,\n+                         kAllowedDownloadURLPatterns[i]);\n+      if (pattern.MatchesURL(download_url)) {\n+        download_valid = true;\n+        break;\n+      }\n+    }\n+  }\n+\n   // If the command-line gallery URL is set, then be a bit more lenient.\n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(""}<_**next**_>{""sha"": ""a224113c1f4316624bd8d0905d08bff6a7f84530"", ""filename"": ""chrome/browser/resources/webstore_app/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/webstore_app/manifest.json?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -10,10 +10,7 @@\n       \""web_url\"": \""https://chrome.google.com/webstore\""\n     },\n     \""urls\"": [\n-      \""*://chrome.google.com/extensions\"",\n-      \""*://chrome.google.com/webstore\"",\n-      \""*://clients2.google.com/service/update2\"",\n-      \""*://clients2.googleusercontent.com/crx\""\n+      \""https://chrome.google.com/webstore\""\n     ]\n   },\n   \""permissions\"": [""}"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",C,"  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

",,,"@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(
   external_extension_url_added_ |= true;
 }
 
+// If a download url matches one of these patterns and has a referrer of the
+// webstore, then we're willing to treat that as a gallery download.
+static const char* kAllowedDownloadURLPatterns[] = {
+  ""https://clients2.google.com/service/update2*"",
+  ""https://clients2.googleusercontent.com/crx/*""
+};
+
 bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
+  // We also allow the download to be from a small set of trusted paths.
+  if (!download_valid) {
+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
+      URLPattern pattern(URLPattern::SCHEME_HTTPS,
+                         kAllowedDownloadURLPatterns[i]);
+      if (pattern.MatchesURL(download_url)) {
+        download_valid = true;
+        break;
+      }
+    }
+  }
+
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(",Chrome,454434f6100cb6a529652a25b5fc181caa7c7f32,4ff8c349b22f825064f526bf6acd53b3a5aecc02,1," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
  // TODO(erikkay) When that gallery goes away, remove this code.
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
//fix_flaw_line_below:
//  // We also allow the download to be from a small set of trusted paths.
//fix_flaw_line_below:
//  if (!download_valid) {
//fix_flaw_line_below:
//    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
//fix_flaw_line_below:
//      URLPattern pattern(URLPattern::SCHEME_HTTPS,
//fix_flaw_line_below:
//                         kAllowedDownloadURLPatterns[i]);
//fix_flaw_line_below:
//      if (pattern.MatchesURL(download_url)) {
//fix_flaw_line_below:
//        download_valid = true;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      // The referrer gets stripped when transitioning from https to http,
      // or when hitting an unknown test cert and that commonly happens in
      // testing environments.  Given this, we allow an empty referrer when
      // the command-line flag is set.
      // Otherwise, the TLD must match the TLD of the command-line url.
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      // Otherwise, the TLD must match the TLD of the command-line url.
      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",183777," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
","The `IsDownloadFromGallery` function determines if a download originated from a specific gallery, primarily the web store. It first checks if the download URL is from a mini gallery and if the referrer URL starts with a designated prefix. If not, it retrieves the extensions associated with both the download and referrer URLs, comparing them to the web store app. The function also validates the top-level domains (TLDs) of the URLs against the web store's URL, ensuring that both the referrer and download URLs are either empty or match the store's TLD. It returns true if both conditions are satisfied.","The function checks whether a file download is originating from a specific gallery, particularly a web store. It first verifies if the download comes from a mini gallery and if the referrer matches a predefined prefix. If these conditions are not met, it assesses the extensions linked to both the download and referrer, ensuring they correspond to the web store application. Additionally, it validates the top-level domains of the URLs against the web store's domain, confirming that both the referrer and download URLs either match or are empty. The function ultimately returns a boolean indicating the validity of the download source.","The vulnerability in the original code stemmed from insufficient validation of the download source, allowing potentially malicious downloads from untrusted URLs. Specifically, the checks for the download's validity relied solely on whether the download extension matched the web store application. This could be exploited by crafting URLs that bypassed these checks. The fixed code enhances security by introducing a mechanism that allows downloads from a predefined set of trusted paths, using the `kAllowedDownloadURLPatterns` array. This additional validation ensures that even if the download does not originate from the web store, it can still be deemed valid if it matches one of the trusted patterns.","The vulnerability in the original code arose from inadequate validation of download sources, which allowed potentially harmful files to be downloaded from untrusted URLs. The checks primarily focused on whether the download originated from a specific application, leaving room for exploitation through crafted URLs that could bypass these conditions. The revised code addresses this issue by incorporating an additional layer of security that permits downloads from a limited set of trusted paths. This enhancement ensures that even if a download does not originate from the designated application, it can still be validated against a predefined list of acceptable sources, thereby mitigating the risk.","The vulnerability was fixed by introducing a validation mechanism that allows downloads from a specific set of trusted paths. In the revised code, if the initial checks for download validity fail, the code iterates through the `kAllowedDownloadURLPatterns` array. For each pattern, it creates a URL pattern object and checks if the download URL matches any of these trusted patterns. If a match is found, the `download_valid` flag is set to true, thereby allowing the download. This enhancement ensures that even if the download does not originate from the web store application, it can still be considered safe if it aligns with the trusted patterns.","The vulnerability was addressed by adding a mechanism that permits downloads from a predefined set of trusted sources, enhancing the validation process. In the updated code, if the initial checks for the download's legitimacy fail, the code now iterates through a list of acceptable patterns. It verifies whether the download URL matches any of these trusted patterns, and if a match is found, the download is deemed valid. This additional layer of security ensures that even if a download does not originate from the primary application, it can still be considered safe if it aligns with the established trusted criteria.","CWE-434, CWE-601, CWE-610, CWE-346, CWE-646, CWE-918, CWE-940, CWE-829, CWE-79, CWE-345",N,-1
60,60,183863,183863,,Remote,Not required,,CVE-2011-2782,https://www.cvedetails.com/cve/CVE-2011-2782/,CWE-264,Medium,,Partial,,2011-08-02,4.3,"The drag-and-drop implementation in Google Chrome before 13.0.782.107 on Linux does not properly enforce permissions for files, which allows user-assisted remote attackers to bypass intended access restrictions via unspecified vectors.",2017-09-18,Bypass ,8,https://github.com/chromium/chromium/commit/20d1c99d9b53a0b2b419aae0075494a9d0b86daf,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,"Ensure URL is updated after a cross-site navigation is pre-empted by
an ""ignored"" navigation.

BUG=77507
TEST=NavigationControllerTest.LoadURL_IgnorePreemptsPending

Review URL: http://codereview.chromium.org/6826015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@81307 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/tab_contents/navigation_controller.cc,"{""sha"": ""ba75cd0ab43021ee1a50605b35eacd3e85af8410"", ""filename"": ""content/browser/tab_contents/navigation_controller.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(\n         return false;\n       break;\n     case NavigationType::NAV_IGNORE:\n-      // There is nothing we can do with this navigation, so we just return to\n+      // If a pending navigation was in progress, this canceled it.  We should\n+      // discard it and make sure it is removed from the URL bar.  After that,\n+      // there is nothing we can do with this navigation, so we just return to\n       // the caller that nothing has happened.\n+      if (pending_entry_) {\n+        DiscardNonCommittedEntries();\n+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;\n+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);\n+      }\n       return false;\n     default:\n       NOTREACHED();""}<_**next**_>{""sha"": ""53c65079b58297c19e40fb5bcfd74696ee0aff20"", ""filename"": ""content/browser/tab_contents/navigation_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 76, ""deletions"": 0, ""changes"": 76, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller_unittest.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -143,6 +143,44 @@ void RegisterForAllNavNotifications(TestNotificationTracker* tracker,\n                      Source<NavigationController>(controller));\n }\n \n+class TestTabContentsDelegate : public TabContentsDelegate {\n+ public:\n+  explicit TestTabContentsDelegate() :\n+      navigation_state_change_count_(0) {}\n+\n+  int navigation_state_change_count() {\n+    return navigation_state_change_count_;\n+  }\n+\n+  virtual void OpenURLFromTab(TabContents* source,\n+                              const GURL& url, const GURL& referrer,\n+                              WindowOpenDisposition disposition,\n+                              PageTransition::Type transition) {}\n+\n+  // Keep track of whether the tab has notified us of a navigation state change.\n+  virtual void NavigationStateChanged(const TabContents* source,\n+                                      unsigned changed_flags) {\n+    navigation_state_change_count_++;\n+  }\n+\n+  virtual void AddNewContents(TabContents* source,\n+                              TabContents* new_contents,\n+                              WindowOpenDisposition disposition,\n+                              const gfx::Rect& initial_pos,\n+                              bool user_gesture) {}\n+  virtual void ActivateContents(TabContents* contents) {}\n+  virtual void DeactivateContents(TabContents* contents) {}\n+  virtual void LoadingStateChanged(TabContents* source) {}\n+  virtual void CloseContents(TabContents* source) {}\n+  virtual void MoveContents(TabContents* source, const gfx::Rect& pos) {}\n+  virtual void ToolbarSizeChanged(TabContents* source, bool is_animating) {}\n+  virtual void UpdateTargetURL(TabContents* source, const GURL& url) {}\n+\n+ private:\n+  // The number of times NavigationStateChanged has been called.\n+  int navigation_state_change_count_;\n+};\n+\n // -----------------------------------------------------------------------------\n \n TEST_F(NavigationControllerTest, Defaults) {\n@@ -427,6 +465,44 @@ TEST_F(NavigationControllerTest, LoadURL_BackPreemptsPending) {\n   EXPECT_EQ(kExistingURL1, controller().GetActiveEntry()->url());\n }\n \n+// Tests an ignored navigation when there is a pending new navigation.\n+// This will happen if the user enters a URL, but before that commits, the\n+// current blank page reloads.  See http://crbug.com/77507.\n+TEST_F(NavigationControllerTest, LoadURL_IgnorePreemptsPending) {\n+  TestNotificationTracker notifications;\n+  RegisterForAllNavNotifications(&notifications, &controller());\n+\n+  // Set a TabContentsDelegate to listen for state changes.\n+  scoped_ptr<TestTabContentsDelegate> delegate(new TestTabContentsDelegate());\n+  EXPECT_FALSE(contents()->delegate());\n+  contents()->set_delegate(delegate.get());\n+\n+  // Without any navigations, the renderer starts at about:blank.\n+  const GURL kExistingURL(\""about:blank\"");\n+\n+  // Now make a pending new navigation.\n+  const GURL kNewURL(\""http://eh\"");\n+  controller().LoadURL(kNewURL, GURL(), PageTransition::TYPED);\n+  EXPECT_EQ(0U, notifications.size());\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_TRUE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(1, delegate->navigation_state_change_count());\n+\n+  // Before that commits, a document.write and location.reload can cause the\n+  // renderer to send a FrameNavigate with page_id -1.\n+  rvh()->SendNavigate(-1, kExistingURL);\n+\n+  // This should clear the pending entry and notify of a navigation state\n+  // change, so that we do not keep displaying kNewURL.\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_FALSE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(2, delegate->navigation_state_change_count());\n+\n+  contents()->set_delegate(NULL);\n+}\n+\n TEST_F(NavigationControllerTest, Reload) {\n   TestNotificationTracker notifications;\n   RegisterForAllNavNotifications(&notifications, &controller());""}","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",C,"      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
",,,"@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(
         return false;
       break;
     case NavigationType::NAV_IGNORE:
-      // There is nothing we can do with this navigation, so we just return to
+      // If a pending navigation was in progress, this canceled it.  We should
+      // discard it and make sure it is removed from the URL bar.  After that,
+      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
+      if (pending_entry_) {
+        DiscardNonCommittedEntries();
+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
+      }
       return false;
     default:
       NOTREACHED();",Chrome,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,e2e2411a8144afd467a0b558541521355b543506,1,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  // Save the previous state before we clobber it.
  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  // The pending_entry has no SiteInstance when we are restoring an entry.  We
  // must fill it in here so we can find the entry later by calling
  // GetEntryIndexWithPageID.  In all other cases, the SiteInstance should be
  // assigned already and we shouldn't change it.
  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  // is_in_page must be computed before the entry gets committed.
  details->is_in_page = IsURLInPageNavigation(params.url);

  // Do navigation-type specific actions. These will make and commit an entry.
  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
//flaw_line_below:
      // There is nothing we can do with this navigation, so we just return to
//fix_flaw_line_below:
//      // If a pending navigation was in progress, this canceled it.  We should
//fix_flaw_line_below:
//      // discard it and make sure it is removed from the URL bar.  After that,
//fix_flaw_line_below:
//      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
//fix_flaw_line_below:
//      if (pending_entry_) {
//fix_flaw_line_below:
//        DiscardNonCommittedEntries();
//fix_flaw_line_below:
//        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
//fix_flaw_line_below:
//        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
//fix_flaw_line_below:
//      }
       return false;
     default:
       NOTREACHED();
  }

  // All committed entries should have nonempty content state so WebKit doesn't
  // get confused when we go back to them (see the function for details).
  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  // The active entry's SiteInstance should match our SiteInstance.
  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  // WebKit doesn't set the ""auto"" transition on meta refreshes properly (bug
  // 1051891) so we manually set it for redirects which we normally treat as
  // ""non-user-gestures"" where we want to update stuff after navigations.
  //
  // Note that the redirect check also checks for a pending entry to
  // differentiate real redirects from browser initiated navigations to a
  // redirected entry. This happens when you hit back to go to a page that was
  // the destination of a redirect, we don't want to treat it as a redirect
  // even though that's what its transition will be. See bug 1117048.
  //
  // TODO(brettw) write a test for this complicated logic.
  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  // Now prep the rest of the details for the notification and broadcast.
  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",183863,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","The `RendererDidNavigate` function in the `NavigationController` class processes navigation events by updating navigation details based on the parameters received. It retrieves the last committed navigation entry, updates the previous URL and entry index, and checks for pending entries to set their site instance. The function classifies the type of navigation (e.g., new page, existing page, in-page) and calls the appropriate handling function for each type. It also updates the active entry's content state, determines if the navigation is automatic, and sets various details like HTTP status code and security information before notifying that the navigation entry has been committed.","The provided code handles navigation events within a web browser's navigation controller. It updates details about the previous navigation state and checks for any pending entries to ensure they are correctly associated with the current site instance. The code classifies the type of navigation that has occurred and invokes specific handling procedures based on this classification. It also updates the active entry's content state and assesses whether the navigation was automatic. Finally, it sets various navigation details, including security information and HTTP status, before notifying the system that the navigation entry has been successfully committed.","The vulnerability in the original code stemmed from inadequate handling of pending navigation entries, particularly when a navigation was ignored. If a pending entry existed and was not properly discarded, it could lead to inconsistent states or unintended behavior in the navigation process. The fix introduced a check for `pending_entry_` within the `NAV_IGNORE` case, ensuring that any non-committed entries were discarded and the URL bar was updated accordingly. This change prevents the system from retaining stale navigation states, thereby enhancing the overall integrity and security of the navigation handling process.","The vulnerability in the original code arose from insufficient management of pending navigation entries, particularly when a navigation was ignored. This oversight could allow stale or inconsistent navigation states to persist, potentially leading to unexpected behavior or security issues. The fix addressed this by ensuring that any pending entries were properly discarded when a navigation was canceled. This change not only updated the user interface to reflect the current state but also reinforced the integrity of the navigation process, preventing the system from operating with outdated or invalid navigation information.","The vulnerability was fixed by adding a check for the existence of a pending entry within the `NAV_IGNORE` case of the navigation handling logic. When a navigation is ignored, the code now calls `DiscardNonCommittedEntries()` to ensure that any pending entries are properly removed from the navigation stack. Additionally, it updates the URL bar by modifying `extra_invalidate_flags` to include `TabContents::INVALIDATE_URL` and subsequently calls `NotifyNavigationStateChanged()` to reflect this change. This ensures that the system does not retain outdated navigation states, thereby enhancing the overall reliability and security of the navigation process.","The vulnerability was addressed by implementing a mechanism to properly handle pending navigation entries when a navigation is ignored. The fix ensures that any non-committed entries are discarded, preventing the system from retaining outdated or inconsistent navigation states. Additionally, the user interface is updated to reflect the current navigation state, ensuring that the displayed URL is accurate. This change enhances the overall integrity of the navigation process by eliminating the risk of operating with stale information, thereby improving both reliability and security in handling navigation events.","CWE-362, CWE-826, CWE-456, CWE-664, CWE-835, CWE-667, CWE-416, CWE-825, CWE-666, CWE-371",N,-1
61,61,183905,183905,,Remote,Not required,Partial,CVE-2011-2798,https://www.cvedetails.com/cve/CVE-2011-2798/,CWE-264,Low,,,,2011-08-02,5.0,"Google Chrome before 13.0.782.107 does not properly restrict access to internal schemes, which allows remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,10,https://github.com/chromium/chromium/commit/ce891a86763d3540e2612be26938a6163310efe0,ce891a86763d3540e2612be26938a6163310efe0,"Prevent navigation to chrome-devtools: and chrome-internal: schemas from http

BUG=87815
Review URL: http://codereview.chromium.org/7275032

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@91002 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/renderer/chrome_content_renderer_client.cc,"{""sha"": ""510dd6385437789e15aa0d0a1b7d6c111cd46d55"", ""filename"": ""chrome/renderer/chrome_content_renderer_client.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/chrome_content_renderer_client.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {\n           switches::kEnableIPCFuzzing)) {\n     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());\n   }\n-  // chrome: pages should not be accessible by normal content, and should\n-  // also be unable to script anything but themselves (to help limit the damage\n-  // that a corrupt chrome: page could cause).\n+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be\n+  // accessible by normal content, and should also be unable to script\n+  // anything but themselves (to help limit the damage that a corrupt\n+  // page could cause).\n   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));\n   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);\n \n+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);\n+\n+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);\n+\n   // chrome-extension: resources shouldn't trigger insecure content warnings.\n   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));\n   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);""}<_**next**_>{""sha"": ""3f6e1091b739477234c7eadcf38ba4b0907d2e28"", ""filename"": ""content/common/url_constants.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/url_constants.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -8,6 +8,9 @@ namespace chrome {\n \n const char kAboutScheme[] = \""about\"";\n const char kBlobScheme[] = \""blob\"";\n+\n+// Before adding new chrome schemes please check with security@chromium.org.\n+// There are security implications associated with introducing new schemes.\n const char kChromeDevToolsScheme[] = \""chrome-devtools\"";\n const char kChromeInternalScheme[] = \""chrome-internal\"";\n const char kChromeUIScheme[] = \""chrome\"";""}","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",C,"  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

",,,"@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
-  // chrome: pages should not be accessible by normal content, and should
-  // also be unable to script anything but themselves (to help limit the damage
-  // that a corrupt chrome: page could cause).
+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
+  // accessible by normal content, and should also be unable to script
+  // anything but themselves (to help limit the damage that a corrupt
+  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
+
+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
+
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);",Chrome,ce891a86763d3540e2612be26938a6163310efe0,0b481bf80794b5c18646b62cec75efebdce7b28d,1,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  // search_extension is null if not enabled.
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
//flaw_line_below:
  // chrome: pages should not be accessible by normal content, and should
//flaw_line_below:
  // also be unable to script anything but themselves (to help limit the damage
//flaw_line_below:
  // that a corrupt chrome: page could cause).
//fix_flaw_line_below:
//  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
//fix_flaw_line_below:
//  // accessible by normal content, and should also be unable to script
//fix_flaw_line_below:
//  // anything but themselves (to help limit the damage that a corrupt
//fix_flaw_line_below:
//  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
//fix_flaw_line_below:
//  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
//fix_flaw_line_below:
//
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",183905,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","The provided code defines the `RenderThreadStarted` function within the `ChromeContentRendererClient` class, which initializes various components essential for rendering web content in a Chrome browser process. It creates and resets instances of observers and dispatchers, such as `ChromeRenderProcessObserver`, `ExtensionDispatcher`, and `PhishingClassifierFilter`, among others. The function also registers these components as observers to the current render thread, adds specific extensions, and configures message filters based on command-line switches. Additionally, it registers URL schemes for security purposes, ensuring that certain schemes are treated as display-isolated or secure.","The code initializes various components necessary for rendering web content in a browser environment. It sets up observers and dispatchers that handle different aspects of the rendering process, ensuring they are properly registered with the current rendering thread. The function also incorporates specific extensions based on command-line options, enhancing the browser's capabilities. Additionally, it configures message filters for inter-process communication and registers URL schemes to enforce security measures, ensuring that certain schemes are treated as isolated or secure. This setup is crucial for maintaining the functionality and security of the rendering process.","The vulnerability in the original code stemmed from the lack of proper isolation for certain URL schemes, which could allow malicious content to access or manipulate sensitive internal pages. This oversight could lead to security risks, such as cross-site scripting or unauthorized access to internal resources. The fixed code addresses this issue by explicitly registering the `chrome`, `chrome-devtools`, and `chrome-internal` schemes as display-isolated, ensuring that they cannot be accessed or scripted by normal content. This change enhances security by limiting the potential damage that could arise from a compromised page, thereby protecting sensitive browser functionalities.","The vulnerability in the original code arose from insufficient isolation of certain internal URL schemes, which could allow malicious web content to interact with sensitive browser components or internal pages. This lack of protection posed risks such as unauthorized access and potential exploitation of internal functionalities. The fixed code rectifies this issue by implementing strict isolation measures for these schemes, ensuring they cannot be accessed or manipulated by regular web content. This enhancement significantly mitigates the risk of cross-site scripting and other attacks, thereby bolstering the overall security of the browser environment.","The vulnerability was fixed by explicitly registering certain URL schemes as display-isolated using the `WebSecurityPolicy::registerURLSchemeAsDisplayIsolated` function. In the updated code, the schemes for `chrome`, `chrome-devtools`, and `chrome-internal` were added to this isolation list, preventing normal web content from accessing or scripting these sensitive internal pages. This change ensures that even if a malicious page is loaded, it cannot interact with or compromise the integrity of the browser's internal functionalities. Additionally, the `WebSecurityPolicy::registerURLSchemeAsSecure` function was used to secure the extension scheme, further enhancing the overall security posture.","The vulnerability was addressed by implementing strict isolation for specific internal URL schemes, ensuring that they cannot be accessed or manipulated by regular web content. This was achieved by registering these schemes as display-isolated, which prevents any potentially malicious pages from interacting with sensitive browser components. Additionally, measures were taken to secure the extension scheme, further protecting the browser's internal functionalities. These changes collectively enhance the security framework of the browser, significantly reducing the risk of unauthorized access and exploitation by malicious content.","CWE-749, CWE-346, CWE-284, CWE-269, CWE-732, CWE-601, CWE-200, CWE-602, CWE-287, CWE-274",N,-1
62,62,184594,184594,,Remote,Not required,,CVE-2011-3956,https://www.cvedetails.com/cve/CVE-2011-3956/,CWE-264,Low,,Partial,,2012-02-08,5.0,"The extension implementation in Google Chrome before 17.0.963.46 does not properly handle sandboxed origins, which might allow remote attackers to bypass the Same Origin Policy via a crafted extension.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/04915c26ea193247b8a29aa24bfa34578ef5d39e,04915c26ea193247b8a29aa24bfa34578ef5d39e,"[Qt] Remove an unnecessary masking from swapBgrToRgb()
https://bugs.webkit.org/show_bug.cgi?id=103630

Reviewed by Zoltan Herczeg.

Get rid of a masking command in swapBgrToRgb() to speed up a little bit.

* platform/graphics/qt/GraphicsContext3DQt.cpp:
(WebCore::swapBgrToRgb):


git-svn-id: svn://svn.chromium.org/blink/trunk@136375 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp,"{""sha"": ""2867e26b69edeaaffebebe3be0f993335b6d4929"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -1,3 +1,15 @@\n+2012-12-03  Gabor Rapcsanyi  <rgabor@webkit.org>\n+\n+        [Qt] Remove an unnecessary masking from swapBgrToRgb()\n+        https://bugs.webkit.org/show_bug.cgi?id=103630\n+\n+        Reviewed by Zoltan Herczeg.\n+\n+        Get rid of a masking command in swapBgrToRgb() to speed up a little bit.\n+\n+        * platform/graphics/qt/GraphicsContext3DQt.cpp:\n+        (WebCore::swapBgrToRgb):\n+\n 2012-12-03  Mikhail Pozdnyakov  <mikhail.pozdnyakov@intel.com>\n \n         CSS Device Adaptation: window.innerWidth returns wrong value if CSS viewport descriptors are applied""}<_**next**_>{""sha"": ""540c501ee1c4d98a24046786c6a1ccf758f33f38"", ""filename"": ""third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()\n \n static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);\n }\n \n #if USE(ACCELERATED_COMPOSITING)""}"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
",C,"    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
","    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
",,"@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()
 
 static inline quint32 swapBgrToRgb(quint32 pixel)
 {
-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
 
 #if USE(ACCELERATED_COMPOSITING)",Chrome,04915c26ea193247b8a29aa24bfa34578ef5d39e,8046e095da6b7fa572ac89972ec041b951c52433,1," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
//flaw_line_below:
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
//fix_flaw_line_below:
//    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
",184594," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
","The provided code defines a static inline function named `swapBgrToRgb`, which takes a 32-bit unsigned integer `pixel` representing a color in BGR (Blue, Green, Red) format and converts it to RGB (Red, Green, Blue) format. It achieves this by shifting the blue component (the least significant byte) to the position of the red component (the most significant byte) and vice versa, while preserving the green component in its original position. The function uses bitwise operations to manipulate the bits of the input pixel and returns the transformed pixel value in RGB format.","The code defines a function that converts a color representation from one format to another by rearranging the color components. It takes a 32-bit integer input, where the color is encoded with blue, green, and red components in a specific order. The function shifts the bits of the input to swap the positions of the blue and red components while keeping the green component unchanged. This manipulation is achieved through bitwise operations, resulting in a new integer that represents the color in the desired format, effectively transforming the original color representation for further use.","The vulnerability in the original code arises from the incorrect bitwise operations used to swap the blue and red components, which could lead to unexpected results when processing certain pixel values. Specifically, the original code used a combination of left and right shifts along with masking that did not properly isolate the color components, potentially causing data corruption. In the fixed code, the expression was modified to ensure that the blue and red components are correctly swapped while preserving the green component. This was achieved by using a bitwise OR operation instead of a bitwise AND, ensuring accurate color representation.","The vulnerability in the original code stems from improper manipulation of color components, which could lead to incorrect color representation when converting from one format to another. The bitwise operations used did not adequately isolate and swap the blue and red components, resulting in potential data corruption or unexpected pixel values. The fixed code addresses this issue by refining the bitwise operations to ensure that the color components are accurately swapped while maintaining the integrity of the green component. This correction enhances the reliability of the color conversion process, preventing erroneous outputs during pixel processing.","The vulnerability was fixed by modifying the bitwise operations in the function to ensure accurate swapping of the blue and red components. In the original code, the expression used for shifting and masking did not correctly isolate the color components, leading to potential data corruption. The revised code employs a combination of left and right shifts along with a bitwise OR operation, specifically using `((pixel << 16) | (pixel >> 16)) & 0x00ff00ff`, which effectively swaps the blue and red components while preserving the green component intact. This change ensures that the color conversion is performed correctly and reliably.","The vulnerability was fixed by refining the bitwise operations used to manipulate the color components during the conversion process. The original approach inadequately isolated and swapped the blue and red components, which could lead to incorrect color values. The revised implementation ensures that the color components are accurately swapped while maintaining the integrity of the green component. By employing a more precise combination of shifts and logical operations, the updated code guarantees that the color representation is correctly transformed, thereby preventing data corruption and ensuring reliable output during pixel processing.","CWE-682, CWE-191, CWE-192, CWE-190, CWE-194, CWE-195, CWE-197, CWE-681, CWE-843, CWE-704",N,-1
63,63,184889,184889,,Remote,Not required,,CVE-2013-2905,https://www.cvedetails.com/cve/CVE-2013-2905/,CWE-264,Low,Partial,,,2013-08-21,5.0,"The SharedMemory::Create function in memory/shared_memory_posix.cc in Google Chrome before 29.0.1547.57 uses weak permissions under /dev/shm/, which allows attackers to obtain sensitive information via direct access to a POSIX shared-memory file.",2017-09-18,+Info ,39,https://github.com/chromium/chromium/commit/afb848acb43ba316097ab4fddfa38dbd80bc6a71,afb848acb43ba316097ab4fddfa38dbd80bc6a71,"Posix: fix named SHM mappings permissions.

Make sure that named mappings in /dev/shm/ aren't created with
broad permissions.

BUG=254159
R=mark@chromium.org, markus@chromium.org

Review URL: https://codereview.chromium.org/17779002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@209814 0039d316-1c4b-4281-b951-d872f2087c98",3,base/memory/shared_memory_posix.cc,"{""sha"": ""2be787d75331d708f9f125ba995f6c42b3691325"", ""filename"": ""base/memory/shared_memory_posix.cc"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 4, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_posix.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <fcntl.h>\n #include <sys/mman.h>\n #include <sys/stat.h>\n+#include <sys/types.h>\n #include <unistd.h>\n \n #include \""base/file_util.h\""\n@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n \n-    fp = file_util::OpenFile(path, \""w+x\"");\n-    if (fp == NULL && options.open_existing) {\n-      // \""w+\"" will truncate if it already exists.\n-      fp = file_util::OpenFile(path, \""a+\"");\n+    // Make sure that the file is opened without any permission\n+    // to other users on the system.\n+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;\n+\n+    // First, try to create the file.\n+    int fd = HANDLE_EINTR(\n+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));\n+    if (fd == -1 && options.open_existing) {\n+      // If this doesn't work, try and open an existing file in append mode.\n+      // Opening an existing file in a world writable directory has two main\n+      // security implications:\n+      // - Attackers could plant a file under their control, so ownership of\n+      //   the file is checked below.\n+      // - Attackers could plant a symbolic link so that an unexpected file\n+      //   is opened, so O_NOFOLLOW is passed to open().\n+      fd = HANDLE_EINTR(\n+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));\n+\n+      // Check that the current user owns the file.\n+      // If uid != euid, then a more complex permission model is used and this\n+      // API is not appropriate.\n+      const uid_t real_uid = getuid();\n+      const uid_t effective_uid = geteuid();\n+      struct stat sb;\n+      if (fd >= 0 &&\n+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||\n+           sb.st_uid != effective_uid)) {\n+        LOG(ERROR) <<\n+            \""Invalid owner when opening existing shared memory file.\"";\n+        HANDLE_EINTR(close(fd));\n+        return false;\n+      }\n+\n+      // An existing file was opened, so its size should not be fixed.\n       fix_size = false;\n     }\n+    fp = NULL;\n+    if (fd >= 0) {\n+      // \""a+\"" is always appropriate: if it's a new file, a+ is similar to w+.\n+      fp = fdopen(fd, \""a+\"");\n+    }\n   }\n   if (fp && fix_size) {\n     // Get current size.""}<_**next**_>{""sha"": ""b1b664a61830eac54bdecc4dfcf97de9eddfa9a4"", ""filename"": ""base/memory/shared_memory_unittest.cc"", ""status"": ""modified"", ""additions"": 72, ""deletions"": 1, ""changes"": 73, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_unittest.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,8 @@\n #endif\n #include \""base/memory/scoped_ptr.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/rand_util.h\""\n+#include \""base/strings/string_number_conversions.h\""\n #include \""base/sys_info.h\""\n #include \""base/test/multiprocess_test.h\""\n #include \""base/threading/platform_thread.h\""\n@@ -21,6 +23,9 @@\n \n #if defined(OS_POSIX)\n #include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n #endif\n \n static const int kNumThreads = 5;\n@@ -401,7 +406,73 @@ TEST(SharedMemoryTest, AnonymousExecutable) {\n   EXPECT_EQ(0, mprotect(shared_memory.memory(), shared_memory.requested_size(),\n                         PROT_READ | PROT_EXEC));\n }\n-#endif\n+\n+// Android supports a different permission model than POSIX for its \""ashmem\""\n+// shared memory implementation. So the tests about file permissions are not\n+// included on Android.\n+#if !defined(OS_ANDROID)\n+\n+// Set a umask and restore the old mask on destruction.\n+class ScopedUmaskSetter {\n+ public:\n+  explicit ScopedUmaskSetter(mode_t target_mask) {\n+    old_umask_ = umask(target_mask);\n+  }\n+  ~ScopedUmaskSetter() { umask(old_umask_); }\n+ private:\n+  mode_t old_umask_;\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(ScopedUmaskSetter);\n+};\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsAnonymous) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should be able to read the shared memory\n+  // file.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsNamed) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  std::string shared_mem_name = \""shared_perm_test-\"" + IntToString(getpid()) +\n+      \""-\"" + Uint64ToString(RandUint64());\n+  options.name = &shared_mem_name;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+  // Clean-up the backing file name immediately, we don't need it.\n+  EXPECT_TRUE(shared_memory.Delete(shared_mem_name));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should have been able to open the shared\n+  // memory file while its name existed.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+#endif  // !defined(OS_ANDROID)\n+\n+#endif  // defined(OS_POSIX)\n \n // Map() will return addresses which are aligned to the platform page size, this\n // varies from platform to platform though.  Since we'd like to advertise a""}","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",C,"    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
","    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
",,"@@ -8,6 +8,7 @@
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <unistd.h>
 
 #include ""base/file_util.h""
@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
-    fp = file_util::OpenFile(path, ""w+x"");
-    if (fp == NULL && options.open_existing) {
-      // ""w+"" will truncate if it already exists.
-      fp = file_util::OpenFile(path, ""a+"");
+    // Make sure that the file is opened without any permission
+    // to other users on the system.
+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
+
+    // First, try to create the file.
+    int fd = HANDLE_EINTR(
+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
+    if (fd == -1 && options.open_existing) {
+      // If this doesn't work, try and open an existing file in append mode.
+      // Opening an existing file in a world writable directory has two main
+      // security implications:
+      // - Attackers could plant a file under their control, so ownership of
+      //   the file is checked below.
+      // - Attackers could plant a symbolic link so that an unexpected file
+      //   is opened, so O_NOFOLLOW is passed to open().
+      fd = HANDLE_EINTR(
+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
+
+      // Check that the current user owns the file.
+      // If uid != euid, then a more complex permission model is used and this
+      // API is not appropriate.
+      const uid_t real_uid = getuid();
+      const uid_t effective_uid = geteuid();
+      struct stat sb;
+      if (fd >= 0 &&
+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
+           sb.st_uid != effective_uid)) {
+        LOG(ERROR) <<
+            ""Invalid owner when opening existing shared memory file."";
+        HANDLE_EINTR(close(fd));
+        return false;
+      }
+
+      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
+    fp = NULL;
+    if (fd >= 0) {
+      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
+      fp = fdopen(fd, ""a+"");
+    }
   }
   if (fp && fix_size) {
     // Get current size.",Chrome,afb848acb43ba316097ab4fddfa38dbd80bc6a71,aea03bd0389780cae5f50d6317cbe0d6b0d0735d,1,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  // This function theoretically can block on the disk, but realistically
  // the temporary files we create will just go into the buffer cache
  // and be deleted before they ever make it out to disk.
  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    // It doesn't make sense to have a open-existing private piece of shmem
    DCHECK(!options.open_existing);
    // Q: Why not use the shm_open() etc. APIs?
    // A: Because they're limited to 4mb on OS X.  FFFFFFFUUUUUUUUUUU
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    // Deleting the file prevents anyone else from mapping it in (making it
    // private), and prevents the need for cleanup (once the last fd is closed,
    // it is truly freed).
    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
//flaw_line_below:
    fp = file_util::OpenFile(path, ""w+x"");
//flaw_line_below:
    if (fp == NULL && options.open_existing) {
//flaw_line_below:
      // ""w+"" will truncate if it already exists.
//flaw_line_below:
      fp = file_util::OpenFile(path, ""a+"");
//fix_flaw_line_below:
//    // Make sure that the file is opened without any permission
//fix_flaw_line_below:
//    // to other users on the system.
//fix_flaw_line_below:
//    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // First, try to create the file.
//fix_flaw_line_below:
//    int fd = HANDLE_EINTR(
//fix_flaw_line_below:
//        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
//fix_flaw_line_below:
//    if (fd == -1 && options.open_existing) {
//fix_flaw_line_below:
//      // If this doesn't work, try and open an existing file in append mode.
//fix_flaw_line_below:
//      // Opening an existing file in a world writable directory has two main
//fix_flaw_line_below:
//      // security implications:
//fix_flaw_line_below:
//      // - Attackers could plant a file under their control, so ownership of
//fix_flaw_line_below:
//      //   the file is checked below.
//fix_flaw_line_below:
//      // - Attackers could plant a symbolic link so that an unexpected file
//fix_flaw_line_below:
//      //   is opened, so O_NOFOLLOW is passed to open().
//fix_flaw_line_below:
//      fd = HANDLE_EINTR(
//fix_flaw_line_below:
//          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // Check that the current user owns the file.
//fix_flaw_line_below:
//      // If uid != euid, then a more complex permission model is used and this
//fix_flaw_line_below:
//      // API is not appropriate.
//fix_flaw_line_below:
//      const uid_t real_uid = getuid();
//fix_flaw_line_below:
//      const uid_t effective_uid = geteuid();
//fix_flaw_line_below:
//      struct stat sb;
//fix_flaw_line_below:
//      if (fd >= 0 &&
//fix_flaw_line_below:
//          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
//fix_flaw_line_below:
//           sb.st_uid != effective_uid)) {
//fix_flaw_line_below:
//        LOG(ERROR) <<
//fix_flaw_line_below:
//            ""Invalid owner when opening existing shared memory file."";
//fix_flaw_line_below:
//        HANDLE_EINTR(close(fd));
//fix_flaw_line_below:
//        return false;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
//fix_flaw_line_below:
//    fp = NULL;
//fix_flaw_line_below:
//    if (fd >= 0) {
//fix_flaw_line_below:
//      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
//fix_flaw_line_below:
//      fp = fdopen(fd, ""a+"");
//fix_flaw_line_below:
//    }
   }
   if (fp && fix_size) {
     // Get current size.
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",184889,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","The `SharedMemory::Create` function is responsible for creating a shared memory segment based on specified options. It first checks if the size is valid and initializes a temporary file if no name is provided. If a name is given, it attempts to open the corresponding file, optionally creating it if it doesn't exist. The function then checks the file size and adjusts it to match the requested size using `ftruncate`. If file creation or size adjustment fails, it logs appropriate error messages, particularly regarding permissions on the `/dev/shm` directory. Finally, it prepares the file for mapping into memory.","The code defines a function that facilitates the creation of a shared memory segment based on user-defined options. It validates the requested size and handles the creation of a temporary file if no specific name is provided. If a name is given, it attempts to open the corresponding file, creating it if necessary. The function checks the current file size and adjusts it to match the requested size if needed. In case of any failures during file operations, it logs error messages, particularly regarding permission issues in a specific directory. Finally, it prepares the file for memory mapping.","The vulnerability in the original code stemmed from inadequate file permission checks when opening shared memory files, particularly in world-writable directories. This allowed attackers to potentially create malicious files or symbolic links, leading to unauthorized access or manipulation of shared memory. The fixed code addresses this by implementing stricter permission settings using `kOwnerOnly`, which restricts file access to the owner only. Additionally, it checks the ownership of existing files by comparing the real and effective user IDs, ensuring that only the legitimate user can access the shared memory, thus mitigating the risk of exploitation.","The vulnerability in the original code arose from insufficient checks on file permissions when creating or opening shared memory files, particularly in directories that could be writable by other users. This oversight allowed attackers to potentially create malicious files or symbolic links, leading to unauthorized access to shared memory. The revised code mitigates this risk by enforcing stricter permissions that limit access to the file owner only. Additionally, it verifies the ownership of existing files to ensure that only the legitimate user can access them, thereby enhancing security and preventing exploitation through unauthorized file manipulation.","The vulnerability was fixed by implementing stricter file permission settings and ownership checks. The code now uses a specific mode to create files, ensuring that only the owner has read and write access, as defined by `kOwnerOnly`. When opening existing files, the code checks the ownership by comparing the real and effective user IDs using `getuid()` and `geteuid()`, ensuring that only the legitimate user can access the file. Additionally, the use of `O_NOFOLLOW` when opening existing files prevents symbolic link attacks, thereby enhancing the overall security of the shared memory creation process.","The vulnerability was addressed by enforcing stricter file permission settings that restrict access to only the file owner, thereby preventing unauthorized users from manipulating shared memory files. The updated code also includes checks to verify the ownership of existing files, ensuring that only the legitimate user can access them. Additionally, measures were implemented to prevent symbolic link attacks, which could lead to unintended file access. These enhancements collectively strengthen the security of the shared memory creation process, mitigating the risk of exploitation through unauthorized file manipulation or access.","CWE-732, CWE-269, CWE-266, CWE-284, CWE-59, CWE-377, CWE-379, CWE-669, CWE-668, CWE-272",N,-1
64,64,184959,184959,,Remote,Not required,,CVE-2013-2874,https://www.cvedetails.com/cve/CVE-2013-2874/,CWE-264,Medium,Partial,,,2013-07-10,4.3,"Google Chrome before 28.0.1500.71 on Windows, when an Nvidia GPU is used, allows remote attackers to bypass intended restrictions on access to screen data via vectors involving IPC transmission of GL textures.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,"DevTools: handle devtools renderer unresponsiveness during beforeunload event interception

This patch fixes the crash which happenes under the following conditions:
1. DevTools window is in undocked state
2. DevTools renderer is unresponsive
3. User attempts to close inspected page

BUG=322380

Review URL: https://codereview.chromium.org/84883002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@237611 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/devtools/devtools_window.cc,"{""sha"": ""41b7b2f30b4a4a051e13365cd4255fbbb0d1b0b3"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -587,6 +587,29 @@ IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n       &chrome::CloseAllBrowsers));\n }\n \n+// Tests that inspected tab gets closed if devtools renderer\n+// becomes unresponsive during beforeunload event interception.\n+// @see http://crbug.com/322380\n+IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n+                       TestUndockedDevToolsUnresponsive) {\n+  ASSERT_TRUE(test_server()->Start());\n+  LoadTestPage(kDebuggerTestPage);\n+  DevToolsWindow* devtools_window = OpenDevToolWindowOnWebContents(\n+      GetInspectedTab());\n+  devtools_window->SetDockSideForTest(DEVTOOLS_DOCK_SIDE_UNDOCKED);\n+  content::WindowedNotificationObserver devtools_close_observer(\n+      content::NOTIFICATION_WEB_CONTENTS_DESTROYED,\n+      content::Source<content::WebContents>(\n+          devtools_window->web_contents()));\n+\n+  ASSERT_TRUE(content::ExecuteScript(\n+      devtools_window->web_contents()->GetRenderViewHost(),\n+      \""window.addEventListener('beforeunload',\""\n+      \""function(event) { while (true); });\""));\n+  CloseInspectedTab();\n+  devtools_close_observer.Wait();\n+}\n+\n // Flaky, see crbug.com/323847.\n //\n // Tests that BeforeUnload event gets called on devtools that are opened""}<_**next**_>{""sha"": ""7ed6e01669c949516d82e6aaab0dd7b5229d5303"", ""filename"": ""chrome/browser/devtools/devtools_window.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_window.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {\n }\n \n void DevToolsWindow::InspectedContentsClosing() {\n+  intercepted_page_beforeunload_ = false;\n   web_contents_->GetRenderViewHost()->ClosePage();\n }\n ""}"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",C,"  intercepted_page_beforeunload_ = false;
",,,"@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {
 }
 
 void DevToolsWindow::InspectedContentsClosing() {
+  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
 ",Chrome,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,d4eca59b36fc7957334f425de843022176b7dcfd,1," void DevToolsWindow::InspectedContentsClosing() {
//fix_flaw_line_below:
//  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",184959," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
","The provided code defines a method named `InspectedContentsClosing` within the `DevToolsWindow` class. This method is responsible for closing the currently inspected web page in a developer tools context. It achieves this by accessing the `web_contents_` member, which represents the content of the web page being inspected. The method then calls `GetRenderViewHost()` on `web_contents_` to obtain the associated render view host, and subsequently invokes `ClosePage()` on that host, effectively terminating the page's rendering and closing it within the developer tools interface.","The code defines a method that handles the closure of a web page currently being inspected within a developer tools interface. When invoked, this method accesses the content associated with the inspected page and retrieves the component responsible for rendering it. Following this, it triggers a function that effectively terminates the rendering process of the page, resulting in the closure of the web page within the developer tools environment. This functionality is essential for developers to manage and control the pages they are inspecting during debugging or development tasks.","The vulnerability in the original code arises from the lack of handling for the page's unload event, which could lead to data loss or unexpected behavior if the page is closed while it is still processing important tasks. By introducing the `intercepted_page_beforeunload_` variable and setting it to `false` before closing the page, the fixed code ensures that any pending unload events are properly managed. This change prevents the closure of the page from occurring abruptly, allowing for a more graceful shutdown process that respects the page's state and any ongoing operations, thereby enhancing stability and user experience.","The vulnerability in the original code stems from the potential for abrupt page closure without considering ongoing processes, which could result in data loss or corruption. This issue arises when a page is closed while it is still executing critical tasks, such as saving user input or completing network requests. The revised code addresses this vulnerability by implementing a mechanism to manage the page's unload events more effectively. By ensuring that any pending operations are acknowledged before the page is closed, the updated code promotes a smoother and safer shutdown process, thereby enhancing the overall stability and reliability of the application.","The vulnerability was fixed by introducing the `intercepted_page_beforeunload_` variable, which is set to `false` before the page closure is initiated. This change ensures that any pending unload events are properly managed, allowing the application to handle the page's state more gracefully. By resetting this variable, the code indicates that the page is no longer in a state that requires interception, thus preventing abrupt closure during critical operations. This enhancement allows for a smoother transition when closing the page, ensuring that ongoing tasks are completed or appropriately canceled, thereby reducing the risk of data loss or corruption.","The vulnerability was addressed by implementing a mechanism to manage the page's unload events more effectively before initiating the closure process. This involved ensuring that any critical operations or pending tasks were acknowledged and properly handled, preventing abrupt termination of the page. By establishing a clear state indicating that the page was ready to be closed, the updated code allows for a smoother and safer shutdown process. This enhancement minimizes the risk of data loss or corruption, ensuring that the application can gracefully handle ongoing processes before closing the inspected content.","CWE-404, CWE-672, CWE-665, CWE-459, CWE-675, CWE-674, CWE-226, CWE-911, CWE-444, CWE-568",N,-1
65,65,184960,184960,,Remote,Not required,,CVE-2013-2876,https://www.cvedetails.com/cve/CVE-2013-2876/,CWE-264,Low,Partial,,,2013-07-10,5.0,"browser/extensions/api/tabs/tabs_api.cc in Google Chrome before 28.0.1500.71 does not properly enforce restrictions on the capture of screenshots by extensions, which allows remote attackers to obtain sensitive information about the content of a previous page via vectors involving an interstitial page.",2017-09-18,+Info ,15,https://github.com/chromium/chromium/commit/016da29386308754274675e65fdb73cf9d59dc2d,016da29386308754274675e65fdb73cf9d59dc2d,"Don't allow extensions to take screenshots of interstitial pages. Branched from
https://codereview.chromium.org/14885004/ which is trying to test it.

BUG=229504

Review URL: https://chromiumcodereview.appspot.com/14954004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@198297 0039d316-1c4b-4281-b951-d872f2087c98",4,chrome/browser/extensions/api/tabs/tabs_api.cc,"{""sha"": ""445857fa0029392571ed26bee157c0b441e2cbf9"", ""filename"": ""chrome/browser/extensions/api/tabs/tabs_api.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/tabs/tabs_api.cc?ref=016da29386308754274675e65fdb73cf9d59dc2d"", ""patch"": ""@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {\n     }\n   }\n \n-  // captureVisibleTab() can return an image containing sensitive information\n-  // that the browser would otherwise protect.  Ensure the extension has\n-  // permission to do this.\n-  if (!GetExtension()->CanCaptureVisiblePage(\n-        web_contents->GetURL(),\n-        SessionID::IdForTab(web_contents),\n-        &error_)) {\n+  // Use the last committed URL rather than the active URL for permissions\n+  // checking, since the visible page won't be updated until it has been\n+  // committed. A canonical example of this is interstitials, which show the\n+  // URL of the new/loading page (active) but would capture the content of the\n+  // old page (last committed).\n+  //\n+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.\n+  // http://crbug.com/237908.\n+  NavigationEntry* last_committed_entry =\n+      web_contents->GetController().GetLastCommittedEntry();\n+  GURL last_committed_url = last_committed_entry ?\n+      last_committed_entry->GetURL() : GURL();\n+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,\n+                                             SessionID::IdForTab(web_contents),\n+                                             &error_)) {\n     return false;\n   }\n ""}","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",C,"  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
","  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
",,"@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {
     }
   }
 
-  // captureVisibleTab() can return an image containing sensitive information
-  // that the browser would otherwise protect.  Ensure the extension has
-  // permission to do this.
-  if (!GetExtension()->CanCaptureVisiblePage(
-        web_contents->GetURL(),
-        SessionID::IdForTab(web_contents),
-        &error_)) {
+  // Use the last committed URL rather than the active URL for permissions
+  // checking, since the visible page won't be updated until it has been
+  // committed. A canonical example of this is interstitials, which show the
+  // URL of the new/loading page (active) but would capture the content of the
+  // old page (last committed).
+  //
+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
+  // http://crbug.com/237908.
+  NavigationEntry* last_committed_entry =
+      web_contents->GetController().GetLastCommittedEntry();
+  GURL last_committed_url = last_committed_entry ?
+      last_committed_entry->GetURL() : GURL();
+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
+                                             SessionID::IdForTab(web_contents),
+                                             &error_)) {
     return false;
   }
 ",Chrome,016da29386308754274675e65fdb73cf9d59dc2d,7b97cf95eb604105998ab67571c30725fe015ba8,1,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        // Schema validation should make this unreachable.
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
//flaw_line_below:
  // captureVisibleTab() can return an image containing sensitive information
//flaw_line_below:
  // that the browser would otherwise protect.  Ensure the extension has
//flaw_line_below:
  // permission to do this.
//flaw_line_below:
  if (!GetExtension()->CanCaptureVisiblePage(
//flaw_line_below:
        web_contents->GetURL(),
//flaw_line_below:
        SessionID::IdForTab(web_contents),
//flaw_line_below:
        &error_)) {
//fix_flaw_line_below:
//  // Use the last committed URL rather than the active URL for permissions
//fix_flaw_line_below:
//  // checking, since the visible page won't be updated until it has been
//fix_flaw_line_below:
//  // committed. A canonical example of this is interstitials, which show the
//fix_flaw_line_below:
//  // URL of the new/loading page (active) but would capture the content of the
//fix_flaw_line_below:
//  // old page (last committed).
//fix_flaw_line_below:
//  //
//fix_flaw_line_below:
//  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
//fix_flaw_line_below:
//  // http://crbug.com/237908.
//fix_flaw_line_below:
//  NavigationEntry* last_committed_entry =
//fix_flaw_line_below:
//      web_contents->GetController().GetLastCommittedEntry();
//fix_flaw_line_below:
//  GURL last_committed_url = last_committed_entry ?
//fix_flaw_line_below:
//      last_committed_entry->GetURL() : GURL();
//fix_flaw_line_below:
//  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
//fix_flaw_line_below:
//                                             SessionID::IdForTab(web_contents),
//fix_flaw_line_below:
//                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",184960,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","The `RunImpl` function in the `TabsCaptureVisibleTabFunction` class captures a screenshot of the currently visible tab in a web browser. It first checks if screenshot functionality is disabled in user preferences; if so, it sets an error and returns false. The function retrieves the tab to capture and sets default image format to JPEG and quality to a predefined value. It then processes optional arguments to adjust the image format and quality if specified. Finally, it verifies if the extension has permission to capture the page and initiates the screenshot capture by calling `CopyFromBackingStore`, handling the completion through a callback.","The provided code defines a function that captures a screenshot of the currently visible tab in a web browser. It first checks user preferences to ensure that screenshot functionality is enabled. If allowed, it retrieves the active tab and sets default parameters for the image format and quality. The function can also process optional settings to customize these parameters. It then verifies if the extension has permission to capture the visible page. If all conditions are met, it initiates the screenshot capture process and handles the completion through a callback mechanism.","The vulnerability in the original code stemmed from using the active URL of the web page for permission checks, which could lead to unauthorized captures, especially during page transitions or interstitials. This was problematic because the visible content might not reflect the active URL, allowing the extension to capture content from a previous page instead. The fix involved changing the permission check to use the last committed URL, ensuring that the extension only captures content from pages that have been fully loaded and committed, thus preventing potential misuse during navigation events.","The vulnerability in the original code arose from using the active URL for permission checks when capturing screenshots, which could allow unauthorized access to content during page transitions or when interstitials were displayed. This approach was risky because the visible content might not correspond to the active URL, potentially leading to the capture of sensitive information from previously loaded pages. The fix involved switching to a method that checks the last committed URL instead, ensuring that only fully loaded and authorized content could be captured, thereby enhancing security and preventing misuse during navigation events.","The vulnerability was fixed by changing the permission check from using the active URL to the last committed URL. In the updated code, the last committed entry is retrieved using the `GetLastCommittedEntry` method, which ensures that the URL being checked corresponds to a fully loaded page. This adjustment prevents unauthorized captures during page transitions, as it accurately reflects the content that has been committed rather than what is currently active. By using the last committed URL in the `CanCaptureVisiblePage` function, the code now ensures that only authorized content can be captured, enhancing overall security.","The vulnerability was addressed by modifying the method used to check permissions for capturing screenshots. Instead of relying on the active URL, which could lead to unauthorized access during page transitions, the fix implemented a check against the last committed URL. This change ensures that the permission verification corresponds to content that has been fully loaded and is stable, rather than potentially transient or outdated information. By focusing on the last committed state, the updated code effectively prevents the capture of sensitive information from previous pages, thereby enhancing security and user privacy.","CWE-284,CWE-285,CWE-732,CWE-863,CWE-862,CWE-269,CWE-287,CWE-749,CWE-346,CWE-470",N,-1
66,66,185091,185091,,Remote,Not required,Partial,CVE-2013-0889,https://www.cvedetails.com/cve/CVE-2013-0889/,CWE-264,Medium,Partial,Partial,,2013-02-23,6.8,"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly enforce a user gesture requirement before proceeding with a file download, which might make it easier for remote attackers to execute arbitrary code via a crafted file.",2018-10-30,Exec Code ,6,https://github.com/chromium/chromium/commit/1538367452b549d929aabb13d54c85ab99f65cd3,1538367452b549d929aabb13d54c85ab99f65cd3,"For ""Dangerous"" file type, no user gesture will bypass the download warning.

BUG=170569
Review URL: https://codereview.chromium.org/12039015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@178072 0039d316-1c4b-4281-b951-d872f2087c98",3,chrome/browser/download/chrome_download_manager_delegate.cc,"{""sha"": ""9a56c725c6ea2e3a022ad0ab5fdbbf5990b6e93c"", ""filename"": ""chrome/browser/download/chrome_download_manager_delegate.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/chrome_download_manager_delegate.cc?ref=1538367452b549d929aabb13d54c85ab99f65cd3"", ""patch"": ""@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n     bool visited_referrer_before) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n \n-  // Anything loaded directly from the address bar is OK.\n-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)\n-    return false;\n-\n   // Extensions that are not from the gallery are considered dangerous.\n   // When off-store install is disabled we skip this, since in this case, we\n   // will not offer to install the extension.\n@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n   // page has been visited before today.\n   download_util::DownloadDangerLevel danger_level =\n       download_util::GetFileDangerLevel(suggested_path.BaseName());\n-  if (danger_level == download_util::AllowOnUserGesture)\n+  if (danger_level == download_util::AllowOnUserGesture) {\n+    if (download.GetTransitionType() &\n+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {\n+      return false;\n+    }\n     return !download.HasUserGesture() || !visited_referrer_before;\n+  }\n \n   return danger_level == download_util::Dangerous;\n }""}","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
",C,"  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
  }
","  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (danger_level == download_util::AllowOnUserGesture)
",,"@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
-  // Anything loaded directly from the address bar is OK.
-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
-    return false;
-
   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
-  if (danger_level == download_util::AllowOnUserGesture)
+  if (danger_level == download_util::AllowOnUserGesture) {
+    if (download.GetTransitionType() &
+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
+      return false;
+    }
     return !download.HasUserGesture() || !visited_referrer_before;
+  }
 
   return danger_level == download_util::Dangerous;
 }",Chrome,1538367452b549d929aabb13d54c85ab99f65cd3,9b95c83639a96a499e6af8d445f47086fd40a206,1,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
//flaw_line_below:
  // Anything loaded directly from the address bar is OK.
//flaw_line_below:
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
//flaw_line_below:
    return false;
//flaw_line_below:

   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  // Anything the user has marked auto-open is OK if it's user-initiated.
  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

  // ""Allow on user gesture"" is OK when we have a user gesture and the hosting
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
//flaw_line_below:
  if (danger_level == download_util::AllowOnUserGesture)
//fix_flaw_line_below:
//  if (danger_level == download_util::AllowOnUserGesture) {
//fix_flaw_line_below:
//    if (download.GetTransitionType() &
//fix_flaw_line_below:
//            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
//fix_flaw_line_below:
//      return false;
//fix_flaw_line_below:
//    }
     return !download.HasUserGesture() || !visited_referrer_before;
//fix_flaw_line_below:
//  }
 
   return danger_level == download_util::Dangerous;
 }
",185091,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","The `IsDangerousFile` function in the `ChromeDownloadManagerDelegate` class assesses whether a downloaded file is considered dangerous based on various criteria. It first checks if the download originated from the address bar, which would exempt it from being flagged. If the download is an extension and lacks user approval, it is marked as dangerous. The function also evaluates the file's extension and user interaction; if the user initiated the download and the file type is deemed safe, it allows the download. Ultimately, it returns true for dangerous files and false otherwise, ensuring user safety during downloads.","The code defines a function that determines whether a downloaded file poses a danger to the user. It evaluates the source of the download, checking if it originated from a specific area of the browser, which would exempt it from being flagged. The function also considers whether the download is an extension without user approval, marking it as dangerous. Additionally, it assesses the file type and user interaction; if the user initiated the download and the file is safe, it allows the download. Ultimately, the function returns a boolean indicating the file's safety status.","The vulnerability in the original code stemmed from inadequate checks for user gestures and download sources, which could allow potentially dangerous files to be downloaded without proper scrutiny. Specifically, the condition that checked for user gestures was not comprehensive, potentially allowing files to bypass safety checks if they originated from the address bar. The fixed code enhances this by adding a more explicit check for the transition type, ensuring that if a download comes from the address bar, it is not flagged as dangerous, thus improving the overall safety of the download process by preventing unintended file access.","The vulnerability in the original code arose from insufficient validation of user interactions and download sources, which could allow harmful files to be downloaded without adequate checks. Specifically, the logic did not effectively differentiate between safe and potentially dangerous downloads, particularly those initiated from certain browser actions. The revised code addresses this issue by implementing stricter conditions that evaluate the source of the download and the presence of user gestures. This enhancement ensures that downloads from less secure origins are more rigorously scrutinized, thereby reducing the risk of inadvertently allowing dangerous files to be accessed by users.","The vulnerability was fixed by enhancing the checks related to user gestures and download sources in the updated code. Specifically, the condition that checks for the transition type was added to ensure that if a download originates from the address bar, it is not automatically considered safe. Additionally, the logic now explicitly verifies the user gesture status in conjunction with the danger level returned by the `GetFileDangerLevel` function. This ensures that files flagged as potentially dangerous are not allowed if the user did not initiate the download or if the referrer was not previously visited, thereby improving overall security.","The vulnerability was addressed by implementing stricter validation criteria for downloads, particularly focusing on the source and user interactions. The updated logic now includes a specific check to determine if a download originated from a less secure area of the browser, which helps prevent potentially harmful files from being treated as safe. Additionally, the revised code ensures that user gestures are properly evaluated in conjunction with the file's danger level, thereby preventing downloads from being allowed without adequate user initiation. This comprehensive approach significantly enhances the security measures surrounding file downloads.","CWE-434, CWE-284, CWE-749, CWE-345, CWE-1021, CWE-646, CWE-610, CWE-799, CWE-501, CWE-494",N,-1
67,67,185132,185132,,Remote,Not required,Partial,CVE-2013-0918,https://www.cvedetails.com/cve/CVE-2013-0918/,CWE-264,Medium,Partial,Partial,,2013-03-28,6.8,"Google Chrome before 26.0.1410.43 does not prevent navigation to developer tools in response to a drag-and-drop operation, which allows user-assisted remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,4,https://github.com/chromium/chromium/commit/0a57375ad73780e61e1770a9d88b0529b0dbd33b,0a57375ad73780e61e1770a9d88b0529b0dbd33b,"Let the browser handle external navigations from DevTools.

BUG=180555


Review URL: https://chromiumcodereview.appspot.com/12531004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@186793 0039d316-1c4b-4281-b951-d872f2087c98",1,content/renderer/render_view_impl.cc,"{""sha"": ""67a61c2652e551b60816bb1a445b332e04edbd90"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -22,6 +22,7 @@\n #include \""chrome/common/chrome_notification_types.h\""\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/chrome_switches.h\""\n+#include \""chrome/common/url_constants.h\""\n #include \""chrome/test/base/in_process_browser_test.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/child_process_data.h\""\n@@ -504,6 +505,25 @@ IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestConsoleOnNavigateBack) {\n   RunTest(\""testConsoleOnNavigateBack\"", kNavigateBackTestPage);\n }\n \n+\n+// Tests that external navigation from inspector page is always handled by\n+// DevToolsWindow and results in inspected page navigation.\n+IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestDevToolsExternalNavigation) {\n+  OpenDevToolsWindow(kDebuggerTestPage);\n+  GURL url = test_server()->GetURL(kNavigateBackTestPage);\n+  content::WindowedNotificationObserver observer(\n+      content::NOTIFICATION_LOAD_STOP,\n+      content::NotificationService::AllSources());\n+  ASSERT_TRUE(content::ExecuteScript(\n+      window_->web_contents(),\n+      std::string(\""window.location = \\\""\"") + url.spec() + \""\\\""\""));\n+  observer.Wait();\n+\n+  ASSERT_TRUE(window_->web_contents()->GetURL().\n+                  SchemeIs(chrome::kChromeDevToolsScheme));\n+  ASSERT_EQ(GetInspectedTab()->GetURL(), url);\n+}\n+\n // Tests that inspector will reattach to inspected page when it is reloaded\n // after a crash. See http://crbug.com/101952\n IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestReattachAfterCrash) {""}<_**next**_>{""sha"": ""53e390b6f828d74f69c8c03f10acf0497c5fda41"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n       !url.SchemeIs(chrome::kAboutScheme)) {\n     bool send_referrer = false;\n \n-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses\n-    // must be handled by the browser process so that the correct bindings and\n-    // data sources can be registered.\n+    // All navigations to or from WebUI URLs or within WebUI-enabled\n+    // RenderProcesses must be handled by the browser process so that the\n+    // correct bindings and data sources can be registered.\n     // Similarly, navigations to view-source URLs or within ViewSource mode\n     // must be handled by the browser process (except for reloads - those are\n     // safe to leave within the renderer).\n@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n     // blessed with file permissions.\n     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();\n     bool is_initial_navigation = page_id_ == -1;\n-    bool should_fork = HasWebUIScheme(url) ||\n+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||\n         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||\n         url.SchemeIs(chrome::kViewSourceScheme) ||\n         (frame->isViewSourceModeEnabled() &&""}","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",C,"    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
","    bool should_fork = HasWebUIScheme(url) ||
",,"@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
-    // must be handled by the browser process so that the correct bindings and
-    // data sources can be registered.
+    // All navigations to or from WebUI URLs or within WebUI-enabled
+    // RenderProcesses must be handled by the browser process so that the
+    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
-    bool should_fork = HasWebUIScheme(url) ||
+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&",Chrome,0a57375ad73780e61e1770a9d88b0529b0dbd33b,e3cb4529d79a4993535da612dafedc8c40f075bb,1,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      // Targeted links may try to navigate a swapped out frame.  Allow the
      // browser process to navigate the tab instead.  Note that it is also
      // possible for non-targeted navigations (from this view) to arrive
      // here just after we are swapped out.  It's ok to send them to the
      // browser, as long as they're for the top level frame.
      // TODO(creis): Ensure this supports targeted form submissions when
      // fixing http://crbug.com/101395.
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      // We should otherwise ignore in-process iframe navigations, if they
      // arrive just after we are swapped out.
      return WebKit::WebNavigationPolicyIgnore;
    }

    // Allow kSwappedOutURL to complete.
    return default_policy;
  }

  // Webkit is asking whether to navigate to a new URL.
  // This is fine normally, except if we're showing UI from one security
  // context and they're trying to navigate to a different context.
  const GURL& url = request.url();

  // A content initiated navigation may have originated from a link-click,
  // script, drag-n-drop operation, etc.
  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  // Experimental:
  // If --enable-strict-site-isolation or --site-per-process is enabled, send
  // all top-level navigations to the browser to let it swap processes when
  // crossing site boundaries.  This is currently expected to break some script
  // calls and navigations, such as form submissions.
  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    // TODO(cevans): revisit whether this site check is still necessary once
    // crbug.com/101395 is fixed.
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  // If the browser is interested, then give it a chance to look at the request.
  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      // Reset these counters as the RenderView could be reused for the next
      // navigation.
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

  // Detect when we're crossing a permission-based boundary (e.g. into or out of
  // an extension or app origin, leaving a WebUI page, etc). We only care about
  // top-level navigations (not iframes). But we sometimes navigate to
  // about:blank to clear a tab, and we want to still allow that.
  //
  // Note: this is known to break POST submissions when crossing process
  // boundaries until http://crbug.com/101395 is fixed.  This is better for
  // security than loading a WebUI, extension or app page in the wrong process.
  // POST requests don't work because this mechanism does not preserve form
  // POST data. We will need to send the request's httpBody data up to the
  // browser process, and issue a special POST navigation in WebKit (via
  // FrameLoader::loadFrameRequest). See ResourceDispatcher and WebURLLoaderImpl
  // for examples of how to send the httpBody data.
  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
//flaw_line_below:
    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
//flaw_line_below:
    // must be handled by the browser process so that the correct bindings and
//flaw_line_below:
    // data sources can be registered.
//fix_flaw_line_below:
//    // All navigations to or from WebUI URLs or within WebUI-enabled
//fix_flaw_line_below:
//    // RenderProcesses must be handled by the browser process so that the
//fix_flaw_line_below:
//    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
//flaw_line_below:
    bool should_fork = HasWebUIScheme(url) ||
//fix_flaw_line_below:
//    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      // Give the embedder a chance.
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Detect when a page is ""forking"" a new tab that can be safely rendered in
  // its own process.  This is done by sites like Gmail that try to open links
  // in new windows without script connections back to the original page.  We
  // treat such cases as browser navigations (in which we will create a new
  // renderer for a cross-site navigation), rather than WebKit navigations.
  //
  // We use the following heuristic to decide whether to fork a new page in its
  // own process:
  // The parent page must open a new tab to about:blank, set the new tab's
  // window.opener to null, and then redirect the tab to a cross-site URL using
  // JavaScript.
  //
  // TODO(creis): Deprecate this logic once we can rely on rel=noreferrer
  // (see below).
  bool is_fork =
      // Must start from a tab showing about:blank, which is later redirected.
      old_url == GURL(chrome::kAboutBlankURL) &&
      // Must be the first real navigation of the tab.
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      // The parent page must have set the child's window.opener to null before
      // redirecting to the desired URL.
      frame->opener() == NULL &&
      // Must be a top-level frame.
      frame->parent() == NULL &&
      // Must not have issued the request from this page.
      is_content_initiated &&
      // Must be targeted at the current tab.
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      // Must be a JavaScript navigation, which appears as ""other"".
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    // Open the URL via the browser, not via WebKit.
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",185132,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","The provided code defines a function `decidePolicyForNavigation` that determines how a web frame should handle navigation requests based on various conditions. It checks if the request URL matches a specific ""swapped out"" URL and whether the navigation is initiated by content or a redirect. Depending on command-line flags and the security origin of the frame, it may suppress the load and open the URL instead. The function also evaluates whether to fork the navigation based on the URL scheme and other criteria, ultimately returning a navigation policy that dictates how the frame should proceed with the request.","The code implements a navigation policy decision-making process for a web frame, determining how to handle navigation requests based on various conditions. It checks if the request URL is a specific ""swapped out"" URL and assesses whether the navigation is initiated by content or a redirect. The function evaluates security origins and command-line flags to decide whether to suppress the load and open the URL. Additionally, it considers the URL scheme and other criteria to determine if the navigation should be forked, ultimately returning a policy that dictates the appropriate action for the navigation request.","The vulnerability in the original code arises from insufficient checks on the navigation requests, particularly regarding the handling of URLs that could lead to cross-origin issues. Specifically, the code did not adequately verify whether the navigation was initiated from a secure context or if it adhered to the same-origin policy, potentially allowing malicious sites to exploit the navigation process. The fix introduced additional checks, such as verifying the security origin of the frame against the requested URL and ensuring that certain command-line flags are respected, thereby enhancing the security of the navigation decision-making process and preventing unauthorized access to sensitive resources.","The vulnerability in the original code stemmed from inadequate validation of navigation requests, which could allow cross-origin navigation without proper checks, potentially exposing sensitive data or enabling malicious actions. The fix addressed this issue by implementing stricter checks on the security context of the navigation, ensuring that requests are only processed if they comply with the same-origin policy. Additionally, the updated code introduced conditions to handle specific scenarios, such as enforcing site isolation and validating the origin of the request, thereby enhancing the overall security and integrity of the navigation process.","The vulnerability was fixed by adding stricter validation checks within the navigation decision-making process. The code now verifies the security origin of the frame against the requested URL using the `SameDomainOrHost` function, ensuring that cross-origin navigations are appropriately handled. Additionally, the introduction of command-line flags, such as `kEnableStrictSiteIsolation` and `kSitePerProcess`, enforces site isolation policies. The checks for whether the navigation is content-initiated or a redirect further enhance security, allowing the code to suppress loads and open URLs only when they meet the defined security criteria, thereby preventing unauthorized access.","The vulnerability was fixed by implementing stricter validation measures for navigation requests to ensure compliance with security policies. The updated code now includes checks that verify the origin of the navigation against the requested URL, preventing unauthorized cross-origin access. Additionally, it enforces site isolation through specific command-line flags, which enhance the security context of the navigation process. By evaluating whether the navigation is initiated by content or a redirect, the code can suppress potentially harmful loads and only allow safe requests to proceed, thereby significantly improving the overall security of the navigation handling.","CWE-346,CWE-20,CWE-601,CWE-79,CWE-269,CWE-287,CWE-345,CWE-200,CWE-669,CWE-610",N,-1
68,68,185137,185137,,Remote,Not required,Partial,CVE-2013-0922,https://www.cvedetails.com/cve/CVE-2013-0922/,CWE-264,Low,Partial,Partial,,2013-03-28,7.5,"Google Chrome before 26.0.1410.43 does not properly restrict brute-force access attempts against web sites that require HTTP Basic Authentication, which has unspecified impact and attack vectors.",2017-09-18,,3,https://github.com/chromium/chromium/commit/28aaa72a03df96fa1934876b0efbbc7e6b4b38af,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,"Revert cross-origin auth prompt blocking.
BUG=174129

Review URL: https://chromiumcodereview.appspot.com/12183030

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@181113 0039d316-1c4b-4281-b951-d872f2087c98",2,content/browser/loader/resource_dispatcher_host_impl.cc,"{""sha"": ""0c104bc1f37c86331b1ae2422cdcf9281f9e2bea"", ""filename"": ""chrome/browser/ui/login/login_prompt_browsertest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/login/login_prompt_browsertest.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -754,7 +754,9 @@ IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, NoLoginPromptForFavicon) {\n }\n \n // Block crossdomain subresource login prompting as a phishing defense.\n-IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, BlockCrossdomainPrompt) {\n+// Disabled per http://crbug.com/174179.\n+IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest,\n+                       DISABLED_BlockCrossdomainPrompt) {\n   const char* kTestPage = \""files/login/load_img_from_b.html\"";\n \n   host_resolver()->AddRule(\""www.a.com\"", \""127.0.0.1\"");""}<_**next**_>{""sha"": ""2eef4361367985c52af103d34c78596b70145ca8"", ""filename"": ""content/browser/loader/resource_dispatcher_host_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/loader/resource_dispatcher_host_impl.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n \n-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n-      return false;\n+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.\n+    // The code once did this, but was changed due to http://crbug.com/174129.\n+    // http://crbug.com/174179 has been filed to track this issue.\n   }\n \n   return true;""}","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
",C,"    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
","    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
",,"@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
-      return false;
+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
+    // The code once did this, but was changed due to http://crbug.com/174129.
+    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;",Chrome,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,f7bbda81940376c6b64e0c3dc8ed189788d3a72e,1,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  // Prevent third-party content from prompting for login, unless it is
  // a proxy that is trying to authenticate.  This is often the foundation
  // of a scam to extract credentials for another domain from the user.
  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
//flaw_line_below:
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
//flaw_line_below:
      return false;
//fix_flaw_line_below:
//    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
//fix_flaw_line_below:
//    // The code once did this, but was changed due to http://crbug.com/174129.
//fix_flaw_line_below:
//    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
",185137,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","The `AcceptAuthRequest` function in the `ResourceDispatcherHostImpl` class is designed to handle authentication requests for network resources. It first checks if a delegate exists and whether it approves the authentication request based on the loader's request and provided authentication information. If the request is not for a proxy, it determines the type of resource associated with the request and logs this information using a histogram for analytics. Additionally, if the resource type indicates a blocked cross-origin request, the function returns false, denying the authentication. Otherwise, it returns true, allowing the authentication to proceed.","The provided code snippet is responsible for managing authentication requests within a resource loading context. It first checks if an external handler is available and whether it permits the authentication based on the current request and associated information. If the request is not related to a proxy, it assesses the type of resource being accessed and logs this information for analysis. Additionally, if the resource type indicates that cross-origin requests are blocked, the function denies the authentication. If all checks are passed, it allows the authentication process to continue, ensuring proper handling of network security.","The vulnerability in the original code arises from the lack of a check for blocked cross-origin requests, specifically when the resource type is identified as `HTTP_AUTH_RESOURCE_BLOCKED_CROSS`. This oversight could allow unauthorized access to sensitive resources by bypassing necessary authentication checks. The fixed code retains the logging functionality but includes a comment indicating that the previous behavior of returning false for blocked cross-origin requests was removed due to specific bug reports. This change highlights the need for careful handling of authentication requests to prevent potential security breaches while acknowledging the complexities involved in managing cross-origin resource access.","The vulnerability in the original code stems from the absence of a safeguard against blocked cross-origin requests, which could potentially allow unauthorized access to sensitive resources without proper authentication. This lack of validation meant that requests deemed unsafe could be processed, exposing the system to security risks. The revised code acknowledges this issue by indicating that the previous functionality, which denied authentication for blocked requests, was intentionally removed due to specific bug reports. This change underscores the importance of maintaining robust authentication checks while navigating the complexities of cross-origin resource management to ensure security.","The vulnerability was addressed by re-evaluating the handling of blocked cross-origin requests within the authentication process. In the fixed code, the comment indicates that the previous behavior of returning false when the resource type was identified as `HTTP_AUTH_RESOURCE_BLOCKED_CROSS` was removed, suggesting a need for further investigation into the implications of this change. The logging functionality using `UMA_HISTOGRAM_ENUMERATION` remains intact, allowing for tracking of resource types, but the explicit check for blocked requests was commented out, highlighting the ongoing discussion about the appropriate handling of such scenarios in the context of authentication.","The vulnerability was addressed by revisiting the handling of authentication requests related to blocked cross-origin resources. The revised code acknowledges that the previous mechanism, which denied authentication for such requests, was removed due to specific bug reports, indicating a need for further analysis of the implications of this change. While the logging functionality for resource types remains, the explicit check for blocked requests was commented out, reflecting an ongoing evaluation of how to balance security with the complexities of resource access management. This highlights the importance of careful consideration in maintaining robust authentication practices.","CWE-346, CWE-287, CWE-602, CWE-942, CWE-1275, CWE-288, CWE-613, CWE-306, CWE-601, CWE-345",N,-1
69,69,185242,185242,,Remote,Not required,,CVE-2012-5155,https://www.cvedetails.com/cve/CVE-2012-5155/,CWE-264,Low,,Partial,,2013-01-15,5.0,"Google Chrome before 24.0.1312.52 on Mac OS X does not use an appropriate sandboxing approach for worker processes, which makes it easier for remote attackers to bypass intended access restrictions via unspecified vectors.",2013-01-16,Bypass ,1,https://github.com/chromium/chromium/commit/0d7717faeaef5b72434632c95c78bee4883e2573,0d7717faeaef5b72434632c95c78bee4883e2573,"Fix OS_MACOS typos. Should be OS_MACOSX.

BUG=163208
TEST=none

Review URL: https://codereview.chromium.org/12829005

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@189130 0039d316-1c4b-4281-b951-d872f2087c98",1,base/path_service_unittest.cc,"{""sha"": ""5f281d129df93d16b739e0d510cc3be239a0e63a"", ""filename"": ""base/path_service_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/path_service_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {\n       check_path_exists = false;\n   }\n #endif\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&\n       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {\n     if (path.ReferencesParent())""}<_**next**_>{""sha"": ""a235b103504c93d8af66da907f900407b4403ad5"", ""filename"": ""chrome/browser/autofill/autofill_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/autofill/autofill_browsertest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -746,7 +746,7 @@ IN_PROC_BROWSER_TEST_F(AutofillTest, DISABLED_AutofillFormWithRepeatedField) {\n }\n \n // http://crbug.com/150084\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n #define MAYBE_AutofillFormWithNonAutofillableField \\\n     AutofillFormWithNonAutofillableField\n #else""}<_**next**_>{""sha"": ""ccb0f539f442af28ef148360a0dd427d0452e4ec"", ""filename"": ""chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/download_path_reservation_tracker_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -455,7 +455,7 @@ TEST_F(DownloadPathReservationTrackerTest, UpdatesToTargetPath) {\n \n // Tests for long name truncation. On other platforms automatic truncation\n // is not performed (yet).\n-#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_CHROMEOS)\n+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_CHROMEOS)\n \n TEST_F(DownloadPathReservationTrackerTest, BasicTruncation) {\n   int real_max_length =""}<_**next**_>{""sha"": ""2953c4dd7373425370e7e29b37e48e77819820c3"", ""filename"": ""chrome/browser/ui/browser_command_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 23, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser_command_controller_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -255,28 +255,8 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   chrome::ToggleFullscreenMode(browser());\n   ASSERT_TRUE(browser()->window()->IsFullscreen());\n   browser()->command_controller()->FullscreenStateChanged();\n-#if defined(OS_MACOS)\n-  // Mac leaves things enabled in fullscreen.\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n-  EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_LOCATION));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_SEARCH));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_MENU_BAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_NEXT_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_PREVIOUS_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_BOOKMARKS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_DEVELOPER_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FEEDBACK));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPTIONS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_IMPORT_SETTINGS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_EDIT_SEARCH_ENGINES));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_VIEW_PASSWORDS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#else\n-  // Windows and GTK disable most commands in fullscreen.\n+\n+  // Most commands are disabled in fullscreen.\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n@@ -295,7 +275,6 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n   EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#endif  // defined(OS_MACOS)\n \n   // Exit fullscreen.\n   chrome::ToggleFullscreenMode(browser());""}","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",C,"#if defined(OS_MACOSX)
","#if defined(OS_MAC)
",,"@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {
       check_path_exists = false;
   }
 #endif
-#if defined(OS_MAC)
+#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())",Chrome,0d7717faeaef5b72434632c95c78bee4883e2573,49d66d27f59c7f8e6f170a2cf313822f49e4e3b0,1,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  // Some paths might not exist on some platforms in which case confirming
  // |result| is true and !path.empty() is the best we can do.
  bool check_path_exists = true;
#if defined(OS_POSIX)
  // If chromium has never been started on this account, the cache path may not
  // exist.
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  // On the linux try-bots: a path is returned (e.g. /home/chrome-bot/Desktop),
  // but it doesn't exist.
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    // On Windows XP, the Quick Launch folder for the ""Default User"" doesn't
    // exist by default. At least confirm that the path returned begins with the
    // Default User's profile path.
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    // There is no pinned-to-taskbar shortcuts prior to Win7.
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
//flaw_line_below:
#if defined(OS_MAC)
//fix_flaw_line_below:
//#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",185242,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","The `ReturnsValidPath` function checks the validity of a file path based on a specified directory type (`dir_type`). It first retrieves the path using `PathService::Get`. Depending on the operating system (POSIX, Linux, Windows, or Mac), it applies specific rules to determine if the path is valid. For instance, it may skip existence checks for certain directory types or validate against the default user profile directory on older Windows versions. The function ultimately returns true if the path is successfully retrieved, is not empty, and meets any additional criteria for existence or structure based on the operating system.","The code defines a function that verifies the validity of a file path based on a specified directory type. It retrieves the path and applies different rules depending on the operating system in use. Certain directory types may bypass existence checks, while others require specific conditions to be met, such as compatibility with user profile directories on older systems. Additionally, the function ensures that the path does not reference parent directories, which could indicate an invalid structure. Ultimately, it returns a boolean indicating whether the path is valid based on these criteria.","The vulnerability in the original code stemmed from insufficient checks on the validity of file paths, particularly allowing paths that referenced parent directories, which could lead to directory traversal attacks. In the fixed code, the condition for checking parent directory references was enhanced, specifically for macOS, ensuring that only certain directory types are exempt from this check. This change mitigates the risk of unauthorized access to sensitive directories by ensuring that any path referencing a parent directory is immediately deemed invalid, thereby improving the overall security of the path validation process.","The vulnerability in the original code arose from inadequate validation of file paths, particularly allowing paths that could reference parent directories, which posed a risk of directory traversal attacks. This oversight could enable unauthorized access to sensitive areas of the file system. The fixed code addressed this issue by implementing stricter checks to ensure that only specific directory types are exempt from validation against parent directory references. By enforcing these additional checks, the revised code significantly enhances security, preventing potential exploitation through invalid path structures and ensuring that only legitimate paths are considered valid.","The vulnerability was fixed by enhancing the checks for path validity, particularly regarding references to parent directories. In the updated code, the condition using `path.ReferencesParent()` was explicitly applied to macOS, ensuring that paths referencing parent directories are deemed invalid unless they belong to specific directory types. This change prevents potential directory traversal attacks by rejecting paths that could lead to unauthorized access. Additionally, the logic for checking the existence of paths was refined, ensuring that only valid paths are returned, thereby improving the overall security of the path validation process.","The vulnerability was addressed by implementing stricter validation rules for file paths, particularly focusing on preventing references to parent directories, which could lead to unauthorized access. The updated code introduced specific checks that ensure only certain directory types are exempt from this validation, thereby enhancing security against directory traversal attacks. Additionally, the logic for verifying the existence of paths was refined to ensure that only legitimate paths are considered valid. This comprehensive approach significantly reduces the risk of exploitation by ensuring that all paths undergo rigorous scrutiny before being accepted as valid.","CWE-23, CWE-22, CWE-35, CWE-99, CWE-36, CWE-73, CWE-434, CWE-641, CWE-41, CWE-32",N,-1
70,70,185375,185375,,Remote,Not required,Partial,CVE-2014-3160,https://www.cvedetails.com/cve/CVE-2014-3160/,CWE-264,Medium,Partial,Partial,,2014-07-20,6.8,"The ResourceFetcher::canRequest function in core/fetch/ResourceFetcher.cpp in Blink, as used in Google Chrome before 36.0.1985.125, does not properly restrict subresource requests associated with SVG files, which allows remote attackers to bypass the Same Origin Policy via a crafted file.",2017-01-06,Bypass ,7,https://github.com/chromium/chromium/commit/ee281f7cac9df44fe241a37f188b28be8845ded0,ee281f7cac9df44fe241a37f188b28be8845ded0,"Enforce SVG image security rules

SVG images have unique security rules that prevent them from loading
any external resources. This patch enforces these rules in
ResourceFetcher::canRequest for all non-data-uri resources. This locks
down our SVG resource handling and fixes two security bugs.

In the case of SVG images that reference other images, we had a bug
where a cached subresource would be used directly from the cache.
This has been fixed because the canRequest check occurs before we use
cached resources.

In the case of SVG images that use CSS imports, we had a bug where
imports were blindly requested. This has been fixed by stopping all
non-data-uri requests in SVG images.

With this patch we now match Gecko's behavior on both testcases.

BUG=380885, 382296

Review URL: https://codereview.chromium.org/320763002

git-svn-id: svn://svn.chromium.org/blink/trunk@176084 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp,"{""sha"": ""447f133110eb629a1d8572dc9c3005dba7697deb"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,3 @@\n+rect {\n+    fill: red;\n+}\n\\ No newline at end of file""}<_**next**_>{""sha"": ""2b23c4527dedc04e28e1fa5189005c5e2901efe3"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <style>\n+        @import url(http://localhost:8000/security/resources/css-import.css);\n+    </style>\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""green\""/>\n+</svg>""}<_**next**_>{""sha"": ""fb20e4cb86d84079925c31dc5db87d401231b1c0"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,4 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>""}<_**next**_>{""sha"": ""73a75e35fd9d98a5c3235e84d9d1dfaddcfe58b9"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -1,6 +1,5 @@\n-<svg xmlns=\""http://www.w3.org/2000/svg\""\n-     xmlns:xlink=\""http://www.w3.org/1999/xlink\""\n-     width=\""100\"" height=\""100\"">\n-    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\""\n-           width=\""100\"" height=\""100\""/>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n </svg>""}<_**next**_>{""sha"": ""480e114a4a66420372b26e21bf21799ecc527306"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n+</svg>\n+\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""b926b53dd3e9948965e23b6a8dbffcab49f9c2bd"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,27 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<object id=\""precache\"" data=\""resources/image-wrapper.svg\"" width=\""100\"" height=\""100\""></object>\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<img id=\""image\"" src=\""\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('precache').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        var image = document.getElementById('image');\n+        image.onload = function() {\n+            // FIXME: crbug.com/382170 SVG onload event bug.\n+            setTimeout(function() {\n+                if (window.testRunner)\n+                    testRunner.notifyDone();\n+            }, 20);\n+        }\n+        image.src = \""resources/image-wrapper.svg\"";\n+    }, 20);\n+}\n+\n+</script>""}<_**next**_>{""sha"": ""2cca3b4cae0eea0f586f1862cc50b21ee80a39ae"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100\"" height=\""100\"" fill=\""green\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""7c61abbb8315871f6dc444916b0f035dd713667c"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<img id=\""image\"" src=\""resources/image-with-css-import.svg\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('image').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        if (window.testRunner)\n+            testRunner.notifyDone();\n+    }, 30);\n+}\n+</script>""}<_**next**_>{""sha"": ""a8dac743c0eeeba9102288a453e2df94595fb999"", ""filename"": ""third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -59,6 +59,7 @@\n #include \""core/timing/Performance.h\""\n #include \""core/timing/ResourceTimingInfo.h\""\n #include \""core/frame/Settings.h\""\n+#include \""core/svg/graphics/SVGImageChromeClient.h\""\n #include \""platform/Logging.h\""\n #include \""platform/TraceEvent.h\""\n #include \""platform/weborigin/SecurityOrigin.h\""\n@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res\n         break;\n     }\n \n+    // SVG Images have unique security rules that prevent all subresource requests\n+    // except for data urls.\n+    if (type != Resource::MainResource) {\n+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())\n+            return false;\n+    }\n+\n     // Last of all, check for insecure content. We do this last so that when\n     // folks block insecure content with a CSP policy, they don't get a warning.\n     // They'll still get a warning in the console about CSP blocking the load.""}","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",C,"    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }

",,,"@@ -59,6 +59,7 @@
 #include ""core/timing/Performance.h""
 #include ""core/timing/ResourceTimingInfo.h""
 #include ""core/frame/Settings.h""
+#include ""core/svg/graphics/SVGImageChromeClient.h""
 #include ""platform/Logging.h""
 #include ""platform/TraceEvent.h""
 #include ""platform/weborigin/SecurityOrigin.h""
@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res
         break;
     }
 
+    // SVG Images have unique security rules that prevent all subresource requests
+    // except for data urls.
+    if (type != Resource::MainResource) {
+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
+            return false;
+    }
+
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.",Chrome,ee281f7cac9df44fe241a37f188b28be8845ded0,41df074d67ea3069264890bd8fe5b65403083a17,1,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    // FIXME: Convert this to check the isolated world's Content Security Policy once webkit.org/b/104520 is solved.
    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    // Some types of resources can be loaded only from the same origin. Other
    // types of resources, like Images, Scripts, and CSS, can be loaded from
    // any URL.
    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        // By default these types of resources can be loaded from any origin.
        // FIXME: Are we sure about Resource::Font?
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    // Don't send CSP messages for preloads, we might never actually display those items.
    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
//fix_flaw_line_below:
//    // SVG Images have unique security rules that prevent all subresource requests
//fix_flaw_line_below:
//    // except for data urls.
//fix_flaw_line_below:
//    if (type != Resource::MainResource) {
//fix_flaw_line_below:
//        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
//fix_flaw_line_below:
//            return false;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.

    // FIXME: Should we consider forPreload here?
    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",185375,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","The `canRequest` function in the `ResourceFetcher` class determines whether a resource of a specified type can be requested from a given URL, considering security policies and origin restrictions. It first retrieves the security origin and checks if it can display the URL; if not, it reports a failure. The function then evaluates various resource types against origin restrictions and content security policies (CSP), allowing or denying requests based on these checks. Additionally, it verifies if the content is secure according to mixed content blocking rules. Ultimately, it returns a boolean indicating whether the request can proceed.","The provided code defines a method that assesses whether a resource can be requested from a specified URL based on security and policy constraints. It begins by determining the security context and verifying if the URL can be displayed. The method then checks various resource types against origin restrictions and content security policies, allowing or denying requests accordingly. It also ensures that the content adheres to security standards regarding mixed content. Ultimately, the method returns a boolean value indicating whether the resource request is permissible, ensuring compliance with security protocols and policies.","The vulnerability in the original code arises from insufficient checks on resource requests, particularly for SVG images, which could allow unauthorized subresource requests. Specifically, the absence of a condition to restrict SVG images from loading external resources, except for data URLs, posed a security risk. The fixed code addresses this by adding a check that verifies if the resource type is not the main resource and whether the current frame is an SVG image client. If these conditions are met, it ensures that only data URLs are permitted, thereby enhancing security and preventing potential exploitation through unauthorized resource loading.","The vulnerability in the original code stemmed from inadequate restrictions on resource requests, particularly for SVG images, which could lead to unauthorized access to external resources. This oversight allowed potentially harmful content to be loaded without proper validation. The fixed code rectifies this by implementing a specific check that limits SVG images from making subresource requests unless the URL is a data URL. This enhancement ensures that only safe content can be loaded, thereby mitigating the risk of exploitation and reinforcing the security framework governing resource requests.","The vulnerability was fixed by adding a specific condition that restricts SVG images from making subresource requests unless the URL is a data URL. In the updated code, a check was introduced to determine if the resource type is not the main resource and if the current frame is an SVG image client. If both conditions are met, the code ensures that the URL must use the data protocol, effectively preventing unauthorized external resource loading. This enhancement strengthens security by ensuring that only safe content can be requested, thereby mitigating potential exploitation risks associated with SVG images.","The vulnerability was addressed by implementing a specific check that restricts SVG images from making subresource requests unless the URL is a data URL. This fix ensures that when the resource type is not the main resource and the current context is identified as an SVG image client, only data URLs are permitted for loading. By adding this condition, the code effectively prevents unauthorized access to external resources, thereby enhancing security and reducing the risk of exploitation through potentially harmful content. This change reinforces the overall integrity of the resource loading process.","CWE-918, CWE-611, CWE-346, CWE-610, CWE-441, CWE-829, CWE-434, CWE-345, CWE-200, CWE-601",N,-1
71,71,185623,185623,,Remote,Not required,Partial,CVE-2015-6768,https://www.cvedetails.com/cve/CVE-2015-6768/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy via unspecified vectors, a different vulnerability than CVE-2015-6770.",2017-09-13,Bypass ,1,https://github.com/chromium/chromium/commit/4c8b008f055f79e622344627fed7f820375a4f01,4c8b008f055f79e622344627fed7f820375a4f01,"Change Document::detach() to RELEASE_ASSERT all subframes are gone.

BUG=556724,577105

Review URL: https://codereview.chromium.org/1667573002

Cr-Commit-Position: refs/heads/master@{#373642}",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""112c8cd99e3f5587281d9fe297c61e280725fcbd"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=4c8b008f055f79e622344627fed7f820375a4f01"", ""patch"": ""@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)\n void Document::detach(const AttachContext& context)\n {\n     TRACE_EVENT0(\""blink\"", \""Document::detach\"");\n-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n     if (!isActive())\n         return;\n ""}"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",C,"    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
","    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
",,"@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)
 void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 ",Chrome,4c8b008f055f79e622344627fed7f820375a4f01,6bc4255ecd25658b430cec1f6191e0044c5e6c7f,1," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
//flaw_line_below:
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
//fix_flaw_line_below:
//    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    // Frame navigation can cause a new Document to be attached. Don't allow that, since that will
    // cause a situation where LocalFrame still has a Document attached after this finishes!
    // Normally, it shouldn't actually be possible to trigger navigation here. However, plugins
    // (see below) can cause lots of crazy things to happen, since plugin detach involves nested
    // message loops.
    FrameNavigationDisabler navigationDisabler(*m_frame);
    // Defer widget updates to avoid plugins trying to run script inside ScriptForbiddenScope,
    // which will crash the renderer after https://crrev.com/200984
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    // Don't allow script to run in the middle of detach() because a detaching Document is not in a
    // consistent state.
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    // FIXME: consider using ActiveDOMObject.
    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    // FIXME: This shouldn't be needed once LocalDOMWindow becomes ExecutionContext.
    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            // Documents that are not a root document use the AXObjectCache in
            // their root document. Node::removedFrom is called after the
            // document has been detached so it can't find the root document.
            // We do the removals here instead.
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    // If this Document is associated with a live DocumentLoader, the
    // DocumentLoader will take care of clearing the FetchContext. Deferring
    // to the DocumentLoader when possible also prevents prematurely clearing
    // the context in the case where multiple Documents end up associated with
    // a single DocumentLoader (e.g., navigating to a javascript: url).
    if (!loader())
        m_fetcher->clearContext();
    // If this document is the master for an HTMLImportsController, sever that
    // relationship. This ensures that we don't leave import loads in flight,
    // thinking they should have access to a valid frame when they don't.
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    // This is required, as our LocalFrame might delete itself as soon as it detaches
    // us. However, this violates Node::detach() semantics, as it's never
    // possible to re-attach. Eventually Document::detach() should be renamed,
    // or this setting of the frame to 0 could be made explicit in each of the
    // callers of Document::detach().
    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    // FIXME: Currently we call notifyContextDestroyed() only in
    // Document::detach(), which means that we don't call
    // notifyContextDestroyed() for a document that doesn't get detached.
    // If such a document has any observer, the observer won't get
    // a contextDestroyed() notification. This can happen for a document
    // created by DOMImplementation::createDocument().
    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",185623," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
","The `Document::detach` function is responsible for safely detaching a document from its associated frame, ensuring that all related resources and references are properly cleaned up. It begins by asserting that the document is not active and that its frame has no children. The function then disables navigation, suspends updates to widget hierarchies, and forbids script execution during the detachment process. It proceeds to dispose of the view, clear event queues, and stop active DOM objects, including animations and timers. Additionally, it notifies various components, such as the page and inspector, about the detachment, and finally advances the document's lifecycle state to indicate it has stopped.","The provided code defines a function that handles the detachment of a document from its associated frame, ensuring a thorough cleanup of resources and references. It begins by verifying the document's state and then disables navigation and script execution to maintain stability during the process. The function proceeds to dispose of the document's view, clear event queues, and halt any active objects or animations. It also notifies various components about the detachment, updates lifecycle states, and ensures that all related caches and timers are properly managed, ultimately signaling that the document has been fully detached and its context destroyed.","The vulnerability in the original code stemmed from the use of an assertion that allowed the function to proceed even if the frame had children, potentially leading to resource leaks or undefined behavior during the detachment process. The fix involved replacing the assertion with a release assertion, which ensures that the function will terminate if the condition is not met, thereby preventing any further execution in an invalid state. This change enhances the robustness of the code by enforcing stricter checks on the document's state before proceeding with the detachment, ensuring that all resources are properly managed and cleaned up.","The vulnerability in the original code arose from an assertion that allowed the detachment process to continue even if certain preconditions were not met, specifically regarding the state of associated resources. This could lead to improper handling of resources, resulting in potential memory leaks or undefined behavior. The fix involved changing the assertion to a release assertion, which ensures that the function will terminate immediately if the condition fails. This adjustment enforces stricter validation of the document's state before proceeding, thereby enhancing the overall stability and reliability of the detachment process by preventing execution in an invalid context.","The vulnerability was fixed by replacing the original assertion with a release assertion, specifically changing the line that checked the frame's child count. This modification ensures that if the condition regarding the frame's state is not satisfied, the function will terminate immediately, preventing any further execution that could lead to resource mismanagement. By using `RELEASE_ASSERT`, the code enforces stricter validation before proceeding with the detachment process, thereby safeguarding against potential memory leaks or undefined behavior. This change enhances the robustness of the function, ensuring that it only operates under valid conditions.","The vulnerability was fixed by changing the assertion mechanism to enforce stricter validation of the document's state before proceeding with the detachment process. This adjustment ensures that if the necessary conditions are not met, the function will terminate immediately rather than continuing execution, which could lead to improper resource management. By implementing this more robust check, the code prevents potential memory leaks and undefined behavior, thereby enhancing the overall stability and reliability of the detachment operation. This fix ensures that the function only operates under valid circumstances, promoting safer execution.","CWE-617, CWE-119, CWE-404, CWE-476, CWE-456, CWE-672, CWE-825, CWE-415, CWE-401, CWE-457",N,-1
72,72,185628,185628,,Remote,Not required,Partial,CVE-2015-6772,https://www.cvedetails.com/cve/CVE-2015-6772/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Blink, as used in Google Chrome before 47.0.2526.73, does not prevent javascript: URL navigation while a document is being detached, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that improperly interacts with a plugin.",2017-09-13,Bypass ,2,https://github.com/chromium/chromium/commit/0b1b7baa4695c945a1b0bea1f0636f1219139e8e,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,"Open Offline Pages in CCT from Downloads Home.

When the respective feature flag is enabled, offline pages opened from
the Downloads Home will use CCT instead of normal tabs.

Bug: 824807
Change-Id: I6d968b8b0c51aaeb7f26332c7ada9f927e151a65
Reviewed-on: https://chromium-review.googlesource.com/977321
Commit-Queue: Carlos Knippschild <carlosk@chromium.org>
Reviewed-by: Ted Choc <tedchoc@chromium.org>
Reviewed-by: Bernhard Bauer <bauerb@chromium.org>
Reviewed-by: Jian Li <jianli@chromium.org>
Cr-Commit-Position: refs/heads/master@{#546545}",1,chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc,"{""sha"": ""7376c8909786382981dc04215c9e9a8fd4de5c86"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 13, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -6,18 +6,30 @@\n \n import android.app.Activity;\n import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.net.Uri;\n+import android.os.Bundle;\n+import android.provider.Browser;\n+import android.support.customtabs.CustomTabsIntent;\n \n import org.chromium.base.ApplicationStatus;\n+import org.chromium.base.ContextUtils;\n import org.chromium.base.annotations.CalledByNative;\n import org.chromium.base.annotations.JNINamespace;\n import org.chromium.chrome.browser.ChromeTabbedActivity;\n+import org.chromium.chrome.browser.IntentHandler;\n+import org.chromium.chrome.browser.LaunchIntentDispatcher;\n import org.chromium.chrome.browser.offlinepages.OfflinePageOrigin;\n import org.chromium.chrome.browser.offlinepages.OfflinePageUtils;\n import org.chromium.chrome.browser.profiles.Profile;\n import org.chromium.chrome.browser.tab.Tab;\n import org.chromium.chrome.browser.tabmodel.TabModel.TabLaunchType;\n import org.chromium.chrome.browser.tabmodel.document.AsyncTabCreationParams;\n import org.chromium.chrome.browser.tabmodel.document.TabDelegate;\n+import org.chromium.content_public.browser.LoadUrlParams;\n+\n+import java.util.Map;\n \n /**\n  * Serves as an interface between Download Home UI and offline page related items that are to be\n@@ -28,7 +40,6 @@\n     private static OfflinePageDownloadBridge sInstance;\n     private static boolean sIsTesting;\n     private long mNativeOfflinePageDownloadBridge;\n-    private boolean mIsLoaded;\n \n     /**\n      * @return An {@link OfflinePageDownloadBridge} instance singleton.  If one\n@@ -54,29 +65,73 @@ public void destroy() {\n         if (mNativeOfflinePageDownloadBridge != 0) {\n             nativeDestroy(mNativeOfflinePageDownloadBridge);\n             mNativeOfflinePageDownloadBridge = 0;\n-            mIsLoaded = false;\n         }\n     }\n \n     /**\n-     * 'Opens' the offline page identified by the given URL and offlineId.\n-     * This is done by creating a new tab and navigating it to the saved local snapshot.\n-     * No automatic redirection is happening based on the connection status.\n-     * If the item with specified GUID is not found or can't be opened, nothing happens.\n+     * 'Opens' the offline page identified by the given URL and offlineId by navigating to the saved\n+     * local snapshot. No automatic redirection is happening based on the connection status. If the\n+     * item with specified GUID is not found or can't be opened, nothing happens.\n      */\n     @CalledByNative\n-    private static void openItem(String url, long offlineId) {\n+    private static void openItem(final String url, final long offlineId, final boolean openInCct) {\n         OfflinePageUtils.getLoadUrlParamsForOpeningOfflineVersion(url, offlineId, (params) -> {\n             if (params == null) return;\n-            ComponentName componentName = getComponentName();\n-            AsyncTabCreationParams asyncParams = componentName == null\n-                    ? new AsyncTabCreationParams(params)\n-                    : new AsyncTabCreationParams(params, componentName);\n-            final TabDelegate tabDelegate = new TabDelegate(false);\n-            tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+            if (openInCct) {\n+                openItemInCct(offlineId, params);\n+            } else {\n+                openItemInNewTab(offlineId, params);\n+            }\n         });\n     }\n \n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a new tab.\n+     */\n+    private static void openItemInNewTab(long offlineId, LoadUrlParams params) {\n+        ComponentName componentName = getComponentName();\n+        AsyncTabCreationParams asyncParams = componentName == null\n+                ? new AsyncTabCreationParams(params)\n+                : new AsyncTabCreationParams(params, componentName);\n+        final TabDelegate tabDelegate = new TabDelegate(false);\n+        tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+    }\n+\n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a CCT.\n+     */\n+    private static void openItemInCct(long offlineId, LoadUrlParams params) {\n+        final Context context;\n+        if (ApplicationStatus.hasVisibleActivities()) {\n+            context = ApplicationStatus.getLastTrackedFocusedActivity();\n+        } else {\n+            context = ContextUtils.getApplicationContext();\n+        }\n+\n+        CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();\n+        builder.setShowTitle(true);\n+        builder.addDefaultShareMenuItem();\n+\n+        CustomTabsIntent customTabIntent = builder.build();\n+        customTabIntent.intent.setData(Uri.parse(params.getUrl()));\n+\n+        Intent intent = LaunchIntentDispatcher.createCustomTabActivityIntent(\n+                context, customTabIntent.intent);\n+        intent.setPackage(context.getPackageName());\n+        intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());\n+\n+        IntentHandler.addTrustedIntentExtras(intent);\n+        if (!(context instanceof Activity)) intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n+\n+        Bundle bundle = new Bundle();\n+        for (Map.Entry<String, String> entry : params.getExtraHeaders().entrySet()) {\n+            bundle.putString(entry.getKey(), entry.getValue());\n+        }\n+        intent.putExtra(Browser.EXTRA_HEADERS, bundle);\n+\n+        context.startActivity(intent);\n+    }\n+\n     /**\n      * Starts download of the page currently open in the specified Tab.\n      * If tab's contents are not yet loaded completely, we'll wait for it""}<_**next**_>{""sha"": ""3f9788b4276be03dea3ec489544bcc80bebfb2b0"", ""filename"": ""chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,\n+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());\n }\n \n // TODO(dewittj): Move to Download UI Adapter.""}","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
",C,"      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
","      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
",,"@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
 
 // TODO(dewittj): Move to Download UI Adapter.",Chrome,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,2f40b7e4357adc7fe930a1e69d7c26347a4da9d4,1,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
//flaw_line_below:
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
//fix_flaw_line_below:
//      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
//fix_flaw_line_below:
//      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
",185628,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","The provided code defines a method `OpenItem` within the `DownloadUIAdapterDelegate` class, which is responsible for opening an offline item. It takes two parameters: an `OfflineItem` object and an `int64_t` representing the offline ID. The method first attaches the current thread to the Java Virtual Machine (JVM) using `AttachCurrentThread()`. It then calls a Java method, `Java_OfflinePageDownloadBridge_openItem`, passing the current thread's environment, the page URL converted to a Java string format, and the offline ID. This facilitates interaction between C++ and Java, enabling the opening of offline content in a user interface.","The code defines a method that facilitates the opening of an offline item within a user interface. It begins by establishing a connection to the Java Virtual Machine to ensure proper interaction between C++ and Java components. Following this, it invokes a specific Java function designed to handle the opening of offline content. This function is provided with the necessary information, including the URL of the page and a unique identifier for the offline item. Overall, the method serves to bridge the two programming languages, enabling seamless access to offline resources in the application.","The vulnerability in the original code stemmed from the lack of a mechanism to control how offline pages were opened, potentially leading to unintended behavior or security issues. Specifically, the absence of a parameter to dictate the opening context could allow offline pages to be displayed in an insecure manner. The fixed code addresses this by adding a new function call, `offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()`, which determines the appropriate context for opening the offline item. This enhancement ensures that offline pages are opened securely and in a controlled environment, mitigating the risk of misuse.","The vulnerability in the original code arose from the lack of control over how offline pages were opened, which could lead to security risks or unintended user experiences. Without a mechanism to specify the context for opening these pages, there was potential for them to be displayed in an insecure manner, exposing users to various threats. The revised code addresses this issue by introducing a function that determines the appropriate context for opening offline items. This enhancement ensures that offline pages are opened in a secure and controlled manner, thereby mitigating the risk of misuse and improving overall security.","The vulnerability was fixed by adding a new function call that determines the appropriate context for opening offline pages. In the revised code, the method now includes `offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()`, which evaluates whether offline pages should be opened in a secure context. This additional parameter is passed to the `Java_OfflinePageDownloadBridge_openItem` function, allowing for more controlled handling of offline content. By implementing this check, the code ensures that offline pages are opened in a manner that enhances security and prevents potential misuse, thereby addressing the original vulnerability effectively.","The vulnerability was fixed by introducing a mechanism that determines the appropriate context for opening offline pages, thereby enhancing security. The revised code includes an additional check that evaluates whether offline content should be opened in a secure environment. This adjustment allows the application to control how offline items are presented to users, ensuring they are displayed in a manner that mitigates potential risks. By implementing this context-sensitive approach, the code effectively addresses the original security concerns, preventing unintended behavior and protecting users from possible threats associated with insecure page openings.","CWE-346, CWE-601, CWE-441, CWE-20, CWE-284, CWE-287, CWE-22, CWE-434, CWE-79, CWE-345",N,-1
73,73,185666,185666,,Remote,Not required,,CVE-2015-6786,https://www.cvedetails.com/cve/CVE-2015-6786/,CWE-264,Medium,,Partial,,2015-12-05,4.3,"The CSPSourceList::matches function in WebKit/Source/core/frame/csp/CSPSourceList.cpp in the Content Security Policy (CSP) implementation in Google Chrome before 47.0.2526.73 accepts a blob:, data:, or filesystem: URL as a match for a * pattern, which allows remote attackers to bypass intended scheme restrictions in opportunistic circumstances by leveraging a policy that relies on this pattern.",2017-09-13,Bypass ,10,https://github.com/chromium/chromium/commit/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,"Disallow CSP source * matching of data:, blob:, and filesystem: URLs

The CSP spec specifically excludes matching of data:, blob:, and
filesystem: URLs with the source '*' wildcard. This adds checks to make
sure that doesn't happen, along with tests.

BUG=534570
R=mkwst@chromium.org

Review URL: https://codereview.chromium.org/1361763005

Cr-Commit-Position: refs/heads/master@{#350950}",6,third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp,"{""sha"": ""04d7709facd4a533ebbc5a285bda64d95f90f5a3"", ""filename"": ""chrome/common/extensions/docs/templates/articles/app_csp.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/app_csp.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -51,12 +51,12 @@ <h2 id=\""what\"">What is the CSP for Chrome Apps?</h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' data: chrome-extension-resource: 'unsafe-inline';\n img-src 'self' data: chrome-extension-resource:;\n frame-src 'self' data: chrome-extension-resource:;\n font-src 'self' data: chrome-extension-resource:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <p>""}<_**next**_>{""sha"": ""e999f552168a0f8bf82aaa4254e03fa4d88e9788"", ""filename"": ""chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/offline_apps.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -135,12 +135,12 @@ <h2 id=\""possibilities\""> Security restrictions </h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' blob: data: filesystem: 'unsafe-inline';\n img-src 'self' blob: data: filesystem:;\n frame-src 'self' blob: data: filesystem:;\n font-src 'self' blob: data: filesystem:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <h2 id=\""manifest\""> Specifying offline_enabled </h2>""}<_**next**_>{""sha"": ""de9843014321c9dadb4a16669eb2d0c36cb9929c"", ""filename"": ""extensions/common/manifest_handlers/csp_info.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/manifest_handlers/csp_info.cc?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -34,7 +34,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     // Platform apps can only use local resources by default.\n     \""default-src 'self' blob: filesystem: chrome-extension-resource:;\""\n     // For remote resources, they can fetch them via XMLHttpRequest.\n-    \"" connect-src *;\""\n+    \"" connect-src * data: blob: filesystem:;\""\n     // And serve them via data: or same-origin (blob:, filesystem:) URLs\n     \"" style-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"" 'unsafe-inline';\""\n     \"" img-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"";\""\n@@ -45,7 +45,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     //    spotty connectivity.\n     // 2. Fetching via XHR and serving via blob: URLs currently does not allow\n     //    streaming or partial buffering.\n-    \"" media-src *;\"";\n+    \"" media-src * data: blob: filesystem:;\"";\n \n int GetValidatorOptions(Extension* extension) {\n   int options = csp_validator::OPTIONS_NONE;""}<_**next**_>{""sha"": ""6c0916c1fed2dbaf5abdca20cab530114b9cad3b"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""status"": ""added"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -0,0 +1,61 @@\n+<!DOCTYPE html>\n+<html>\n+    <head>\n+    <title>script-src disallowed wildcard use</title>\n+    <script src=\""../../../resources/testharness.js\""></script>\n+    <script src=\""../../../resources/testharnessreport.js\""></script>\n+    <meta http-equiv=\""Content-Security-Policy\"" content=\""script-src 'nonce-nonce' *\"">\n+    </head>\n+    <body>\n+    <script nonce=\""nonce\"">\n+        var t1 = async_test('data: URIs should not match *');\n+        t1.step(function() {\n+            var script = document.createElement(\""script\"");\n+            script.src = 'data:application/javascript,';\n+            script.addEventListener('load', t1.step_func(function() {\n+                assert_unreached('Should not successfully load data URI.');\n+            }));\n+            script.addEventListener('error', t1.step_func(function() {\n+                t1.done();\n+            }));\n+            document.head.appendChild(script);\n+        });\n+\n+        var t2 = async_test('blob: URIs should not match *');\n+        t2.step(function() {\n+            var b = new Blob([''], { type: 'application/javascript' });\n+            var script = document.createElement('script');\n+            script.addEventListener('load', t2.step_func(function() {\n+                assert_unreached('Should not successfully load blob URI.');\n+            }));\n+            script.addEventListener('error', t2.step_func(function() {\n+                t2.done();\n+            }));\n+\n+            script.src = URL.createObjectURL(b);\n+            document.head.appendChild(script);\n+        });\n+\n+        if (window.webkitRequestFileSystem) {\n+            var t3 = async_test('filesystem URIs should not match *');\n+            window.webkitRequestFileSystem(TEMPORARY, 1024*1024 /*1MB*/, function(fs) {\n+                fs.root.getFile('fail.js', {create: true}, function(fileEntry) {\n+                    fileEntry.createWriter(function(fileWriter) {\n+                        var script = document.createElement('script');\n+\n+                        script.addEventListener('load', t3.step_func(function() {\n+                            assert_unreached('Should not successfully load filesystem URI.');\n+                        }));\n+                        script.addEventListener('error', t3.step_func(function() {\n+                            t3.done();\n+                        }));\n+\n+                        script.src = fileEntry.toURL('application/javascript');\n+                        document.body.appendChild(script);\n+                    });\n+                });\n+            });\n+        }\n+    </script>\n+    </body>\n+</html>""}<_**next**_>{""sha"": ""1191abce7fe4c98eaeefc3dd95e90342aa113ade"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 7, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct\n \n bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n-    if (m_allowStar)\n+    // The CSP spec specifically states that data:, blob:, and filesystem URLs\n+    // should not be captured by a '*\"" source\n+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the\n+    // case of a full wildcard, data:, blob:, and filesystem: URLs are\n+    // explicitly checked for in the source list before allowing them through.\n+    if (m_allowStar) {\n+        if (url.protocolIs(\""blob\"") || url.protocolIs(\""data\"") || url.protocolIs(\""filesystem\""))\n+            return hasSourceMatchInList(url, redirectStatus);\n         return true;\n+    }\n \n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n \n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n \n-    for (size_t i = 0; i < m_list.size(); ++i) {\n-        if (m_list[i].matches(effectiveURL, redirectStatus))\n-            return true;\n-    }\n-\n-    return false;\n+    return hasSourceMatchInList(effectiveURL, redirectStatus);\n }\n \n bool CSPSourceList::allowInline() const\n@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo\n     m_hashAlgorithmsUsed |= algorithm;\n }\n \n+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n+{\n+    for (size_t i = 0; i < m_list.size(); ++i) {\n+        if (m_list[i].matches(url, redirectStatus))\n+            return true;\n+    }\n+\n+    return false;\n+}\n \n } // namespace blink""}<_**next**_>{""sha"": ""fceb8158a1b7c8c9471676d479833eb499d3f012"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -50,6 +50,8 @@ class CORE_EXPORT CSPSourceList {\n     void addSourceNonce(const String& nonce);\n     void addSourceHash(const ContentSecurityPolicyHashAlgorithm&, const DigestValue& hash);\n \n+    bool hasSourceMatchInList(const KURL&, ContentSecurityPolicy::RedirectStatus) const;\n+\n     ContentSecurityPolicy* m_policy;\n     Vector<CSPSource> m_list;\n     String m_directiveName;""}<_**next**_>{""sha"": ""106e8e72f16939961020c1bffd149182cce45d3b"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -54,6 +54,24 @@ TEST_F(CSPSourceListTest, BasicMatchingNone)\n     EXPECT_FALSE(sourceList.matches(KURL(base, \""https://example.test/\"")));\n }\n \n+TEST_F(CSPSourceListTest, BasicMatchingStar)\n+{\n+    KURL base;\n+    String sources = \""*\"";\n+    CSPSourceList sourceList(csp.get(), \""script-src\"");\n+    parseSourceList(sourceList, sources);\n+\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""https://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/bar\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/bar\"")));\n+\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""data:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""blob:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""filesystem:https://example.test/\"")));\n+}\n+\n TEST_F(CSPSourceListTest, BasicMatchingSelf)\n {\n     KURL base;""}"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
",C,"    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
    }
    return hasSourceMatchInList(effectiveURL, redirectStatus);
","    if (m_allowStar)
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
",,"@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct
 
 bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
-    if (m_allowStar)
+    // The CSP spec specifically states that data:, blob:, and filesystem URLs
+    // should not be captured by a '*"" source
+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
+    // case of a full wildcard, data:, blob:, and filesystem: URLs are
+    // explicitly checked for in the source list before allowing them through.
+    if (m_allowStar) {
+        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
+            return hasSourceMatchInList(url, redirectStatus);
         return true;
+    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
-    for (size_t i = 0; i < m_list.size(); ++i) {
-        if (m_list[i].matches(effectiveURL, redirectStatus))
-            return true;
-    }
-
-    return false;
+    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
 
 bool CSPSourceList::allowInline() const
@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo
     m_hashAlgorithmsUsed |= algorithm;
 }
 
+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
+{
+    for (size_t i = 0; i < m_list.size(); ++i) {
+        if (m_list[i].matches(url, redirectStatus))
+            return true;
+    }
+
+    return false;
+}
 
 } // namespace blink",Chrome,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,4b86b23ef2edc67efd12a111ad4ddf83ca53329c,1," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
//flaw_line_below:
    if (m_allowStar)
//fix_flaw_line_below:
//    // The CSP spec specifically states that data:, blob:, and filesystem URLs
//fix_flaw_line_below:
//    // should not be captured by a '*"" source
//fix_flaw_line_below:
//    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
//fix_flaw_line_below:
//    // case of a full wildcard, data:, blob:, and filesystem: URLs are
//fix_flaw_line_below:
//    // explicitly checked for in the source list before allowing them through.
//fix_flaw_line_below:
//    if (m_allowStar) {
//fix_flaw_line_below:
//        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
//fix_flaw_line_below:
//            return hasSourceMatchInList(url, redirectStatus);
         return true;
//fix_flaw_line_below:
//    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
//flaw_line_below:
    for (size_t i = 0; i < m_list.size(); ++i) {
//flaw_line_below:
        if (m_list[i].matches(effectiveURL, redirectStatus))
//flaw_line_below:
            return true;
//flaw_line_below:
    }
//flaw_line_below:

//flaw_line_below:
    return false;
//fix_flaw_line_below:
//    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
",185666," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
","The `CSPSourceList::matches` function checks if a given URL matches the content security policy (CSP) rules defined in the `CSPSourceList` object. It first evaluates if wildcard matching is allowed (`m_allowStar`), returning true if so. Then, it determines the effective URL based on whether inner URL matching is applicable. If self-origin matching is permitted (`m_allowSelf`), it checks if the effective URL matches the policy's self URL. Finally, it iterates through a list of defined sources (`m_list`), returning true if any source matches the effective URL and redirect status; otherwise, it returns false.","The provided code defines a method that determines whether a specified URL complies with a set of content security policy rules. It first checks if wildcard matching is enabled, allowing any URL to be accepted. Next, it assesses the URL's context to decide if it should be treated as an inner URL. If the policy allows matching against the originating URL, it verifies this condition. Finally, the method iterates through a collection of defined sources to see if any of them match the processed URL and its associated redirect status, returning true for a match or false otherwise.","The vulnerability in the original code arises from the unrestricted acceptance of any URL when wildcard matching is enabled, specifically allowing potentially harmful protocols like data, blob, and filesystem. This could lead to security risks, such as data injection or unauthorized access to sensitive resources. The fixed code addresses this issue by explicitly checking if the URL's protocol is one of these potentially dangerous types before allowing it through. If the URL is deemed unsafe, it ensures that only URLs matching the defined sources in the list are accepted, thereby enhancing the security of the content security policy implementation.","The vulnerability in the original code stems from the lack of restrictions on accepting any URL when wildcard matching is enabled, which could allow harmful protocols to bypass security measures. This oversight could lead to risks such as data injection or unauthorized access to sensitive resources. The fixed code addresses this issue by implementing explicit checks for potentially dangerous URL protocols before allowing them through. By ensuring that only safe URLs are processed and requiring a match against defined sources for certain protocols, the updated implementation significantly enhances the security of the content security policy.","The vulnerability was fixed by modifying the handling of wildcard matching to include explicit checks for potentially dangerous URL protocols, such as ""blob,"" ""data,"" and ""filesystem."" In the updated code, when `m_allowStar` is true, the function first checks if the URL's protocol matches any of these unsafe types. If it does, the code calls `hasSourceMatchInList` to determine if the URL is allowed based on the defined sources. This ensures that harmful protocols are not accepted indiscriminately, thereby reinforcing the security of the content security policy by preventing unauthorized access to sensitive resources.","The vulnerability was addressed by implementing specific checks for potentially harmful URL protocols when wildcard matching is enabled. The updated code now verifies if the URL falls under unsafe categories, such as data or blob protocols, before allowing it to pass through. If the URL is deemed unsafe, it requires a match against a predefined list of acceptable sources instead of granting blanket access. This change effectively prevents the acceptance of potentially malicious URLs, thereby enhancing the overall security of the content security policy and protecting sensitive resources from unauthorized access.","CWE-346,CWE-284,CWE-287,CWE-601,CWE-611,CWE-20,CWE-159,CWE-436,CWE-183,CWE-641",N,-1
74,74,186091,186091,,Remote,Not required,Partial,CVE-2016-1631,https://www.cvedetails.com/cve/CVE-2016-1631/,CWE-264,Medium,Partial,Partial,,2016-03-05,6.8,"The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",2016-12-02,Bypass ,4,https://github.com/chromium/chromium/commit/dd77c2a41c72589d929db0592565125ca629fb2c,dd77c2a41c72589d929db0592565125ca629fb2c,"Fix PPB_Flash_MessageLoop.

This CL suspends script callbacks and resource loads while running nested message loop using PPB_Flash_MessageLoop.

BUG=569496

Review URL: https://codereview.chromium.org/1559113002

Cr-Commit-Position: refs/heads/master@{#374529}",0,content/renderer/pepper/ppb_flash_message_loop_impl.cc,"{""sha"": ""279bfc99449026df2d8c842a91b95a674a451c07"", ""filename"": ""chrome/test/ppapi/ppapi_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/ppapi/ppapi_browsertest.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -1105,6 +1105,7 @@ IN_PROC_BROWSER_TEST_F(PPAPINaClPNaClNonSfiTest, MAYBE_PNACL_NONSFI(View)) {\n   RunTest( \\\n       LIST_TEST(FlashMessageLoop_Basics) \\\n       LIST_TEST(FlashMessageLoop_RunWithoutQuit) \\\n+      LIST_TEST(FlashMessageLoop_SuspendScriptCallbackWhileRunning) \\\n   )\n \n #if defined(OS_LINUX)  // Disabled due to flakiness http://crbug.com/316925""}<_**next**_>{""sha"": ""89ac5adde7a0e7de7fc17cdfa3527311a31cee90"", ""filename"": ""content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/pepper/ppb_flash_message_loop_impl.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -7,6 +7,7 @@\n #include \""base/callback.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""ppapi/c/pp_errors.h\""\n+#include \""third_party/WebKit/public/web/WebView.h\""\n \n using ppapi::thunk::PPB_Flash_MessageLoop_API;\n \n@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n+    blink::WebView::willEnterModalLoop();\n+\n     base::MessageLoop::current()->Run();\n+\n+    blink::WebView::didExitModalLoop();\n   }\n   // Don't access data members of the class below.\n ""}<_**next**_>{""sha"": ""2043cbeb11c6b01f8662ccf28702a9006268f3f9"", ""filename"": ""ppapi/tests/test_flash_message_loop.cc"", ""status"": ""modified"", ""additions"": 111, ""deletions"": 6, ""changes"": 117, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -5,27 +5,97 @@\n #include \""ppapi/tests/test_flash_message_loop.h\""\n \n #include \""ppapi/c/pp_macros.h\""\n+#include \""ppapi/c/ppb_var.h\""\n #include \""ppapi/cpp/core.h\""\n+#include \""ppapi/cpp/dev/scriptable_object_deprecated.h\""\n #include \""ppapi/cpp/logging.h\""\n #include \""ppapi/cpp/module.h\""\n #include \""ppapi/cpp/private/flash_message_loop.h\""\n #include \""ppapi/tests/testing_instance.h\""\n \n+namespace {\n+\n+const char kDidRunScriptCallback[] = \""DidRunScriptCallback\"";\n+\n+}  // namespace\n+\n+class TestFlashMessageLoop::InstanceSO\n+    : public pp::deprecated::ScriptableObject {\n+ public:\n+  explicit InstanceSO(TestFlashMessageLoop* owner) : owner_(owner) {}\n+\n+  ~InstanceSO() override {\n+    if (owner_)\n+      owner_->clear_instance_so();\n+  }\n+\n+  // pp::deprecated::ScriptableObject overrides.\n+  bool HasMethod(const pp::Var& name, pp::Var* exception) override {\n+    if (!name.is_string())\n+      return false;\n+    return name.AsString() == kDidRunScriptCallback;\n+  }\n+\n+  pp::Var Call(const pp::Var& method_name,\n+               const std::vector<pp::Var>& args,\n+               pp::Var* exception) override {\n+    if (!method_name.is_string())\n+      return false;\n+    std::string name = method_name.AsString();\n+\n+    if (name == kDidRunScriptCallback) {\n+      if (args.size() != 0) {\n+        *exception = pp::Var(\""Bad argument to DidRunScriptCallback()\"");\n+      } else if (owner_) {\n+        owner_->DidRunScriptCallback();\n+      }\n+    } else {\n+      *exception = pp::Var(\""Bad function call\"");\n+    }\n+\n+    return pp::Var();\n+  }\n+\n+  void clear_owner() { owner_ = nullptr; }\n+\n+ private:\n+  TestFlashMessageLoop* owner_;\n+};\n+\n REGISTER_TEST_CASE(FlashMessageLoop);\n \n TestFlashMessageLoop::TestFlashMessageLoop(TestingInstance* instance)\n     : TestCase(instance),\n-      message_loop_(NULL),\n-      callback_factory_(this) {\n-}\n+      message_loop_(nullptr),\n+      instance_so_(nullptr),\n+      suspend_script_callback_result_(false),\n+      callback_factory_(this) {}\n \n TestFlashMessageLoop::~TestFlashMessageLoop() {\n   PP_DCHECK(!message_loop_);\n+\n+  ResetTestObject();\n+  if (instance_so_)\n+    instance_so_->clear_owner();\n }\n \n void TestFlashMessageLoop::RunTests(const std::string& filter) {\n   RUN_TEST(Basics, filter);\n   RUN_TEST(RunWithoutQuit, filter);\n+  RUN_TEST(SuspendScriptCallbackWhileRunning, filter);\n+}\n+\n+void TestFlashMessageLoop::DidRunScriptCallback() {\n+  // Script callbacks are not supposed to run while the Flash message loop is\n+  // running.\n+  if (message_loop_)\n+    suspend_script_callback_result_ = false;\n+}\n+\n+pp::deprecated::ScriptableObject* TestFlashMessageLoop::CreateTestObject() {\n+  if (!instance_so_)\n+    instance_so_ = new InstanceSO(this);\n+  return instance_so_;\n }\n \n std::string TestFlashMessageLoop::TestBasics() {\n@@ -38,7 +108,7 @@ std::string TestFlashMessageLoop::TestBasics() {\n \n   ASSERT_TRUE(message_loop_);\n   delete message_loop_;\n-  message_loop_ = NULL;\n+  message_loop_ = nullptr;\n \n   ASSERT_EQ(PP_OK, result);\n   PASS();\n@@ -54,14 +124,49 @@ std::string TestFlashMessageLoop::TestRunWithoutQuit() {\n \n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n     ASSERT_TRUE(false);\n   }\n \n   ASSERT_EQ(PP_ERROR_ABORTED, result);\n   PASS();\n }\n \n+std::string TestFlashMessageLoop::TestSuspendScriptCallbackWhileRunning() {\n+  suspend_script_callback_result_ = true;\n+  message_loop_ = new pp::flash::MessageLoop(instance_);\n+\n+  pp::CompletionCallback callback = callback_factory_.NewCallback(\n+      &TestFlashMessageLoop::TestSuspendScriptCallbackTask);\n+  pp::Module::Get()->core()->CallOnMainThread(0, callback);\n+  message_loop_->Run();\n+\n+  ASSERT_TRUE(message_loop_);\n+  delete message_loop_;\n+  message_loop_ = nullptr;\n+\n+  ASSERT_TRUE(suspend_script_callback_result_);\n+  PASS();\n+}\n+\n+void TestFlashMessageLoop::TestSuspendScriptCallbackTask(int32_t unused) {\n+  pp::Var exception;\n+  pp::Var rev = instance_->ExecuteScript(\n+      \""(function() {\""\n+      \""  function delayedHandler() {\""\n+      \""    document.getElementById('plugin').DidRunScriptCallback();\""\n+      \""  }\""\n+      \""  setTimeout(delayedHandler, 1);\""\n+      \""})()\"",\n+      &exception);\n+  if (!exception.is_undefined())\n+    suspend_script_callback_result_ = false;\n+\n+  pp::CompletionCallback callback =\n+      callback_factory_.NewCallback(&TestFlashMessageLoop::QuitMessageLoopTask);\n+  pp::Module::Get()->core()->CallOnMainThread(500, callback);\n+}\n+\n void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n   if (message_loop_)\n     message_loop_->Quit();\n@@ -72,7 +177,7 @@ void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n void TestFlashMessageLoop::DestroyMessageLoopResourceTask(int32_t unused) {\n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n   } else {\n     PP_NOTREACHED();\n   }""}<_**next**_>{""sha"": ""31b27916cc2d8b006f8bcd0125975bf157f5f492"", ""filename"": ""ppapi/tests/test_flash_message_loop.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 2, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.h?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -20,19 +20,37 @@ class MessageLoop;\n class TestFlashMessageLoop : public TestCase {\n  public:\n   explicit TestFlashMessageLoop(TestingInstance* instance);\n-  virtual ~TestFlashMessageLoop();\n+  ~TestFlashMessageLoop() override;\n \n   // TestCase implementation.\n-  virtual void RunTests(const std::string& filter);\n+  void RunTests(const std::string& filter) override;\n+\n+  void clear_instance_so() { instance_so_ = nullptr; }\n+\n+  void DidRunScriptCallback();\n \n  private:\n+  // ScriptableObject implementation.\n+  class InstanceSO;\n+\n+  // TestCase protected overrides.\n+  pp::deprecated::ScriptableObject* CreateTestObject() override;\n+\n   std::string TestBasics();\n   std::string TestRunWithoutQuit();\n+  std::string TestSuspendScriptCallbackWhileRunning();\n \n+  void TestSuspendScriptCallbackTask(int32_t unused);\n   void QuitMessageLoopTask(int32_t unused);\n   void DestroyMessageLoopResourceTask(int32_t unused);\n \n   pp::flash::MessageLoop* message_loop_;\n+\n+  // The scriptable object and result storage for the\n+  // SuspendScriptCallbackWhileRunning test.\n+  InstanceSO* instance_so_;\n+  bool suspend_script_callback_result_;\n+\n   pp::CompletionCallbackFactory<TestFlashMessageLoop> callback_factory_;\n };\n ""}","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
",C,"    blink::WebView::willEnterModalLoop();


    blink::WebView::didExitModalLoop();
",,,"@@ -7,6 +7,7 @@
 #include ""base/callback.h""
 #include ""base/message_loop/message_loop.h""
 #include ""ppapi/c/pp_errors.h""
+#include ""third_party/WebKit/public/web/WebView.h""
 
 using ppapi::thunk::PPB_Flash_MessageLoop_API;
 
@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
+    blink::WebView::willEnterModalLoop();
+
     base::MessageLoop::current()->Run();
+
+    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 ",Chrome,dd77c2a41c72589d929db0592565125ca629fb2c,fc51e9e93e12a0f3d6b4f3e1f33c5e252d0dff95,1,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  // It is possible that the PPB_Flash_MessageLoop_Impl object has been
  // destroyed when the nested message loop exits.
  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
//fix_flaw_line_below:
//    blink::WebView::willEnterModalLoop();
//fix_flaw_line_below:
//
     base::MessageLoop::current()->Run();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 
  return state_protector->result();
}
",186091,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","The provided code defines a method `InternalRun` within the `PPB_Flash_MessageLoop_Impl` class, which manages the execution of a message loop. It first checks if the method has already been called; if so, it invokes a callback with an error code and returns a failure status. If not, it marks the method as called, stores the callback, and allows nested tasks in the current message loop. The message loop is then executed, and upon completion, the method returns the result stored in a protected state object, ensuring thread safety during the operation.","The code implements a method that manages the execution of a message loop while ensuring it is not called multiple times. It first checks if the method has been previously invoked, and if so, it triggers a callback with an error indication and exits. If the method is being called for the first time, it marks the invocation, stores the callback, and allows for nested task execution within the current message loop. After running the message loop, it retrieves and returns a result from a protected state object, ensuring safe access during the operation.","The vulnerability in the original code stemmed from the lack of proper handling for modal loop entry and exit, which could lead to inconsistent states or resource leaks when the message loop was executed. Specifically, the absence of calls to `blink::WebView::willEnterModalLoop()` and `blink::WebView::didExitModalLoop()` meant that the system did not properly manage the modal state, potentially allowing for unexpected behavior or crashes. The fixed code addresses this by explicitly invoking these functions before and after running the message loop, ensuring that the modal state is correctly entered and exited, thus enhancing stability and resource management.","The vulnerability in the original code was related to the improper management of modal loop states, which could lead to inconsistent behavior or resource leaks during the execution of the message loop. Without the necessary mechanisms to signal when entering and exiting a modal state, the system risked encountering unexpected conditions that could disrupt normal operations. The fixed code rectifies this issue by explicitly incorporating calls to manage the modal state before and after the message loop execution, ensuring that the system maintains a consistent state and properly handles resources, thereby enhancing overall stability and reliability.","The vulnerability was fixed by adding calls to `blink::WebView::willEnterModalLoop()` and `blink::WebView::didExitModalLoop()` around the execution of the message loop. This ensures that the system properly signals when it is entering and exiting a modal state, which is crucial for maintaining consistent behavior and resource management. By placing these calls before and after `base::MessageLoop::current()->Run()`, the code now effectively manages the modal state, preventing potential issues such as resource leaks or unexpected behavior that could arise from not handling the modal state correctly during the message loop execution.","The vulnerability was addressed by incorporating mechanisms to properly manage the entry and exit of a modal state during the execution of the message loop. By explicitly signaling when the system enters and exits this state, the code ensures that resources are handled correctly and that the system maintains a consistent operational state. This addition prevents potential issues such as resource leaks or unexpected behavior that could arise from improper state management. Overall, the fix enhances the stability and reliability of the system during the execution of critical operations within the message loop.","CWE-404, CWE-459, CWE-672, CWE-666, CWE-667, CWE-668, CWE-671, CWE-673, CWE-401, CWE-405",N,-1
75,75,187364,187364,,Remote,Not required,Partial,CVE-2015-3845,https://www.cvedetails.com/cve/CVE-2015-3845/,CWE-264,Medium,Partial,Partial,,2015-09-30,6.8,"The Parcel::appendFrom function in libs/binder/Parcel.cpp in Binder in Android before 5.1.1 LMY48M does not consider parcel boundaries during identification of binder objects in an append operation, which allows attackers to obtain a different application's privileges via a crafted application, aka internal bug 17312693.",2015-10-01,,1,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20,e68cbc3e9e66df4231e70efa3e9c41abc12aea20,"Disregard alleged binder entities beyond parcel bounds

When appending one parcel's contents to another, ignore binder
objects within the source Parcel that appear to lie beyond the
formal bounds of that Parcel's data buffer.

Bug 17312693

Change-Id: If592a260f3fcd9a56fc160e7feb2c8b44c73f514
(cherry picked from commit 27182be9f20f4f5b48316666429f09b9ecc1f22e)
",1,libs/binder/Parcel.cpp,"{""filename"": ""libs/binder/Parcel.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/libs/binder/Parcel.cpp"", ""patch"": ""@@ -411,7 +411,7 @@\n\n     // Count objects in range\n     for (int i = 0; i < (int) size; i++) {\n         size_t off = objects[i];\n-        if ((off >= offset) && (off < offset + len)) {\n+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {\n             if (firstIndex == -1) {\n                 firstIndex = i;\n             }\n""}","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",C,"        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
","        if ((off >= offset) && (off < offset + len)) {
",,"@@ -411,7 +411,7 @@

     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
-        if ((off >= offset) && (off < offset + len)) {
+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
",Android,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20%5E/,1,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 // range checks against the source parcel size
 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
//flaw_line_below:
        if ((off >= offset) && (off < offset + len)) {
//fix_flaw_line_below:
//        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
 // grow data
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

 // append data
    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 // grow objects
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 // append and acquire objects
 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
 // If this is a file descriptor, we need to dup it so the
 // new Parcel now owns its own fd, and can declare that we
 // officially know we have fds.
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",187364,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","The `Parcel::appendFrom` function is designed to append a specified segment of data from one `Parcel` object to another, while managing associated binder objects. It first checks for valid input parameters, ensuring the specified offset and length do not exceed the source parcel's data size. The function identifies binder objects within the specified range and adjusts the destination parcel's data and object arrays accordingly. If necessary, it reallocates memory to accommodate new objects and handles special cases for file descriptors. Finally, it updates the internal state of the destination parcel and returns an appropriate status code indicating success or failure.","The provided code defines a method that appends a segment of data from one object to another while managing associated resources. It begins by validating the input parameters to ensure they are within acceptable limits. The method identifies any related resources within the specified data range and adjusts the destination object's data and resource arrays as needed. If the destination lacks sufficient memory, it reallocates space to accommodate the new resources. Additionally, it handles specific cases for resource types, ensuring proper management and duplication when necessary. Finally, the method returns a status code indicating the outcome of the operation.","The vulnerability in the original code stemmed from insufficient validation of object offsets, which could lead to out-of-bounds memory access when processing binder objects. Specifically, the condition checking whether an offset was within the specified range did not account for the size of the `flat_binder_object`, potentially allowing access to memory beyond the intended segment. The fix introduced an additional check to ensure that the offset plus the size of the `flat_binder_object` remained within the bounds of the specified length, thereby preventing potential buffer overflows and enhancing the overall safety of memory operations.","The vulnerability in the original code arose from inadequate validation of memory offsets, which could lead to out-of-bounds access when handling associated resources. This oversight allowed the potential for reading or writing beyond allocated memory, risking data corruption or crashes. The fix addressed this issue by adding a condition to ensure that the calculated offsets, when combined with the size of the resource, remained within the valid range. This enhancement effectively mitigated the risk of buffer overflows, ensuring safer memory operations and protecting the integrity of the data being processed.","The vulnerability was fixed by modifying the condition within the loop that identifies valid object offsets. The original code only checked if the offset was within the specified range, which could lead to out-of-bounds access. The updated code now includes an additional check to ensure that the offset plus the size of the `flat_binder_object` does not exceed the range defined by the specified length. This change ensures that any accessed memory remains within valid bounds, thereby preventing potential buffer overflows and enhancing the overall safety of memory operations in the `appendFrom` function.","The vulnerability was addressed by enhancing the validation checks for memory offsets during the identification of associated resources. The fix introduced an additional condition to ensure that the calculated offsets, when combined with the size of the resource, remained within the valid range defined by the specified length. This adjustment effectively prevented any potential out-of-bounds access, thereby mitigating the risk of buffer overflows. By ensuring that all memory accesses are confined to allocated regions, the fix improved the overall safety and integrity of the memory operations within the function.","CWE-119, CWE-125, CWE-787, CWE-823, CWE-788, CWE-124, CWE-789, CWE-122, CWE-121, CWE-126",N,-1
76,76,187420,187420,,Remote,Not required,Complete,CVE-2016-3913,https://www.cvedetails.com/cve/CVE-2016-3913/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"media/libmediaplayerservice/MediaPlayerService.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate a certain static_cast operation, which allows attackers to gain privileges via a crafted application, aka internal bug 30204103.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d,0c3b93c8c2027e74af642967eee5c142c8fd185d,"MediaPlayerService: avoid invalid static cast

Bug: 30204103
Change-Id: Ie0dd3568a375f1e9fed8615ad3d85184bcc99028
(cherry picked from commit ee0a0e39acdcf8f97e0d6945c31ff36a06a36e9d)
",0,media/libmediaplayerservice/MediaPlayerService.cpp,"{""filename"": ""media/libmediaplayerservice/MediaPlayerService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.cpp"", ""patch"": ""@@ -558,6 +558,12 @@\n\n     mClients.remove(client);\n }\n \n+bool MediaPlayerService::hasClient(wp<Client> client)\n+{\n+    Mutex::Autolock lock(mLock);\n+    return mClients.indexOf(client) != NAME_NOT_FOUND;\n+}\n+\n MediaPlayerService::Client::Client(\n         const sp<MediaPlayerService>& service, pid_t pid,\n         int32_t connId, const sp<IMediaPlayerClient>& client,\n@@ -1086,6 +1092,10 @@\n\n     ALOGV(\""setNextPlayer\"");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n+    if (!mService->hasClient(c)) {\n+      return BAD_VALUE;\n+    }\n+\n     mNextClient = c;\n \n     if (c != NULL) {\n""}<_**next**_>{""filename"": ""media/libmediaplayerservice/MediaPlayerService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.h"", ""patch"": ""@@ -226,6 +226,7 @@\n\n     virtual status_t            dump(int fd, const Vector<String16>& args);\n \n             void                removeClient(wp<Client> client);\n+            bool                hasClient(wp<Client> client);\n \n     enum {\n         MEDIASERVER_PROCESS_DEATH = 0,\n""}","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",C,"    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

",,,"@@ -558,6 +558,12 @@

     mClients.remove(client);
 }
 
+bool MediaPlayerService::hasClient(wp<Client> client)
+{
+    Mutex::Autolock lock(mLock);
+    return mClients.indexOf(client) != NAME_NOT_FOUND;
+}
+
 MediaPlayerService::Client::Client(
         const sp<MediaPlayerService>& service, pid_t pid,
         int32_t connId, const sp<IMediaPlayerClient>& client,
@@ -1086,6 +1092,10 @@

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
+    if (!mService->hasClient(c)) {
+      return BAD_VALUE;
+    }
+
     mNextClient = c;
 
     if (c != NULL) {
",Android,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d%5E/,1,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
//fix_flaw_line_below:
//    if (!mService->hasClient(c)) {
//fix_flaw_line_below:
//      return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",187420,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","The `setNextPlayer` function in the `MediaPlayerService::Client` class is designed to set a new media player as the next player to be used. It begins by acquiring a lock to ensure thread safety and retrieves the client associated with the provided player. If the client is valid, it checks if there is an existing audio output; if so, it sets the next audio output for the new client. If there is no current audio output and a player is present, it logs an error. Finally, if both the current player and the next client’s player are valid, it sets the next player for the current player, returning an OK status upon completion.","The provided code defines a method that assigns a new media player to be used subsequently within a media service. It ensures thread safety by locking access during the operation. If the new player is valid, the method checks for an existing audio output and updates it accordingly. If no audio output is available and a current player exists, an error is logged. Additionally, if both the current and new players are valid, the method sets the new player as the next one for the current player. The method concludes by returning a success status.","The vulnerability in the original code stemmed from the lack of validation for the new client before it was assigned as the next player. This oversight allowed potentially unauthorized or invalid clients to be set, which could lead to unexpected behavior or security issues. The fixed code addresses this vulnerability by introducing a check using the `mService->hasClient(c)` function, ensuring that the client is valid and recognized by the service before proceeding with the assignment. This additional validation step prevents the assignment of unverified clients, thereby enhancing the overall security and stability of the media player service.","The vulnerability in the original code arose from the absence of validation for the new client before it was assigned, allowing potentially unauthorized or invalid clients to be set as the next player. This could lead to security risks or instability within the media service, as unverified clients might not adhere to expected behaviors. The fixed code rectifies this issue by implementing a validation check to ensure that the client is recognized and authorized by the service before proceeding with the assignment. This crucial step enhances the security and reliability of the media player service by preventing the use of invalid clients.","The vulnerability was fixed by adding a validation check using the `mService->hasClient(c)` function before assigning the new client. This check ensures that the client being set as the next player is recognized and authorized by the service, preventing unauthorized or invalid clients from being assigned. If the client fails this validation, the function returns `BAD_VALUE`, halting further execution and protecting the system from potential security risks or instability. This enhancement effectively safeguards the media player service by ensuring that only valid clients can be processed, thereby improving overall reliability and security.","The vulnerability was addressed by introducing a validation step that checks whether the new client is recognized and authorized by the service before proceeding with its assignment. This additional check ensures that only valid clients can be set as the next player, effectively preventing unauthorized or potentially harmful clients from being processed. If the client does not pass this validation, the function immediately returns an error, stopping any further actions. This fix enhances the security and stability of the media service by ensuring that only legitimate clients are allowed to interact with the system.","CWE-287, CWE-306, CWE-522, CWE-284, CWE-285, CWE-807, CWE-288, CWE-346, CWE-602, CWE-425",N,-1
77,77,187425,187425,,Remote,Not required,Complete,CVE-2016-3900,https://www.cvedetails.com/cve/CVE-2016-3900/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69,047eec456943dc082e33220d28abb7df4e089f69,"ServiceManager: Allow system services running as secondary users to add services

This should be reverted when all system services have been cleaned up to not
do this. A process looking up a service while running in the background will
see the service registered by the active user (assuming the service is
registered on every user switch), not the service registered by the user that
the process itself belongs to.

BUG: 30795333
Change-Id: I1b74d58be38ed358f43c163692f9e704f8f31dbe
(cherry picked from commit e6bbe69ba739c8a08837134437aaccfea5f1d943)
",1,cmds/servicemanager/service_manager.c,"{""filename"": ""cmds/servicemanager/Android.mk"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/Android.mk"", ""patch"": ""@@ -18,7 +18,7 @@\n\n include $(BUILD_EXECUTABLE)\n \n include $(CLEAR_VARS)\n-LOCAL_SHARED_LIBRARIES := liblog libselinux\n+LOCAL_SHARED_LIBRARIES := liblog libcutils libselinux\n LOCAL_SRC_FILES := service_manager.c binder.c\n LOCAL_CFLAGS += $(svc_c_flags)\n LOCAL_MODULE := servicemanager\n""}<_**next**_>{""filename"": ""cmds/servicemanager/service_manager.c"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/service_manager.c"", ""patch"": ""@@ -8,6 +8,8 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n+#include <cutils/multiuser.h>\n+\n #include <private/android_filesystem_config.h>\n \n #include <selinux/android.h>\n@@ -122,7 +124,7 @@\n\n {\n     const char *perm = \""add\"";\n \n-    if (uid >= AID_APP) {\n+    if (multiuser_get_app_id(uid) >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n""}","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",C,"    if (multiuser_get_app_id(uid) >= AID_APP) {
","    if (uid >= AID_APP) {
",,"@@ -8,6 +8,8 @@

 #include <stdlib.h>
 #include <string.h>
 
+#include <cutils/multiuser.h>
+
 #include <private/android_filesystem_config.h>
 
 #include <selinux/android.h>
@@ -122,7 +124,7 @@

 {
     const char *perm = ""add"";
 
-    if (uid >= AID_APP) {
+    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
",Android,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69%5E/,1,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
//flaw_line_below:
    if (uid >= AID_APP) {
//fix_flaw_line_below:
//    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",187425,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","The provided code defines a static function `svc_can_register` that determines whether a service can be registered based on the user ID (UID) and service name. It takes three parameters: a pointer to a service name (`name`), the length of the name (`name_len`), and the process ID (`spid`). The function first checks if the UID is greater than or equal to `AID_APP`, which indicates that the caller is an application; if so, it returns 0, denying registration. Otherwise, it calls `check_mac_perms_from_lookup` to verify if the process has the necessary permissions to register the service, returning 1 for success or 0 for failure.","The code defines a function that checks if a service can be registered based on the user identity and the associated process. It first verifies if the user belongs to a specific category, which would restrict applications from registering services. If the user is deemed valid, the function then assesses whether the process has the necessary permissions to proceed with the registration. The outcome is a binary response indicating whether the registration is allowed, with a denial for applications and a permission check for other users, ensuring that only authorized entities can register services.","The vulnerability in the original code stemmed from directly comparing the user ID (`uid`) to a constant value (`AID_APP`) to determine if the caller was an application, which could potentially allow unauthorized access if the UID was manipulated. The fixed code addresses this issue by using the `multiuser_get_app_id(uid)` function, which retrieves the application ID in a more secure manner, ensuring that the check is robust against spoofing. This change enhances the security of the registration process by providing a more reliable way to identify applications, thereby preventing unauthorized service registrations.","The vulnerability in the original code arose from a simplistic check that allowed applications to potentially bypass restrictions based on user identity, which could lead to unauthorized service registrations. This was due to the direct comparison of user identifiers, making it susceptible to manipulation. The fixed code mitigates this risk by implementing a more secure method to determine the application identity, ensuring that the check is not easily spoofed. This enhancement strengthens the overall security of the registration process, effectively preventing unauthorized entities from registering services and maintaining system integrity.","The vulnerability was fixed by replacing the direct comparison of the user ID (`uid`) with a constant value (`AID_APP`) with a call to the `multiuser_get_app_id(uid)` function. This change ensures that the application ID is retrieved in a more secure manner, allowing for a more accurate determination of whether the caller is an application. By using this function, the code can effectively prevent unauthorized applications from registering services, as it provides a robust mechanism to validate the identity of the user, thereby enhancing the security of the registration process.","The vulnerability was addressed by implementing a more secure method for identifying the caller's application status, replacing a direct comparison that could be easily manipulated. The updated approach retrieves the application identity in a way that is less susceptible to spoofing, ensuring that only legitimate applications are recognized. This change enhances the integrity of the registration process by providing a reliable mechanism to validate user permissions, effectively preventing unauthorized entities from registering services and thereby strengthening the overall security of the system.","CWE-287, CWE-284, CWE-285, CWE-290, CWE-347, CWE-346, CWE-295, CWE-306, CWE-807, CWE-269",N,-1
78,78,187427,187427,,Remote,Not required,Complete,CVE-2016-3890,https://www.cvedetails.com/cve/CVE-2016-3890/,CWE-264,High,Complete,Complete,,2016-09-11,7.6,"The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842.",2017-08-12,+Priv ,1,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d,014b01706cc64dc9c2ad94a96f62e07c058d0b5d,"adb: use asocket's close function when closing.

close_all_sockets was assuming that all registered local sockets used
local_socket_close as their close function. However, this is not true
for JDWP sockets.

Bug: http://b/28347842
Change-Id: I40a1174845cd33f15f30ce70828a7081cd5a087e
(cherry picked from commit 53eb31d87cb84a4212f4850bf745646e1fb12814)
",1,adb/sockets.cpp,"{""filename"": ""adb/sockets.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/adb/sockets.cpp"", ""patch"": ""@@ -39,8 +39,6 @@\n\n #include \""sysdeps/mutex.h\""\n #include \""transport.h\""\n \n-static void local_socket_close(asocket* s);\n-\n static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();\n static unsigned local_socket_next_id = 1;\n \n@@ -118,7 +116,7 @@\n\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n-            local_socket_close(s);\n+            s->close(s);\n             goto restart;\n         }\n     }\n""}","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
",C,"            s->close(s);
","            local_socket_close(s);
",,"@@ -39,8 +39,6 @@

 #include ""sysdeps/mutex.h""
 #include ""transport.h""
 
-static void local_socket_close(asocket* s);
-
 static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
@@ -118,7 +116,7 @@

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close(s);
+            s->close(s);
             goto restart;
         }
     }
",Android,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d%5E/,1,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
//flaw_line_below:
            local_socket_close(s);
//fix_flaw_line_below:
//            s->close(s);
             goto restart;
         }
     }
}
",187427,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","The provided code defines a function `close_all_sockets` that iterates through a linked list of sockets, represented by `local_socket_list`, to close all sockets associated with a specified transport object `t`. It employs a recursive mutex lock to ensure thread safety while modifying the socket list. The function checks each socket to see if it is directly linked to the transport or if its peer socket is linked to it. If a matching socket is found, it calls `local_socket_close` to close it and restarts the iteration to handle any changes in the list due to the closure, ensuring all relevant sockets are processed.","The code defines a function that closes all network connections associated with a specific transport object. It uses a locking mechanism to ensure that the operation is thread-safe while traversing a list of connections. The function iterates through the list, checking each connection to determine if it is linked to the specified transport or its counterpart. When a matching connection is found, it is closed, and the iteration restarts to account for any changes in the list due to the closure. This process continues until all relevant connections have been successfully closed.","The vulnerability in the original code arises from the use of `local_socket_close(s)`, which modifies the linked list of sockets while it is being iterated over. This can lead to undefined behavior or crashes, as the iterator may reference invalid memory after a socket is closed. The fixed code addresses this issue by replacing `local_socket_close(s)` with `s->close(s)`, which presumably handles the closure of the socket more safely, ensuring that the list's integrity is maintained during iteration. This change mitigates the risk of accessing invalid pointers and enhances the overall stability of the function.","The vulnerability in the original code stems from modifying a data structure while iterating over it, which can lead to accessing invalid memory or causing crashes. When a connection is closed, the underlying list is altered, potentially invalidating the current iterator state. The fixed code addresses this issue by implementing a safer closure method that ensures the integrity of the data structure during iteration. This change allows for the closure of connections without disrupting the traversal process, thereby preventing undefined behavior and enhancing the stability and reliability of the function.","The vulnerability was fixed by replacing the call to `local_socket_close(s)` with `s->close(s)`. This change ensures that the closure of the socket is handled in a way that maintains the integrity of the linked list during iteration. By using `s->close(s)`, the function likely encapsulates the closing logic in a manner that prevents modifications to the list from affecting the current iteration state. This approach allows the loop to safely continue processing the remaining sockets without encountering invalid memory references, thereby enhancing the overall stability and reliability of the function.","The vulnerability was fixed by changing the method used to close connections, ensuring that the closure process does not disrupt the iteration over the data structure. The new approach encapsulates the closing logic in a way that maintains the integrity of the list during traversal, preventing any modifications from invalidating the current iterator state. This allows the function to safely continue processing without encountering issues related to accessing invalid memory. As a result, the overall stability and reliability of the operation are significantly improved, reducing the risk of crashes or undefined behavior.","CWE-664, CWE-401, CWE-672, CWE-665, CWE-415, CWE-825, CWE-666, CWE-675, CWE-416, CWE-476",N,-1
79,79,187796,187796,,Remote,Not required,Complete,CVE-2016-2494,https://www.cvedetails.com/cve/CVE-2016-2494/,CWE-264,Medium,Complete,Complete,,2016-06-12,9.3,"Off-by-one error in sdcard/sdcard.c in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28085658.",2016-11-29,+Priv ,1,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d,864e2e22fcd0cba3f5e67680ccabd0302dfda45d,"Fix overflow in path building

An incorrect size was causing an unsigned value
to wrap, causing it to write past the end of
the buffer.

Bug: 28085658
Change-Id: Ie9625c729cca024d514ba2880ff97209d435a165
",1,sdcard/sdcard.c,"{""filename"": ""sdcard/sdcard.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/sdcard/sdcard.c"", ""patch"": ""@@ -337,7 +337,7 @@\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\n         if (pathlen < 0) {\n             return -1;\n         }\n""}","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",C,"        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
","        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
",,"@@ -337,7 +337,7 @@

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
",Android,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d%5E/,1,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
//flaw_line_below:
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
//fix_flaw_line_below:
//        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",187796,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","The `get_node_path_locked` function constructs the path of a given node in a tree-like structure, storing the result in a provided buffer. It first determines the node's name by checking its `graft_path`, `actual_name`, or default `name`, and calculates the length of this name. If the buffer is insufficient to hold the name, it returns -1. If the node has a parent and no graft path, it recursively retrieves the parent's path, appending a '/' before adding the current node's name to the buffer. Finally, it returns the total length of the constructed path, including the null terminator.","The provided code defines a function that constructs the path of a node within a hierarchical structure and stores it in a specified buffer. It first determines the appropriate name for the node based on available attributes. If the buffer is too small to accommodate the name, the function returns an error. If the node has a parent and lacks a specific path, the function recursively retrieves the parent's path, adding a separator before appending the current node's name. Ultimately, the function returns the total length of the constructed path, including a null terminator to signify the end of the string.","The vulnerability in the original code arises from the potential for a buffer overflow when constructing the node path. Specifically, the function calculates the remaining buffer size using `bufsize - namelen - 2`, which does not account for the null terminator, leading to insufficient space for the complete string. This could result in writing beyond the allocated buffer, causing memory corruption. The fixed code addresses this issue by changing the calculation to `bufsize - namelen - 1`, ensuring that there is enough space for the null terminator, thus preventing the overflow and enhancing the overall safety of the function.","The vulnerability in the original code stems from a potential buffer overflow due to incorrect calculations of the available space in the buffer when constructing a string. Specifically, the code failed to account for the null terminator, which could lead to writing beyond the allocated memory, resulting in memory corruption or crashes. The fixed code rectifies this issue by adjusting the calculation to ensure that sufficient space is reserved for the null terminator. This change enhances the safety of the function by preventing overflow and ensuring that the constructed string fits within the provided buffer.","The vulnerability was fixed by modifying the calculation of the available buffer size when calling the function recursively. In the original code, the expression `bufsize - namelen - 2` was used, which did not account for the null terminator, potentially leading to a buffer overflow. The revised code changes this to `bufsize - namelen - 1`, ensuring that there is enough space for the null terminator when constructing the path. This adjustment prevents writing beyond the allocated buffer, thereby enhancing the function's safety and stability when handling node paths.","The vulnerability was addressed by correcting the calculation of the available space in the buffer during the recursive call to construct the node path. The original implementation failed to allocate sufficient space for the null terminator, which could lead to writing beyond the buffer's limits and causing memory corruption. The fix involved adjusting the calculation to ensure that enough space is reserved for the null terminator, thereby preventing any overflow. This change enhances the overall safety of the function by ensuring that the constructed string fits properly within the provided buffer, thus mitigating the risk of memory-related issues.","CWE-119, CWE-120, CWE-131, CWE-122, CWE-787, CWE-788, CWE-125, CWE-170, CWE-193, CWE-121",N,-1
80,80,187905,187905,,Remote,Not required,Complete,CVE-2016-2449,https://www.cvedetails.com/cve/CVE-2016-2449/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"services/camera/libcameraservice/device3/Camera3Device.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate template IDs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27568958.",2016-05-10,+Priv ,7,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353,b04aee833c5cfb6b31b8558350feb14bb1a0f353,"Camera3Device: Validate template ID

Validate template ID before creating a default request.

Bug: 26866110
Bug: 27568958
Change-Id: Ifda457024f1d5c2b1382f189c1a8d5fda852d30d
",0,services/camera/libcameraservice/device3/Camera3Device.cpp,"{""filename"": ""services/camera/libcameraservice/device3/Camera3Device.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/services/camera/libcameraservice/device3/Camera3Device.cpp"", ""patch"": ""@@ -43,6 +43,7 @@\n\n #include <utils/Trace.h>\n #include <utils/Timers.h>\n \n+#include \""CameraService.h\""\n #include \""utils/CameraTraces.h\""\n #include \""mediautils/SchedulingPolicyService.h\""\n #include \""device3/Camera3Device.h\""\n@@ -1115,6 +1116,13 @@\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\""%s: for template %d\"", __FUNCTION__, templateId);\n+\n+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {\n+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, \""26866110\"",\n+                IPCThreadState::self()->getCallingUid(), NULL, 0);\n+        return BAD_VALUE;\n+    }\n+\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n""}","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",C,"
    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

",,,"@@ -43,6 +43,7 @@

 #include <utils/Trace.h>
 #include <utils/Timers.h>
 
+#include ""CameraService.h""
 #include ""utils/CameraTraces.h""
 #include ""mediautils/SchedulingPolicyService.h""
 #include ""device3/Camera3Device.h""
@@ -1115,6 +1116,13 @@

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
+
+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
+                IPCThreadState::self()->getCallingUid(), NULL, 0);
+        return BAD_VALUE;
+    }
+
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353%5E/,1,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
//fix_flaw_line_below:
//                IPCThreadState::self()->getCallingUid(), NULL, 0);
//fix_flaw_line_below:
//        return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 // OK
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",187905,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","The `createDefaultRequest` function in the `Camera3Device` class generates a default camera request based on a specified template ID. It first locks the necessary mutexes to ensure thread safety and checks the device's status, returning an error if the device is in an invalid state. If a cached request for the given template ID exists, it retrieves and returns it. If not, it calls a HAL (Hardware Abstraction Layer) function to construct a new default request. If the template is unsupported, it logs an informational message and returns an error; otherwise, it caches the new request and returns success.","The provided code defines a function that creates a default request for a camera based on a specified template. It begins by ensuring thread safety and checking the current status of the camera device, returning an error if the device is in an invalid state. If a request for the specified template is already cached, it retrieves and returns that cached request. If not, it attempts to construct a new default request using a hardware interface. If the template is unsupported, it logs a message and returns an error; otherwise, it caches the new request and indicates success.","The vulnerability in the original code stemmed from a lack of validation for the `templateId` parameter, which could allow an attacker to pass an invalid or out-of-bounds value, potentially leading to memory access violations or undefined behavior. The fixed code addresses this issue by adding a check to ensure that `templateId` is within a valid range, specifically greater than zero and less than `CAMERA3_TEMPLATE_COUNT`. If the check fails, it logs an error and returns a `BAD_VALUE`, thereby preventing the function from proceeding with an invalid request and enhancing overall security.","The vulnerability in the original code arose from the absence of validation for the input parameter, allowing an attacker to provide an invalid value that could lead to memory access issues or crashes. This lack of checks could result in the function attempting to access or manipulate data outside of its intended bounds, creating potential security risks. The fixed code rectifies this by implementing a validation step that ensures the input falls within an acceptable range. If the input fails this validation, the function logs an error and terminates early, thereby preventing further execution with invalid data and enhancing the system's security.","The vulnerability was fixed by adding a validation check for the `templateId` parameter at the beginning of the function. The code now verifies that `templateId` is greater than zero and less than `CAMERA3_TEMPLATE_COUNT`. If this condition is not met, the function logs an error using `android_errorWriteWithInfoLog` and returns `BAD_VALUE`, preventing further execution with an invalid input. This change ensures that only valid template IDs are processed, thereby mitigating the risk of memory access violations or undefined behavior that could arise from invalid input values.","The vulnerability was addressed by introducing a validation step for the input parameter at the start of the function. This new check ensures that the input falls within a specified valid range, effectively preventing any out-of-bounds values from being processed. If the input fails this validation, the function logs an error and terminates early, avoiding any further execution that could lead to memory access issues or crashes. This enhancement significantly improves the robustness of the code by ensuring that only appropriate and safe values are handled, thereby reducing potential security risks.","CWE-129, CWE-789, CWE-119, CWE-120, CWE-125, CWE-126, CWE-787, CWE-823, CWE-824, CWE-20",N,-1
81,81,187906,187906,,Remote,Not required,Complete,CVE-2016-2448,https://www.cvedetails.com/cve/CVE-2016-2448/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not properly validate entry data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27533704.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,"NuPlayerStreamListener: NULL and bounds check before memcpy

Bug: 27533704
Change-Id: I992a7709b92b1cbc3114c97bec48a3fc5b22ba6e
",1,media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp,"{""filename"": ""media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""patch"": ""@@ -144,8 +144,17 @@\n\n         copy = size;\n     }\n \n+    if (entry->mIndex >= mBuffers.size()) {\n+        return ERROR_MALFORMED;\n+    }\n+\n+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);\n+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {\n+        return ERROR_MALFORMED;\n+    }\n+\n     memcpy(data,\n-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n+           (const uint8_t *)mem->pointer()\n             + entry->mOffset,\n            copy);\n \n""}","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",C,"    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

           (const uint8_t *)mem->pointer()
","           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
",,"@@ -144,8 +144,17 @@

         copy = size;
     }
 
+    if (entry->mIndex >= mBuffers.size()) {
+        return ERROR_MALFORMED;
+    }
+
+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
+        return ERROR_MALFORMED;
+    }
+
     memcpy(data,
-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
+           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b%5E/,1,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
//fix_flaw_line_below:
//    if (entry->mIndex >= mBuffers.size()) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
//fix_flaw_line_below:
//    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     memcpy(data,
//flaw_line_below:
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
//fix_flaw_line_below:
//           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",187906,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","The provided code defines a method `read` within the `NuPlayerStreamListener` class, which handles reading data from a queue of media buffers. It first checks if the requested size is greater than zero and clears any extra messages. If the end-of-stream (EOS) flag is set, it returns zero, indicating no more data is available. If the queue is empty, it sets a notification flag and returns an error. The method processes commands like EOS and DISCONTINUITY, updating the queue accordingly. Finally, it copies data from the buffer to the provided memory location, adjusting offsets and sizes, and returns the number of bytes copied.","The code implements a method that reads data from a media buffer queue, managing the flow of data for a media player. It begins by ensuring that the requested size is valid and checks for the end of the stream condition. If the queue is empty, it sets a notification flag and indicates that no data can be read. The method processes specific commands that may alter the state of the queue. It then copies available data into a provided memory location, updates the offsets and sizes accordingly, and returns the number of bytes successfully read, ensuring proper handling of buffer states.","The vulnerability in the original code arises from insufficient validation of the buffer index and size before accessing memory, which could lead to out-of-bounds reads or writes. Specifically, the code did not check if `entry->mIndex` was within the bounds of `mBuffers`, nor did it verify that the memory size was adequate for the requested copy operation. The fixed code addresses this by adding checks to ensure that `entry->mIndex` is valid, and that the memory size is sufficient to accommodate the requested data, returning an error if any of these conditions are not met, thus preventing potential memory corruption or crashes.","The vulnerability in the original code stemmed from inadequate checks on buffer indices and sizes, which could lead to accessing memory outside of allocated bounds, resulting in potential crashes or data corruption. This issue arose when the code attempted to read data without confirming that the index was valid and that the buffer had sufficient size for the requested operation. The fixed code rectified this by implementing additional validation steps to ensure that the index was within acceptable limits and that the memory was large enough to accommodate the data being copied, thereby enhancing overall safety and stability.","The vulnerability was fixed by adding critical validation checks before accessing memory. Specifically, the code now verifies that `entry->mIndex` is less than the size of `mBuffers`, ensuring it points to a valid buffer. Additionally, it checks that the memory at the specified index is not null and that its size is sufficient to accommodate the requested copy size. These checks prevent out-of-bounds access and ensure that the offset does not exceed the allocated memory, thereby safeguarding against potential crashes or memory corruption during the data reading process.","The vulnerability was addressed by implementing additional validation checks to ensure safe memory access. The updated code now verifies that the index used to access the buffer is within valid bounds, preventing out-of-bounds access. It also checks that the memory associated with the index is not null and that it has sufficient size to accommodate the requested data copy. These enhancements ensure that any read or write operations are performed only on valid memory regions, significantly reducing the risk of crashes or data corruption due to improper memory handling.","CWE-125, CWE-119, CWE-787, CWE-788, CWE-823, CWE-824, CWE-789, CWE-120, CWE-126, CWE-122",N,-1
82,82,187907,187907,,Remote,Not required,Complete,CVE-2016-2440,https://www.cvedetails.com/cve/CVE-2016-2440/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libs/binder/IPCThreadState.cpp in Binder in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 mishandles object references, which allows attackers to gain privileges via a crafted application, aka internal bug 27252896.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a,a59b827869a2ea04022dd225007f29af8d61837a,"Fix issue #27252896: Security Vulnerability -- weak binder

Sending transaction to freed BBinder through weak handle
can cause use of a (mostly) freed object.  We need to try to
safely promote to a strong reference first.

Change-Id: Ic9c6940fa824980472e94ed2dfeca52a6b0fd342
(cherry picked from commit c11146106f94e07016e8e26e4f8628f9a0c73199)
",2,libs/binder/IPCThreadState.cpp,"{""filename"": ""libs/binder/IPCThreadState.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/libs/binder/IPCThreadState.cpp"", ""patch"": ""@@ -1083,8 +1083,16 @@\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n-                sp<BBinder> b((BBinder*)tr.cookie);\n-                error = b->transact(tr.code, buffer, &reply, tr.flags);\n+                // We only have a weak reference on the target object, so we must first try to\n+                // safely acquire a strong reference before doing anything else with it.\n+                if (reinterpret_cast<RefBase::weakref_type*>(\n+                        tr.target.ptr)->attemptIncStrong(this)) {\n+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,\n+                            &reply, tr.flags);\n+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);\n+                } else {\n+                    error = UNKNOWN_TRANSACTION;\n+                }\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n""}","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",C,"                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
","                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
",,"@@ -1083,8 +1083,16 @@

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
-                sp<BBinder> b((BBinder*)tr.cookie);
-                error = b->transact(tr.code, buffer, &reply, tr.flags);
+                // We only have a weak reference on the target object, so we must first try to
+                // safely acquire a strong reference before doing anything else with it.
+                if (reinterpret_cast<RefBase::weakref_type*>(
+                        tr.target.ptr)->attemptIncStrong(this)) {
+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
+                            &reply, tr.flags);
+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
+                } else {
+                    error = UNKNOWN_TRANSACTION;
+                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
",Android,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a%5E/,1,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 // NOTE: This assertion is not valid, because the object may no
 // longer exist (thus the (BBinder*)cast above resulting in a different
 // memory address).
 //ALOG_ASSERT(refs->refBase() == obj,
 //           ""BR_DECREFS: object %p does not match cookie %p (expected %p)"",
 //           refs, obj, refs->refBase());
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
 // We have inherited a reduced priority from the caller, but do not
 // want to run in that state in this process.  The driver set our
 // priority already (though not our scheduling class), so bounce
 // it back to the default before invoking the transaction.
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
 // We want to use the inherited priority from the caller.
 // Ensure this thread is in the background scheduling class,
 // since the driver won't modify scheduling classes for us.
 // The scheduling group is reset to default by the caller
 // once this method returns after the transaction is complete.
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }

 //ALOGI("">>>> TRANSACT from pid %d uid %d\n"", mCallingPid, mCallingUid);

 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
//flaw_line_below:
                sp<BBinder> b((BBinder*)tr.cookie);
//flaw_line_below:
                error = b->transact(tr.code, buffer, &reply, tr.flags);
//fix_flaw_line_below:
//                // We only have a weak reference on the target object, so we must first try to
//fix_flaw_line_below:
//                // safely acquire a strong reference before doing anything else with it.
//fix_flaw_line_below:
//                if (reinterpret_cast<RefBase::weakref_type*>(
//fix_flaw_line_below:
//                        tr.target.ptr)->attemptIncStrong(this)) {
//fix_flaw_line_below:
//                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
//fix_flaw_line_below:
//                            &reply, tr.flags);
//fix_flaw_line_below:
//                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    error = UNKNOWN_TRANSACTION;
//fix_flaw_line_below:
//                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 //ALOGI(""<<<< TRANSACT from pid %d restore pid %d uid %d\n"",
 //     mCallingPid, origPid, origUid);
 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",187907,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","The `IPCThreadState::executeCommand` function processes various inter-process communication (IPC) commands received from a Binder driver, handling commands such as error reporting, object reference management (acquire, release, increment, decrement), and transaction processing. It reads command-specific data from an input buffer, performs necessary actions like adjusting reference counts or executing transactions, and writes responses to an output buffer. The function also includes logging for debugging purposes and ensures that the integrity of object references is maintained through assertions. Finally, it returns a status indicating the success or failure of the command execution.","The provided code implements a command execution mechanism for inter-process communication, handling various commands related to object reference management and transaction processing. It reads commands from an input buffer, performs actions such as acquiring or releasing object references, and processes transactions while ensuring the integrity of object references. The code also includes logging for debugging purposes and manages the response to the sender based on the command type. Finally, it returns a status indicating the outcome of the command execution, ensuring proper error handling throughout the process.","The vulnerability in the original code stemmed from the lack of proper reference management when handling transactions, particularly when dealing with weak references. In the fixed code, the addition of a check using `attemptIncStrong` ensures that a strong reference is safely acquired before any operations are performed on the target object. This prevents potential use-after-free errors, where the object could be deleted while still being accessed, leading to undefined behavior or crashes. By enforcing this check, the code enhances its robustness against memory-related vulnerabilities during inter-process communication.","The vulnerability in the original code arose from inadequate management of object references during inter-process communication, particularly when weak references were used without ensuring a strong reference was acquired first. This oversight could lead to scenarios where an object was accessed after it had been deleted, resulting in potential crashes or undefined behavior. The fixed code addresses this issue by implementing a check to safely acquire a strong reference before performing any operations on the object. This enhancement ensures that the object remains valid throughout its usage, thereby mitigating risks associated with memory management errors.","The vulnerability was fixed by introducing a check using the `attemptIncStrong` function to ensure that a strong reference is safely acquired before any operations are performed on the target object. In the updated code, when processing a transaction, the code first verifies if the weak reference can be promoted to a strong reference. If successful, it proceeds with the transaction using the strong reference; otherwise, it returns an error. This change prevents potential use-after-free issues by ensuring that the object remains valid during its usage, thereby enhancing the overall safety and stability of the inter-process communication mechanism.","The vulnerability was fixed by implementing a mechanism to ensure that a strong reference to the object is acquired before any operations are performed. This involves checking whether the weak reference can be safely promoted to a strong reference, which prevents access to an object that may have been deleted. If the promotion is successful, the code proceeds with the intended operations; if not, it returns an error. This enhancement effectively mitigates the risk of memory-related issues, ensuring that the object remains valid throughout its usage and improving the overall robustness of the inter-process communication system.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-476, CWE-822, CWE-367, CWE-666, CWE-404, CWE-426",N,-1
83,83,187909,187909,,Remote,Not required,Complete,CVE-2016-2430,https://www.cvedetails.com/cve/CVE-2016-2430/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libbacktrace/Backtrace.cpp in debuggerd in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows attackers to gain privileges via an application containing a crafted symbol name, aka internal bug 27299236.",2016-05-10,+Priv ,0,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0,ad54cfed4516292654c997910839153264ae00a0,"Don't demangle symbol names.

Bug: http://b/27299236
Change-Id: I26ef47f80d4d6048a316ba51e83365ff65d70439
",12,libbacktrace/Backtrace.cpp,"{""filename"": ""libbacktrace/Backtrace.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/libbacktrace/Backtrace.cpp"", ""patch"": ""@@ -54,24 +54,8 @@\n\n   }\n }\n \n-extern \""C\"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,\n-                                int* status);\n-\n std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n-  if (!func_name.empty()) {\n-#if defined(__APPLE__)\n-    // Mac OS' __cxa_demangle demangles \""f\"" as \""float\""; last tested on 10.7.\n-    if (func_name[0] != '_') {\n-      return func_name;\n-    }\n-#endif\n-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n-    if (name) {\n-      func_name = name;\n-      free(name);\n-    }\n-  }\n   return func_name;\n }\n \n""}"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
",C,,"  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
",,"@@ -54,24 +54,8 @@

   }
 }
 
-extern ""C"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,
-                                int* status);
-
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
-  if (!func_name.empty()) {
-#if defined(__APPLE__)
-    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
-    if (func_name[0] != '_') {
-      return func_name;
-    }
-#endif
-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
-    if (name) {
-      func_name = name;
-      free(name);
-    }
-  }
   return func_name;
 }
 
",Android,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0%5E/,1," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
//flaw_line_below:
  if (!func_name.empty()) {
//flaw_line_below:
#if defined(__APPLE__)
//flaw_line_below:
    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
//flaw_line_below:
    if (func_name[0] != '_') {
//flaw_line_below:
      return func_name;
//flaw_line_below:
    }
//flaw_line_below:
#endif
//flaw_line_below:
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
//flaw_line_below:
    if (name) {
//flaw_line_below:
      func_name = name;
//flaw_line_below:
      free(name);
//flaw_line_below:
    }
//flaw_line_below:
  }
   return func_name;
 }
",187909," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
","The provided code defines a method `GetFunctionName` within the `Backtrace` class, which retrieves the name of a function based on a given program counter (`pc`) and optionally populates an offset. It first calls `GetFunctionNameRaw` to obtain the raw function name. If the name is not empty and the platform is Apple, it checks if the name starts with an underscore; if not, it returns the name directly. Otherwise, it demangles the name using `__cxa_demangle`, updates the function name if demangling is successful, and finally returns the processed function name.","The code defines a method that retrieves the name of a function based on a specific memory address and can also provide an offset. It first attempts to obtain the raw function name from the address. If the name is valid and the operating system is a specific type, it checks for a particular character at the start of the name; if absent, it returns the name as is. If the character is present, the method demangles the name to convert it into a more readable format, updates the name if successful, and ultimately returns the final function name.","The vulnerability in the original code stemmed from the potential misuse of the `__cxa_demangle` function, which could lead to memory management issues, such as memory leaks or dangling pointers, if the demangled name was not properly handled. Specifically, the original code allocated memory for the demangled name but did not ensure it was always freed, creating a risk of memory leaks. In the fixed code, the logic for demangling and memory management was removed entirely, simplifying the function to directly return the raw function name obtained from `GetFunctionNameRaw`, thereby eliminating the associated vulnerabilities.","The vulnerability in the original code arose from improper memory management related to the demangling process, which could lead to memory leaks if allocated memory was not correctly freed. The code attempted to convert a raw function name into a more readable format, but it did not consistently handle the memory allocated for this conversion, risking unintentional memory consumption. In the revised code, this complexity was removed entirely by eliminating the demangling step, thereby simplifying the function to return the raw name directly, which effectively mitigated the risk of memory-related vulnerabilities.","The vulnerability was fixed by removing the demangling logic that involved the `__cxa_demangle` function and its associated memory management. In the original code, after obtaining the raw function name with `GetFunctionNameRaw`, the code attempted to demangle it and allocated memory for the demangled name, which was not always freed, leading to potential memory leaks. In the revised code, the function was simplified to directly return the result from `GetFunctionNameRaw`, eliminating the need for demangling and ensuring that no additional memory was allocated or left unfreed, thus enhancing overall memory safety.","The vulnerability was fixed by eliminating the complex memory management associated with converting a raw function name into a more readable format. The original implementation involved allocating memory for the demangled name, which posed risks of memory leaks if not properly handled. In the revised version, this unnecessary step was removed, simplifying the function to return the raw name directly. This change not only reduced the potential for memory-related issues but also streamlined the code, making it safer and easier to maintain by ensuring that no additional memory was allocated or left unfreed.","CWE-401, CWE-119, CWE-789, CWE-763, CWE-476, CWE-590, CWE-415, CWE-416, CWE-399, CWE-242",N,-1
84,84,187912,187912,,Remote,Not required,Complete,CVE-2016-2420,https://www.cvedetails.com/cve/CVE-2016-2420/,CWE-264,Medium,Complete,Complete,,2016-04-17,9.3,"rootdir/init.rc in Android 4.x before 4.4.4 does not ensure that the /data/tombstones directory exists for the Debuggerd component, which allows attackers to gain privileges via a crafted application, aka internal bug 26403620.",2016-04-22,+Priv ,1,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c,81df1cc77722000f8d0025c1ab00ced123aa573c,"Don't create tombstone directory.

Partial backport of cf79748.

Bug: http://b/26403620
Change-Id: Ib877ab6cfab6aef079830c5a50ba81141ead35ee
",12,debuggerd/tombstone.cpp,"{""filename"": ""debuggerd/tombstone.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/debuggerd/tombstone.cpp"", ""patch"": ""@@ -743,21 +743,8 @@\n\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n \n-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n-    _LOG(&log, logtype::ERROR, \""failed to create %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n-    _LOG(&log, logtype::ERROR, \""failed to change ownership of %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n   int fd = -1;\n-  char* path = NULL;\n-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n-    path = find_and_open_tombstone(&fd);\n-  } else {\n-    _LOG(&log, logtype::ERROR, \""Failed to restore security context, not writing tombstone.\\n\"");\n-  }\n+  char* path = find_and_open_tombstone(&fd);\n \n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \""Skipping tombstone write, nothing to do.\\n\"");\n""}","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
",C,"  char* path = find_and_open_tombstone(&fd);
","  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
",,"@@ -743,21 +743,8 @@

   log.current_tid = tid;
   log.crashed_tid = tid;
 
-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
-    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
-    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
   int fd = -1;
-  char* path = NULL;
-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
-    path = find_and_open_tombstone(&fd);
-  } else {
-    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
-  }
+  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
",Android,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c%5E/,1,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
//flaw_line_below:
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

   int fd = -1;
//flaw_line_below:
  char* path = NULL;
//flaw_line_below:
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
//flaw_line_below:
    path = find_and_open_tombstone(&fd);
//flaw_line_below:
  } else {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
//flaw_line_below:
  }
//fix_flaw_line_below:
//  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 // Preserve amfd since it can be modified through the calls below without
 // being closed.
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

 // Either of these file descriptors can be -1, any error is ignored.
  close(amfd);
  close(fd);

 return path;
}
",187912,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","The `engrave_tombstone` function is designed to create and manage a tombstone file for logging crash information related to a specific thread and process. It first attempts to create a directory for the tombstone and change its ownership, logging errors if these operations fail. If the security context is successfully restored, it opens a tombstone file; otherwise, it logs an error and exits. If a valid file descriptor is obtained, it connects to the activity manager and calls `dump_crash` to log the crash details. Finally, it logs the path of the written tombstone, closes the file descriptors, and returns the path.","The code is responsible for creating a log entry for a crash event associated with a specific thread and process. It attempts to establish a directory for storing crash logs and modifies its ownership, while logging any errors encountered during these operations. If the security context is successfully restored, it opens a log file; if not, it logs an error and terminates the process. Upon successfully obtaining a file descriptor, it connects to a management service to record the crash details. Finally, it logs the location of the created log file, closes the necessary connections, and returns the file path.","The vulnerability in the original code stemmed from the lack of proper checks after attempting to create a directory for the tombstone, which could lead to a situation where the code proceeded to write a tombstone without ensuring that the necessary file descriptor was valid. Specifically, the original code attempted to open a tombstone file only after checking the security context, potentially allowing for a null or invalid file descriptor to be used later. The fixed code addresses this by moving the file descriptor check immediately after attempting to open the tombstone, ensuring that the logging process only continues if a valid file descriptor is obtained.","The vulnerability in the original code arose from inadequate validation of the file descriptor after attempting to create a directory and open a log file, which could lead to attempts to write to an invalid or null file descriptor. This oversight risked causing undefined behavior or crashes during execution. The fixed code rectifies this issue by ensuring that the validity of the file descriptor is checked immediately after the log file is opened. This change guarantees that the logging process only proceeds if a valid file descriptor is confirmed, thereby enhancing the robustness and reliability of the code.","The vulnerability was fixed by restructuring the order of operations related to file descriptor validation. In the original code, the check for a valid file descriptor occurred after attempting to write the tombstone, which could lead to errors if the file descriptor was invalid. In the revised code, the check for the file descriptor is performed immediately after calling `find_and_open_tombstone`, ensuring that the logging process only continues if the file descriptor is valid. This change prevents any attempts to write to an invalid file descriptor, thereby enhancing the stability and reliability of the logging functionality.","The vulnerability was fixed by reorganizing the code to ensure that the validity of the file descriptor is checked immediately after attempting to open the log file. In the original version, the code could proceed to write logs without confirming that the file descriptor was valid, which posed a risk of undefined behavior. The revised code introduces a conditional check right after the file opening attempt, allowing the process to only continue if the file descriptor is confirmed to be valid. This adjustment effectively prevents any operations on an invalid file descriptor, thereby enhancing the overall stability and reliability of the logging mechanism.","CWE-404,CWE-685,CWE-672,CWE-252,CWE-459,CWE-762,CWE-910,CWE-686,CWE-248,CWE-415",N,-1
85,85,187913,187913,,Remote,Not required,Complete,CVE-2016-2419,https://www.cvedetails.com/cve/CVE-2016-2419/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IDrm.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize a certain key-request data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26323455.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34,5a856f2092f7086aa0fea9ae06b9255befcdcd34,"Fix info leak vulnerability of IDrm

bug: 26323455
Change-Id: I25bb30d3666ab38d5150496375ed2f55ecb23ba8
",1,media/libmedia/IDrm.cpp,"{""filename"": ""media/libmedia/IDrm.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/media/libmedia/IDrm.cpp"", ""patch"": ""@@ -658,7 +658,7 @@\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n-            DrmPlugin::KeyRequestType keyRequestType;\n+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n""}","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
","            DrmPlugin::KeyRequestType keyRequestType;
",,"@@ -658,7 +658,7 @@

 
             Vector<uint8_t> request;
             String8 defaultUrl;
-            DrmPlugin::KeyRequestType keyRequestType;
+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
",Android,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34%5E/,1,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
//flaw_line_below:
            DrmPlugin::KeyRequestType keyRequestType;
//fix_flaw_line_below:
//            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187913,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The provided code defines the `onTransact` method for the `BnDrm` class, which handles various transactions related to Digital Rights Management (DRM) operations. It processes different request codes, such as initializing checks, managing plugins, opening and closing sessions, and handling key requests and responses. Each case reads input data from a `Parcel`, performs the corresponding DRM operation (like encryption, decryption, signing, or verifying), and writes the results back to a reply `Parcel`. The method ensures proper interface checks and returns appropriate status codes, facilitating communication between the client and the DRM service.","The code implements a method that manages various transactions related to Digital Rights Management operations. It processes different request types, handling tasks such as initializing checks, managing plugins, and opening or closing sessions. The method reads input data, executes the corresponding DRM functionality, and writes the results back to a response object. It ensures that proper interface checks are performed and returns appropriate status codes, facilitating effective communication between the client and the DRM service. This structure allows for a wide range of DRM-related functionalities to be accessed and managed seamlessly.","The vulnerability in the original code stemmed from insufficient validation of input data, particularly in the handling of session IDs and other vectors, which could lead to buffer overflows or unauthorized access to sensitive operations. For instance, the lack of checks when reading vectors could allow an attacker to manipulate the input, potentially causing memory corruption or executing unintended commands. The fixed code addresses this by ensuring that all input data is properly validated and that the sizes of read vectors are checked, thereby enhancing the security of the DRM operations and preventing exploitation through malformed input.","The vulnerability in the original code was primarily due to inadequate validation of input data, which could lead to buffer overflows and unauthorized access to sensitive operations. This lack of checks allowed attackers to manipulate input, potentially causing memory corruption or executing unintended commands. The fixed code addresses this issue by implementing proper validation mechanisms to ensure that all input data is checked for size and integrity before processing. This enhancement significantly improves the security of the operations by preventing exploitation through malformed or malicious input, thereby safeguarding the system against potential attacks.","The vulnerability was fixed by incorporating rigorous input validation and ensuring that all data read from the input source is properly checked before use. For instance, the code now utilizes functions like `readVector` to safely read session IDs and other vectors, ensuring that the sizes are appropriate and preventing buffer overflows. Additionally, the introduction of checks for the integrity of the data being processed, such as validating the size of the `uuid` array and ensuring that the `CHECK_INTERFACE` macro is consistently applied, enhances the overall security of the operations, mitigating the risk of exploitation through malformed input.","The vulnerability was fixed by implementing comprehensive input validation to ensure that all data read from external sources is checked for size and integrity before processing. This involved adding safeguards to verify that the input data conforms to expected formats and lengths, thereby preventing potential buffer overflows and unauthorized access. Additionally, the code was modified to consistently apply interface checks, ensuring that only valid and authorized requests are processed. These enhancements collectively strengthen the security of the operations, significantly reducing the risk of exploitation through malformed or malicious input.","CWE-20, CWE-119, CWE-125, CWE-787, CWE-131, CWE-789, CWE-130, CWE-74, CWE-78, CWE-120",N,-1
86,86,187915,187915,,Remote,Not required,Complete,CVE-2016-2417,https://www.cvedetails.com/cve/CVE-2016-2417/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IOMX.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a parameter data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26914474.",2017-09-07,Bypass +Info ,30,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84,1171e7c047bf79e7c93342bb6a812c9edd86aa84,"Clear allocation to avoid info leak

Bug: 26914474
Change-Id: Ie1a86e86d78058d041149fe599a4996e7f8185cf
",24,media/libmedia/IOMX.cpp,"{""filename"": ""media/libmedia/IOMX.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/media/libmedia/IOMX.cpp"", ""patch"": ""@@ -618,34 +618,39 @@\n\n \n             size_t size = data.readInt64();\n \n-            void *params = malloc(size);\n-            data.read(params, size);\n+            status_t err = NO_MEMORY;\n+            void *params = calloc(size, 1);\n+            if (params) {\n+                err = data.read(params, size);\n+                if (err != OK) {\n+                    android_errorWriteLog(0x534e4554, \""26914474\"");\n+                } else {\n+                    switch (code) {\n+                        case GET_PARAMETER:\n+                            err = getParameter(node, index, params, size);\n+                            break;\n+                        case SET_PARAMETER:\n+                            err = setParameter(node, index, params, size);\n+                            break;\n+                        case GET_CONFIG:\n+                            err = getConfig(node, index, params, size);\n+                            break;\n+                        case SET_CONFIG:\n+                            err = setConfig(node, index, params, size);\n+                            break;\n+                        case SET_INTERNAL_OPTION:\n+                        {\n+                            InternalOptionType type =\n+                                (InternalOptionType)data.readInt32();\n \n-            status_t err;\n-            switch (code) {\n-                case GET_PARAMETER:\n-                    err = getParameter(node, index, params, size);\n-                    break;\n-                case SET_PARAMETER:\n-                    err = setParameter(node, index, params, size);\n-                    break;\n-                case GET_CONFIG:\n-                    err = getConfig(node, index, params, size);\n-                    break;\n-                case SET_CONFIG:\n-                    err = setConfig(node, index, params, size);\n-                    break;\n-                case SET_INTERNAL_OPTION:\n-                {\n-                    InternalOptionType type =\n-                        (InternalOptionType)data.readInt32();\n+                            err = setInternalOption(node, index, type, params, size);\n+                            break;\n+                        }\n \n-                    err = setInternalOption(node, index, type, params, size);\n-                    break;\n+                        default:\n+                            TRESPASS();\n+                    }\n                 }\n-\n-                default:\n-                    TRESPASS();\n             }\n \n             reply->writeInt32(err);\n""}","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
                        default:
                            TRESPASS();
                    }
","            void *params = malloc(size);
            data.read(params, size);
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
                    err = setInternalOption(node, index, type, params, size);
                    break;
                default:
                    TRESPASS();
",,"@@ -618,34 +618,39 @@

 
             size_t size = data.readInt64();
 
-            void *params = malloc(size);
-            data.read(params, size);
+            status_t err = NO_MEMORY;
+            void *params = calloc(size, 1);
+            if (params) {
+                err = data.read(params, size);
+                if (err != OK) {
+                    android_errorWriteLog(0x534e4554, ""26914474"");
+                } else {
+                    switch (code) {
+                        case GET_PARAMETER:
+                            err = getParameter(node, index, params, size);
+                            break;
+                        case SET_PARAMETER:
+                            err = setParameter(node, index, params, size);
+                            break;
+                        case GET_CONFIG:
+                            err = getConfig(node, index, params, size);
+                            break;
+                        case SET_CONFIG:
+                            err = setConfig(node, index, params, size);
+                            break;
+                        case SET_INTERNAL_OPTION:
+                        {
+                            InternalOptionType type =
+                                (InternalOptionType)data.readInt32();
 
-            status_t err;
-            switch (code) {
-                case GET_PARAMETER:
-                    err = getParameter(node, index, params, size);
-                    break;
-                case SET_PARAMETER:
-                    err = setParameter(node, index, params, size);
-                    break;
-                case GET_CONFIG:
-                    err = getConfig(node, index, params, size);
-                    break;
-                case SET_CONFIG:
-                    err = setConfig(node, index, params, size);
-                    break;
-                case SET_INTERNAL_OPTION:
-                {
-                    InternalOptionType type =
-                        (InternalOptionType)data.readInt32();
+                            err = setInternalOption(node, index, type, params, size);
+                            break;
+                        }
 
-                    err = setInternalOption(node, index, type, params, size);
-                    break;
+                        default:
+                            TRESPASS();
+                    }
                 }
-
-                default:
-                    TRESPASS();
             }
 
             reply->writeInt32(err);
",Android,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84%5E/,1,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
//flaw_line_below:
            void *params = malloc(size);
//flaw_line_below:
            data.read(params, size);
//fix_flaw_line_below:
//            status_t err = NO_MEMORY;
//fix_flaw_line_below:
//            void *params = calloc(size, 1);
//fix_flaw_line_below:
//            if (params) {
//fix_flaw_line_below:
//                err = data.read(params, size);
//fix_flaw_line_below:
//                if (err != OK) {
//fix_flaw_line_below:
//                    android_errorWriteLog(0x534e4554, ""26914474"");
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    switch (code) {
//fix_flaw_line_below:
//                        case GET_PARAMETER:
//fix_flaw_line_below:
//                            err = getParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_PARAMETER:
//fix_flaw_line_below:
//                            err = setParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case GET_CONFIG:
//fix_flaw_line_below:
//                            err = getConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_CONFIG:
//fix_flaw_line_below:
//                            err = setConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_INTERNAL_OPTION:
//fix_flaw_line_below:
//                        {
//fix_flaw_line_below:
//                            InternalOptionType type =
//fix_flaw_line_below:
//                                (InternalOptionType)data.readInt32();
 
//flaw_line_below:
            status_t err;
//flaw_line_below:
            switch (code) {
//flaw_line_below:
                case GET_PARAMETER:
//flaw_line_below:
                    err = getParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_PARAMETER:
//flaw_line_below:
                    err = setParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case GET_CONFIG:
//flaw_line_below:
                    err = getConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_CONFIG:
//flaw_line_below:
                    err = setConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_INTERNAL_OPTION:
//flaw_line_below:
                {
//flaw_line_below:
                    InternalOptionType type =
//flaw_line_below:
                        (InternalOptionType)data.readInt32();
//fix_flaw_line_below:
//                            err = setInternalOption(node, index, type, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        }
 
//flaw_line_below:
                    err = setInternalOption(node, index, type, params, size);
//flaw_line_below:
                    break;
//fix_flaw_line_below:
//                        default:
//fix_flaw_line_below:
//                            TRESPASS();
//fix_flaw_line_below:
//                    }
                 }
//flaw_line_below:

//flaw_line_below:
                default:
//flaw_line_below:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187915,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The provided code defines the `onTransact` method for the `BnOMX` class, which handles various transactions related to the OpenMAX (OMX) interface. It processes different command codes, such as checking if a node lives locally, listing nodes, allocating and freeing nodes, sending commands, and managing parameters and configurations. Each case reads input data from a `Parcel`, performs the corresponding operation (like allocating buffers or enabling graphic buffers), and writes the result back to the `reply` parcel. The method ensures proper interface checks and memory management, returning appropriate status codes for each operation.","The code implements a method that manages various transactions for an interface related to multimedia processing. It handles commands such as checking node availability, listing components, allocating and freeing resources, and sending commands. The method processes input data, executes the corresponding operations, and returns results, including status codes and additional data when necessary. It ensures proper validation and memory management throughout the process, allowing for configuration adjustments and buffer management. Each command is distinctly processed, enabling efficient interaction with multimedia components while maintaining system integrity and performance.","The vulnerability in the original code stemmed from improper memory allocation and handling, particularly in the section where parameters were read from the input data. The use of `malloc` without checking if the allocation was successful could lead to null pointer dereferences or memory corruption if the size was incorrectly specified. The fixed code addresses this by replacing `malloc` with `calloc`, ensuring that memory is allocated and initialized to zero, and adding checks to confirm successful memory allocation before proceeding with reading data. This change enhances the robustness of the code by preventing potential crashes and undefined behavior.","The vulnerability in the original code arose from inadequate memory management, specifically the lack of checks after memory allocation, which could lead to dereferencing null pointers or accessing uninitialized memory. This could result in crashes or unpredictable behavior if the allocated memory was insufficient or failed. The fixed code addresses this issue by implementing a safer memory allocation method that initializes the allocated memory and includes checks to ensure that the allocation was successful before proceeding with further operations. This enhancement significantly improves the stability and reliability of the code by preventing potential runtime errors.","The vulnerability was fixed by replacing the use of `malloc` with `calloc` for memory allocation, which not only allocates the required memory but also initializes it to zero. This change ensures that any uninitialized memory is not accessed, reducing the risk of undefined behavior. Additionally, the fixed code includes a check to verify if the memory allocation was successful before proceeding to read data into the allocated memory. If the allocation fails, the code handles the error gracefully, preventing potential crashes or memory corruption during operations like reading parameters or configurations.","The vulnerability was addressed by enhancing memory management practices within the code. The original method of memory allocation was replaced with a safer approach that not only allocates the required memory but also initializes it to prevent access to uninitialized data. Furthermore, the updated code includes checks to confirm successful memory allocation before any data operations are performed. This ensures that the program can handle allocation failures gracefully, thereby reducing the risk of crashes or undefined behavior and improving overall stability and reliability during execution.","CWE-789, CWE-401, CWE-119, CWE-476, CWE-908, CWE-665, CWE-131, CWE-457, CWE-415, CWE-763",N,-1
87,87,187916,187916,,Remote,Not required,Complete,CVE-2016-2416,https://www.cvedetails.com/cve/CVE-2016-2416/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"libs/gui/BufferQueueConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for the android.permission.DUMP permission, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via a dump request, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27046057.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,"Add SN logging

Bug 27046057

Change-Id: Iede7c92e59e60795df1ec7768ebafd6b090f1c27
",0,libs/gui/BufferQueueConsumer.cpp,"{""filename"": ""libs/gui/BufferQueueConsumer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/libs/gui/BufferQueueConsumer.cpp"", ""patch"": ""@@ -529,6 +529,7 @@\n\n             \""android.permission.DUMP\""), pid, uid)) {\n         result.appendFormat(\""Permission Denial: can't dump BufferQueueConsumer \""\n                 \""from pid=%d, uid=%d\\n\"", pid, uid);\n+        android_errorWriteWithInfoLog(0x534e4554, \""27046057\"", uid, NULL, 0);\n     } else {\n         mCore->dump(result, prefix);\n     }\n""}","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
",C,"        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
",,,"@@ -529,6 +529,7 @@

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
+        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
",Android,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a%5E/,1,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
",187916,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","The provided code defines a method `dump` within the `BufferQueueConsumer` class, which is responsible for generating a dump of the object's state. It first retrieves the current IPC thread state to obtain the calling process's PID and UID. The method checks if the calling UID is not equal to `AID_SHELL` and whether it has the necessary permission (`android.permission.DUMP`). If permission is denied, it appends an error message to the `result` string indicating the PID and UID of the caller. If permission is granted, it calls the `dump` method on `mCore` to append the object's state to the `result`.","The code defines a method that generates a state dump of an object while enforcing permission checks. It retrieves the current process's identifiers to determine the caller's identity. The method verifies if the caller has the appropriate permissions to access the object's state. If the caller lacks the necessary permissions, an error message is appended to the output, indicating the caller's identifiers. Conversely, if permission is granted, the method proceeds to append the object's state information to the output. This ensures that sensitive information is protected from unauthorized access while allowing legitimate requests to succeed.","The vulnerability in the original code arises from the lack of logging when a permission denial occurs, which could hinder the ability to track unauthorized access attempts. In the fixed code, the addition of the `android_errorWriteWithInfoLog` function provides a mechanism to log detailed information about the permission denial, including the user ID. This enhancement allows for better monitoring and auditing of security incidents, making it easier to identify potential misuse or attacks. By capturing this information, the system can improve its security posture and respond more effectively to unauthorized access attempts.","The vulnerability in the original code stems from the absence of logging for permission denials, which could prevent the detection and analysis of unauthorized access attempts. Without this logging, it becomes challenging to monitor security incidents and understand the context of permission violations. The fixed code addresses this issue by introducing a logging mechanism that captures relevant information whenever a permission denial occurs. This enhancement not only aids in tracking potential misuse but also strengthens the overall security framework by enabling better auditing and response to unauthorized access attempts, thereby improving the system's resilience against threats.","The vulnerability was fixed by adding a logging mechanism that captures details about permission denials. In the updated code, the `android_errorWriteWithInfoLog` function was introduced to log the user ID whenever a permission check fails. This occurs in the conditional block where the permission is denied, allowing the system to record the specific context of the denial, including the user ID. By implementing this logging, the code enhances its ability to monitor unauthorized access attempts, thereby improving security and enabling better auditing of incidents related to permission violations.","The vulnerability was addressed by incorporating a logging mechanism that records details whenever a permission denial occurs. This enhancement allows the system to capture relevant information about unauthorized access attempts, improving the ability to monitor and audit security incidents. By logging the user identity associated with the denial, the updated code provides valuable context that can be used for further analysis and response to potential misuse. This proactive approach strengthens the overall security framework, enabling better tracking of permission violations and enhancing the system's resilience against unauthorized access.","CWE-285, CWE-264, CWE-732, CWE-862, CWE-863, CWE-223, CWE-778, CWE-779, CWE-532, CWE-778",N,-1
88,88,187928,187928,,Local,Not required,Complete,CVE-2016-0846,https://www.cvedetails.com/cve/CVE-2016-0846/,CWE-264,Low,Complete,Complete,,2016-04-17,7.2,"libs/binder/IMemory.cpp in the IMemory Native Interface in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider the heap size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26877992.",2017-09-07,+Priv ,14,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149,f3199c228aced7858b75a8070b8358c155ae0149,"Sanity check IMemory access versus underlying mmap

Bug 26877992

Change-Id: Ibbf4b1061e4675e4e96bc944a865b53eaf6984fe
",3,libs/binder/IMemory.cpp,"{""filename"": ""libs/binder/IMemory.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/libs/binder/IMemory.cpp"", ""patch"": ""@@ -26,6 +26,7 @@\n\n #include <sys/mman.h>\n \n #include <binder/IMemory.h>\n+#include <cutils/log.h>\n #include <utils/KeyedVector.h>\n #include <utils/threads.h>\n #include <utils/Atomic.h>\n@@ -187,15 +188,26 @@\n\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n-                    mOffset = o;\n-                    mSize = s;\n+                    size_t heapSize = mHeap->getSize();\n+                    if (s <= heapSize\n+                            && o >= 0\n+                            && (static_cast<size_t>(o) <= heapSize - s)) {\n+                        mOffset = o;\n+                        mSize = s;\n+                    } else {\n+                        // Hm.\n+                        android_errorWriteWithInfoLog(0x534e4554,\n+                            \""26877992\"", -1, NULL, 0);\n+                        mOffset = 0;\n+                        mSize = 0;\n+                    }\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n-    return mHeap;\n+    return (mSize > 0) ? mHeap : 0;\n }\n \n // ---------------------------------------------------------------------------\n""}","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
",C,"                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
    return (mSize > 0) ? mHeap : 0;
","                    mOffset = o;
                    mSize = s;
    return mHeap;
",,"@@ -26,6 +26,7 @@

 #include <sys/mman.h>
 
 #include <binder/IMemory.h>
+#include <cutils/log.h>
 #include <utils/KeyedVector.h>
 #include <utils/threads.h>
 #include <utils/Atomic.h>
@@ -187,15 +188,26 @@

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
-                    mOffset = o;
-                    mSize = s;
+                    size_t heapSize = mHeap->getSize();
+                    if (s <= heapSize
+                            && o >= 0
+                            && (static_cast<size_t>(o) <= heapSize - s)) {
+                        mOffset = o;
+                        mSize = s;
+                    } else {
+                        // Hm.
+                        android_errorWriteWithInfoLog(0x534e4554,
+                            ""26877992"", -1, NULL, 0);
+                        mOffset = 0;
+                        mSize = 0;
+                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
-    return mHeap;
+    return (mSize > 0) ? mHeap : 0;
 }
 
 // ---------------------------------------------------------------------------
",Android,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149%5E/,1,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
//flaw_line_below:
                    mOffset = o;
//flaw_line_below:
                    mSize = s;
//fix_flaw_line_below:
//                    size_t heapSize = mHeap->getSize();
//fix_flaw_line_below:
//                    if (s <= heapSize
//fix_flaw_line_below:
//                            && o >= 0
//fix_flaw_line_below:
//                            && (static_cast<size_t>(o) <= heapSize - s)) {
//fix_flaw_line_below:
//                        mOffset = o;
//fix_flaw_line_below:
//                        mSize = s;
//fix_flaw_line_below:
//                    } else {
//fix_flaw_line_below:
//                        // Hm.
//fix_flaw_line_below:
//                        android_errorWriteWithInfoLog(0x534e4554,
//fix_flaw_line_below:
//                            ""26877992"", -1, NULL, 0);
//fix_flaw_line_below:
//                        mOffset = 0;
//fix_flaw_line_below:
//                        mSize = 0;
//fix_flaw_line_below:
//                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
//flaw_line_below:
    return mHeap;
//fix_flaw_line_below:
//    return (mSize > 0) ? mHeap : 0;
 }
",187928,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","The provided code defines a method `getMemory` within the `BpMemory` class, which retrieves a memory heap from a remote service if it hasn't been initialized yet. It first checks if `mHeap` is null; if so, it creates a `Parcel` to communicate with the remote service, sending a request for memory. Upon receiving a response, it extracts a strong binder reference to the memory heap, along with offset and size values. If the memory heap is successfully obtained, it updates the class's member variables and returns the memory heap, while also optionally setting the provided offset and size parameters.","The code defines a method that retrieves a memory resource from a remote service if it has not been previously initialized. It first checks the current state of the memory resource; if it is uninitialized, it prepares a communication packet to request the memory from the remote service. Upon receiving a response, it extracts the necessary information, including a reference to the memory resource and its associated offset and size. If the retrieval is successful, it updates the internal state and returns the memory resource, while also providing the offset and size values if requested.","The vulnerability in the original code arises from the lack of validation for the offset and size values obtained from the remote service, which could lead to buffer overflows or memory corruption if they exceed the actual memory bounds. In the fixed code, additional checks are introduced to ensure that the size is less than or equal to the actual size of the memory resource, and that the offset is non-negative and does not cause an overflow when combined with the size. This validation prevents potential exploitation by ensuring that only safe and valid memory access is allowed, thereby enhancing the overall security of the method.","The vulnerability in the original code stems from the absence of checks on the values received from a remote service, specifically regarding their validity in relation to memory boundaries. This oversight could allow an attacker to manipulate the offset and size, potentially leading to buffer overflows or unauthorized memory access. The fixed code addresses this issue by implementing strict validation criteria to ensure that the size does not exceed the actual memory capacity and that the offset is within safe limits. These enhancements significantly reduce the risk of exploitation by ensuring that only legitimate memory access is permitted.","The vulnerability was fixed by introducing validation checks for the offset and size values obtained from the remote service. In the updated code, after retrieving the size and offset, the method now verifies that the size is less than or equal to the actual size of the memory resource obtained through `mHeap->getSize()`. Additionally, it checks that the offset is non-negative and that the combination of offset and size does not exceed the memory bounds. If any of these conditions are not met, the method resets the offset and size to zero and logs an error, thereby preventing unsafe memory access.","The vulnerability was addressed by implementing rigorous validation checks for the offset and size values received from the remote service. The updated code ensures that the size does not exceed the actual memory capacity and that the offset is non-negative and does not lead to an overflow when combined with the size. If any of these conditions are violated, the method resets the offset and size to zero and logs an error, effectively preventing unsafe memory access. This proactive approach significantly enhances the security of the memory handling process by ensuring that only valid and safe parameters are utilized.","CWE-119, CWE-788, CWE-120, CWE-789, CWE-823, CWE-129, CWE-680, CWE-190, CWE-131, CWE-787",N,-1
89,89,187958,187958,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",1,services/camera/libcameraservice/CameraService.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",C,"            client->dumpClient(fd, args);
","            client->dump(fd, args);
",,"@@ -985,6 +985,14 @@

     mClientPid = 0;
 }
 
+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {
+    // No dumping of clients directly over Binder,
+    // must go through CameraService::dump
+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, ""26265403"",
+            IPCThreadState::self()->getCallingUid(), NULL, 0);
+    return OK;
+}
+
 status_t CameraService::BasicClient::startCameraOps() {
     int32_t res;
 
@@ -1222,7 +1230,7 @@

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
-            client->dump(fd, args);
+            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 // failed to lock - CameraService is probably deadlocked
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
//flaw_line_below:
            client->dump(fd, args);
//fix_flaw_line_below:
//            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

 // Dump camera traces if there were any
        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 // change logging level
 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",187958,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","The `CameraService::dump` function is designed to provide diagnostic information about the camera service in an Android system. It first checks if the calling process has the necessary permissions to access the camera service data. If permitted, it attempts to lock the service to prevent deadlocks and retrieves details about the camera module, including its API versions, name, author, and the number of available camera devices. For each camera, it gathers static information such as facing direction and orientation, and checks for active client instances. Additionally, it allows for setting a log level based on provided arguments, ensuring comprehensive logging and debugging capabilities.","The code implements a diagnostic function for a camera service in an Android system, allowing authorized users to retrieve detailed information about the camera module and its devices. It checks for necessary permissions and attempts to prevent deadlocks while gathering data. The function collects and formats information about the camera module, including its API versions, name, and author, as well as details for each camera device, such as orientation and facing direction. It also identifies active client instances and allows for adjusting logging levels based on user input, facilitating effective debugging and monitoring of the camera service.","The vulnerability in the original code stemmed from the potential for unauthorized access to sensitive camera service information, as it did not adequately verify the calling process's permissions before executing the dump operation. This could allow malicious actors to exploit the `CameraService::dump` function and gain access to private camera data. The fix involved adding a permission check using `checkCallingPermission`, ensuring that only processes with the appropriate ""android.permission.DUMP"" permission could execute the dump. This change effectively mitigated the risk of unauthorized access and enhanced the overall security of the camera service.","The vulnerability in the original code allowed unauthorized users to access sensitive information about the camera service, potentially exposing private data. This risk arose because the code did not sufficiently verify whether the calling process had the necessary permissions before executing the diagnostic function. The fix implemented a permission check to ensure that only authorized processes could access the camera service data. By enforcing this permission requirement, the updated code effectively mitigated the risk of unauthorized access, thereby enhancing the security and integrity of the camera service and its associated information.","The vulnerability was fixed by introducing a permission check at the beginning of the function using `checkCallingPermission` to verify if the calling process has the ""android.permission.DUMP"" permission. If the permission is denied, the function appends a denial message to the result and writes it to the output file descriptor, preventing further execution. This ensures that only authorized processes can access sensitive camera service information. Additionally, the code structure was maintained to handle potential deadlocks and check for the availability of the camera module, reinforcing the overall security of the diagnostic functionality.","The vulnerability was addressed by implementing a permission verification step at the start of the function, ensuring that only authorized processes can access sensitive information related to the camera service. If the necessary permission is not granted, the function generates a denial message and halts further execution, effectively preventing unauthorized access. This change not only safeguards private data but also maintains the integrity of the service by ensuring that only legitimate requests are processed. Additionally, the overall structure of the code was preserved to handle potential deadlocks and check for the availability of the camera module, enhancing security.","CWE-285,CWE-732,CWE-269,CWE-862,CWE-264,CWE-287,CWE-284,CWE-863,CWE-732,CWE-250",Y,5
90,90,187959,187959,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/Camera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",C,"    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -158,6 +158,10 @@

 }
 
 status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",187959," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
","The `Camera2Client::dump` function is designed to output detailed diagnostic information about the camera client state and its parameters to a specified file descriptor. It constructs a formatted string that includes the camera ID, client package name, process ID, and various camera parameters such as preview size, frame rates, image quality settings, GPS status, and focus modes. The function also enumerates current streams, quirks, and additional processing components related to the camera. Finally, it writes this information to the provided file descriptor and invokes dump methods on associated processors, ensuring comprehensive logging for debugging purposes.","The code is responsible for generating a detailed diagnostic report of a camera client’s current state and configuration. It compiles information about the camera's operational parameters, including image sizes, frame rates, quality settings, and GPS status. Additionally, it outlines various modes related to white balance, effects, scene settings, and focus, while also listing any quirks associated with the camera. The report is formatted as a string and written to a specified output, ensuring that all relevant details are captured for debugging and analysis purposes, along with invoking additional diagnostic outputs from related processing components.","The vulnerability in the original code stemmed from the direct exposure of sensitive camera parameters and client information through the `dump` function, which could be exploited by unauthorized users to gain insights into the camera's configuration and state. This was addressed by refactoring the code to separate the dumping functionality into a dedicated method, `dumpClient`, which encapsulates the sensitive information and limits access. By doing so, the code enhances security by controlling how and when sensitive data is exposed, thereby reducing the risk of information leakage and potential misuse.","The vulnerability in the original code was due to the direct exposure of sensitive information related to the camera's configuration and client details, which could be accessed by unauthorized users through a single function. This posed a significant security risk, as it allowed potential attackers to gather critical data about the camera's state and parameters. The issue was mitigated by restructuring the code to separate the sensitive data handling into a dedicated method, thereby controlling access and limiting the exposure of sensitive information. This change enhances security by ensuring that only authorized components can access critical camera details.","The vulnerability was fixed by refactoring the original `dump` function to delegate the sensitive data handling to a new method called `dumpClient`. This separation ensures that the detailed diagnostic information, including sensitive parameters and client details, is only accessed through this dedicated function. The original `dump` function now simply calls `BasicClient::dump`, which likely has more controlled access to sensitive information. This restructuring limits the exposure of critical data, enhancing security by ensuring that sensitive camera configurations are only processed and logged in a more secure context, reducing the risk of unauthorized access.","The vulnerability was addressed by restructuring the code to separate the handling of sensitive information from the general logging functionality. By creating a dedicated method for managing sensitive data, the code now restricts access to critical camera parameters and client details, ensuring that they are only processed in a controlled manner. This change minimizes the risk of unauthorized access to sensitive information, as it limits exposure to only those components that require it. Overall, the refactoring enhances security by implementing a more robust access control mechanism for sensitive data within the application.","CWE-200, CWE-732, CWE-269, CWE-285, CWE-916, CWE-921, CWE-359, CWE-532, CWE-779, CWE-284",N,-1
91,91,187960,187960,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/CameraClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -112,6 +112,10 @@

 }
 
 status_t CameraClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",187960," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
","The provided code defines a method `dump` within the `CameraClient` class, which is responsible for outputting diagnostic information about the camera client to a specified file descriptor (`fd`). It constructs a formatted string containing the camera ID, the remote callback's binder pointer, and the client process ID (PID), ensuring the string does not exceed a predefined buffer size. This string is then written to the file descriptor. Finally, the method calls another `dump` function on the `mHardware` object, passing along the file descriptor and additional arguments, allowing for further hardware-specific diagnostics to be output.","The code defines a method that outputs diagnostic information about a camera client to a specified file descriptor. It formats a string that includes the client's unique identifier, a pointer to a remote callback, and the process identifier of the client. This formatted string is written to the provided file descriptor, ensuring it does not exceed a certain length. After this, the method invokes another function related to the hardware component, passing the file descriptor and additional arguments, which allows for further detailed diagnostics specific to the hardware being used.","The vulnerability in the original code arises from the potential for buffer overflow when constructing the formatted string using `snprintf`. If the combined length of the camera ID, remote callback pointer, and client PID exceeds the predefined buffer size, it could lead to memory corruption or unintended behavior. In the fixed code, the `dump` method is refactored to call a safer implementation from `BasicClient`, while the actual string formatting and writing to the file descriptor are moved to a new method called `dumpClient`. This separation enhances safety by ensuring that the buffer handling is managed more effectively, reducing the risk of overflow.","The vulnerability in the original code stems from the risk of buffer overflow due to improper handling of string formatting. When constructing a diagnostic message, if the combined length of the components exceeds the allocated buffer size, it could lead to memory corruption or crashes. The fixed code addresses this issue by separating the responsibilities into two distinct methods. One method now handles the actual string formatting and writing, while the other calls a safer implementation for dumping information. This change enhances safety by ensuring that buffer management is more robust and reduces the likelihood of overflow vulnerabilities.","The vulnerability was fixed by refactoring the original `dump` method to delegate the string formatting and writing operations to a new method called `dumpClient`. In this new method, the formatted string is constructed using `snprintf`, which is still subject to buffer size limitations, but the overall structure is improved. The original `dump` method now simply calls `BasicClient::dump`, which likely implements safer handling of the file descriptor and arguments. This separation of concerns enhances the robustness of the code by isolating the potentially vulnerable operations and allowing for better management of buffer sizes and error handling.","The vulnerability was addressed by restructuring the code to separate the responsibilities of handling diagnostic output. The original method, which combined string formatting and writing operations, was split into two distinct methods. One method now focuses solely on invoking a safer implementation for output, while the other is dedicated to constructing and writing the formatted message. This change enhances safety by isolating the potentially risky operations, allowing for better management of buffer sizes and reducing the likelihood of memory-related issues, ultimately leading to a more robust and secure implementation.","CWE-120, CWE-119, CWE-121, CWE-20, CWE-134, CWE-787, CWE-126, CWE-131, CWE-789, CWE-74",N,-1
92,92,187961,187961,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api2/CameraDeviceClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -480,6 +480,10 @@

 }
 
 status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187961," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The provided code defines a method `dump` within the `CameraDeviceClient` class, which is responsible for outputting diagnostic information about the camera device. It begins by creating a formatted string that includes the camera ID, the remote callback's binder pointer, and the client process ID (PID). It then appends the current state of the camera device. The method subsequently calls `dump` on the `mFrameProcessor` object, passing the file descriptor and arguments for further diagnostics. Finally, it invokes `dumpDevice`, which likely outputs additional device-specific information to the specified file descriptor.","The code defines a method that generates and outputs diagnostic information related to a camera device. It constructs a formatted string that includes identifiers for the camera and the associated client process, along with the current state of the device. The method also retrieves and appends details from a frame processing component, which provides additional context about the camera's operation. Finally, it calls another function to output further device-specific information, ensuring a comprehensive overview of the camera's status and functionality for debugging or monitoring purposes.","The vulnerability in the original code arises from the direct exposure of sensitive information, such as the camera ID and client process ID, through the `dump` method. This could potentially allow unauthorized access to critical system details, leading to security risks. In the fixed code, the `dump` method has been modified to call a more secure method, `BasicClient::dump`, which likely implements stricter access controls or sanitization measures. The detailed logging and state information have been moved to a separate method, `dumpClient`, reducing the risk of sensitive data leakage during diagnostic operations.","The vulnerability in the original code stems from the potential exposure of sensitive information related to the camera device and client process, which could be accessed by unauthorized users during diagnostic operations. This could lead to security risks, such as information leakage or exploitation of system details. In the revised code, the method responsible for outputting this sensitive information has been altered to delegate the task to a more secure implementation, which likely includes enhanced access controls. Additionally, the detailed logging has been separated into a different method, thereby minimizing the risk of inadvertently disclosing critical data during diagnostics.","The vulnerability was fixed by restructuring the `dump` method to call `BasicClient::dump`, which likely implements stricter security measures to prevent unauthorized access to sensitive information. This change reduces the risk of exposing critical details, such as the camera ID and client process ID, during diagnostic operations. Additionally, the detailed logging and state information were moved to a separate method, `dumpClient`, which allows for better control over what information is exposed. This separation ensures that sensitive data is handled more securely, minimizing the chances of information leakage during the diagnostic process.","The vulnerability was addressed by modifying the method responsible for outputting diagnostic information to utilize a more secure implementation that likely enforces stricter access controls. This change helps prevent the exposure of sensitive details that could be exploited by unauthorized users. Additionally, the detailed logging and state information were relocated to a separate method, allowing for better management of what information is shared during diagnostics. This separation enhances security by ensuring that critical data is not inadvertently disclosed, thereby reducing the risk of information leakage during the diagnostic process.","CWE-200, CWE-532, CWE-209, CWE-359, CWE-552, CWE-538, CWE-497, CWE-214, CWE-201, CWE-213",N,-1
93,93,187962,187962,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api_pro/ProCamera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -331,6 +331,10 @@

 }
 
 status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187962," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The provided code defines a method `dump` within the `ProCamera2Client` class, which is responsible for generating a diagnostic output of the camera client’s state. It takes a file descriptor `fd` and a vector of arguments `args` as parameters. The method constructs a formatted string that includes the camera ID, a pointer to the remote callback, and the client’s process ID. It appends the current state of the camera client and invokes the `dump` method of the `mFrameProcessor` to include additional frame processing details. Finally, it calls `dumpDevice` to output device-specific information.","The code defines a method that generates a diagnostic report for a camera client, capturing its current state and relevant identifiers. It constructs a formatted string that includes the camera's unique identifier, a reference to a callback mechanism, and the process identifier of the client. The method appends information about the client's state and retrieves additional details from a frame processing component. Finally, it outputs device-specific information, providing a comprehensive overview of the camera client's status and functionality for debugging or monitoring purposes.","The vulnerability in the original code stemmed from directly exposing sensitive information about the camera client, such as the camera ID, process ID, and a reference to the remote callback, which could be exploited by unauthorized entities to gain insights into the system's internals. By modifying the code to separate the functionality into two distinct methods—`dump` and `dumpClient`—the sensitive information is now encapsulated within `dumpClient`, which is not directly exposed. The `dump` method now simply calls the base class's `dump`, thereby reducing the risk of information leakage and enhancing security.","The vulnerability in the original code arose from the direct exposure of sensitive information related to the camera client, which could potentially be accessed by unauthorized users, leading to security risks. This included details such as identifiers and process information that could aid in exploiting the system. The fix involved restructuring the code to separate the functionality into two distinct methods, ensuring that sensitive data is encapsulated and not directly accessible. By limiting the exposure of critical information, the revised code enhances security and reduces the risk of information leakage, thereby protecting the system's integrity.","The vulnerability was fixed by restructuring the code to separate the sensitive information handling from the general dumping functionality. The `dump` method now simply calls the base class's `dump`, which limits the exposure of sensitive data. Meanwhile, the `dumpClient` method is responsible for constructing the detailed diagnostic output, including the camera ID, process ID, and state information. This separation ensures that sensitive details are only accessed when explicitly needed, reducing the risk of unauthorized access. By encapsulating the sensitive data within a dedicated method, the overall security of the camera client is significantly improved.","The vulnerability was fixed by restructuring the code to separate the handling of sensitive information from the general diagnostic output process. By creating distinct methods, the sensitive data is now encapsulated and only accessed when necessary, thereby limiting its exposure. The main method now focuses on invoking a base functionality that does not reveal sensitive details, while a separate method is dedicated to constructing and managing the diagnostic output. This approach enhances security by ensuring that critical information is not directly accessible, reducing the risk of unauthorized access and potential exploitation.","CWE-200, CWE-209, CWE-359, CWE-532, CWE-538, CWE-312, CWE-552, CWE-215, CWE-497, CWE-501",N,-1
94,94,187986,187986,,Local Network,Not required,Complete,CVE-2016-0809,https://www.cvedetails.com/cve/CVE-2016-0809/,CWE-264,Low,Complete,Complete,,2016-02-06,8.3,"Use-after-free vulnerability in the wifi_cleanup function in bcmdhd/wifi_hal/wifi_hal.cpp in Wi-Fi in Android 6.x before 2016-02-01 allows attackers to gain privileges by leveraging access to the local physical environment during execution of a crafted application, aka internal bug 25753768.",2016-03-14,+Priv ,2,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,"Fix use-after-free in wifi_cleanup()

Release reference to cmd only after possibly calling getType().


BUG: 25753768
Change-Id: Id2156ce51acec04e8364706cf7eafc7d4adae9eb
(cherry picked from commit d7f3cb9915d9ac514393d0ad7767662958054b8f https://googleplex-android-review.git.corp.google.com/#/c/815223)
",2,bcmdhd/wifi_hal/wifi_hal.cpp,"{""filename"": ""bcmdhd/wifi_hal/wifi_hal.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/bcmdhd/wifi_hal/wifi_hal.cpp"", ""patch"": ""@@ -335,12 +335,12 @@\n\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n-            /* release reference added when command is saved */\n-            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\""Cancelling command %p:%s did not work\"", cmd, (cmd ? cmd->getType(): \""\""));\n                 bad_commands++;\n             }\n+            /* release reference added when command is saved */\n+            cmd->releaseRef();\n         }\n     }\n \n""}","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",C,"            /* release reference added when command is saved */
            cmd->releaseRef();
","            /* release reference added when command is saved */
            cmd->releaseRef();
",,"@@ -335,12 +335,12 @@

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
-            /* release reference added when command is saved */
-            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
+            /* release reference added when command is saved */
+            cmd->releaseRef();
         }
     }
 
",Android,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1%5E/,1,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
 // As a fallback set the cleanup flag to TRUE
        ALOGE(""could not write to the cleanup socket"");
 } else {
 // Listen to the response
 // Hopefully we dont get errors or get hung up
 // Not much can be done in that case, but assume that
 // it has rx'ed the Exit message to exit the thread.
 // As a fallback set the cleanup flag to TRUE
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
//flaw_line_below:
            /* release reference added when command is saved */
//flaw_line_below:
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
//fix_flaw_line_below:
//            /* release reference added when command is saved */
//fix_flaw_line_below:
//            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",187986,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","The `wifi_cleanup` function is designed to clean up resources associated with a Wi-Fi handle. It first retrieves hardware abstraction layer (HAL) information and sets a cleanup handler. The function attempts to signal cleanup via a socket and reads the response to confirm termination of event processing. It then locks a mutex to safely iterate through and cancel any remaining commands, logging details about each command. After attempting to cancel commands, it checks for any leaked commands and logs them. Finally, it calls an internal cleanup handler to finalize the cleanup process.","The provided code implements a cleanup routine for managing Wi-Fi resources. It initiates the cleanup process by signaling through a communication channel and checks for a confirmation response. The routine ensures thread safety by locking access to shared data while it iterates through outstanding commands, attempting to cancel each one and logging relevant information. After processing the commands, it checks for any that may not have been properly released and logs these instances. Finally, it invokes a designated internal handler to complete the cleanup, ensuring that all resources are appropriately released and managed.","The vulnerability in the original code arises from improper handling of command cancellation and resource management, which could lead to memory leaks or dangling pointers. Specifically, the lack of a proper reference release after canceling commands allowed for potential memory leaks, as commands could remain allocated without being freed. In the fixed code, the addition of a reference release after the command cancellation ensures that resources are properly managed, preventing memory leaks. This change enhances the robustness of the cleanup process by ensuring that all allocated resources are appropriately released, thus mitigating the risk of resource exhaustion or undefined behavior.","The vulnerability in the original code stemmed from inadequate management of resources during the cleanup process, which could lead to memory leaks and unreferenced commands remaining in memory. Specifically, commands that were canceled were not properly released, resulting in potential resource exhaustion over time. The fixed code addressed this issue by ensuring that references to commands were released immediately after cancellation, thereby promoting proper memory management. This change not only prevents memory leaks but also enhances the overall stability and reliability of the cleanup routine, ensuring that all resources are appropriately freed when no longer needed.","The vulnerability was fixed by ensuring that references to commands are properly released after they are canceled. In the original code, the cancellation of commands did not include a corresponding release of references, which could lead to memory leaks. The updated code introduces a call to `cmd->releaseRef()` immediately after the `cmd->cancel()` function is executed. This guarantees that for every command that is canceled, its reference count is decremented, allowing for proper memory management. Additionally, the code now checks if the command cancellation was successful, further enhancing the robustness of the cleanup process.","The vulnerability was addressed by implementing a mechanism to ensure that resources associated with commands are properly released after they are canceled. The updated code introduced a step to decrement the reference count of each command immediately following its cancellation, which prevents memory leaks by ensuring that allocated resources are freed when no longer needed. Additionally, the code now includes a check to confirm whether the cancellation was successful, enhancing the reliability of the cleanup process. This comprehensive approach to resource management significantly improves the stability and efficiency of the system during the cleanup operation.","CWE-401, CWE-772, CWE-404, CWE-775, CWE-459, CWE-763, CWE-911, CWE-771, CWE-773, CWE-400",N,-1
95,95,187990,187990,,Local,Not required,Complete,CVE-2016-0807,https://www.cvedetails.com/cve/CVE-2016-0807/,CWE-264,Low,Complete,Complete,,2016-02-06,7.2,"The get_build_id function in elf_utils.cpp in Debuggerd in Android 6.x before 2016-02-01 allows attackers to gain privileges via a crafted application that mishandles a Desc Size element in an ELF Note, aka internal bug 25187394.",2016-03-11,+Priv ,4,https://android.googlesource.com/platform%2Fsystem%2Fcore/+/d917514bd6b270df431ea4e781a865764d406120,d917514bd6b270df431ea4e781a865764d406120,"Fix incorrect check of descsz value.

Bug: 25187394

(cherry picked from commit 1fa55234d6773e09e3bb934419b5b6cc0df981c9)

Change-Id: Idbc9071e8b2b25a062c4e94118808d6e19d443d9
",4,debuggerd/elf_utils.cpp,"{""filename"": ""debuggerd/elf_utils.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/debuggerd/elf_utils.cpp"", ""patch"": ""@@ -63,10 +63,10 @@\n\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           // Skip the name (which is the owner and should be \""GNU\"").\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n-          uint8_t build_id_data[128];\n-          if (nhdr.n_namesz > sizeof(build_id_data)) {\n-            ALOGE(\""Possible corrupted note, name size value is too large: %u\"",\n-                  nhdr.n_namesz);\n+          uint8_t build_id_data[160];\n+          if (nhdr.n_descsz > sizeof(build_id_data)) {\n+            ALOGE(\""Possible corrupted note, desc size value is too large: %u\"",\n+                  nhdr.n_descsz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n""}","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",C,"          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
","          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
",,"@@ -63,10 +63,10 @@

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
-          uint8_t build_id_data[128];
-          if (nhdr.n_namesz > sizeof(build_id_data)) {
-            ALOGE(""Possible corrupted note, name size value is too large: %u"",
-                  nhdr.n_namesz);
+          uint8_t build_id_data[160];
+          if (nhdr.n_descsz > sizeof(build_id_data)) {
+            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
+                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
",Android,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120%5E/,1,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 // First read the rest of the header.
 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 // Looking for the .note.gnu.build-id note.
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
//flaw_line_below:
          uint8_t build_id_data[128];
//flaw_line_below:
          if (nhdr.n_namesz > sizeof(build_id_data)) {
//flaw_line_below:
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
//flaw_line_below:
                  nhdr.n_namesz);
//fix_flaw_line_below:
//          uint8_t build_id_data[160];
//fix_flaw_line_below:
//          if (nhdr.n_descsz > sizeof(build_id_data)) {
//fix_flaw_line_below:
//            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
//fix_flaw_line_below:
//                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
 // Move past the extra note data.
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",187990,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","The provided code defines a function `get_build_id` that retrieves the build ID from a binary file's ELF (Executable and Linkable Format) header. It first copies the ELF identification data and reads the header information, including program headers. The function iterates through these headers to locate the one of type `PT_NOTE`, which contains notes about the binary. Within this section, it searches for a note of type `NT_GNU_BUILD_ID`, extracts the associated data, and formats it as a hexadecimal string. If successful, the build ID is stored in the provided string, and the function returns true; otherwise, it returns false.","The code defines a function that extracts a unique identifier from a binary file's header structure. It begins by copying identification data and reading additional header information. The function then searches through the program headers to find a specific type that contains notes about the binary. Within this section, it looks for a particular note type that holds the unique identifier, retrieves the associated data, and formats it into a hexadecimal string. If the extraction is successful, the identifier is stored in a provided string; otherwise, the function indicates failure.","The vulnerability in the original code arises from the fixed-size array `build_id_data[128]`, which could lead to a buffer overflow if the size of the descriptor (`nhdr.n_descsz`) exceeds 128 bytes. This could allow an attacker to write beyond the allocated memory, potentially leading to arbitrary code execution or data corruption. The fixed code addresses this issue by increasing the size of the `build_id_data` array to 160 bytes, providing a larger buffer to accommodate potential descriptor sizes. Additionally, it includes a check to log an error if the descriptor size exceeds the new buffer size, enhancing overall safety.","The vulnerability in the original code stems from the use of a fixed-size buffer that could be insufficient to hold larger data, leading to a potential buffer overflow. This flaw could allow an attacker to overwrite adjacent memory, resulting in arbitrary code execution or data corruption. The revised code mitigates this risk by increasing the buffer size, providing more space for the data being processed. Additionally, it implements a check to ensure that the size of the incoming data does not exceed the new buffer limit, thereby enhancing the overall security and stability of the function.","The vulnerability was fixed by increasing the size of the `build_id_data` array from 128 bytes to 160 bytes, allowing for a larger buffer to accommodate potential descriptor sizes. Additionally, the code now includes a check that verifies if the descriptor size (`nhdr.n_descsz`) exceeds the size of the `build_id_data` array. If it does, an error message is logged using `ALOGE`, and the function returns false to prevent further processing. This combination of a larger buffer and a size check significantly reduces the risk of buffer overflow and enhances the function's overall safety.","The vulnerability was addressed by increasing the size of the buffer used to store incoming data, allowing for a greater capacity to handle larger inputs without risking overflow. Additionally, a validation step was introduced to check if the size of the incoming data exceeds the new buffer limit. If the data size is too large, an error message is logged, and the function safely terminates without processing the data further. This combination of a larger buffer and a size validation mechanism significantly enhances the security and stability of the code by preventing potential memory corruption issues.","CWE-119, CWE-120, CWE-131, CWE-789, CWE-130, CWE-788, CWE-787, CWE-20, CWE-680, CWE-122",N,-1
96,96,187994,187994,,Remote,Not required,Complete,CVE-2015-6640,https://www.cvedetails.com/cve/CVE-2015-6640/,CWE-264,Medium,Complete,Complete,,2016-01-06,9.3,"The prctl_set_vma_anon_name function in kernel/sys.c in Android before 5.1.1 LMY49F and 6.0 before 2016-01-01 does not ensure that only one vma is accessed in a certain update action, which allows attackers to gain privileges or cause a denial of service (vma list corruption) via a crafted application, aka internal bug 20017123.",2016-12-07,DoS +Priv ,1,https://android.googlesource.com/kernel%2Fcommon/+/69bfe2d957d903521d32324190c2754cb073be15,69bfe2d957d903521d32324190c2754cb073be15,"mm: fix prctl_set_vma_anon_name

prctl_set_vma_anon_name could attempt to set the name across
two vmas at the same time due to a typo, which might corrupt
the vma list.  Fix it to use tmp instead of end to limit
the name setting to a single vma at a time.

Change-Id: Ie32d8ddb0fd547efbeedd6528acdab5ca5b308b4
Reported-by: Jed Davis <jld@mozilla.com>
Signed-off-by: Colin Cross <ccross@android.com>
",1,kernel/sys.c,"{""filename"": ""kernel/sys.c"", ""raw_url"": ""https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/kernel/sys.c"", ""patch"": ""@@ -1934,7 +1934,7 @@\n\n \t\t\ttmp = end;\n \n \t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n-\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n+\t\terror = prctl_update_vma_anon_name(vma, &prev, start, tmp,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n""}","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",C,"		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
","		error = prctl_update_vma_anon_name(vma, &prev, start, end,
",,"@@ -1934,7 +1934,7 @@

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
-		error = prctl_update_vma_anon_name(vma, &prev, start, end,
+		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
",Android,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15%5E/,1,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
//flaw_line_below:
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
//fix_flaw_line_below:
//		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",187994,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","The provided code defines a function `prctl_set_vma_anon_name` that updates the anonymous name of virtual memory areas (VMAs) within a specified address range in a process's memory. It first checks for unmapped address ranges and initializes error handling. The function iterates through VMAs, adjusting the start and end addresses as necessary, and calls `prctl_update_vma_anon_name` to perform the actual update. If any errors occur during the process, such as encountering unmapped addresses or invalid parameters, it returns appropriate error codes, ensuring that the function handles memory management robustly while adhering to the constraints of the specified range.","The code defines a function that updates the names of specific memory regions within a process's address space. It begins by checking for any unmapped address ranges and sets up error handling. The function then iterates through the memory regions, adjusting the specified start and end addresses as needed, while ensuring that updates are only applied to valid regions. If any issues arise, such as encountering unmapped areas or invalid inputs, the function returns appropriate error codes. This approach ensures effective memory management while adhering to the constraints of the specified address range.","The vulnerability in the original code arises from inadequate handling of unmapped address ranges, which could lead to memory corruption or access violations. Specifically, if the specified range includes addresses that are not mapped, the function could attempt to update memory regions incorrectly, potentially allowing unauthorized access or modification of memory. The fixed code addresses this by ensuring that if the start address is less than the beginning of a valid memory region, it adjusts the start to the region's beginning, thereby preventing any operations on unmapped addresses and ensuring that updates are only applied to valid memory areas.","The vulnerability in the original code stems from insufficient checks for unmapped address ranges, which could lead to operations on invalid memory areas, resulting in potential memory corruption or unauthorized access. This flaw could allow the function to attempt updates on addresses that are not properly allocated, compromising system stability and security. The fixed code enhances this by implementing stricter validation, ensuring that if the specified start address falls outside valid memory regions, it is adjusted to align with the nearest valid region. This change effectively prevents any operations on unmapped addresses, thereby safeguarding memory integrity.","The vulnerability was fixed by enhancing the handling of unmapped address ranges within the function. In the updated code, when the start address is found to be less than the beginning of a valid memory region, it is adjusted to the region's start using the `vma->vm_start` value. This adjustment ensures that the function does not attempt to operate on invalid memory areas. Additionally, the code checks if the adjusted start address is still within the specified range before proceeding with the update, thereby preventing any operations on unmapped addresses and ensuring that updates are only applied to valid memory regions.","The vulnerability was addressed by implementing stricter validation of address ranges to prevent operations on unmapped memory areas. The updated code ensures that if the starting address is found to be outside the bounds of valid memory regions, it is adjusted to align with the nearest valid region. This adjustment prevents the function from attempting to access or modify memory that is not allocated, thereby reducing the risk of memory corruption or unauthorized access. Additionally, the code checks that the adjusted address remains within the specified range before proceeding, further enhancing memory safety and integrity.","CWE-119, CWE-125, CWE-787, CWE-823, CWE-788, CWE-824, CWE-789, CWE-123, CWE-415, CWE-416",N,-1
97,97,188143,188143,,Remote,Not required,Complete,CVE-2015-3849,https://www.cvedetails.com/cve/CVE-2015-3849/,CWE-264,Medium,Complete,Complete,,2015-09-30,9.3,"The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255.",2015-10-01,Exec Code ,6,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,"DO NOT MERGE: Ensure that unparcelling Region only reads the expected number of bytes

bug: 20883006
Change-Id: I4f109667fb210a80fbddddf5f1bfb7ef3a02b6ce
",1,core/jni/android/graphics/Region.cpp,"{""filename"": ""core/jni/android/graphics/Region.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/core/jni/android/graphics/Region.cpp"", ""patch"": ""@@ -218,7 +218,12 @@\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n-    region->readFromMemory(regionData, size);\n+    size_t actualSize = region->readFromMemory(regionData, size);\n+\n+    if (size != actualSize) {\n+        delete region;\n+        return NULL;\n+    }\n \n     return reinterpret_cast<jlong>(region);\n }\n""}","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
",C,"    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
","    region->readFromMemory(regionData, size);
",,"@@ -218,7 +218,12 @@

         return NULL;
     }
     SkRegion* region = new SkRegion;
-    region->readFromMemory(regionData, size);
+    size_t actualSize = region->readFromMemory(regionData, size);
+
+    if (size != actualSize) {
+        delete region;
+        return NULL;
+    }
 
     return reinterpret_cast<jlong>(region);
 }
",Android,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3%5E/,1,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
//flaw_line_below:
    region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//    size_t actualSize = region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (size != actualSize) {
//fix_flaw_line_below:
//        delete region;
//fix_flaw_line_below:
//        return NULL;
//fix_flaw_line_below:
//    }
 
     return reinterpret_cast<jlong>(region);
 }
",188143,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","The provided code defines a function `Region_createFromParcel` that creates a Skia `SkRegion` object from a Java `Parcel` in a JNI (Java Native Interface) context. It first checks if the `parcel` is null, returning null if it is. Then, it retrieves the underlying Android `Parcel` object and reads an integer value representing the size of the region data. If the data is successfully read, it allocates a new `SkRegion` object, populates it with the data from memory, and returns a pointer to the newly created `SkRegion` as a `jlong`. If any step fails, it returns null.","The code defines a function that creates a graphical region object from a data parcel in a native environment. It begins by checking if the input parcel is null, returning null if so. The function then retrieves the underlying data structure and reads an integer indicating the size of the region data. If the data is successfully accessed, it allocates a new graphical region object and populates it with the retrieved data from memory. Finally, it returns a pointer to the newly created region object, ensuring proper handling of any failures by returning null when necessary.","The vulnerability in the original code arises from the lack of validation for the size of the data read into the graphical region object. Specifically, after reading the data with `readFromMemory`, the original code did not check if the actual size of the data matched the expected size, which could lead to buffer overflows or memory corruption if the data was incomplete or malformed. The fixed code addresses this by introducing a check that compares the expected size with the actual size returned by `readFromMemory`. If they do not match, the code safely deletes the allocated region object and returns null, preventing potential security issues.","The vulnerability in the original code stems from the absence of validation for the size of the data being processed, which could lead to buffer overflows or memory corruption if the data is incomplete or malformed. This oversight allowed for the possibility of reading more data than intended, potentially compromising the integrity of the application. The fixed code addresses this issue by implementing a check that compares the expected size of the data with the actual size read. If there is a mismatch, the code ensures that any allocated resources are properly released, thereby enhancing security and stability.","The vulnerability was fixed by adding a validation step after reading the data into the graphical region object. In the updated code, after calling `readFromMemory` to populate the region, the actual size of the data is compared to the expected size using the `size` and `actualSize` variables. If these two values do not match, the code safely deletes the allocated region object to prevent memory leaks and returns null. This additional check ensures that only correctly sized data is processed, thereby mitigating the risk of buffer overflows and enhancing the overall security of the function.","The vulnerability was fixed by introducing a validation mechanism that checks the integrity of the data being processed. After reading the data into the graphical region object, the updated code compares the expected size of the data with the actual size that was read. If there is a discrepancy between these two values, the code ensures that any allocated resources are properly released to prevent memory leaks and potential security issues. This additional validation step effectively mitigates the risk of buffer overflows and enhances the overall robustness and security of the function.","CWE-119, CWE-120, CWE-122, CWE-131, CWE-789, CWE-401, CWE-415, CWE-416, CWE-190, CWE-680",N,-1
98,98,188170,188170,,Remote,Not required,Complete,CVE-2016-3909,https://www.cvedetails.com/cve/CVE-2016-3909/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990.",2016-11-28,+Priv ,2,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba,c48ef757cc50906e8726a3bebc3b60716292cdba,"Fix build breakage caused by commit
940829f69b52d6038db66a9c727534636ecc456d.

Change-Id: I4776db4a26fb3c31bb994d48788373fe569c812a
(cherry picked from commit baa9146401e28c5acf54dea21ddd197f0d3a8fcd)
",2,media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp,"{""filename"": ""media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""patch"": ""@@ -213,8 +213,8 @@\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n-                ALOGE(\""Too small output buffer for reference frame: %zu bytes\"",\n-                        outHeader->nAllocLen);\n+                ALOGE(\""Too small output buffer for reference frame: %lu bytes\"",\n+                        (unsigned long)outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \""30033990\"");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n""}","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",C,"                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
","                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
",,"@@ -213,8 +213,8 @@

             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
-                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
-                        outHeader->nAllocLen);
+                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
+                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba%5E/,1,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
//flaw_line_below:
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
//flaw_line_below:
                        outHeader->nAllocLen);
//fix_flaw_line_below:
//                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
//fix_flaw_line_below:
//                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 // decoder deals in ms (int32_t), OMX in us (int64_t)
 // so use fake timestamp instead
 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 // The PV decoder is lying to us, sometimes it'll claim to only have
 // consumed a subset of the buffer when it clearly consumed all of it.
 // ignore whatever it says...
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 // H263 doesn't have VOL header, the frame size information is in short header, i.e. the
 // decoder may detect size change after PVDecodeVideoFrame.
 if (handlePortSettingsChange()) {
 return;
 }

 // decoder deals in ms, OMX in us.
        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",188170,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","The provided code is a method from a video decoder class that processes input buffers containing MPEG4 or H.263 video data. It checks for errors and manages input and output buffer queues, ensuring that the decoder is initialized before processing frames. The method handles various scenarios, such as empty input buffers, end-of-stream flags, and codec configuration data. It decodes video frames, updates timestamps, and manages memory for output buffers. If any issues arise, such as insufficient buffer sizes or decoding failures, it signals errors and cleans up resources, ensuring robust handling of video data streams.","The code defines a method that processes video data from input buffers, managing the flow between input and output queues. It checks for errors and ensures the decoder is properly initialized before handling video frames. The method addresses various conditions, such as empty buffers and end-of-stream signals, while decoding video frames and updating timestamps. It also verifies buffer sizes to prevent overflow and signals errors when issues arise. Overall, the method ensures efficient video decoding and resource management, facilitating smooth playback of MPEG4 or H.263 content while handling potential errors gracefully.","The vulnerability in the original code arises from insufficient checks on buffer sizes and conditions before processing video frames, which could lead to buffer overflows or memory corruption. Specifically, the code did not adequately verify whether the output buffer was large enough to accommodate the decoded frame size, potentially causing writes beyond allocated memory. The fixed code introduces additional checks for the output buffer's allocation length against the required frame size, ensuring that it is sufficient before proceeding with the decoding operation. This change mitigates the risk of memory-related vulnerabilities by enforcing stricter validation of buffer sizes.","The vulnerability in the original code stemmed from inadequate validation of buffer sizes before processing video frames, which could lead to buffer overflows or memory corruption. Specifically, the code failed to ensure that the output buffer was sufficiently large to hold the decoded frame data, risking writes beyond allocated memory. The fixed code addresses this issue by implementing additional checks to verify that the output buffer's allocation is appropriate for the required frame size before proceeding with any decoding operations. This enhancement significantly reduces the risk of memory-related vulnerabilities by enforcing stricter validation of buffer capacities.","The vulnerability was fixed by adding checks to ensure that the output buffer's allocation length is sufficient to accommodate the required frame size before decoding. In the updated code, the condition checks whether the output buffer's allocation length is less than the calculated frame size, which includes the necessary space for the YUV data. If the allocation is insufficient, the code logs an error and signals an undefined error event, preventing any further processing. This proactive validation ensures that memory overflows do not occur, thereby enhancing the overall stability and security of the video decoding process.","The vulnerability was addressed by implementing additional checks to verify that the output buffer has adequate memory allocated to handle the required frame size before any decoding operations take place. The updated code includes conditions that assess the allocation length against the calculated frame size, ensuring that it meets the necessary requirements. If the buffer is found to be insufficient, the code logs an error and prevents further processing, effectively mitigating the risk of memory overflows. This enhancement improves the robustness and security of the video decoding process by enforcing stricter validation of memory usage.","CWE-119, CWE-131, CWE-789, CWE-120, CWE-400, CWE-190, CWE-399, CWE-401, CWE-787, CWE-788",N,-1
99,99,188178,188178,,Remote,Not required,Complete,CVE-2016-3871,https://www.cvedetails.com/cve/CVE-2016-3871/,CWE-264,Medium,Complete,Complete,,2016-09-11,9.3,"Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022.",2017-08-12,Overflow +Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,"Fix build

Change-Id: I48ba34b3df9c9a896d4b18c3f48e41744b7dab54
",1,media/libstagefright/codecs/mp3dec/SoftMP3.cpp,"{""filename"": ""media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""patch"": ""@@ -122,7 +122,7 @@\n\n \n void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n-        ALOGE(\""memset buffer too small: got %lu, expected %zu\"", (unsigned long)outHeader->nAllocLen, len);\n+        ALOGE(\""memset buffer too small: got %u, expected %zu\"", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \""29422022\"");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n""}"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",C,"        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
","        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
",,"@@ -122,7 +122,7 @@

 
 void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
-        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
+        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad%5E/,1," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
//flaw_line_below:
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
//fix_flaw_line_below:
//        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",188178," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
","The `memsetSafe` function in the `SoftMP3` class is designed to safely set a specified number of bytes in a buffer, ensuring that the buffer's allocated length is sufficient for the operation. It takes an `OMX_BUFFERHEADERTYPE` pointer, a character value `c`, and a size `len` as parameters. If the requested length exceeds the buffer's allocated size (`nAllocLen`), it logs an error message, writes an error log, signals an error event, and returns `NULL`. If the buffer is adequately sized, it uses the standard `memset` function to fill the buffer with the specified character value.","The provided code defines a function that safely initializes a specified number of bytes in a memory buffer. It first checks if the requested size exceeds the buffer's allocated capacity. If it does, the function logs an error message, records an error event, and indicates that an error has occurred, returning a null value. If the buffer is sufficiently large, the function proceeds to fill the specified portion of the buffer with a given character value. This ensures that memory operations are performed safely, preventing potential buffer overflows and maintaining system stability.","The vulnerability in the original code arises from the lack of a proper check on the size of the buffer before performing the memory set operation. If the requested length exceeds the allocated length (`nAllocLen`), it could lead to a buffer overflow, potentially corrupting adjacent memory and causing undefined behavior. The fixed code addresses this issue by ensuring that the length parameter is compared against `nAllocLen` before proceeding with the memory operation. Additionally, the error logging was updated to use an unsigned integer format specifier, enhancing the clarity of the error message and ensuring that the logged values are correctly represented.","The vulnerability in the original code stems from the absence of a proper validation mechanism for the size of the memory buffer before attempting to initialize it. This oversight could allow a request to write beyond the allocated memory, leading to buffer overflow issues that may corrupt adjacent memory and compromise system stability. The revised code rectifies this by implementing a check that ensures the requested size does not exceed the allocated buffer size. Additionally, the error logging format was improved to enhance clarity, ensuring that any issues are accurately reported and handled, thereby increasing the overall robustness of the function.","The vulnerability was fixed by adding a conditional check that compares the requested length against the allocated length of the buffer. In the revised code, the condition `if (len > outHeader->nAllocLen)` ensures that the function only proceeds with the memory set operation if the requested size is within the buffer's limits. If the condition is met, an error message is logged using `ALOGE`, and an error event is signaled with `notify`, preventing any unsafe memory operations. This change effectively mitigates the risk of buffer overflow, enhancing the function's safety and reliability.","The vulnerability was addressed by implementing a validation step that checks whether the requested memory size exceeds the allocated buffer size before performing any operations. This safeguard ensures that the function only proceeds if the requested size is safe, thereby preventing potential buffer overflow issues. Additionally, the error handling was improved to log a clear message and signal an error event if the size is insufficient. These changes enhance the overall robustness of the function, ensuring that it operates within safe memory boundaries and reduces the risk of memory corruption or system instability.","CWE-120, CWE-119, CWE-131, CWE-789, CWE-788, CWE-122, CWE-680, CWE-401, CWE-754, CWE-193",N,-1
100,100,188253,188253,,Remote,Not required,Complete,CVE-2016-2452,https://www.cvedetails.com/cve/CVE-2016-2452/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673.",2016-05-10,+Priv ,24,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f,65756b4082cd79a2d99b2ccb5b392291fd53703f,"SoftAMR: check input buffer size to avoid overflow.

Bug: 27662364
Change-Id: I47380545ea7d85845e141e722b0d84f498d27145
",1,media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp,"{""filename"": ""media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""patch"": ""@@ -286,6 +286,13 @@\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n+        if (inHeader->nFilledLen == 0) {\n+            inInfo->mOwnedByUs = false;\n+            inQueue.erase(inQueue.begin());\n+            notifyEmptyBufferDone(inHeader);\n+            continue;\n+        }\n+\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n@@ -321,6 +328,17 @@\n\n                 return;\n             }\n \n+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n+            // for WMF since MIME_IETF is used when calling AMRDecode.\n+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n+\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n+\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n@@ -370,7 +388,12 @@\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n-            CHECK_GE(inHeader->nFilledLen, frameSize);\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""patch"": ""@@ -104,7 +104,6 @@\n\n ; INCLUDES\n ----------------------------------------------------------------------------*/\n #include    \""typedef.h\""\n-#include    \""mode.h\""\n #include    \""frame_type_3gpp.h\""\n \n /*--------------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""patch"": ""@@ -87,6 +87,7 @@\n\n \n #include \""gsm_amr_typedefs.h\""\n #include \""frame_type_3gpp.h\""\n+#include \""amrdecode.h\""\n \n /*--------------------------------------------------------------------------*/\n #ifdef __cplusplus\n@@ -136,19 +137,6 @@\n\n                          Word8 *id);\n \n     /*\n-     * AMRDecode steps into the part of the library that decodes the raw data\n-     * speech bits for the decoding process. It returns the address offset of\n-     * the next frame to be decoded.\n-     */\n-    Word16 AMRDecode(\n-        void                      *state_data,\n-        enum Frame_Type_3GPP      frame_type,\n-        UWord8                    *speech_bits_ptr,\n-        Word16                    *raw_pcm_buffer,\n-        Word16                    input_format\n-    );\n-\n-    /*\n      * This function resets the state memory used by the GSM AMR decoder. This\n      * function returns zero. It will return negative one if there is an error.\n      */\n""}","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",C,"        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
","            CHECK_GE(inHeader->nFilledLen, frameSize);
",,"@@ -286,6 +286,13 @@

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
+        if (inHeader->nFilledLen == 0) {
+            inInfo->mOwnedByUs = false;
+            inQueue.erase(inQueue.begin());
+            notifyEmptyBufferDone(inHeader);
+            continue;
+        }
+
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
@@ -321,6 +328,17 @@

                 return;
             }
 
+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
+            // for WMF since MIME_IETF is used when calling AMRDecode.
+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
+
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
+
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
@@ -370,7 +388,12 @@

             }
 
             size_t frameSize = getFrameSize(mode);
-            CHECK_GE(inHeader->nFilledLen, frameSize);
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f%5E/,1,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
//fix_flaw_line_below:
//        if (inHeader->nFilledLen == 0) {
//fix_flaw_line_below:
//            inInfo->mOwnedByUs = false;
//fix_flaw_line_below:
//            inQueue.erase(inQueue.begin());
//fix_flaw_line_below:
//            notifyEmptyBufferDone(inHeader);
//fix_flaw_line_below:
//            continue;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
//fix_flaw_line_below:
//            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
//fix_flaw_line_below:
//            // for WMF since MIME_IETF is used when calling AMRDecode.
//fix_flaw_line_below:
//            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {
 // This is bad, should never have happened, but did. Abort now.

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
//flaw_line_below:
            CHECK_GE(inHeader->nFilledLen, frameSize);
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
 // Produce silence instead of comfort noise and for
 // speech lost/no data.
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",188253,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","The provided code is a method from the `SoftAMR` class that processes audio buffers in an OpenMAX (OMX) multimedia framework. It manages input and output queues for audio data, handling both narrowband and wideband AMR (Adaptive Multi-Rate) audio formats. The function checks for errors and processes buffers until either queue is empty. It decodes audio frames, updates timestamps, and manages buffer ownership. If an end-of-stream (EOS) flag is detected, it finalizes the output buffer accordingly. The method also ensures that the output buffer is appropriately sized and handles various error conditions, signaling errors when necessary.","The code defines a method that processes audio data buffers in a multimedia framework, specifically for decoding audio formats. It manages input and output queues, ensuring that audio frames are decoded correctly while handling both narrowband and wideband formats. The method checks for errors and end-of-stream conditions, updating timestamps and managing buffer ownership as it processes the data. It verifies that output buffers are adequately sized and handles various error scenarios, signaling issues when necessary. The overall functionality focuses on efficient audio decoding and buffer management within the framework.","The vulnerability in the original code stemmed from insufficient checks on the size of the input buffer before processing, which could lead to buffer overflows or reading beyond allocated memory. Specifically, the code did not verify if the filled length of the input buffer was adequate for the expected frame size before decoding, potentially causing undefined behavior. The fixed code introduced checks to ensure that the filled length of the input buffer is compared against the expected frame size, thereby preventing attempts to read more data than is available and enhancing overall stability and security during audio processing.","The vulnerability in the original code arose from inadequate validation of the input buffer's size before processing, which could lead to buffer overflows or accessing unallocated memory. This lack of checks allowed the program to attempt reading more data than was available, resulting in potential crashes or undefined behavior. The fixed code addressed this issue by implementing explicit checks to ensure that the input buffer's filled length was sufficient for the expected data size before any decoding operations. This enhancement significantly improved the code's robustness and security by preventing unsafe memory access during audio processing.","The vulnerability was fixed by adding checks to ensure that the filled length of the input buffer is sufficient before proceeding with decoding operations. Specifically, the code now verifies that `inHeader->nFilledLen` is greater than or equal to the expected `frameSize` before calling the decoding function. This prevents attempts to read beyond the allocated memory, which could lead to buffer overflows. Additionally, similar checks were introduced for both narrowband and wideband modes, ensuring that the output buffer's allocation length is also validated, thereby enhancing the overall safety and stability of the audio processing functionality.","The vulnerability was fixed by implementing additional validation checks to ensure that the input buffer's size is adequate before processing. The updated code now verifies that the amount of data available in the input buffer meets the expected requirements for decoding operations. This prevents the program from attempting to read more data than is present, which could lead to memory access violations or crashes. By enforcing these checks, the code enhances its robustness and security, ensuring safe handling of audio data during processing and reducing the risk of undefined behavior.","CWE-119, CWE-131, CWE-789, CWE-120, CWE-125, CWE-787, CWE-788, CWE-823, CWE-129, CWE-805",N,-1
