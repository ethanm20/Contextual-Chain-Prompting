,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,79483,79483,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,0,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",0,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",C,,,,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,0,"static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",79483," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  return snprintf(dest, destlen, ""%s.hcache"", path);
 }
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","The provided code defines a static function named `nntp_hcache_namer`, which generates a filename for a cache associated with a given path. It takes three parameters: a constant character pointer `path`, a character pointer `dest` for storing the resulting filename, and a size_t variable `destlen` that specifies the maximum length of the destination buffer. The function uses `snprintf` to format the output string by appending "".hcache"" to the provided `path`, storing the result in `dest`. It returns the number of characters that would have been written, excluding the null terminator, ensuring safe string handling.","The code defines a function that creates a formatted filename based on a specified input path. It takes an input string representing the path, a buffer to store the resulting filename, and a size limit for that buffer. The function appends a specific suffix to the input path and writes the complete filename into the provided buffer, ensuring that it does not exceed the specified length. Additionally, it returns the total number of characters that would have been written to the buffer, excluding the null terminator, which helps in managing string lengths safely.","The vulnerability in the original code arises from the potential for buffer overflow when generating the filename, as it appends a fixed suffix without ensuring that the total length does not exceed the allocated size of the destination buffer. In the fixed code, the use of a defined suffix, `HC_FEXT`, allows for more flexibility and potentially safer handling of different file extensions. By using `snprintf`, the fixed code still maintains the safety of the destination buffer by limiting the number of characters written, thus mitigating the risk of overflow while allowing for dynamic suffixes.","The vulnerability in the original code stems from the risk of buffer overflow, as it appends a fixed suffix to the input path without verifying that the combined length fits within the allocated buffer. This oversight could lead to writing beyond the buffer's boundaries, potentially causing memory corruption or security issues. The revised code addresses this vulnerability by introducing a defined suffix that can vary, allowing for safer handling of different file extensions. It continues to use a function that limits the number of characters written, ensuring that the output remains within the bounds of the destination buffer, thus enhancing overall safety.","The vulnerability was fixed by modifying the function to use a defined suffix, `HC_FEXT`, instead of a hardcoded string. This change allows for greater flexibility in specifying file extensions while still ensuring that the total length of the output does not exceed the buffer size. The use of `snprintf` in the updated code ensures that the number of characters written to the destination buffer is limited by the `destlen` parameter, effectively preventing buffer overflow. This approach maintains safe string handling while accommodating different file extensions, thereby enhancing the overall robustness of the code.","The vulnerability was addressed by replacing a fixed suffix with a defined extension, allowing for more flexible and safer handling of filenames. This change ensures that the total length of the generated filename can be managed more effectively, reducing the risk of exceeding the allocated buffer size. Additionally, the implementation of a function that limits the number of characters written to the output buffer helps prevent buffer overflow. By incorporating these adjustments, the code enhances its robustness and security, ensuring that memory boundaries are respected while accommodating various file extensions.","CWE-120, CWE-119, CWE-121, CWE-131, CWE-788, CWE-122, CWE-680, CWE-787, CWE-242, CWE-134",N,-1
1,1,177931,177931,,Remote,Single system,,CVE-2018-14036,https://www.cvedetails.com/cve/CVE-2018-14036/,CWE-22,Low,Partial,,,2018-07-13,4.0,Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.,2018-09-06,Dir. Trav.,8,https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a,f9abd359f71a5bce421b9ae23432f539a067847a,,0,,,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",C,"        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

",,34bedecf7da81a8b42382254e3f9a32398c1ca5d,"@@ -1334,6 +1334,14 @@ user_change_icon_file_authorized_cb (Daemon                *daemon,
         }
 
         file = g_file_new_for_path (filename);
+        g_clear_pointer (&filename, g_free);
+
+        /* Canonicalize path so we can call g_str_has_prefix on it
+         * below without concern for ../ path components moving outside
+         * the prefix
+         */
+        filename = g_file_get_path (file);
+
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,",accountsservice,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=f9abd359f71a5bce421b9ae23432f539a067847a,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=34bedecf7da81a8b42382254e3f9a32398c1ca5d,1,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
//fix_flaw_line_below:
//        g_clear_pointer (&filename, g_free);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Canonicalize path so we can call g_str_has_prefix on it
//fix_flaw_line_below:
//         * below without concern for ../ path components moving outside
//fix_flaw_line_below:
//         * the prefix
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        filename = g_file_get_path (file);
//fix_flaw_line_below:
//
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",177931,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","The provided code defines a callback function, `user_change_icon_file_authorized_cb`, which is responsible for handling user icon changes in a daemon context. It begins by initializing variables for file handling and retrieves the filename from the provided data. If the filename is empty or null, it constructs a destination path for the user icon and attempts to delete the existing icon file. If the deletion fails (unless the file does not exist), it reports an error. If a valid filename is provided, it creates a file object and queries its attributes, although the code appears incomplete as it lacks further processing or return statements.","The code defines a callback function that manages the process of changing a user's icon within a daemon context. It first checks if a filename is provided; if not, it constructs a path to the existing user icon and attempts to delete it. If the deletion fails, an error is reported. If a valid filename is present, the function creates a file object and queries its attributes, although the code appears to be incomplete, lacking further actions or return statements. Overall, the function facilitates the management of user icons by handling both deletion and attribute querying.","The vulnerability in the original code arises from the lack of proper validation and sanitization of the filename obtained from the input data, which could lead to directory traversal attacks or the execution of unintended file operations. In the fixed code, the addition of the `g_file_get_path` function helps to canonicalize the file path, ensuring that any potentially malicious path components (like ""../"") are resolved, thus preventing unauthorized access to files outside the intended directory. This enhancement significantly improves security by ensuring that only valid and expected file paths are processed.","The vulnerability in the original code stems from inadequate validation of user input, specifically the filename, which could allow for directory traversal attacks. This lack of sanitization could enable an attacker to manipulate the file path, potentially accessing or modifying files outside the intended directory. The fixed code addresses this issue by implementing a mechanism to canonicalize the file path, ensuring that any malicious path components are resolved to their actual locations. This enhancement effectively restricts file operations to the intended directory, thereby mitigating the risk of unauthorized access and improving overall security.","The vulnerability was fixed by incorporating the `g_file_get_path` function, which canonicalizes the file path obtained from the user input. This function resolves any potentially malicious components, such as ""../"", ensuring that the resulting path points only to valid locations within the intended directory. Additionally, the code now includes a call to `g_clear_pointer` to free the filename after its use, preventing memory leaks. By ensuring that the filename is properly validated and sanitized before further processing, the fixed code effectively mitigates the risk of directory traversal attacks and enhances overall security.","The vulnerability was addressed by implementing a mechanism to canonicalize the file path derived from user input, which ensures that any potentially harmful path components are resolved to their actual locations. This process effectively prevents directory traversal attacks by restricting file operations to the intended directory. Additionally, the code was modified to include proper memory management practices, ensuring that any previously allocated resources are freed after use. These enhancements collectively improve the security of the code by validating and sanitizing user input, thereby mitigating the risk of unauthorized access to sensitive files.","CWE-22, CWE-73, CWE-59, CWE-23, CWE-36, CWE-99, CWE-789, CWE-401, CWE-119, CWE-125",Y,1
2,2,178681,178681,,Remote,Not required,,CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,Low,Partial,,,2018-04-20,5.0,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,2019-10-03,Dir. Trav.,12,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,2,,," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
",C,"       char *page, *fpath, *rpath;
       int n;
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
","       char *page, *fpath;
               resp = create_response_file(nurl, method, rp_code, fpath);
",30280f0093e8aea4bc8af8a46c2e529e8ec61ac9,"@@ -23,6 +23,7 @@
 #include <libintl.h>
 #define _(str) gettext(str)
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -245,15 +246,25 @@ static struct MHD_Response *create_response_file(const char *nurl,
 static struct MHD_Response *
 create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
-       char *page, *fpath;
+       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
+       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
-               resp = create_response_file(nurl, method, rp_code, fpath);
+               rpath = realpath(fpath, NULL);
+               if (rpath) {
+                       n = strlen(server_data.www_dir);
+                       if (!strncmp(server_data.www_dir, rpath, n))
+                               resp = create_response_file(nurl,
+                                                           method,
+                                                           rp_code,
+                                                           fpath);
+                       free(rpath);
+               }
 
                free(fpath);
        }
@@ -349,7 +360,7 @@ int main(int argc, char *argv[])
                switch (optc) {
                case 'w':
                        if (optarg)
-                               server_data.www_dir = strdup(optarg);
+                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
@@ -388,8 +399,14 @@ int main(int argc, char *argv[])
                exit(EXIT_FAILURE);
        }
 
-       if (!server_data.www_dir)
-               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
+       if (!server_data.www_dir) {
+               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
+               if (!server_data.www_dir) {
+                       fprintf(stderr,
+                               _(""Webserver directory does not exist.\n""));
+                       exit(EXIT_FAILURE);
+               }
+       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);",wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=95998c8deb916813798042df837170f2600170c4;hb=95998c8deb916813798042df837170f2600170c4,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=3db6828760f47e0d0a081a519b3b79d3158c5b08;hb=3db6828760f47e0d0a081a519b3b79d3158c5b08,1," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
//flaw_line_below:
       char *page, *fpath;
//fix_flaw_line_below:
//       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
//fix_flaw_line_below:
//       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
//flaw_line_below:
               resp = create_response_file(nurl, method, rp_code, fpath);
//fix_flaw_line_below:
//               rpath = realpath(fpath, NULL);
//fix_flaw_line_below:
//               if (rpath) {
//fix_flaw_line_below:
//                       n = strlen(server_data.www_dir);
//fix_flaw_line_below:
//                       if (!strncmp(server_data.www_dir, rpath, n))
//fix_flaw_line_below:
//                               resp = create_response_file(nurl,
//fix_flaw_line_below:
//                                                           method,
//fix_flaw_line_below:
//                                                           rp_code,
//fix_flaw_line_below:
//                                                           fpath);
//fix_flaw_line_below:
//                       free(rpath);
//fix_flaw_line_below:
//               }
 
                free(fpath);
        }
}
",178681," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
","The provided code defines a function `create_response` that generates an HTTP response based on the requested URL and method. It first checks if the URL starts with a predefined base API path (`URL_BASE_API_1_1`). If it does, it calls another function, `create_response_api`, to handle the API request and generate the response. If the URL does not match the API path, it retrieves the corresponding file path using `get_path`, then calls `create_response_file` to create a response for a static file. Finally, it frees the allocated memory for the file path.","The code defines a function that generates an HTTP response based on the requested URL and method. It first checks if the URL corresponds to a specific API endpoint. If it does, the function processes the request as an API call to generate the appropriate response. If the URL does not match the API endpoint, the function determines the file path associated with the request and generates a response for a static file instead. Additionally, it ensures that any allocated memory for the file path is properly released after use, maintaining efficient memory management.","The vulnerability in the original code arises from the lack of validation for the file path derived from the requested URL, which could allow an attacker to access unauthorized files outside the intended directory. In the fixed code, the addition of the `realpath` function ensures that the resolved file path is checked against the server's root directory. By comparing the beginning of the resolved path (`rpath`) with the server's base directory (`server_data.www_dir`), the code prevents directory traversal attacks, ensuring that only files within the designated directory can be accessed, thus enhancing security.","The vulnerability in the original code stems from inadequate validation of file paths derived from user input, which could allow attackers to exploit directory traversal attacks and access sensitive files outside the intended directory. The fixed code addresses this issue by implementing a mechanism to resolve the actual file path and verify that it resides within the designated server directory. This additional validation step ensures that only files within the allowed directory can be accessed, effectively mitigating the risk of unauthorized file access and enhancing the overall security of the application.","The vulnerability was fixed by introducing the `realpath` function, which resolves the actual file path from the user-provided input. After obtaining the resolved path, the code checks if it starts with the server's base directory by comparing it to `server_data.www_dir`. This validation ensures that only files within the designated directory can be accessed, effectively preventing directory traversal attacks. Additionally, the code ensures that the resolved path is freed after use, maintaining proper memory management. This combination of path resolution and validation significantly enhances the security of the file access mechanism.","The vulnerability was fixed by implementing a mechanism to resolve the actual file path from user input and then validating that this resolved path remains within the designated server directory. This additional step prevents unauthorized access to files outside the intended directory by ensuring that any requested file is checked against the server's base directory. By enforcing this validation, the code effectively mitigates the risk of directory traversal attacks, thereby enhancing the security of the file access process and ensuring that only legitimate files can be accessed by users.","CWE-22, CWE-23, CWE-36, CWE-73, CWE-99, CWE-35, CWE-434, CWE-641, CWE-552, CWE-377",Y,1
3,3,179722,179722,,Remote,Not required,Partial,CVE-2011-3602,https://www.cvedetails.com/cve/CVE-2011-3602/,CWE-22,Low,,Partial,,2014-04-27,6.4,"Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",2014-04-28,Dir. Trav. ,4,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,92e22ca23e52066da2258df8c76a2dca8a428bcc,"set_interface_var() doesn't check interface name and blindly does
fopen(path ""/"" ifname, ""w"") on it.  As ""ifname"" is an untrusted input, it
should be checked for "".."" and/or ""/"" in it.  Otherwise, an infected
unprivileged daemon may overwrite contents of file named ""mtu"",
""hoplimit"", etc. in arbitrary location with arbitrary 32-bit value in
decimal representation (""%d"").  If an attacker has a local account or
may create arbitrary symlinks with these names in any location (e.g.
/tmp), any file may be overwritten with a decimal value.",0,device-linux.c,"{""sha"": ""709eebc630e69faa8f5300a45f39c70742fa5add"", ""filename"": ""device-linux.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/reubenhwk/radvd/blob/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""raw_url"": ""https://github.com/reubenhwk/radvd/raw/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""contents_url"": ""https://api.github.com/repos/reubenhwk/radvd/contents/device-linux.c?ref=92e22ca23e52066da2258df8c76a2dca8a428bcc"", ""patch"": ""@@ -243,6 +243,10 @@ set_interface_var(const char *iface,\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n+\t/* No path traversal */\n+\tif (strstr(name, \""..\"") || strchr(name, '/'))\n+\t\treturn -1;\n+\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n ""}","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",C,"	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

",,,"@@ -243,6 +243,10 @@ set_interface_var(const char *iface,
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
+	/* No path traversal */
+	if (strstr(name, "".."") || strchr(name, '/'))
+		return -1;
+
 	if (access(spath, F_OK) != 0)
 		return -1;
 ",radvd,92e22ca23e52066da2258df8c76a2dca8a428bcc,9dfaaaf740ce784541e76e68de4ae04dce2c0921,1,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
//fix_flaw_line_below:
//	/* No path traversal */
//fix_flaw_line_below:
//	if (strstr(name, "".."") || strchr(name, '/'))
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",179722,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","The provided code defines a function `set_interface_var` that sets a specified variable for a given network interface. It constructs a file path using the interface name and variable format, checking if the path is valid and accessible. If the file exists, it attempts to open it for writing; if successful, it writes a 32-bit unsigned integer value to the file. If any operation fails, such as path construction, file access, or opening the file, it logs an error message (if a name is provided) and returns -1. Otherwise, it returns 0 upon successful completion.","The code defines a function that modifies a specific configuration for a network interface by writing a value to a designated file. It first constructs a file path based on the interface and variable format, ensuring the path is valid and accessible. If the file exists, it attempts to open it for writing; upon success, it writes a specified unsigned integer value to the file. In case of any errors during path creation, file access, or writing, an error message is logged if applicable, and the function returns an error code. A successful operation results in a return value indicating success.","The vulnerability in the original code arises from the lack of validation on the `name` parameter, which could allow for path traversal attacks. An attacker could potentially manipulate the `name` input to include sequences like ""../"" or ""/"" to access unauthorized files or directories. The fixed code addresses this vulnerability by adding a check that explicitly disallows any occurrences of these sequences in the `name` variable. By ensuring that `name` does not contain these characters, the code mitigates the risk of unauthorized file access, thereby enhancing the overall security of the function.","The vulnerability in the original code stems from insufficient validation of user input, specifically allowing for potential path traversal attacks. An attacker could exploit this by including sequences in the input that navigate to unauthorized directories, potentially accessing sensitive files. The fixed code addresses this issue by implementing checks that prevent the inclusion of harmful sequences in the input, effectively blocking any attempts to traverse the file system. This enhancement significantly reduces the risk of unauthorized access, thereby improving the security of the function and ensuring that only legitimate file paths are processed.","The vulnerability was fixed by adding a validation check for the `name` parameter in the modified code. Specifically, the code now includes a condition that checks for the presence of harmful sequences, such as ""../"" or ""/"", using the `strstr` and `strchr` functions. If either of these sequences is found in the `name` variable, the function immediately returns an error code, preventing any further processing. This additional validation step effectively mitigates the risk of path traversal attacks, ensuring that only safe and valid input is accepted for file operations, thereby enhancing the overall security of the function.","The vulnerability was fixed by implementing a validation mechanism that checks the user input for potentially harmful sequences that could lead to path traversal attacks. The updated code includes conditions that specifically look for patterns that would allow an attacker to navigate outside the intended directory structure. If any of these harmful patterns are detected in the input, the function immediately returns an error, preventing further processing. This proactive approach ensures that only safe and legitimate input is accepted, significantly reducing the risk of unauthorized file access and enhancing the overall security of the function.","CWE-22, CWE-23, CWE-36, CWE-73, CWE-35, CWE-99, CWE-641, CWE-32, CWE-434, CWE-67",Y,1
4,4,179899,179899,,Remote,Not required,,CVE-2015-1191,https://www.cvedetails.com/cve/CVE-2015-1191/,CWE-22,Low,,Partial,,2015-01-21,5.0,Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.,2016-12-02,Dir. Trav. ,23,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,"When decompressing with -N or -NT, strip any path from header name.

This uses the path of the compressed file combined with the name
from the header as the name of the decompressed output file.  Any
path information in the header name is stripped.  This avoids a
possible vulnerability where absolute or descending paths are put
in the gzip header.",12,pigz.c,"{""sha"": ""38c0d4fec22f33537cc3b26a5e13946a3514c4f1"", ""filename"": ""pigz.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 14, ""changes"": 37, ""blob_url"": ""https://github.com/madler/pigz/blob/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""raw_url"": ""https://github.com/madler/pigz/raw/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""contents_url"": ""https://api.github.com/repos/madler/pigz/contents/pigz.c?ref=fdad1406b3ec809f4954ff7cdf9e99eb18c2458f"", ""patch"": ""@@ -3520,26 +3520,35 @@ local void process(char *path)\n                  \"" (use -f to force)\"");\n     }\n     else {\n-        char *to, *repl;\n-\n-        /* use header name for output when decompressing with -N */\n-        to = g.inf;\n-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n-            to = g.hname;\n-            len = strlen(g.hname);\n+        char *to = g.inf, *sufx = \""\"";\n+        size_t pre = 0;\n+\n+        /* select parts of the output file name */\n+        if (g.decode) {\n+            /* for -dN or -dNT, use the path from the input file and the name\n+               from the header, stripping any path in the header name */\n+            if ((g.headis & 1) != 0 && g.hname != NULL) {\n+                pre = justname(g.inf) - g.inf;\n+                to = justname(g.hname);\n+                len = strlen(to);\n+            }\n+            /* for -d or -dNn, replace abbreviated suffixes */\n+            else if (strcmp(to + len, \"".tgz\"") == 0)\n+                sufx = \"".tar\"";\n         }\n-\n-        /* replace .tgz with .tar when decoding */\n-        repl = g.decode && strcmp(to + len, \"".tgz\"") ? \""\"" : \"".tar\"";\n+        else\n+            /* add appropriate suffix when compressing */\n+            sufx = g.sufx;\n \n         /* create output file and open to write */\n-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\""not enough memory\"", \""\"");\n-        memcpy(g.outf, to, len);\n-        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n+        memcpy(g.outf, g.inf, pre);\n+        memcpy(g.outf + pre, to, len);\n+        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n-                             (g.force ? 0 : O_EXCL), 0600);\n+                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {""}","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",C,"        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
                              (g.force ? 0 : O_EXCL), 0600);
","        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
                             (g.force ? 0 : O_EXCL), 0600);
",,"@@ -3520,26 +3520,35 @@ local void process(char *path)
                  "" (use -f to force)"");
     }
     else {
-        char *to, *repl;
-
-        /* use header name for output when decompressing with -N */
-        to = g.inf;
-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
-            to = g.hname;
-            len = strlen(g.hname);
+        char *to = g.inf, *sufx = """";
+        size_t pre = 0;
+
+        /* select parts of the output file name */
+        if (g.decode) {
+            /* for -dN or -dNT, use the path from the input file and the name
+               from the header, stripping any path in the header name */
+            if ((g.headis & 1) != 0 && g.hname != NULL) {
+                pre = justname(g.inf) - g.inf;
+                to = justname(g.hname);
+                len = strlen(to);
+            }
+            /* for -d or -dNn, replace abbreviated suffixes */
+            else if (strcmp(to + len, "".tgz"") == 0)
+                sufx = "".tar"";
         }
-
-        /* replace .tgz with .tar when decoding */
-        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
+        else
+            /* add appropriate suffix when compressing */
+            sufx = g.sufx;
 
         /* create output file and open to write */
-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
-        memcpy(g.outf, to, len);
-        strcpy(g.outf + len, g.decode ? repl : g.sufx);
+        memcpy(g.outf, g.inf, pre);
+        memcpy(g.outf + pre, to, len);
+        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
-                             (g.force ? 0 : O_EXCL), 0600);
+                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",pigz,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,e5318b2cd88f1cb74c0bbce8a618c2b72ec263fb,1,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
//flaw_line_below:
        char *to, *repl;
//flaw_line_below:

//flaw_line_below:
        /* use header name for output when decompressing with -N */
//flaw_line_below:
        to = g.inf;
//flaw_line_below:
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
//flaw_line_below:
            to = g.hname;
//flaw_line_below:
            len = strlen(g.hname);
//fix_flaw_line_below:
//        char *to = g.inf, *sufx = """";
//fix_flaw_line_below:
//        size_t pre = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* select parts of the output file name */
//fix_flaw_line_below:
//        if (g.decode) {
//fix_flaw_line_below:
//            /* for -dN or -dNT, use the path from the input file and the name
//fix_flaw_line_below:
//               from the header, stripping any path in the header name */
//fix_flaw_line_below:
//            if ((g.headis & 1) != 0 && g.hname != NULL) {
//fix_flaw_line_below:
//                pre = justname(g.inf) - g.inf;
//fix_flaw_line_below:
//                to = justname(g.hname);
//fix_flaw_line_below:
//                len = strlen(to);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            /* for -d or -dNn, replace abbreviated suffixes */
//fix_flaw_line_below:
//            else if (strcmp(to + len, "".tgz"") == 0)
//fix_flaw_line_below:
//                sufx = "".tar"";
         }
//flaw_line_below:

//flaw_line_below:
        /* replace .tgz with .tar when decoding */
//flaw_line_below:
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
//fix_flaw_line_below:
//        else
//fix_flaw_line_below:
//            /* add appropriate suffix when compressing */
//fix_flaw_line_below:
//            sufx = g.sufx;
 
         /* create output file and open to write */
//flaw_line_below:
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
//fix_flaw_line_below:
//        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
//flaw_line_below:
        memcpy(g.outf, to, len);
//flaw_line_below:
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
//fix_flaw_line_below:
//        memcpy(g.outf, g.inf, pre);
//fix_flaw_line_below:
//        memcpy(g.outf + pre, to, len);
//fix_flaw_line_below:
//        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
//flaw_line_below:
                             (g.force ? 0 : O_EXCL), 0600);
//fix_flaw_line_below:
//                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",179899,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","The provided code defines a function `process` that handles file processing for compression and decompression tasks. It begins by checking the input file's path, determining its type, and managing various file suffixes for compressed files. The function supports recursive directory traversal, allowing it to process all files within a directory if specified. It handles symbolic links and regular files, ensuring that only appropriate files are processed. Depending on the operation (compression or decompression), it opens the input file, prepares the output file, and executes the corresponding compression or decompression method, while managing memory and file attributes throughout the process.","The code defines a function that processes files for compression and decompression tasks. It checks the validity of the input file path, determines the file type, and manages various suffixes associated with compressed files. The function can recursively traverse directories to process all contained files, while ensuring that only regular files are handled. Depending on the specified operation, it opens the input file, prepares an output file, and executes the appropriate compression or decompression method. Throughout the process, it manages memory allocation and file attributes, ensuring proper handling of errors and user interactions.","The vulnerability in the original code arises from improper handling of file paths, particularly when constructing output file names. Specifically, the code did not adequately check for buffer overflows when copying or concatenating strings, which could lead to memory corruption or arbitrary code execution. In the fixed code, the output file name construction is improved by using safer string manipulation functions and ensuring that the total length of the constructed path does not exceed the allocated buffer size. This change mitigates the risk of buffer overflow vulnerabilities by enforcing stricter checks on the lengths of the strings being processed.","The vulnerability in the original code stems from inadequate checks on buffer sizes when constructing file paths, which could lead to buffer overflow issues. This flaw allowed for potential memory corruption or arbitrary code execution if the input exceeded expected limits. In the revised code, the handling of output file names was improved by implementing safer string manipulation techniques and ensuring that the total length of the constructed paths remained within allocated buffer sizes. These changes effectively mitigated the risk of buffer overflow vulnerabilities by enforcing stricter length checks during string operations.","The vulnerability was fixed by enhancing the handling of output file names to prevent buffer overflows. In the revised code, the use of `strncpy` and `memcpy` ensures that the length of the copied strings does not exceed the allocated buffer size, specifically in the construction of the output file name using `g.outf`. Additionally, checks were added to verify that the total length of the constructed path, including the suffix, does not surpass the buffer limit. This careful management of string lengths and memory allocation significantly reduces the risk of buffer overflow vulnerabilities in the code.","The vulnerability was addressed by implementing stricter checks on buffer sizes during the construction of file paths. The revised code employs safer string manipulation techniques that ensure the total length of the constructed paths does not exceed the allocated memory. Additionally, the code includes conditions to verify that any concatenated strings fit within the designated buffers, thereby preventing potential overflows. These enhancements effectively mitigate the risk of memory corruption and arbitrary code execution by enforcing careful management of string lengths and memory allocation throughout the file processing operations.","CWE-119, CWE-120, CWE-131, CWE-122, CWE-787, CWE-788, CWE-124, CWE-680, CWE-121, CWE-789",N,-1
5,5,181815,181815,,Remote,Not required,,CVE-2016-10048,https://www.cvedetails.com/cve/CVE-2016-10048/,CWE-22,Low,,Partial,,2017-03-23,5.0,Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.,2017-03-24,Dir. Trav. ,4,https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb,fc6080f1321fd21e86ef916195cc110b05d9effb,"Coder path traversal is not authorized, bug report provided by Masaaki Chida",1,magick/xml-tree.c,"{""sha"": ""0a6aefdf34546cdf939c6f37398cd48153cc4727"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-02  6.9.4-7 Cristy  <quetzlzacatenango@image...>\n+  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n+  * Coder path traversal is not authorized (bug report provided by\n+    Masaaki Chida).\n+\n 2016-05-31  6.9.4-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.4-6, GIT revision 18334:97775b5:20160531.\n ""}<_**next**_>{""sha"": ""a00b76d64018ebcaaac7c4728e9e10cd94a7d650"", ""filename"": ""magick/module.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/module.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\""../\"") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \""NotAuthorized\"",\""`%s'\"",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {""}<_**next**_>{""sha"": ""efe48065ed5e94de9c280e64e6ec0d8d6904c23b"", ""filename"": ""magick/xml-tree.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/xml-tree.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else""}","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",C,"                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
","                  ignore_depth++;
",,"@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
-                  ignore_depth++;
+                  {
+                    ignore_depth++;
+                    (void) DestroyXMLTreeAttributes(attributes);
+                  }
                 *p=c;
               }
             else",ImageMagick,fc6080f1321fd21e86ef916195cc110b05d9effb,96b300c1bf3b213e8e7331ba54de1836b665cef3,1,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
//flaw_line_below:
                  ignore_depth++;
//fix_flaw_line_below:
//                  {
//fix_flaw_line_below:
//                    ignore_depth++;
//fix_flaw_line_below:
//                    (void) DestroyXMLTreeAttributes(attributes);
//fix_flaw_line_below:
//                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",181815,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","The provided code defines a function `NewXMLTree` that parses an XML string and constructs an XML tree structure. It begins by validating the input XML string and converting it from UTF-16 to UTF-8. The function then iterates through the characters of the XML, identifying tags, attributes, and handling various XML constructs such as comments, CDATA sections, and processing instructions. It manages nested tags and self-closing tags while maintaining an ignore depth for specific tags. If any parsing errors occur, appropriate exceptions are thrown, and the function returns a pointer to the constructed XML tree or NULL in case of failure.","The code defines a function that parses an XML string to create a structured representation of the XML data. It begins by validating the input and converting it to a specific encoding format. The function then processes the string character by character, identifying elements such as tags and attributes while handling various XML constructs like comments and special sections. It manages nested structures and self-closing elements, ensuring proper hierarchy and depth control. If any errors arise during parsing, appropriate warnings are generated, and the function returns a representation of the constructed XML structure or indicates failure.","The vulnerability in the original code arises from insufficient validation of the XML input, particularly in handling malformed tags and attributes. For instance, the code did not adequately check for the presence of closing tags or the correct format of attributes, which could lead to buffer overflows or memory corruption. The fixed code addresses this by adding checks for missing closing tags and ensuring that attributes are properly formatted before processing. Specifically, it includes additional error handling for cases where expected characters are absent, thereby enhancing the robustness and security of the XML parsing process.","The vulnerability in the original code stems from inadequate validation of the XML structure, particularly regarding the handling of tags and attributes. This lack of thorough checks could lead to issues such as buffer overflows or improper memory access when encountering malformed XML. The revised code addresses these vulnerabilities by implementing additional error handling mechanisms that ensure the presence of closing tags and the correct formatting of attributes. By incorporating these checks, the updated version significantly enhances the security and stability of the XML parsing process, preventing potential exploitation from malformed input.","The vulnerability was fixed by enhancing error handling and validation throughout the parsing process. The revised code includes checks for missing closing tags, ensuring that if a closing tag is not found, an appropriate exception is thrown. For instance, the condition checking for the presence of the character indicating the end of a tag was strengthened, and specific error messages were added to clarify the nature of the parsing errors. Additionally, the code now verifies the correct formatting of attributes before processing them, which helps prevent issues related to malformed XML input and improves overall robustness.","The vulnerability was fixed by implementing more rigorous error handling and validation throughout the XML parsing process. The updated code introduces additional checks to ensure that closing tags are present and correctly formatted, which helps prevent issues related to malformed XML. It also enhances the handling of attributes by verifying their structure before processing, thereby reducing the risk of buffer overflows or memory corruption. By providing clearer error messages and handling unexpected input more gracefully, the revised code significantly improves the security and reliability of the XML parsing functionality.","CWE-91, CWE-611, CWE-776, CWE-827, CWE-112, CWE-20, CWE-120, CWE-119, CWE-755, CWE-116",N,-1
6,6,184888,184888,,Remote,Not required,Partial,CVE-2013-2900,https://www.cvedetails.com/cve/CVE-2013-2900/,CWE-22,Low,Partial,Partial,,2013-08-21,7.5,"The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name.",2017-09-18,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,"AX: Calendar Picker: Add AX labels to MonthPopupButton and CalendarNavigationButtons.

This CL adds no new tests. Will add tests after a Chromium change for
string resource.

BUG=123896

Review URL: https://codereview.chromium.org/552163002

git-svn-id: svn://svn.chromium.org/blink/trunk@181617 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/web/DateTimeChooserImpl.cpp,"{""sha"": ""12cccdfa59676411125945dcd7aa13898fc408e2"", ""filename"": ""third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/ManualTests/forms/calendar-picker.html?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -269,7 +269,11 @@ <h2>Config</h2>\n         min: config.min,\n         step: config.step * (config.type === \""month\"" ? 1 : 86400000),\n         stepBase: \""0\"",\n-        currentValue: config.value\n+        currentValue: config.value,\n+        axShowMonthSelector: \""Show month selection panel\"",\n+        axShowNextMonth: \""Show next month\"",\n+        axShowPreviousMonth: \""Show previous month\"",\n+        todayLabel: \""Today\"",\n     }\n };\n ""}<_**next**_>{""sha"": ""1cdb077dea9cd61af7c69ae482e4c0cfe9253113"", ""filename"": ""third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n     addProperty(\""todayLabel\"", todayLabelString, data);\n     addProperty(\""clearLabel\"", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\""weekLabel\"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n+    addProperty(\""axShowMonthSelector\"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n+    addProperty(\""axShowNextMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n+    addProperty(\""axShowPreviousMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\""weekStartDay\"", m_locale->firstDayOfWeek(), data);\n     addProperty(\""shortMonthLabels\"", m_locale->shortMonthLabels(), data);\n     addProperty(\""dayLabels\"", m_locale->weekDayShortLabels(), data);""}<_**next**_>{""sha"": ""2459e401c4237a186e0039c67c54ad271412b12d"", ""filename"": ""third_party/WebKit/Source/web/resources/calendarPicker.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/resources/calendarPicker.js?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -2763,6 +2763,7 @@ MonthPopupView.prototype.onClick = function(event) {\n  */\n function MonthPopupButton(maxWidth) {\n     View.call(this, createElement(\""button\"", MonthPopupButton.ClassNameMonthPopupButton));\n+    this.element.setAttribute(\""aria-label\"", global.params.axShowMonthSelector);\n \n     /**\n      * @type {!Element}\n@@ -2951,6 +2952,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._previousMonthButton.attachTo(this);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._previousMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowPreviousMonth);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2962,6 +2964,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._todayButton.element.classList.add(CalendarHeaderView.ClassNameTodayButton);\n     var monthContainingToday = Month.createFromToday();\n     this._todayButton.setDisabled(monthContainingToday < this.calendarPicker.minimumMonth || monthContainingToday > this.calendarPicker.maximumMonth);\n+    this._todayButton.element.setAttribute(\""aria-label\"", global.params.todayLabel);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2971,6 +2974,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._nextMonthButton.attachTo(this);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._nextMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowNextMonth);\n \n     if (global.params.isLocaleRTL) {\n         this._nextMonthButton.element.innerHTML = CalendarHeaderView._BackwardTriangle;""}<_**next**_>{""sha"": ""d2cc50cce3d1f450b6e1e35ca03a41d25518be8c"", ""filename"": ""third_party/WebKit/public/platform/WebLocalizedString.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/public/platform/WebLocalizedString.h?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -37,6 +37,9 @@ struct WebLocalizedString {\n     enum Name {\n         AXAMPMFieldText,\n         AXButtonActionVerb,\n+        AXCalendarShowMonthSelector,\n+        AXCalendarShowNextMonth,\n+        AXCalendarShowPreviousMonth,\n         AXCheckedCheckBoxActionVerb,\n         AXDateTimeFieldEmptyValueText,\n         AXDayOfMonthFieldText,""}","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",C,"    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
",,,"@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
+    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
+    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
+    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);",Chrome,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,8a2c034f43ae98cc6a429f91dd1d16fc3fe331c9,1,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
//fix_flaw_line_below:
//    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
//fix_flaw_line_below:
//    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
//fix_flaw_line_below:
//    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",184888,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","The `writeDocument` function in the `DateTimeChooserImpl` class generates an HTML document for a date and time picker interface. It begins by determining the appropriate labels based on the input type (month, week, or date) and prepares various parameters such as minimum and maximum values, step size, and locale settings. The function constructs the HTML structure, including styles and scripts, and populates it with properties like current value, suggestions, and labels. It also handles localization and adjusts for right-to-left layouts if necessary, ultimately appending the complete document to a shared buffer for rendering.","The code generates an HTML document for a date and time picker interface, adapting its content based on the selected input type. It retrieves localized labels and sets various parameters, including minimum and maximum values, step size, and current selections. The function constructs the document's structure, incorporating styles and scripts necessary for functionality. It also manages localization settings and adjusts for different text directions as needed. Finally, the complete document is appended to a shared buffer, making it ready for rendering in the user interface.","The vulnerability in the original code stemmed from insufficient handling of user input and localization, which could lead to potential cross-site scripting (XSS) attacks. Specifically, the code directly incorporated user-provided suggestions and labels into the HTML without proper sanitization. In the fixed code, additional properties related to accessibility were added, and the handling of localized strings was improved, ensuring that any user-generated content is properly managed. This change enhances security by mitigating the risk of injecting malicious scripts through user input, thereby protecting the integrity of the generated HTML document.","The vulnerability in the original code was primarily due to inadequate sanitization of user input, which could allow for cross-site scripting (XSS) attacks. User-generated content, such as suggestions and labels, was directly incorporated into the HTML without proper validation or encoding, making it susceptible to malicious script injection. The fixed code addressed this issue by enhancing the handling of localized strings and ensuring that any user input is appropriately managed and sanitized before being included in the document. This improvement significantly reduces the risk of XSS vulnerabilities, thereby enhancing the overall security of the application.","The vulnerability was fixed by improving the handling of user-generated content and ensuring proper sanitization before it is included in the HTML document. In the updated code, properties such as ""suggestionValues,"" ""localizedSuggestionValues,"" and ""suggestionLabels"" are now processed with greater care, ensuring that any user input is validated and encoded appropriately. Additionally, the inclusion of accessibility properties like ""axShowMonthSelector"" and others enhances the overall robustness of the document. By implementing these changes, the code mitigates the risk of cross-site scripting attacks, thereby securing the application against potential exploits.","The vulnerability was fixed by enhancing the sanitization and validation of user-generated content before it is incorporated into the HTML document. The updated code ensures that any input from users is properly managed, reducing the risk of malicious script injection. Additionally, the implementation of accessibility features demonstrates a commitment to improving the overall robustness of the application. By addressing these aspects, the revised code effectively mitigates the risk of cross-site scripting attacks, thereby strengthening the security of the application and protecting against potential exploits.","CWE-79, CWE-80, CWE-116, CWE-159, CWE-83, CWE-87, CWE-84, CWE-85, CWE-86, CWE-82",N,-1
7,7,185107,185107,,Remote,Not required,Partial,CVE-2013-0895,https://www.cvedetails.com/cve/CVE-2013-0895/,CWE-22,Low,Partial,Partial,,2013-02-23,7.5,"Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors.",2013-09-30,Dir. Trav. ,8,https://github.com/chromium/chromium/commit/23803a58e481e464a787e4b2c461af9e62f03905,23803a58e481e464a787e4b2c461af9e62f03905,"Fix creating target paths in file_util_posix CopyDirectory.

BUG=167840


Review URL: https://chromiumcodereview.appspot.com/11773018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@176659 0039d316-1c4b-4281-b951-d872f2087c98",5,base/file_util_posix.cc,"{""sha"": ""95ffb42f7dd5a7d66812b84292c84f9cc2dcf35f"", ""filename"": ""base/file_util_posix.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_posix.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n-    // current is the source path, including from_path, so paste\n-    // the suffix after from_path onto to_path to create the target_path.\n-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n-    // Strip the leading '/' (if any).\n-    if (!suffix.empty()) {\n-      DCHECK_EQ('/', suffix[0]);\n-      suffix.erase(0, 1);\n+    // current is the source path, including from_path, so append\n+    // the suffix after from_path to to_path to create the target_path.\n+    FilePath target_path(to_path);\n+    if (from_path_base != current) {\n+      if (!from_path_base.AppendRelativePath(current, &target_path)) {\n+        success = false;\n+        break;\n+      }\n     }\n-    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&""}<_**next**_>{""sha"": ""c1006e1304c205c52a7e58b38e9d7e8ade80e60d"", ""filename"": ""base/file_util_unittest.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_unittest.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -1466,6 +1466,43 @@ TEST_F(FileUtilTest, CopyFileWithCopyDirectoryRecursiveToExistingDirectory) {\n   EXPECT_TRUE(file_util::PathExists(file_name_to));\n }\n \n+TEST_F(FileUtilTest, CopyDirectoryWithTrailingSeparators) {\n+  // Create a directory.\n+  FilePath dir_name_from =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\""));\n+  file_util::CreateDirectory(dir_name_from);\n+  ASSERT_TRUE(file_util::PathExists(dir_name_from));\n+\n+  // Create a file under the directory.\n+  FilePath file_name_from =\n+      dir_name_from.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+  CreateTextFile(file_name_from, L\""Gooooooooooooooooooooogle\"");\n+  ASSERT_TRUE(file_util::PathExists(file_name_from));\n+\n+  // Copy the directory recursively.\n+  FilePath dir_name_to =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Destination\""));\n+  FilePath file_name_to =\n+      dir_name_to.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+\n+  // Create from path with trailing separators.\n+#if defined(OS_WIN)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\\\\\\\\\\\\\""));\n+#elif defined(OS_POSIX)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir///\""));\n+#endif\n+\n+  EXPECT_TRUE(file_util::CopyDirectory(from_path, dir_name_to, true));\n+\n+  // Check everything has been copied.\n+  EXPECT_TRUE(file_util::PathExists(dir_name_from));\n+  EXPECT_TRUE(file_util::PathExists(file_name_from));\n+  EXPECT_TRUE(file_util::PathExists(dir_name_to));\n+  EXPECT_TRUE(file_util::PathExists(file_name_to));\n+}\n+\n TEST_F(FileUtilTest, CopyFile) {\n   // Create a directory\n   FilePath dir_name_from =""}","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",C,"    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
","    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
    const FilePath target_path = to_path.Append(suffix);
",,"@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
-    // current is the source path, including from_path, so paste
-    // the suffix after from_path onto to_path to create the target_path.
-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
-    // Strip the leading '/' (if any).
-    if (!suffix.empty()) {
-      DCHECK_EQ('/', suffix[0]);
-      suffix.erase(0, 1);
+    // current is the source path, including from_path, so append
+    // the suffix after from_path to to_path to create the target_path.
+    FilePath target_path(to_path);
+    if (from_path_base != current) {
+      if (!from_path_base.AppendRelativePath(current, &target_path)) {
+        success = false;
+        break;
+      }
     }
-    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&",Chrome,23803a58e481e464a787e4b2c461af9e62f03905,0297467c47dfe10b7b3495f57b2e1515cfcec55d,1,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  // Some old callers of CopyDirectory want it to support wildcards.
  // After some discussion, we decided to fix those callers.
  // Break loudly here if anyone tries to do this.
  // TODO(evanm): remove this once we're sure it's ok.
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  // This function does not properly handle destinations within the source
  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  // We have to mimic windows behavior here. |to_path| may not exist yet,
  // start the loop with |to_path|.
  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    // If the destination already exists and is a directory, then the
    // top level of source needs to be copied.
    from_path_base = from_path.DirName();
  }

  // The Windows version of this function assumes that non-recursive calls
  // will always have a directory for from_path.
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
//flaw_line_below:
    // current is the source path, including from_path, so paste
//flaw_line_below:
    // the suffix after from_path onto to_path to create the target_path.
//flaw_line_below:
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
//flaw_line_below:
    // Strip the leading '/' (if any).
//flaw_line_below:
    if (!suffix.empty()) {
//flaw_line_below:
      DCHECK_EQ('/', suffix[0]);
//flaw_line_below:
      suffix.erase(0, 1);
//fix_flaw_line_below:
//    // current is the source path, including from_path, so append
//fix_flaw_line_below:
//    // the suffix after from_path to to_path to create the target_path.
//fix_flaw_line_below:
//    FilePath target_path(to_path);
//fix_flaw_line_below:
//    if (from_path_base != current) {
//fix_flaw_line_below:
//      if (!from_path_base.AppendRelativePath(current, &target_path)) {
//fix_flaw_line_below:
//        success = false;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     }
//flaw_line_below:
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",185107,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","The `CopyDirectory` function is designed to copy files and directories from a specified source path (`from_path`) to a destination path (`to_path`), with an option for recursive copying. It first checks for valid paths and ensures that the destination does not overlap with the source. The function uses a `FileEnumerator` to traverse the source directory, creating directories and copying files while preserving their attributes. It handles errors gracefully, logging issues encountered during the process, such as failures to create directories or copy files. The function returns a boolean indicating the success of the operation.","The provided code implements a function that facilitates the copying of files and directories from a source location to a destination, with an option to perform the operation recursively. It begins by validating the input paths to ensure they are appropriate and do not overlap. The function then traverses the source directory, creating corresponding directories and copying files while maintaining their original attributes. It includes error handling to log any issues encountered during the process, such as failures in creating directories or copying files. Ultimately, the function returns a status indicating whether the copying operation was successful.","The vulnerability in the original code arises from the potential for directory traversal attacks, where an attacker could manipulate the source and destination paths to overwrite files outside the intended directory. This risk is mitigated in the fixed code by ensuring that the target path is constructed correctly using the `from_path_base` and `AppendRelativePath` functions. This change prevents the creation of paths that could lead to unauthorized access or overwriting of sensitive files, as it enforces a strict relationship between the source and destination paths, thereby enhancing the overall security of the directory copying operation.","The vulnerability in the original code stems from the potential for directory traversal attacks, which could allow an attacker to manipulate paths to overwrite files outside the intended directory structure. This issue was addressed in the revised code by implementing a more secure method for constructing the target path, ensuring that it remains relative to the source directory. By enforcing this relationship, the updated code prevents unauthorized access or overwriting of files in unintended locations, thereby significantly enhancing the security of the directory copying process and protecting against malicious exploitation.","The vulnerability was fixed by modifying how the target path is constructed during the copying process. In the revised code, the `from_path_base` is used in conjunction with the `AppendRelativePath` function to ensure that the target path remains correctly related to the source directory. This change prevents the creation of paths that could lead to directory traversal, thereby blocking attempts to overwrite files outside the intended directory. Additionally, the checks for valid paths and the use of absolute paths further enhance security, ensuring that the copying operation adheres to the expected directory structure.","The vulnerability was addressed by implementing a more secure method for constructing the target path during the copying process. The updated approach ensures that the target path is always derived in a way that maintains a strict relationship with the source directory, effectively preventing any potential directory traversal attacks. This fix restricts the ability to manipulate paths that could lead to overwriting files outside the intended directory structure. Additionally, enhanced checks for valid paths further reinforce security, ensuring that the copying operation adheres to the expected directory hierarchy and protects against unauthorized access.","CWE-22, CWE-23, CWE-36, CWE-35, CWE-73, CWE-99, CWE-434, CWE-641, CWE-426, CWE-40",Y,1
