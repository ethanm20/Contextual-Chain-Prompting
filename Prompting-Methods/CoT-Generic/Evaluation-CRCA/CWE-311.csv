,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,178310,178310,,Remote,Not required,,CVE-2019-1563,https://www.cvedetails.com/cve/CVE-2019-1563/,CWE-311,Medium,Partial,,,2019-09-10,4.3,"In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",2019-09-12,,4,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=08229ad838c50f644d7e928e2eef147b4308ad64,08229ad838c50f644d7e928e2eef147b4308ad64,,0,,,"int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
                BIO *dcont, BIO *out, unsigned int flags)
{
    int r;
    BIO *cont;
    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
        return 0;
    }
    if (!dcont && !check_content(cms))
        return 0;
    if (flags & CMS_DEBUG_DECRYPT)
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
    if (!cert)
        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
    else
        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
    r = cms_copy_content(out, cont, flags);
    do_free_upto(cont, dcont);
    return r;
}
","int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
                BIO *dcont, BIO *out, unsigned int flags)
{
    int r;
    BIO *cont;
    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
        return 0;
    }
    if (!dcont && !check_content(cms))
        return 0;
    if (flags & CMS_DEBUG_DECRYPT)
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
    r = cms_copy_content(out, cont, flags);
    do_free_upto(cont, dcont);
    return r;
}
",C,"    if (!cert)
        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
    else
        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
",,7ff84d88036237dc36f4c2cf2dc814e4bf611084,"@@ -743,6 +743,10 @@ int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
+    if (!cert)
+        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
+    else
+        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/cms/cms_smime.c;h=3a26108b8ccb05a22afd2457360a3b823de3eb48;hb=08229ad838c50f644d7e928e2eef147b4308ad64,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/cms/cms_smime.c;h=5dcf803f4bd3c9bdfe1a04d6a7c2fc34f5a0a23d,1,"int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
                BIO *dcont, BIO *out, unsigned int flags)
{
    int r;
    BIO *cont;
    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
        return 0;
    }
    if (!dcont && !check_content(cms))
        return 0;
    if (flags & CMS_DEBUG_DECRYPT)
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
//fix_flaw_line_below:
//    if (!cert)
//fix_flaw_line_below:
//        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
//fix_flaw_line_below:
//    else
//fix_flaw_line_below:
//        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
    r = cms_copy_content(out, cont, flags);
    do_free_upto(cont, dcont);
    return r;
}
",178310,"int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
                BIO *dcont, BIO *out, unsigned int flags)
{
    int r;
    BIO *cont;
    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
        return 0;
    }
    if (!dcont && !check_content(cms))
        return 0;
    if (flags & CMS_DEBUG_DECRYPT)
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
    r = cms_copy_content(out, cont, flags);
    do_free_upto(cont, dcont);
    return r;
}
","int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
                BIO *dcont, BIO *out, unsigned int flags)
{
    int r;
    BIO *cont;
    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
        return 0;
    }
    if (!dcont && !check_content(cms))
        return 0;
    if (flags & CMS_DEBUG_DECRYPT)
         cms->d.envelopedData->encryptedContentInfo->debug = 1;
     else
         cms->d.envelopedData->encryptedContentInfo->debug = 0;
    if (!cert)
        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
    else
        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
     if (!pk && !cert && !dcont && !out)
         return 1;
     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
    r = cms_copy_content(out, cont, flags);
    do_free_upto(cont, dcont);
    return r;
}
","The `CMS_decrypt` function is designed to decrypt CMS (Cryptographic Message Syntax) enveloped data using a provided private key (`pk`) and certificate (`cert`). It first checks if the CMS content is of the correct type (enveloped data) and verifies the presence of necessary parameters. If debugging is enabled, it sets a debug flag in the encrypted content info. The function handles various scenarios, including cases where no decryption parameters are provided, and attempts to set the private key if available. Finally, it copies the decrypted content to the specified output BIO (`out`) and manages memory cleanup before returning the result of the decryption process.","The provided code implements a function that decrypts cryptographic messages that are encapsulated in a specific format. It begins by verifying that the input data is correctly formatted for decryption. The function checks for the presence of necessary parameters and can enable debugging features based on a flag. It also handles scenarios where decryption parameters may be missing. If a private key is available, it attempts to set it for the decryption process. Finally, the function copies the decrypted content to an output location and ensures proper memory management before returning the outcome of the decryption operation.","The vulnerability in the original code arises from the lack of proper handling when no certificate is provided, which could lead to unintended behavior during decryption. In the fixed code, a new check was introduced to set a flag indicating the absence of a certificate (`havenocert`) when the `cert` variable is null. This addition helps to explicitly manage the state of the decryption process, ensuring that the absence of a certificate is acknowledged and handled appropriately. By doing so, the code mitigates potential issues that could arise from proceeding with decryption without necessary cryptographic credentials, enhancing overall security.","The vulnerability in the original code stems from inadequate handling of scenarios where a required certificate is missing, which could lead to improper decryption processes and potential security risks. The fixed code addresses this issue by introducing a mechanism to explicitly indicate when a certificate is absent, allowing the system to manage this state more effectively. This enhancement ensures that the decryption operation does not proceed without the necessary cryptographic credentials, thereby reducing the likelihood of unintended behavior and improving the overall security posture of the decryption function.","The vulnerability was fixed by adding a check for the presence of a certificate within the decryption function. In the updated code, when the `cert` variable is found to be null, a flag (`havenocert`) is set to indicate that no certificate is available. This explicit handling allows the function to acknowledge the absence of a certificate and manage the decryption process accordingly. By doing so, the code prevents potential issues that could arise from proceeding with decryption without necessary credentials, thereby enhancing the security and reliability of the decryption operation.","The vulnerability was addressed by implementing a mechanism to explicitly check for the presence of a required certificate during the decryption process. By introducing a flag that indicates whether a certificate is absent, the updated code ensures that the system can appropriately manage this condition. This enhancement allows the function to recognize when it lacks necessary cryptographic credentials, preventing it from proceeding with decryption under potentially insecure circumstances. As a result, the fix improves the overall security and reliability of the decryption operation, reducing the risk of unintended behavior.","4, 4","5,5","3,4","4,4"
