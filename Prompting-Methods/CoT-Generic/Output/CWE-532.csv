,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,181561,181561,,Local,Not required,,CVE-2017-5549,https://www.cvedetails.com/cve/CVE-2017-5549/,CWE-532,Low,Partial,,,2017-02-06,2.1,"The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log.",2018-08-24,+Info ,5,https://github.com/torvalds/linux/commit/146cc8a17a3b4996f6805ee5c080e7101277c410,146cc8a17a3b4996f6805ee5c080e7101277c410,"USB: serial: kl5kusb105: fix line-state error handling

The current implementation failed to detect short transfers when
attempting to read the line state, and also, to make things worse,
logged the content of the uninitialised heap transfer buffer.

Fixes: abf492e7b3ae (""USB: kl5kusb105: fix DMA buffers on stack"")
Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Cc: stable <stable@vger.kernel.org>
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",4,drivers/usb/serial/kl5kusb105.c,"{""sha"": ""6cb45757818fae2222383358b4d38d7c87b2dbf4"", ""filename"": ""drivers/usb/serial/kl5kusb105.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/146cc8a17a3b4996f6805ee5c080e7101277c410/drivers/usb/serial/kl5kusb105.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/146cc8a17a3b4996f6805ee5c080e7101277c410/drivers/usb/serial/kl5kusb105.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/kl5kusb105.c?ref=146cc8a17a3b4996f6805ee5c080e7101277c410"", ""patch"": ""@@ -192,10 +192,11 @@ static int klsi_105_get_line_state(struct usb_serial_port *port,\n \t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n \t\t\t     10000\n \t\t\t     );\n-\tif (rc < 0)\n-\t\tdev_err(&port->dev, \""Reading line status failed (error = %d)\\n\"",\n-\t\t\trc);\n-\telse {\n+\tif (rc != KLSI_STATUSBUF_LEN) {\n+\t\tdev_err(&port->dev, \""reading line status failed: %d\\n\"", rc);\n+\t\tif (rc >= 0)\n+\t\t\trc = -EIO;\n+\t} else {\n \t\tstatus = get_unaligned_le16(status_buf);\n \n \t\tdev_info(&port->serial->dev->dev, \""read status %x %x\\n\"",""}","static int klsi_105_get_line_state(struct usb_serial_port *port,
				   unsigned long *line_state_p)
{
	int rc;
	u8 *status_buf;
	__u16 status;

	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");

	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
	if (!status_buf)
		return -ENOMEM;

	status_buf[0] = 0xff;
	status_buf[1] = 0xff;
	rc = usb_control_msg(port->serial->dev,
			     usb_rcvctrlpipe(port->serial->dev, 0),
			     KL5KUSB105A_SIO_POLL,
			     USB_TYPE_VENDOR | USB_DIR_IN,
			     0, /* value */
			     0, /* index */
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
	if (rc != KLSI_STATUSBUF_LEN) {
		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
		if (rc >= 0)
			rc = -EIO;
	} else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
			 status_buf[0], status_buf[1]);

		*line_state_p = klsi_105_status2linestate(status);
	}

	kfree(status_buf);
	return rc;
}
","static int klsi_105_get_line_state(struct usb_serial_port *port,
				   unsigned long *line_state_p)
{
	int rc;
	u8 *status_buf;
	__u16 status;

	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");

	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
	if (!status_buf)
		return -ENOMEM;

	status_buf[0] = 0xff;
	status_buf[1] = 0xff;
	rc = usb_control_msg(port->serial->dev,
			     usb_rcvctrlpipe(port->serial->dev, 0),
			     KL5KUSB105A_SIO_POLL,
			     USB_TYPE_VENDOR | USB_DIR_IN,
			     0, /* value */
			     0, /* index */
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
	if (rc < 0)
		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
			rc);
	else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
			 status_buf[0], status_buf[1]);

		*line_state_p = klsi_105_status2linestate(status);
	}

	kfree(status_buf);
	return rc;
}
",C,"	if (rc != KLSI_STATUSBUF_LEN) {
		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
		if (rc >= 0)
			rc = -EIO;
	} else {
","	if (rc < 0)
		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
			rc);
	else {
",,"@@ -192,10 +192,11 @@ static int klsi_105_get_line_state(struct usb_serial_port *port,
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
-	if (rc < 0)
-		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
-			rc);
-	else {
+	if (rc != KLSI_STATUSBUF_LEN) {
+		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
+		if (rc >= 0)
+			rc = -EIO;
+	} else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",",linux,146cc8a17a3b4996f6805ee5c080e7101277c410,55fa15b5987db22b4f35d3f0798928c126be5f1c,1,"static int klsi_105_get_line_state(struct usb_serial_port *port,
				   unsigned long *line_state_p)
{
	int rc;
	u8 *status_buf;
	__u16 status;

	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");

	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
	if (!status_buf)
		return -ENOMEM;

	status_buf[0] = 0xff;
	status_buf[1] = 0xff;
	rc = usb_control_msg(port->serial->dev,
			     usb_rcvctrlpipe(port->serial->dev, 0),
			     KL5KUSB105A_SIO_POLL,
			     USB_TYPE_VENDOR | USB_DIR_IN,
			     0, /* value */
			     0, /* index */
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
//flaw_line_below:
	if (rc < 0)
//flaw_line_below:
		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
//flaw_line_below:
			rc);
//flaw_line_below:
	else {
//fix_flaw_line_below:
//	if (rc != KLSI_STATUSBUF_LEN) {
//fix_flaw_line_below:
//		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
//fix_flaw_line_below:
//		if (rc >= 0)
//fix_flaw_line_below:
//			rc = -EIO;
//fix_flaw_line_below:
//	} else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
			 status_buf[0], status_buf[1]);

		*line_state_p = klsi_105_status2linestate(status);
	}

	kfree(status_buf);
	return rc;
}
",181561,"static int klsi_105_get_line_state(struct usb_serial_port *port,
				   unsigned long *line_state_p)
{
	int rc;
	u8 *status_buf;
	__u16 status;

	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");

	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
	if (!status_buf)
		return -ENOMEM;

	status_buf[0] = 0xff;
	status_buf[1] = 0xff;
	rc = usb_control_msg(port->serial->dev,
			     usb_rcvctrlpipe(port->serial->dev, 0),
			     KL5KUSB105A_SIO_POLL,
			     USB_TYPE_VENDOR | USB_DIR_IN,
			     0, /* value */
			     0, /* index */
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
	if (rc < 0)
		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
			rc);
	else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
			 status_buf[0], status_buf[1]);

		*line_state_p = klsi_105_status2linestate(status);
	}

	kfree(status_buf);
	return rc;
}
","static int klsi_105_get_line_state(struct usb_serial_port *port,
				   unsigned long *line_state_p)
{
	int rc;
	u8 *status_buf;
	__u16 status;

	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");

	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
	if (!status_buf)
		return -ENOMEM;

	status_buf[0] = 0xff;
	status_buf[1] = 0xff;
	rc = usb_control_msg(port->serial->dev,
			     usb_rcvctrlpipe(port->serial->dev, 0),
			     KL5KUSB105A_SIO_POLL,
			     USB_TYPE_VENDOR | USB_DIR_IN,
			     0, /* value */
			     0, /* index */
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
	if (rc != KLSI_STATUSBUF_LEN) {
		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
		if (rc >= 0)
			rc = -EIO;
	} else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
			 status_buf[0], status_buf[1]);

		*line_state_p = klsi_105_status2linestate(status);
	}

	kfree(status_buf);
	return rc;
}
","The provided code defines a function `klsi_105_get_line_state` that retrieves the line state of a USB serial port. It begins by allocating a buffer for status data and checks for successful memory allocation. The function then sends a control message to the USB device to request the line status, logging the operation's success or failure. If successful, it reads the status from the buffer, converts it to a line state format using the `klsi_105_status2linestate` function, and stores the result in the provided pointer. Finally, it frees the allocated buffer and returns the result of the USB operation.","The code defines a function that retrieves the line state of a USB serial port by sending a polling request to the device. It starts by allocating memory for a buffer to hold the status data and checks if the allocation was successful. A control message is then sent to the USB device to request the line status, with logging for both success and failure. Upon successful retrieval, the status is processed to convert it into a line state format, which is then stored in a provided pointer. Finally, the allocated memory is freed before returning the result of the operation.","The vulnerability in the original code arises from the lack of proper validation of the return value from the `usb_control_msg` function, which could lead to incorrect handling of error conditions. In the fixed code, the check is modified to ensure that the return code matches the expected buffer length, enhancing error handling. If the return value does not equal the expected length, an error message is logged, and the return code is set to a specific error value if the operation was not negative. This change prevents potential misuse of uninitialized or incorrect data, thereby improving the robustness of the function.","The vulnerability in the original code stems from inadequate error handling after a critical operation, which could lead to the use of invalid or uninitialized data if the operation fails. The fixed code addresses this issue by implementing a check to ensure that the result of the operation matches the expected length of the data buffer. If the result does not meet this expectation, an error message is logged, and a specific error code is returned, thereby preventing the function from proceeding with potentially erroneous data. This enhancement significantly improves the reliability and safety of the code.","The vulnerability was fixed by modifying the error handling logic after the call to `usb_control_msg`. In the original code, the return value was only checked for negativity, which could lead to incorrect assumptions about the success of the operation. The updated code now checks if the return code equals `KLSI_STATUSBUF_LEN`, ensuring that the expected amount of data was received. If the return value does not match, an error message is logged using `dev_err`, and the return code is set to `-EIO` if the operation was not already negative. This change enhances the robustness of the function by preventing the use of invalid data.","The vulnerability was addressed by enhancing the error handling mechanism following a critical operation. The revised code now verifies that the result of the operation matches the expected data length, ensuring that the correct amount of data has been received. If the result does not align with this expectation, an error message is logged, and a specific error code is returned if the operation was not already flagged as an error. This improvement prevents the function from proceeding with potentially invalid or uninitialized data, thereby increasing the overall reliability and safety of the code."
1,181621,181621,,Remote,Not required,,CVE-2017-0380,https://www.cvedetails.com/cve/CVE-2017-0380/,CWE-532,Medium,Partial,,,2017-09-18,4.3,"The rend_service_intro_established function in or/rendservice.c in Tor before 0.2.8.15, 0.2.9.x before 0.2.9.12, 0.3.0.x before 0.3.0.11, 0.3.1.x before 0.3.1.7, and 0.3.2.x before 0.3.2.1-alpha, when SafeLogging is disabled, allows attackers to obtain sensitive information by leveraging access to the log files of a hidden service, because uninitialized stack data is included in an error message about construction of an introduction point circuit.",2017-11-05,+Info ,2,https://github.com/torproject/tor/commit/09ea89764a4d3a907808ed7d4fe42abfe64bd486,09ea89764a4d3a907808ed7d4fe42abfe64bd486,"Fix log-uninitialized-stack bug in rend_service_intro_established.

Fixes bug 23490; bugfix on 0.2.7.2-alpha.

TROVE-2017-008
CVE-2017-0380",2,src/or/rendservice.c,"{""sha"": ""4b9c5b0a127bbb78d94809aa1658a45f72608762"", ""filename"": ""changes/trove-2017-008"", ""status"": ""added"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torproject/tor/blob/09ea89764a4d3a907808ed7d4fe42abfe64bd486/changes/trove-2017-008"", ""raw_url"": ""https://github.com/torproject/tor/raw/09ea89764a4d3a907808ed7d4fe42abfe64bd486/changes/trove-2017-008"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/changes/trove-2017-008?ref=09ea89764a4d3a907808ed7d4fe42abfe64bd486"", ""patch"": ""@@ -0,0 +1,5 @@\n+  o Major bugfixes (security, hidden services, loggging):\n+    - Fix a bug where we could log uninitialized stack when a certain\n+      hidden service error occurred while SafeLogging was disabled.\n+      Fixes bug #23490; bugfix on 0.2.7.2-alpha.\n+      This is also tracked as TROVE-2017-008 and CVE-2017-0380.""}<_**next**_>{""sha"": ""8087e884998ce2b299c09f445119e8eb6a0b0473"", ""filename"": ""src/or/rendservice.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torproject/tor/blob/09ea89764a4d3a907808ed7d4fe42abfe64bd486/src/or/rendservice.c"", ""raw_url"": ""https://github.com/torproject/tor/raw/09ea89764a4d3a907808ed7d4fe42abfe64bd486/src/or/rendservice.c"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/src/or/rendservice.c?ref=09ea89764a4d3a907808ed7d4fe42abfe64bd486"", ""patch"": ""@@ -3372,6 +3372,8 @@ rend_service_intro_established(origin_circuit_t *circuit,\n              (unsigned)circuit->base_.n_circ_id);\n     goto err;\n   }\n+  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n+                rend_pk_digest, REND_SERVICE_ID_LEN);\n   /* We've just successfully established a intro circuit to one of our\n    * introduction point, account for it. */\n   intro = find_intro_point(circuit);\n@@ -3388,8 +3390,6 @@ rend_service_intro_established(origin_circuit_t *circuit,\n   service->desc_is_dirty = time(NULL);\n   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n \n-  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n-                rend_pk_digest, REND_SERVICE_ID_LEN);\n   log_info(LD_REND,\n            \""Received INTRO_ESTABLISHED cell on circuit %u for service %s\"",\n            (unsigned)circuit->base_.n_circ_id, serviceid);""}","rend_service_intro_established(origin_circuit_t *circuit,
                               const uint8_t *request,
                               size_t request_len)
{
  rend_service_t *service;
  rend_intro_point_t *intro;
  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];
  (void) request;
  (void) request_len;
  tor_assert(circuit->rend_data);
  /* XXX: This is version 2 specific (only supported one for now). */
  const char *rend_pk_digest =
    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);

  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
    log_warn(LD_PROTOCOL,
             ""received INTRO_ESTABLISHED cell on non-intro circuit."");
    goto err;
  }
  service = rend_service_get_by_pk_digest(rend_pk_digest);
  if (!service) {
    log_warn(LD_REND, ""Unknown service on introduction circuit %u."",
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
  if (intro == NULL) {
    log_warn(LD_REND,
             ""Introduction circuit established without a rend_intro_point_t ""
             ""object for service %s on circuit %u"",
             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);
    goto err;
  }
  intro->circuit_established = 1;
  /* We might not have every introduction point ready but at this point we
   * know that the descriptor needs to be uploaded. */
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);

  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully
   * used the circ */
  pathbias_mark_use_success(circuit);

  return 0;
 err:
  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);
  return -1;
}
","rend_service_intro_established(origin_circuit_t *circuit,
                               const uint8_t *request,
                               size_t request_len)
{
  rend_service_t *service;
  rend_intro_point_t *intro;
  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];
  (void) request;
  (void) request_len;
  tor_assert(circuit->rend_data);
  /* XXX: This is version 2 specific (only supported one for now). */
  const char *rend_pk_digest =
    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);

  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
    log_warn(LD_PROTOCOL,
             ""received INTRO_ESTABLISHED cell on non-intro circuit."");
    goto err;
  }
  service = rend_service_get_by_pk_digest(rend_pk_digest);
  if (!service) {
    log_warn(LD_REND, ""Unknown service on introduction circuit %u."",
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
  if (intro == NULL) {
    log_warn(LD_REND,
             ""Introduction circuit established without a rend_intro_point_t ""
             ""object for service %s on circuit %u"",
             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);
    goto err;
  }
  intro->circuit_established = 1;
  /* We might not have every introduction point ready but at this point we
   * know that the descriptor needs to be uploaded. */
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);

  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully
   * used the circ */
  pathbias_mark_use_success(circuit);

  return 0;
 err:
  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);
  return -1;
}
",C,"  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
","  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
",,"@@ -3372,6 +3372,8 @@ rend_service_intro_established(origin_circuit_t *circuit,
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
+  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
+                rend_pk_digest, REND_SERVICE_ID_LEN);
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
@@ -3388,8 +3390,6 @@ rend_service_intro_established(origin_circuit_t *circuit,
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
-  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
-                rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);",tor,09ea89764a4d3a907808ed7d4fe42abfe64bd486,e468498469ebb2a676e74884a34fa017fa8ac3a4,1,"rend_service_intro_established(origin_circuit_t *circuit,
                               const uint8_t *request,
                               size_t request_len)
{
  rend_service_t *service;
  rend_intro_point_t *intro;
  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];
  (void) request;
  (void) request_len;
  tor_assert(circuit->rend_data);
  /* XXX: This is version 2 specific (only supported one for now). */
  const char *rend_pk_digest =
    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);

  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
    log_warn(LD_PROTOCOL,
             ""received INTRO_ESTABLISHED cell on non-intro circuit."");
    goto err;
  }
  service = rend_service_get_by_pk_digest(rend_pk_digest);
  if (!service) {
    log_warn(LD_REND, ""Unknown service on introduction circuit %u."",
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
//fix_flaw_line_below:
//  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
//fix_flaw_line_below:
//                rend_pk_digest, REND_SERVICE_ID_LEN);
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
  if (intro == NULL) {
    log_warn(LD_REND,
             ""Introduction circuit established without a rend_intro_point_t ""
             ""object for service %s on circuit %u"",
             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);
    goto err;
  }
  intro->circuit_established = 1;
  /* We might not have every introduction point ready but at this point we
   * know that the descriptor needs to be uploaded. */
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
//flaw_line_below:
  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
//flaw_line_below:
                rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);

  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully
   * used the circ */
  pathbias_mark_use_success(circuit);

  return 0;
 err:
  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);
  return -1;
}
",181621,"rend_service_intro_established(origin_circuit_t *circuit,
                               const uint8_t *request,
                               size_t request_len)
{
  rend_service_t *service;
  rend_intro_point_t *intro;
  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];
  (void) request;
  (void) request_len;
  tor_assert(circuit->rend_data);
  /* XXX: This is version 2 specific (only supported one for now). */
  const char *rend_pk_digest =
    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);

  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
    log_warn(LD_PROTOCOL,
             ""received INTRO_ESTABLISHED cell on non-intro circuit."");
    goto err;
  }
  service = rend_service_get_by_pk_digest(rend_pk_digest);
  if (!service) {
    log_warn(LD_REND, ""Unknown service on introduction circuit %u."",
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
  if (intro == NULL) {
    log_warn(LD_REND,
             ""Introduction circuit established without a rend_intro_point_t ""
             ""object for service %s on circuit %u"",
             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);
    goto err;
  }
  intro->circuit_established = 1;
  /* We might not have every introduction point ready but at this point we
   * know that the descriptor needs to be uploaded. */
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);

  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully
   * used the circ */
  pathbias_mark_use_success(circuit);

  return 0;
 err:
  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);
  return -1;
}
","rend_service_intro_established(origin_circuit_t *circuit,
                               const uint8_t *request,
                               size_t request_len)
{
  rend_service_t *service;
  rend_intro_point_t *intro;
  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];
  (void) request;
  (void) request_len;
  tor_assert(circuit->rend_data);
  /* XXX: This is version 2 specific (only supported one for now). */
  const char *rend_pk_digest =
    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);

  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
    log_warn(LD_PROTOCOL,
             ""received INTRO_ESTABLISHED cell on non-intro circuit."");
    goto err;
  }
  service = rend_service_get_by_pk_digest(rend_pk_digest);
  if (!service) {
    log_warn(LD_REND, ""Unknown service on introduction circuit %u."",
              (unsigned)circuit->base_.n_circ_id);
     goto err;
   }
  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                rend_pk_digest, REND_SERVICE_ID_LEN);
   /* We've just successfully established a intro circuit to one of our
    * introduction point, account for it. */
   intro = find_intro_point(circuit);
  if (intro == NULL) {
    log_warn(LD_REND,
             ""Introduction circuit established without a rend_intro_point_t ""
             ""object for service %s on circuit %u"",
             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);
    goto err;
  }
  intro->circuit_established = 1;
  /* We might not have every introduction point ready but at this point we
   * know that the descriptor needs to be uploaded. */
   service->desc_is_dirty = time(NULL);
   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);
 
   log_info(LD_REND,
            ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"",
            (unsigned)circuit->base_.n_circ_id, serviceid);

  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully
   * used the circ */
  pathbias_mark_use_success(circuit);

  return 0;
 err:
  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);
  return -1;
}
","The provided code defines a function `rend_service_intro_established` that handles the establishment of an introduction circuit for a Tor hidden service. It first verifies that the circuit is intended for introduction purposes and retrieves the service associated with the provided public key digest. If the service is valid, it marks the introduction point as established and updates the service descriptor's status. The function logs relevant information and changes the circuit's purpose to indicate successful establishment. If any checks fail, it logs a warning and marks the circuit for closure, returning an error status.","The code defines a function that manages the establishment of a secure communication channel for a hidden service within a privacy-focused network. It verifies that the channel is intended for the correct purpose and retrieves the associated service based on a unique identifier. Upon successful validation, it marks the introduction point as established and updates the service's status to indicate that its descriptor needs to be refreshed. The function logs relevant information about the process, and if any validation fails, it logs a warning and initiates the closure of the communication channel, returning an error status.","The vulnerability in the original code stemmed from the lack of proper validation for the introduction circuit's purpose and the associated service. Specifically, if the circuit was not intended for establishing an introduction, the code would still attempt to process the request, potentially leading to undefined behavior or security issues. The fix introduced checks to ensure that the circuit's purpose is verified before proceeding, and it also confirmed the existence of the service associated with the public key digest. This added validation prevents the function from executing further actions on invalid circuits or services, enhancing overall security.","The vulnerability in the original code arose from insufficient validation of the circuit's intended purpose and the associated service, which could lead to processing requests on invalid circuits. This lack of checks allowed for potential exploitation, as the function could execute actions without confirming that the circuit was appropriate for establishing an introduction. The fix implemented additional validation steps to ensure that the circuit's purpose was correct and that the service was valid before proceeding. This enhancement effectively mitigated the risk of executing operations on unauthorized or incorrect circuits, thereby improving the overall security of the system.","The vulnerability was fixed by introducing critical validation checks before processing the introduction circuit. The code now verifies that the circuit's purpose is set to the correct type using a conditional check on `circuit->base_.purpose`. If the purpose is not appropriate, a warning is logged, and the function exits early. Additionally, the code checks for the existence of the service associated with the public key digest through `rend_service_get_by_pk_digest`. If the service is not found, it logs a warning and also exits, preventing further execution on invalid circuits or services and enhancing overall security.","The vulnerability was addressed by implementing additional validation checks to ensure that the circuit is appropriate for establishing an introduction. The code now verifies that the circuit's intended purpose aligns with the expected type before proceeding with any operations. If the purpose is incorrect, the function logs a warning and exits early, preventing further processing. Furthermore, the code checks for the existence of the associated service, and if it is not found, it logs a warning and terminates the operation. These enhancements effectively prevent unauthorized actions on invalid circuits, thereby improving the overall security of the system."
