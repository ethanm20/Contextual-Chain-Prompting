,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,182200,182200,,Remote,Not required,,CVE-2018-17082,https://www.cvedetails.com/cve/CVE-2018-17082/,CWE-79,Medium,,Partial,,2018-09-16,4.3,"The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.",2019-08-19,XSS ,1,https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e,23b057742e3cf199612fa8050ae86cae675e214e,"Fix for bug #76582

The brigade seems to end up in a messed up state if something fails
in shutdown, so we clean it up.",0,sapi/apache2handler/sapi_apache2.c,"{""sha"": ""0ebca9bca863909aef3fd3417bb3baad1605df34"", ""filename"": ""sapi/apache2handler/sapi_apache2.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""raw_url"": ""https://github.com/php/php-src/raw/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/apache2handler/sapi_apache2.c?ref=23b057742e3cf199612fa8050ae86cae675e214e"", ""patch"": ""@@ -678,6 +678,7 @@ zend_first_try {\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n ""}","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",C,"		apr_brigade_cleanup(brigade);
",,,"@@ -678,6 +678,7 @@ zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
+		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 ",php-src,23b057742e3cf199612fa8050ae86cae675e214e,1ba3314335b8bb7c86c24443588d5ef9c55d4a44,1,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
//fix_flaw_line_below:
//		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",182200,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","The provided code defines a function `php_handler` that processes incoming HTTP requests for PHP scripts in an Apache server environment. It initializes a context for the PHP execution, checks various conditions such as the request handler type and file type, and sets up necessary CGI variables. The function handles different scenarios, including executing PHP scripts or highlighting source code, while managing memory and cleanup operations. It also logs errors for missing scripts or directory access attempts. Finally, it passes the output to the next filter in the Apache processing chain and ensures proper cleanup of resources after the request is processed.","The code defines a function that handles HTTP requests for executing scripts in a web server environment. It initializes a context for processing, checks the request's validity, and sets up necessary variables for execution. The function manages different scenarios, such as executing scripts or displaying source code, while ensuring proper error handling and logging for issues like missing files or unauthorized access. It also prepares the output for further processing by the server and performs cleanup operations to free resources after the request is completed, maintaining efficient memory management throughout the process.","The vulnerability in the original code stemmed from inadequate checks on the request's handler type and file type, which could allow unauthorized script execution or directory access. Specifically, the absence of checks for certain conditions, such as the execution of scripts when the engine was turned off or when the file type was a directory, could lead to security breaches. The fixed code introduces additional checks, such as verifying the handler against specific types and ensuring that the execution environment is properly configured, thereby preventing unauthorized access and ensuring that only valid scripts are executed, enhancing overall security.","The vulnerability in the original code arose from insufficient validation of incoming requests, which could allow unauthorized script execution or access to directories. This lack of checks meant that requests could be processed even when the execution environment was not properly configured, leading to potential security risks. The fixed code addresses this issue by implementing stricter validation criteria, ensuring that only requests with valid handlers and file types are processed. Additionally, it enforces checks to confirm that the execution environment is active, thereby preventing unauthorized access and enhancing the overall security of the script execution process.","The vulnerability was fixed by introducing additional validation checks within the request handling process. The code now verifies the request's handler type against specific constants, ensuring that only valid script types are processed. For instance, it checks if the handler matches certain predefined types and confirms that the execution engine is enabled using the `AP2(engine)` condition. Furthermore, it includes checks for file types, logging errors for missing scripts or attempts to execute directories. These enhancements ensure that only legitimate requests are processed, significantly improving the security of the script execution environment.","The vulnerability was addressed by implementing stricter validation checks for incoming requests to ensure that only authorized and valid script types are processed. The updated code now verifies the request's handler against specific criteria, preventing the execution of unauthorized scripts. Additionally, it enforces checks to confirm that the execution environment is active and that the requested file is not a directory or missing. These enhancements effectively restrict access to legitimate requests only, thereby mitigating the risk of unauthorized script execution and improving the overall security of the system."
1,184492,184492,,Remote,Not required,,CVE-2012-2872,https://www.cvedetails.com/cve/CVE-2012-2872/,CWE-79,Medium,,Partial,,2012-08-31,4.3,Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.,2018-10-30,XSS ,3,https://github.com/chromium/chromium/commit/68b6502084af7e2021f7321633f5fbb5f997a58b,68b6502084af7e2021f7321633f5fbb5f997a58b,"Properly EscapeForHTML potentially malicious input from X.509 certificates.

BUG=142956

TEST=Create an X.509 certificate with a CN field that contains JavaScript.
When you get the SSL error screen, check that the HTML + JavaScript is
escape instead of being treated as HTML and/or script.

Review URL: https://chromiumcodereview.appspot.com/10827364

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@152210 0039d316-1c4b-4281-b951-d872f2087c98",2,chrome/browser/ssl/ssl_error_info.cc,"{""sha"": ""d33960e55ff85b6899415bd0be1f0f9e14daca04"", ""filename"": ""chrome/browser/ssl/ssl_error_info.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ssl/ssl_error_info.cc?ref=68b6502084af7e2021f7321633f5fbb5f997a58b"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""grit/chromium_strings.h\""\n #include \""grit/generated_resources.h\""\n #include \""net/base/cert_status_flags.h\""\n+#include \""net/base/escape.h\""\n #include \""net/base/net_errors.h\""\n #include \""net/base/ssl_info.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n-                                     UTF8ToUTF16(dns_names[i]),\n+                                     net::EscapeForHTML(\n+                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n-              UTF8ToUTF16(cert->subject().common_name),\n+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }""}","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",C,"                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
","                                     UTF8ToUTF16(dns_names[i]),
              UTF8ToUTF16(cert->subject().common_name),
",,"@@ -12,6 +12,7 @@
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
 #include ""net/base/cert_status_flags.h""
+#include ""net/base/escape.h""
 #include ""net/base/net_errors.h""
 #include ""net/base/ssl_info.h""
 #include ""ui/base/l10n/l10n_util.h""
@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
-                                     UTF8ToUTF16(dns_names[i]),
+                                     net::EscapeForHTML(
+                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
-              UTF8ToUTF16(cert->subject().common_name),
+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }",Chrome,68b6502084af7e2021f7321633f5fbb5f997a58b,4150ecc30d10d0f211033346f10611e3c6083160,1,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      // If the certificate contains multiple DNS names, we choose the most
      // representative one -- either the DNS name that's also in the subject
      // field, or the first one.  If this heuristic turns out to be
      // inadequate, we can consider choosing the DNS name that is the
      // ""closest match"" to the host name in the request URL, or listing all
      // the DNS names with an HTML <ul>.
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
//flaw_line_below:
                                     UTF8ToUTF16(dns_names[i]),
//fix_flaw_line_below:
//                                     net::EscapeForHTML(
//fix_flaw_line_below:
//                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
//flaw_line_below:
              UTF8ToUTF16(cert->subject().common_name),
//fix_flaw_line_below:
//              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        // Then it must be not yet valid.  We don't check that it is not yet
        // valid as there is still a very unlikely chance that the cert might
        // have become valid since the error occurred.
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",184492,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","The provided code defines a method `CreateError` within the `SSLErrorInfo` class, which generates detailed error information based on the type of SSL certificate error encountered. It takes an `ErrorType`, an `X509Certificate`, and a request URL as parameters. Depending on the error type (e.g., common name invalid, date invalid, authority invalid), the method constructs a title, detailed message, short description, and additional information, utilizing localization utilities for user-friendly text. Finally, it returns an `SSLErrorInfo` object encapsulating this error information, facilitating user awareness and understanding of SSL issues.","The code defines a method that generates detailed error information related to SSL certificate issues based on the type of error encountered. It takes parameters representing the error type, a certificate, and a request URL. Depending on the specific error, the method constructs a title, detailed explanation, short description, and additional context, ensuring the messages are user-friendly and localized. The method ultimately returns an object containing this comprehensive error information, which aids users in understanding the nature of SSL problems and the implications for their connection security.","The vulnerability in the original code stemmed from the potential for cross-site scripting (XSS) attacks due to unescaped output of user-controlled data, specifically the DNS names and common names derived from the certificate. In the fixed code, the addition of the `net::EscapeForHTML` function ensures that any special characters in these names are properly escaped before being included in the error details. This change mitigates the risk of malicious scripts being executed in the user's browser by sanitizing the output, thereby enhancing the security of the error reporting mechanism.","The vulnerability in the original code was related to the risk of cross-site scripting (XSS) attacks, as it allowed user-controlled data to be displayed without proper sanitization. This could enable an attacker to inject malicious scripts through the output, compromising the security of the application. The fix involved implementing a mechanism to escape special characters in the user-controlled data before it was included in the error messages. This change effectively mitigated the risk of XSS by ensuring that any potentially harmful input was rendered harmless, thereby enhancing the overall security of the error reporting process.","The vulnerability was fixed by incorporating the `net::EscapeForHTML` function to sanitize user-controlled data before it was included in the error messages. Specifically, this function was applied to the DNS names and the common name extracted from the certificate, ensuring that any special characters were properly escaped. For instance, the common name and DNS names were passed through `net::EscapeForHTML` when constructing the details and extra information strings. This sanitization prevents the execution of malicious scripts, effectively mitigating the risk of cross-site scripting (XSS) attacks in the error reporting mechanism.","The vulnerability was fixed by implementing a sanitization process for user-controlled data before it was displayed in error messages. This involved escaping special characters in the data, which prevents the inclusion of potentially harmful scripts in the output. By ensuring that any user input is properly sanitized, the risk of cross-site scripting (XSS) attacks was significantly reduced. This change enhances the security of the application by making it more resilient against malicious attempts to inject code through the error reporting mechanism, thereby protecting users from potential exploitation."
2,185960,185960,,Remote,Not required,,CVE-2016-5147,https://www.cvedetails.com/cve/CVE-2016-5147/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles deferred page loads, which allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2017-08-12,XSS ,3,https://github.com/chromium/chromium/commit/5472db1c7eca35822219d03be5c817d9a9258c11,5472db1c7eca35822219d03be5c817d9a9258c11,"Always call UpdateCompositedScrollOffset, not just for the root layer

Bug: 927560
Change-Id: I1d5522aae4f11dd3f5b8947bb089bac1bf19bdb4
Reviewed-on: https://chromium-review.googlesource.com/c/1452701
Reviewed-by: Chris Harrelson <chrishtr@chromium.org>
Commit-Queue: Mason Freed <masonfreed@chromium.org>
Cr-Commit-Position: refs/heads/master@{#628942}",1,third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc,"{""sha"": ""7f1f0a4890e03135c6d704b67d0de508ffda6c7d"", ""filename"": ""third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc?ref=5472db1c7eca35822219d03be5c817d9a9258c11"", ""patch"": ""@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n-        Layer()->IsRootLayer() && scrolling_coordinator &&\n+        (Layer()->IsRootLayer() ||\n+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&\n+        scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {""}","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",C,"        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
","        Layer()->IsRootLayer() && scrolling_coordinator &&
",,"@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
-        Layer()->IsRootLayer() && scrolling_coordinator &&
+        (Layer()->IsRootLayer() ||
+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
+        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {",Chrome,5472db1c7eca35822219d03be5c817d9a9258c11,756828f7b127d39fb9863dc0c5db67640a88724f,1,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
//flaw_line_below:
        Layer()->IsRootLayer() && scrolling_coordinator &&
//fix_flaw_line_below:
//        (Layer()->IsRootLayer() ||
//fix_flaw_line_below:
//         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
//fix_flaw_line_below:
//        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        // In non-BGPT mode, we need to do a full sub-tree update here, because
        // we need to update the position property to compute
        // offset_to_transform_parent. For more context, see the comment from
        // chrishtr@ here:
        // https://chromium-review.googlesource.com/c/chromium/src/+/1403639/6/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    // If we have fixed elements and we scroll the root layer we might
    // change compositing since the fixed elements might now overlap a
    // composited layer.
    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185960,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","The `UpdateCompositingLayersAfterScroll` function is responsible for managing the compositing layers in a scrollable area after a scroll event occurs. It first checks if the compositor is in compositing mode and whether composited scrolling is being used. If so, it attempts to update the scroll offset through the scrolling coordinator. If the scroll is not handled, it marks the layer for a graphics update unless certain runtime features are enabled. Additionally, if the layer is the root layer and the associated frame has viewport-constrained objects, it requests an update for compositing inputs, ensuring that the visual representation remains accurate after scrolling.","The function manages the update of compositing layers in a scrollable area following a scroll event. It first verifies if the compositor is active and whether composited scrolling is enabled. If composited scrolling is in use, it attempts to update the scroll offset; if this update is not successful, it marks the layer for a graphics update unless specific features are active. Additionally, if the layer is the primary one and the associated frame contains certain objects, it requests an update for compositing inputs, ensuring that the visual output accurately reflects any changes resulting from the scroll action.","The vulnerability in the original code stemmed from the handling of scroll events, particularly when the layer was not the root layer. The condition for updating the composited scroll offset was too restrictive, potentially allowing for improper handling of scroll events, which could lead to visual inconsistencies or crashes. The fix introduced a more inclusive condition that checks if the layer is either the root layer or if specific runtime features are enabled before attempting to update the scroll offset. This change ensures that scroll events are managed correctly across different layer types, enhancing stability and visual integrity.","The vulnerability in the original code arose from inadequate handling of scroll events, particularly when the layer was not the primary one. This limitation could result in improper updates to the scroll offset, leading to visual inconsistencies or application crashes. The fix addressed this issue by broadening the conditions under which scroll offsets could be updated, allowing for more scenarios to be handled correctly. By ensuring that both primary and certain feature-enabled layers could properly process scroll events, the updated code enhances the overall stability and visual accuracy of the compositing layers during scrolling actions.","The vulnerability was fixed by modifying the condition that determines whether the scroll offset should be updated. In the original code, the update was only attempted if the layer was the root layer, which limited its effectiveness. The revised code introduces an additional check that allows the update to proceed if either the layer is the root layer or specific runtime features are enabled. This change ensures that the `ScrollingCoordinator` can successfully call `UpdateCompositedScrollOffset`, thereby improving the handling of scroll events across different layer types and enhancing the overall stability and visual consistency of the compositing process.","The vulnerability was addressed by expanding the conditions under which scroll offsets could be updated, allowing for a broader range of scenarios to be handled effectively. Previously, the update process was limited to only the primary layer, which restricted its functionality and could lead to inconsistencies. The fix introduced an additional check that permits updates when certain features are enabled, ensuring that scroll events are processed correctly across various layer types. This enhancement improves the overall robustness of the code, leading to better stability and visual accuracy during scrolling actions."
3,186016,186016,,Remote,Not required,,CVE-2016-5191,https://www.cvedetails.com/cve/CVE-2016-5191/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:",2018-01-04,XSS ,12,https://github.com/chromium/chromium/commit/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,"Prevent interpretating userinfo as url scheme when editing bookmarks

Chrome's Edit Bookmark dialog formats urls for display such that a
url of http://javascript:scripttext@host.com is later converted to a
javascript url scheme, allowing persistence of a script injection
attack within the user's bookmarks.

This fix prevents such misinterpretations by always showing the
scheme when a userinfo component is present within the url.

BUG=639126

Review-Url: https://codereview.chromium.org/2368593002
Cr-Commit-Position: refs/heads/master@{#422467}",4,chrome/browser/ui/bookmarks/bookmark_utils.cc,"{""sha"": ""ffebacaa0f6864fd57e0d0cda9b2dbb08552a13c"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 5, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {\n \n base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n-  // and trailing slash, and unescape most characters.  However, it's\n+  // and trailing slash, and unescape most characters. However, it's\n   // important not to drop any username/password, or unescape anything that\n   // changes the URL's meaning.\n-  return url_formatter::FormatUrl(\n-      url, url_formatter::kFormatUrlOmitAll &\n-               ~url_formatter::kFormatUrlOmitUsernamePassword,\n-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n+  url_formatter::FormatUrlTypes format_types =\n+      url_formatter::kFormatUrlOmitAll &\n+      ~url_formatter::kFormatUrlOmitUsernamePassword;\n+\n+  // If username is present, we must not omit the scheme because FixupURL() will\n+  // subsequently interpret the username as a scheme. crbug.com/639126\n+  if (url.has_username())\n+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n+\n+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n+                                  nullptr, nullptr, nullptr);\n }\n \n bool IsAppsShortcutEnabled(Profile* profile) {""}<_**next**_>{""sha"": ""1a5bf29d3599fce20c987c7c997a9c80aa331c7a"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.h?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -53,9 +53,8 @@ void GetURLAndTitleToBookmark(content::WebContents* web_contents,\n // all tabs. This is a preference modifier, not a visual modifier.\n void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context);\n \n-// Returns a formatted version of |url| appropriate to display to a user with\n-// the given |prefs|, which may be NULL.  When re-parsing this URL, clients\n-// should call url_formatter::FixupURL().\n+// Returns a formatted version of |url| appropriate to display to a user.\n+// When re-parsing this URL, clients should call url_formatter::FixupURL().\n base::string16 FormatBookmarkURLForDisplay(const GURL& url);\n \n // Returns whether the Apps shortcut is enabled. If true, then the visibility""}<_**next**_>{""sha"": ""4098467fc081af1263246bbe49d32fbea47d7ae9"", ""filename"": ""chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -259,6 +259,45 @@ void TearDown() override {\n   [controller_ cancel:nil];\n }\n \n+using BookmarkEditorControllerEditKeepsSchemeTest = CocoaProfileTest;\n+TEST_F(BookmarkEditorControllerEditKeepsSchemeTest, EditKeepsScheme) {\n+  // Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+  // when userinfo is present in the URL\n+  ASSERT_TRUE(profile());\n+\n+  BookmarkModel* model = BookmarkModelFactory::GetForBrowserContext(profile());\n+  const BookmarkNode* kParent = model->bookmark_bar_node();\n+  const base::string16 kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+  const BookmarkNode* kNode = model->AddURL(kParent, 0, base::string16(), kUrl);\n+\n+  BookmarkEditorController* controller = [[BookmarkEditorController alloc]\n+      initWithParentWindow:test_window()\n+                   profile:profile()\n+                    parent:kParent\n+                      node:kNode\n+                       url:GURL()\n+                     title:base::string16()\n+             configuration:BookmarkEditor::SHOW_TREE];\n+\n+  [controller runAsModalSheet];\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_NSEQ(base::SysUTF8ToNSString(kUrl.spec()),\n+              [[controller displayURL] stringByAppendingString:@\""/\""]);\n+\n+  [controller setDisplayName:base::SysUTF16ToNSString(kTitle)];\n+\n+  EXPECT_TRUE([controller okButtonEnabled]);\n+  [controller ok:nil];\n+\n+  ASSERT_EQ(1, kParent->child_count());\n+  const BookmarkNode* kChild = kParent->GetChild(0);\n+  EXPECT_EQ(kTitle, kChild->GetTitle());\n+  EXPECT_EQ(kUrl, kChild->url());\n+}\n+\n class BookmarkEditorControllerTreeTest : public CocoaProfileTest {\n \n  public:""}<_**next**_>{""sha"": ""2abe3d77823e2f144ab3c2c62b5117ac182d68d0"", ""filename"": ""chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -73,6 +73,13 @@ class BookmarkEditorViewTest : public testing::Test {\n       editor_->url_tf_->SetText(text);\n   }\n \n+  base::string16 GetURLText() const {\n+    if (editor_->details_.type != BookmarkEditor::EditDetails::NEW_FOLDER)\n+      return editor_->url_tf_->text();\n+\n+    return base::string16();\n+  }\n+\n   void ApplyEdits() {\n     editor_->ApplyEdits();\n   }\n@@ -332,6 +339,34 @@ TEST_F(BookmarkEditorViewTest, ChangeTitleNoTree) {\n   EXPECT_EQ(ASCIIToUTF16(\""new_a\""), new_node->GetTitle());\n }\n \n+// Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+// when userinfo is present in the URL\n+TEST_F(BookmarkEditorViewTest, EditKeepsScheme) {\n+  const BookmarkNode* kBBNode = model_->bookmark_bar_node();\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+\n+  CreateEditor(profile_.get(), kBBNode,\n+               BookmarkEditor::EditDetails::AddNodeInFolder(kBBNode, 1, kUrl,\n+                                                            base::string16()),\n+               BookmarkEditorView::SHOW_TREE);\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_EQ(ASCIIToUTF16(kUrl.spec()), GetURLText() + ASCIIToUTF16(\""/\""));\n+\n+  const base::string16& kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+  SetTitleText(kTitle);\n+\n+  ApplyEdits(editor_tree_model()->GetRoot()->GetChild(0));\n+\n+  ASSERT_EQ(4, kBBNode->child_count());\n+\n+  const BookmarkNode* kNewNode = kBBNode->GetChild(1);\n+\n+  EXPECT_EQ(kTitle, kNewNode->GetTitle());\n+  EXPECT_EQ(kUrl, kNewNode->url());\n+}\n+\n // Creates a new folder.\n TEST_F(BookmarkEditorViewTest, NewFolder) {\n   const BookmarkNode* bb_node = model_->bookmark_bar_node();""}"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
",C,"  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
","  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
",,"@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {
 
 base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
-  // and trailing slash, and unescape most characters.  However, it's
+  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
-  return url_formatter::FormatUrl(
-      url, url_formatter::kFormatUrlOmitAll &
-               ~url_formatter::kFormatUrlOmitUsernamePassword,
-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
+  url_formatter::FormatUrlTypes format_types =
+      url_formatter::kFormatUrlOmitAll &
+      ~url_formatter::kFormatUrlOmitUsernamePassword;
+
+  // If username is present, we must not omit the scheme because FixupURL() will
+  // subsequently interpret the username as a scheme. crbug.com/639126
+  if (url.has_username())
+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
+
+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
+                                  nullptr, nullptr, nullptr);
 }
 
 bool IsAppsShortcutEnabled(Profile* profile) {",Chrome,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,60cf29f2af9a364c215f71c9ac8fdd92c16b82b4,1," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
//flaw_line_below:
  // and trailing slash, and unescape most characters.  However, it's
//fix_flaw_line_below:
//  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
//flaw_line_below:
  return url_formatter::FormatUrl(
//flaw_line_below:
      url, url_formatter::kFormatUrlOmitAll &
//flaw_line_below:
               ~url_formatter::kFormatUrlOmitUsernamePassword,
//flaw_line_below:
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
//fix_flaw_line_below:
//  url_formatter::FormatUrlTypes format_types =
//fix_flaw_line_below:
//      url_formatter::kFormatUrlOmitAll &
//fix_flaw_line_below:
//      ~url_formatter::kFormatUrlOmitUsernamePassword;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // If username is present, we must not omit the scheme because FixupURL() will
//fix_flaw_line_below:
//  // subsequently interpret the username as a scheme. crbug.com/639126
//fix_flaw_line_below:
//  if (url.has_username())
//fix_flaw_line_below:
//    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
//fix_flaw_line_below:
//                                  nullptr, nullptr, nullptr);
 }
",186016," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
","The provided code defines a function `FormatBookmarkURLForDisplay` that takes a `GURL` object representing a URL as input and returns a formatted string of that URL. It utilizes the `url_formatter::FormatUrl` function to format the URL by omitting all components except for the username and password, which are preserved. The formatting options include unescaping spaces in the URL. The function is designed to create a user-friendly display of the URL, suitable for bookmarks, while ensuring sensitive information like username and password remains intact for potential use.","The code defines a function that formats a given URL for display purposes. It processes the URL to create a user-friendly version by omitting certain components while retaining sensitive information like the username and password. Additionally, it ensures that spaces within the URL are properly unescaped for better readability. The resulting formatted string is intended for use in contexts such as bookmarks, where a clean and clear presentation of the URL is essential, while still allowing for the inclusion of critical authentication details if necessary.","The vulnerability in the original code arises from the potential exposure of sensitive information, specifically the username, when formatting the URL. By omitting the scheme in the formatted output, the function could misinterpret the username as part of the scheme, leading to incorrect URL handling. The fixed code addresses this issue by checking if the URL contains a username and ensuring that the scheme is not omitted in such cases. This adjustment prevents misinterpretation and enhances security by maintaining the integrity of the URL structure, thereby safeguarding sensitive information during formatting.","The vulnerability in the original code stems from the risk of misinterpreting sensitive information, particularly when a username is present in the URL. By omitting the scheme during formatting, the function could mistakenly treat the username as part of the scheme, leading to incorrect URL processing and potential exposure of sensitive data. The revised code addresses this issue by implementing a check for the presence of a username, ensuring that the scheme is retained in such cases. This fix enhances the security of the URL handling process, preventing misinterpretation and protecting sensitive information during formatting.","The vulnerability was fixed by introducing a conditional check for the presence of a username in the URL. In the revised code, if the URL contains a username, the formatting options are adjusted to ensure that the scheme is not omitted by modifying the `format_types` variable. Specifically, the code updates `format_types` to exclude the option that omits the scheme, thereby preventing the misinterpretation of the username as part of the scheme. This change ensures that the URL is correctly formatted while maintaining the integrity of sensitive information, thereby enhancing overall security during the formatting process.","The vulnerability was addressed by implementing a check to determine if the URL contains a username. When a username is present, the code ensures that the scheme is retained during the formatting process, preventing any misinterpretation of the username as part of the scheme. This adjustment safeguards the integrity of the URL structure and protects sensitive information from being exposed or mishandled. By modifying the formatting options based on the presence of a username, the revised code enhances security and ensures that the URL is processed correctly without compromising user credentials."
4,186246,186246,,Remote,Not required,,CVE-2016-1652,https://www.cvedetails.com/cve/CVE-2016-1652/,CWE-79,Medium,,Partial,,2016-04-18,4.3,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,5,https://github.com/chromium/chromium/commit/7c5aa07be11cd63d953fbe66370c5869a52170bf,7c5aa07be11cd63d953fbe66370c5869a52170bf,"Use install_static::GetAppGuid instead of the hardcoded string in BrandcodeConfigFetcher.

Bug: 769756
Change-Id: Ifdcb0a5145ffad1d563562e2b2ea2390ff074cdc
Reviewed-on: https://chromium-review.googlesource.com/1213178
Reviewed-by: Dominic Battré <battre@chromium.org>
Commit-Queue: Vasilii Sukhanov <vasilii@chromium.org>
Cr-Commit-Position: refs/heads/master@{#590275}",6,chrome/browser/profile_resetter/brandcode_config_fetcher.cc,"{""sha"": ""c15c60c3ac2815695cc024d1e7891827c18383c5"", ""filename"": ""chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 10, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profile_resetter/brandcode_config_fetcher.cc?ref=7c5aa07be11cd63d953fbe66370c5869a52170bf"", ""patch"": ""@@ -9,7 +9,9 @@\n \n #include \""base/callback_helpers.h\""\n #include \""base/macros.h\""\n+#include \""base/strings/stringprintf.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""build/build_config.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/profile_resetter/brandcoded_default_settings.h\""\n #include \""libxml/parser.h\""\n@@ -20,30 +22,34 @@\n #include \""services/network/public/cpp/simple_url_loader.h\""\n #include \""services/network/public/mojom/url_loader_factory.mojom.h\""\n \n+#if defined(OS_WIN)\n+#include \""chrome/install_static/install_util.h\""\n+#endif  // defined(OS_WIN)\n+\n namespace {\n \n-const int kDownloadTimeoutSec = 10;\n-const char kPostXml[] =\n+constexpr char kDefaultAppID[] = \""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"";\n+constexpr int kDownloadTimeoutSec = 10;\n+constexpr char kPostXml[] =\n     \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\""?>\""\n     \""<request\""\n     \""    version=\\\""chromeprofilereset-1.1\\\""\""\n     \""    protocol=\\\""3.0\\\""\""\n     \""    installsource=\\\""profilereset\\\"">\""\n-    \""  <app appid=\\\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\\\"">\""\n-    \""    <data name=\\\""install\\\"" index=\\\""__BRANDCODE_PLACEHOLDER__\\\""/>\""\n+    \""  <app appid=\\\""%s\\\"">\""\n+    \""    <data name=\\\""install\\\"" index=\\\""%s\\\""/>\""\n     \""  </app>\""\n     \""</request>\"";\n \n // Returns the query to the server which can be used to retrieve the config.\n // |brand| is a brand code, it mustn't be empty.\n std::string GetUploadData(const std::string& brand) {\n+  std::string app_id(kDefaultAppID);\n+#if defined(OS_WIN)\n+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());\n+#endif  // defined(OS_WIN)\n   DCHECK(!brand.empty());\n-  std::string data(kPostXml);\n-  const std::string placeholder(\""__BRANDCODE_PLACEHOLDER__\"");\n-  size_t placeholder_pos = data.find(placeholder);\n-  DCHECK(placeholder_pos != std::string::npos);\n-  data.replace(placeholder_pos, placeholder.size(), brand);\n-  return data;\n+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());\n }\n \n // Extracts json master prefs from xml.""}"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
"," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
",C,"  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
","  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
",,"@@ -9,7 +9,9 @@
 
 #include ""base/callback_helpers.h""
 #include ""base/macros.h""
+#include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
+#include ""build/build_config.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/profile_resetter/brandcoded_default_settings.h""
 #include ""libxml/parser.h""
@@ -20,30 +22,34 @@
 #include ""services/network/public/cpp/simple_url_loader.h""
 #include ""services/network/public/mojom/url_loader_factory.mojom.h""
 
+#if defined(OS_WIN)
+#include ""chrome/install_static/install_util.h""
+#endif  // defined(OS_WIN)
+
 namespace {
 
-const int kDownloadTimeoutSec = 10;
-const char kPostXml[] =
+constexpr char kDefaultAppID[] = ""{8A69D345-D564-463C-AFF1-A69D9E530F96}"";
+constexpr int kDownloadTimeoutSec = 10;
+constexpr char kPostXml[] =
     ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
     ""<request""
     ""    version=\""chromeprofilereset-1.1\""""
     ""    protocol=\""3.0\""""
     ""    installsource=\""profilereset\"">""
-    ""  <app appid=\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"">""
-    ""    <data name=\""install\"" index=\""__BRANDCODE_PLACEHOLDER__\""/>""
+    ""  <app appid=\""%s\"">""
+    ""    <data name=\""install\"" index=\""%s\""/>""
     ""  </app>""
     ""</request>"";
 
 // Returns the query to the server which can be used to retrieve the config.
 // |brand| is a brand code, it mustn't be empty.
 std::string GetUploadData(const std::string& brand) {
+  std::string app_id(kDefaultAppID);
+#if defined(OS_WIN)
+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
+#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
-  std::string data(kPostXml);
-  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
-  size_t placeholder_pos = data.find(placeholder);
-  DCHECK(placeholder_pos != std::string::npos);
-  data.replace(placeholder_pos, placeholder.size(), brand);
-  return data;
+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
 
 // Extracts json master prefs from xml.",Chrome,7c5aa07be11cd63d953fbe66370c5869a52170bf,32582f5489e1e45821e4583886ba5c19845bb2ac,1," std::string GetUploadData(const std::string& brand) {
//fix_flaw_line_below:
//  std::string app_id(kDefaultAppID);
//fix_flaw_line_below:
//#if defined(OS_WIN)
//fix_flaw_line_below:
//  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
//fix_flaw_line_below:
//#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
//flaw_line_below:
  std::string data(kPostXml);
//flaw_line_below:
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
//flaw_line_below:
  size_t placeholder_pos = data.find(placeholder);
//flaw_line_below:
  DCHECK(placeholder_pos != std::string::npos);
//flaw_line_below:
  data.replace(placeholder_pos, placeholder.size(), brand);
//flaw_line_below:
  return data;
//fix_flaw_line_below:
//  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
",186246," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
","The provided code defines a function `GetUploadData` that takes a string parameter `brand`. It first checks that the `brand` is not empty using a debug assertion. The function initializes a string `data` with a predefined XML template (`kPostXml`). It then searches for a placeholder string (`__BRANDCODE_PLACEHOLDER__`) within `data` and asserts that the placeholder exists. If found, it replaces the placeholder with the provided `brand` string. Finally, the modified `data` string is returned, effectively customizing the XML template with the specified brand code.","The code defines a function that generates a customized XML string based on a provided brand name. It begins by ensuring that the brand name is not empty, which is crucial for the function's operation. A predefined XML template is used as the base, and the function searches for a specific placeholder within this template. Once the placeholder is located, it is replaced with the given brand name. The final output is the modified XML string, which incorporates the brand name, allowing for dynamic content generation tailored to different brands.","The vulnerability in the original code arises from the potential for an empty or invalid brand name to be used in the XML generation process, which could lead to malformed XML or injection attacks. In the fixed code, the function still checks that the brand is not empty using `DCHECK`, but it also incorporates an application ID that is conditionally set based on the operating system. By using `base::StringPrintf` to format the XML string with both the application ID and the brand name, the fixed code enhances security by ensuring that both values are properly handled and formatted, reducing the risk of injection vulnerabilities.","The vulnerability in the original code stems from the lack of proper validation and handling of the input, specifically the potential for an empty or invalid brand name, which could lead to malformed output or security risks such as injection attacks. The revised code addresses this issue by ensuring that the input is validated before use and incorporates additional context, such as an application identifier, which is conditionally set based on the operating system. This change not only enhances the robustness of the output but also mitigates the risk of injection vulnerabilities by ensuring that all components are properly formatted and validated before being included in the final output.","The vulnerability was fixed by incorporating a validation check for the brand name and ensuring that it is not empty using `DCHECK`. Additionally, the revised code introduces an application ID, which is conditionally assigned based on the operating system using `install_static::GetAppGuid()`. This ID is converted to a UTF-8 string format when on Windows. The use of `base::StringPrintf` to format the final XML string with both the application ID and the brand name enhances security by ensuring that both values are properly handled and formatted, thus reducing the risk of injection attacks and malformed output.","The vulnerability was addressed by implementing a validation check to ensure that the input is not empty, which helps prevent malformed output and potential security risks. Additionally, the revised code introduces a mechanism to include an application identifier that is conditionally set based on the operating system, enhancing the context of the output. By formatting the final output string with both the application identifier and the validated input, the updated code ensures that all components are properly handled and formatted, thereby reducing the risk of injection attacks and improving the overall security of the generated output."
5,186366,186366,,Remote,Not required,,CVE-2017-5069,https://www.cvedetails.com/cve/CVE-2017-5069/,CWE-79,Medium,,Partial,,2017-10-27,4.3,"Incorrect MIME type of XSS-Protection reports in Blink in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac, and 58.0.3029.83 for Android, allowed a remote attacker to circumvent Cross-Origin Resource Sharing checks via a crafted HTML page.",2019-10-02,XSS ,1,https://github.com/chromium/chromium/commit/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,"Prevent regular mode session startup pref type turning to default.

When user loses past session tabs of regular mode after
invoking a new window from the incognito mode.

This was happening because the SessionStartUpPref type was being set
to default, from last, for regular user mode. This was happening in
the RestoreIfNecessary method where the restoration was taking place
for users whose SessionStartUpPref type was set to last.

The fix was to make the protocol of changing the pref type to
default more explicit to incognito users and not regular users
of pref type last.

Bug: 481373
Change-Id: I96efb4cf196949312181c83c6dcd45986ddded13
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1774441
Reviewed-by: Tommy Martino <tmartino@chromium.org>
Reviewed-by: Ramin Halavati <rhalavati@chromium.org>
Commit-Queue: Rohit Agarwal <roagarwal@chromium.org>
Cr-Commit-Position: refs/heads/master@{#691726}",2,chrome/browser/ui/startup/startup_browser_creator.cc,"{""sha"": ""f118e6d27ecca45fecfc48580608159a47d2de24"", ""filename"": ""chrome/browser/ui/startup/startup_browser_creator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/startup/startup_browser_creator.cc?ref=7a0dee9d17d0ee7fd1b40b017442f4952384a7c2"", ""patch"": ""@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n       pref.type = SessionStartupPref::LAST;\n   }\n \n-  if (pref.type == SessionStartupPref::LAST &&\n-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {\n     // We don't store session information when incognito. If the user has\n     // chosen to restore last session and launched incognito, fallback to\n     // default launch behavior.""}","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",C,"  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
","  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
",,"@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
       pref.type = SessionStartupPref::LAST;
   }
 
-  if (pref.type == SessionStartupPref::LAST &&
-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.",Chrome,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,278e05fafb1fc77c5d23425c3c1c5ee5a4082f17,1,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

  // IsChromeFirstRun() looks for a sentinel file to determine whether the user
  // is starting Chrome for the first time. On Chrome OS, the sentinel is stored
  // in a location shared by all users and the check is meaningless. Query the
  // UserManager instead to determine whether the user is new.
#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  // On ChromeOS restarts force the user to login again. The expectation is that
  // after a login the user gets clean state. For this reason we ignore
  // StartupBrowserCreator::WasRestarted(). However
  // StartupBrowserCreator::WasRestarted has to be called in order to correctly
  // update pref values.
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  // The pref has an OS-dependent default value. For the first run only, this
  // default is overridden with SessionStartupPref::DEFAULT so that first run
  // behavior (sync promo, welcome page) is consistently invoked.
  // This applies only if the pref is still at its default and has not been
  // set by the user, managed prefs or policy.
  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  // The switches::kRestoreLastSession command line switch is used to restore
  // sessions after a browser self restart (e.g. after a Chrome upgrade).
  // However, new profiles can be created from a browser process that has this
  // switch so do not set the session pref to SessionStartupPref::LAST for
  // those as there is nothing to restore.
  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  // A browser starting for a profile being unlocked should always restore.
  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
//flaw_line_below:
  if (pref.type == SessionStartupPref::LAST &&
//flaw_line_below:
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
//fix_flaw_line_below:
//  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",186366,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","The provided code defines a function that determines the session startup preferences for a browser based on various conditions, such as whether it's the first run, if the browser was restarted, and the profile type. It retrieves the user's preferences and checks if the current user is new or if the browser has been restarted. Depending on these checks, it sets the session type to either restore the last session or use default settings. Additionally, it considers whether the profile requires sign-in and whether incognito mode should be launched, ultimately returning the appropriate session startup preference.","The code defines a function that determines the startup preferences for a browser session based on several conditions, including whether it is the user's first time running the browser and if the browser has been restarted. It checks the user's profile type and adjusts the session type accordingly, opting to restore the last session or use default settings. The function also considers whether the profile requires sign-in and if incognito mode should be activated. Ultimately, it returns the appropriate session startup preference based on these evaluations, ensuring a tailored user experience upon launching the browser.","The vulnerability in the original code stemmed from the potential mishandling of session preferences for off-the-record profiles, which could lead to unintended behavior when restoring sessions. Specifically, the condition that checked if the session type was set to restore the last session did not account for off-the-record profiles, allowing them to potentially restore sensitive information. The fix introduced a check for off-the-record profiles, ensuring that if the session type was set to restore the last session, it would instead default to the standard session type, thereby preventing the exposure of sensitive data in incognito mode.","The vulnerability in the original code arose from the lack of proper handling for off-the-record profiles, which could inadvertently allow sensitive information to be restored during a session. This oversight meant that if a user had previously restored a session, it could lead to the exposure of private data when the browser was launched in incognito mode. The fix addressed this issue by introducing a condition that checks for off-the-record profiles, ensuring that if the session type was set to restore the last session, it would instead revert to default settings, thereby safeguarding user privacy and preventing data leaks.","The vulnerability was fixed by adding a condition that checks if the profile is off-the-record before determining the session startup preference. In the updated code, if the session type is set to restore the last session and the profile is identified as off-the-record, the session type is changed to default. This adjustment ensures that sensitive information from previous sessions is not restored in incognito mode, thereby enhancing user privacy. The specific check for off-the-record profiles prevents the unintended exposure of data, effectively addressing the security flaw present in the original implementation.","The vulnerability was fixed by implementing a check to determine if the user profile is operating in incognito mode before restoring session preferences. This new condition ensures that if the session type is set to restore the last session, it will instead default to standard settings when the profile is identified as off-the-record. By doing so, the fix prevents the potential exposure of sensitive information that could occur if private data from previous sessions were inadvertently restored in a private browsing context, thereby enhancing user privacy and security."
6,186418,186418,,Remote,Not required,,CVE-2017-5008,https://www.cvedetails.com/cve/CVE-2017-5008/,CWE-79,Medium,,Partial,,2017-02-17,4.3,"Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed attacker controlled JavaScript to be run during the invocation of a private script method, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,6,https://github.com/chromium/chromium/commit/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,"Don't touch the prototype chain to get the private script controller.

Prior to this patch, private scripts attempted to get the
""privateScriptController"" property off the global object without verifying if
the property actually exists on the global. If the property hasn't been set yet,
this operation could descend into the prototype chain and potentially return
a named property from the WindowProperties object, leading to release asserts
and general confusion.

BUG=668552

Review-Url: https://codereview.chromium.org/2529163002
Cr-Commit-Position: refs/heads/master@{#434627}",6,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""1560d1019cd74abcf6c6d6d16fc0ed9e83f91c1b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,2 @@\n+ \n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552). If the test is successful, it should not crash.""}<_**next**_>{""sha"": ""1e410c0447a83fab2da5eb9fb6693d754719d9e8"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+<img name=\""privateScriptController\"">\n+<marquee></marquee>\n+<div>\n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552).\n+If the test is successful, it should not crash.\n+</div>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""eb4974e91d06882361bb7a1470c0d82fbb358bd7"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n-  v8::Local<v8::Value> privateScriptController =\n-      global->Get(context, v8String(isolate, \""privateScriptController\""))\n-          .ToLocalChecked();\n-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n-                 privateScriptController->IsObject());\n-  if (privateScriptController->IsObject()) {\n+  v8::Local<v8::String> key = v8String(isolate, \""privateScriptController\"");\n+\n+  if (global->HasOwnProperty(context, key).ToChecked()) {\n+    v8::Local<v8::Value> privateScriptController =\n+        global->Get(context, key).ToLocalChecked();\n+    CHECK(privateScriptController->IsObject());\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =""}<_**next**_>{""sha"": ""e2571f43f7722dbf99cb78d37b6c9948ff06e6aa"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -139,7 +139,7 @@ PrivateScriptController.prototype = {\n     },\n }\n \n-if (typeof window.privateScriptController === 'undefined')\n+if (!window.hasOwnProperty(\""privateScriptController\""))\n     window.privateScriptController = new PrivateScriptController();\n \n // This line must be the last statement of this JS file.""}","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",C,"  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
","  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
",,"@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
-  v8::Local<v8::Value> privateScriptController =
-      global->Get(context, v8String(isolate, ""privateScriptController""))
-          .ToLocalChecked();
-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
-                 privateScriptController->IsObject());
-  if (privateScriptController->IsObject()) {
+  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
+
+  if (global->HasOwnProperty(context, key).ToChecked()) {
+    v8::Local<v8::Value> privateScriptController =
+        global->Get(context, key).ToLocalChecked();
+    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =",Chrome,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,42839ee8c1195b25fbe327057e10c54f592b6693,1,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
//flaw_line_below:
  v8::Local<v8::Value> privateScriptController =
//flaw_line_below:
      global->Get(context, v8String(isolate, ""privateScriptController""))
//flaw_line_below:
          .ToLocalChecked();
//flaw_line_below:
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
//flaw_line_below:
                 privateScriptController->IsObject());
//flaw_line_below:
  if (privateScriptController->IsObject()) {
//fix_flaw_line_below:
//  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (global->HasOwnProperty(context, key).ToChecked()) {
//fix_flaw_line_below:
//    v8::Local<v8::Value> privateScriptController =
//fix_flaw_line_below:
//        global->Get(context, key).ToLocalChecked();
//fix_flaw_line_below:
//    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      // This is a memory leak, FunctionTemplates are eternal.
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",186418,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","The `compileAndRunPrivateScript` function compiles and executes a JavaScript script within a specified V8 context, utilizing a private script controller for managing imports. It begins by retrieving the global context and checking for the existence of a private script controller object. If it exists, the function attempts to set an import function; if this fails, an error is logged. The function then compiles the provided script source and, upon successful compilation, executes the script. Any errors encountered during compilation or execution are captured and logged, ensuring robust error handling throughout the process.","The code defines a function that compiles and executes a JavaScript script within a specific execution context. It first checks for a controller object that manages script imports; if it exists, it attempts to set an import function. The function then compiles the provided script source code, and if successful, it executes the compiled script. Throughout the process, any errors encountered during compilation or execution are captured and logged, ensuring that issues are reported clearly. This approach facilitates the dynamic execution of scripts while maintaining robust error handling and management of dependencies.","The vulnerability in the original code stemmed from the lack of a check to ensure that the private script controller object existed and was indeed an object before attempting to access its properties. This oversight could lead to potential crashes or undefined behavior if the controller was absent or not of the expected type. The fixed code addresses this by introducing a check using `global->HasOwnProperty` to confirm the existence of the controller, followed by a `CHECK` to ensure it is an object. This added validation enhances the robustness of the code and mitigates risks associated with improper type handling.","The vulnerability in the original code arose from the absence of checks to verify the existence and type of a critical object before accessing its properties. This lack of validation could lead to crashes or unexpected behavior if the object was missing or not of the expected type, potentially allowing for exploitation. The fixed code introduces a verification step to ensure that the object exists and is indeed of the correct type before any further operations are performed. This enhancement significantly improves the code's robustness by preventing errors related to improper type handling and ensuring safer execution of the script.","The vulnerability was fixed by adding a check to ensure the existence of the private script controller object before accessing its properties. The updated code uses `global->HasOwnProperty` to verify that the controller exists, preventing attempts to access it if it is undefined. Additionally, a `CHECK` statement is employed to confirm that the retrieved value is indeed an object. This validation ensures that the code only proceeds with setting the import function if the controller is valid, thereby mitigating risks associated with null or incorrect type references and enhancing overall stability and security during script execution.","The vulnerability was addressed by implementing checks to ensure that a critical object exists and is of the correct type before any operations are performed on it. The updated code first verifies the presence of the object, preventing access if it is absent. Additionally, a validation step confirms that the retrieved value is indeed an object, which safeguards against potential crashes or undefined behavior. These enhancements ensure that the code only proceeds with further actions when the necessary conditions are met, thereby improving the robustness and security of the script execution process."
7,186670,186670,,Remote,Not required,,CVE-2018-6051,https://www.cvedetails.com/cve/CVE-2018-6051/,CWE-79,Medium,Partial,,,2018-09-25,4.3,"XSS Auditor in Google Chrome prior to 64.0.3282.119, did not ensure the reporting URL was in the same origin as the page it was on, which allowed a remote attacker to obtain referrer details via a crafted HTML page.",2018-11-15,XSS ,7,https://github.com/chromium/chromium/commit/0da6dcdbe8e34740133773d20cc466b89d399d0a,0da6dcdbe8e34740133773d20cc466b89d399d0a,"Restrict the xss audit report URL to same origin

BUG=441275
R=tsepez@chromium.org,mkwst@chromium.org

Change-Id: I27bc8e251b9ad962c3b4fdebf084a2b9152f915d
Reviewed-on: https://chromium-review.googlesource.com/768367
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Jochen Eisinger <jochen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516666}",0,third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp,"{""sha"": ""f991b2454bb8761dcd41fdcbfccaba4aab310f42"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,11 @@\n+CONSOLE ERROR: Error parsing header X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=report-script-tag.html: reporting URL is not same scheme, host, and port as page at character position 10. The default protections will be applied.\n+CONSOLE ERROR: line 4: The XSS Auditor blocked access to 'http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=%3Cscript%3Ealert(String.fromCharCode(0x58,0x53,0x53))%3C/script%3E%3Cp%3EIf%20you%20see%20this%20message,%20no%20JavaScript%20alert(),%20and%20not%20dump%20of%20a%20report%20is%20displayed%20below,%20then%20the%20test%20PASSED.%3C/p%3E' because the source code of a script was found within the request. The server sent an 'X-XSS-Protection' header requesting this behavior.\n+This tests that the X-XSS-Protection reports are sent out properly\n+\n+\n+\n+--------\n+Frame: 'frame'\n+--------\n+Could not load the requested resource.\n+Error code: -28 (net::ERR_BLOCKED_BY_XSS_AUDITOR)""}<_**next**_>{""sha"": ""ca8a315df359e6b57849c3d798aa87496719b89f"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,25 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<script src=\""http://localhost:8000/security/xssAuditor/resources/utilities.js\""></script>\n+<script>\n+if (window.testRunner) {\n+    testRunner.dumpAsText();\n+    testRunner.dumpChildFramesAsText();\n+    testRunner.waitUntilDone();\n+    testRunner.setXSSAuditorEnabled(true);\n+}\n+\n+function notify() {\n+  if (window.testRunner) {\n+    setTimeout(testRunner.notifyDone.bind(testRunner), 0);\n+  }\n+}\n+</script>\n+</head>\n+<body>\n+<p>This tests that the X-XSS-Protection reports are sent out properly</p>\n+<iframe onload=\""notify()\"" name=\""frame\"" src=\""http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=<script>alert(String.fromCharCode(0x58,0x53,0x53))</script><p>If you see this message, no JavaScript alert(), and not dump of a report is displayed below, then the test PASSED.</p>\"">\n+</iframe>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""d3cb1524857b6ca8557df334e6feeb380123f922"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -13,6 +13,8 @@\n     print \""X-XSS-Protection: 1; mode=block\\n\"";\n } elsif ($cgi->param('enable-report')) {\n     print \""X-XSS-Protection: 1; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n+} elsif ($cgi->param('enable-report-cross-origin')) {\n+    print \""X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('enable-full-block-report')) {\n     print \""X-XSS-Protection: 1; mode=block; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('valid-header')) {""}<_**next**_>{""sha"": ""4005f3b4c046b0d63dd7c2dfdc71790ee4849bdf"", ""filename"": ""third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n+      if (!SecurityOrigin::Create(xss_protection_report_url)\n+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {\n+        error_details =\n+            \""reporting URL is not same scheme, host, and port as page\"";\n+        xss_protection_header = kReflectedXSSInvalid;\n+        xss_protection_report_url = KURL();\n+      }\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \""insecure reporting URL for secure page\"";""}","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",C,"      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
",,,"@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
+      if (!SecurityOrigin::Create(xss_protection_report_url)
+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
+        error_details =
+            ""reporting URL is not same scheme, host, and port as page"";
+        xss_protection_header = kReflectedXSSInvalid;
+        xss_protection_report_url = KURL();
+      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";",Chrome,0da6dcdbe8e34740133773d20cc466b89d399d0a,c99c6fa1c62d04fb36be582fae389b9f34c2c089,1,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  // In theory, the Document could have detached from the LocalFrame after the
  // XSSAuditor was constructed.
  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    // The URL can be empty when opening a new browser window or calling
    // window.open("""").
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
//fix_flaw_line_below:
//      if (!SecurityOrigin::Create(xss_protection_report_url)
//fix_flaw_line_below:
//               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
//fix_flaw_line_below:
//        error_details =
//fix_flaw_line_below:
//            ""reporting URL is not same scheme, host, and port as page"";
//fix_flaw_line_below:
//        xss_protection_header = kReflectedXSSInvalid;
//fix_flaw_line_below:
//        xss_protection_report_url = KURL();
//fix_flaw_line_below:
//      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",186670,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","The `XSSAuditor::Init` function initializes the XSS auditor for a given document, checking various conditions to determine if XSS protection should be enabled. It verifies that the function is called on the main thread and that the auditor is in an uninitialized state. The function retrieves settings from the document, including whether XSS auditing is enabled, and checks the document's URL and frame. It parses the `X-XSS-Protection` HTTP header to determine the appropriate XSS protection level, counts usage statistics, and handles potential errors related to the header. Finally, it sets the encoding and prepares any necessary reporting URLs.","The code initializes an XSS auditor for a document, ensuring it operates on the main thread and is in an uninitialized state. It checks if XSS auditing is enabled based on document settings and verifies the document's URL and frame presence. The function processes a specific HTTP header to determine the level of XSS protection, counting usage statistics accordingly. It handles potential errors related to the header parsing and sets a default protection level if necessary. Additionally, it prepares any required reporting URLs and sets the document's encoding based on its content.","The vulnerability in the original code stemmed from inadequate validation of the reporting URL derived from the `X-XSS-Protection` header, which could allow attackers to exploit reflected XSS by providing a malicious URL. The fixed code enhances security by ensuring that the reporting URL's scheme, host, and port match those of the document's security origin using `SecurityOrigin::Create` and `IsSameSchemeHostPort`. This additional check prevents the use of potentially harmful reporting URLs, thereby mitigating the risk of XSS attacks while maintaining the functionality of the XSS auditor.","The vulnerability in the original code arose from insufficient validation of the reporting URL associated with XSS protection, which could allow attackers to inject malicious URLs, leading to reflected XSS attacks. The fixed code addresses this issue by implementing a check to ensure that the reporting URL shares the same scheme, host, and port as the document's origin. This additional validation step prevents the use of potentially harmful reporting URLs, thereby enhancing the security of the XSS auditor and reducing the risk of exploitation through improper handling of the XSS protection mechanism.","The vulnerability was fixed by adding a validation check for the reporting URL derived from the `X-XSS-Protection` header. In the updated code, after obtaining the reporting URL, the function uses `SecurityOrigin::Create` to create a security origin for the reporting URL and checks it against the document's security origin with `IsSameSchemeHostPort`. This ensures that the reporting URL matches the scheme, host, and port of the document, preventing the use of potentially malicious URLs. Additionally, the code checks for mixed content scenarios, further enhancing the security of the XSS protection mechanism.","The vulnerability was fixed by implementing a validation mechanism for the reporting URL associated with XSS protection. The updated code ensures that the reporting URL matches the scheme, host, and port of the document's origin, thereby preventing the use of potentially harmful URLs that could lead to reflected XSS attacks. Additionally, the code checks for mixed content scenarios, which further enhances security by ensuring that insecure reporting URLs are not used in secure contexts. This comprehensive validation process significantly reduces the risk of exploitation through improper handling of the XSS protection feature."
8,186873,186873,,Remote,Not required,,CVE-2018-6070,https://www.cvedetails.com/cve/CVE-2018-6070/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Lack of CSP enforcement on WebUI pages in Bink in Google Chrome prior to 65.0.3325.146 allowed an attacker who convinced a user to install a malicious extension to bypass content security policy via a crafted Chrome Extension.,2019-10-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/f283cdf7c850f3db923a5303c7e01bd929d4117f,f283cdf7c850f3db923a5303c7e01bd929d4117f,"Move Initialize() to VaapiImageDecoder parent class.

This CL moves the implementation of Initialize() to VaapiImageDecoder,
since it is common to all implementing classes.

Bug: 877694
Test: jpeg_decode_accelerator_unittest
Change-Id: Ic99601953ae1c7a572ba8a0b0bf43675b2b0969d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1654249
Commit-Queue: Gil Dekel <gildekel@chromium.org>
Reviewed-by: Andres Calderon Jaramillo <andrescj@chromium.org>
Reviewed-by: Miguel Casas <mcasas@chromium.org>
Cr-Commit-Position: refs/heads/master@{#668645}",8,media/gpu/vaapi/vaapi_jpeg_decoder.cc,"{""sha"": ""7671f22290878c00f91af2e1d87d9de0140ae980"", ""filename"": ""media/gpu/vaapi/OWNERS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/OWNERS?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -4,3 +4,6 @@ posciak@chromium.org\n \n # (M)JPEG related stuff\n per-file *jpeg*=andrescj@chromium.org\n+\n+# General VA-API decoding related stuff\n+per-file *image_decoder*=andrescj@chromium.org""}<_**next**_>{""sha"": ""5bafbd695cceeb07b4e15d0812f1e3ecfb60573a"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -6,13 +6,37 @@\n \n #include <va/va.h>\n \n+#include \""base/logging.h\""\n #include \""media/gpu/vaapi/vaapi_wrapper.h\""\n \n namespace media {\n \n+namespace {\n+\n+VAProfile ConvertToVAProfile(VaapiImageDecoder::Type type) {\n+  switch (type) {\n+    case VaapiImageDecoder::Type::kJpeg:\n+      return VAProfileJPEGBaseline;\n+    case VaapiImageDecoder::Type::kWebP:\n+      return VAProfileVP8Version0_3;\n+    default:\n+      NOTREACHED() << \""Undefined Type value\"";\n+      return VAProfileNone;\n+  }\n+}\n+\n+}  // namespace\n+\n VaapiImageDecoder::VaapiImageDecoder()\n     : va_surface_id_(VA_INVALID_SURFACE), va_rt_format_(kInvalidVaRtFormat) {}\n \n VaapiImageDecoder::~VaapiImageDecoder() = default;\n \n+bool VaapiImageDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n+  const VAProfile va_profile = ConvertToVAProfile(GetType());\n+  vaapi_wrapper_ =\n+      VaapiWrapper::Create(VaapiWrapper::kDecode, va_profile, error_uma_cb);\n+  return !!vaapi_wrapper_;\n+}\n+\n }  // namespace media""}<_**next**_>{""sha"": ""68eaf26e7e53f695f831bf805696d423cb2da451"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -50,11 +50,17 @@ enum class VaapiImageDecodeStatus : uint32_t {\n // more implementing classes are added (e.g. VaapiWebPDecoder).\n class VaapiImageDecoder {\n  public:\n+  // Type of image decoder.\n+  enum class Type {\n+    kJpeg,\n+    kWebP,\n+  };\n+\n   virtual ~VaapiImageDecoder();\n \n-  // Initializes |vaapi_wrapper_| in kDecode mode with the appropriate VAAPI\n-  // profile and |error_uma_cb| for error reporting.\n-  virtual bool Initialize(const base::RepeatingClosure& error_uma_cb) = 0;\n+  // Uses GetType() to initialize |vaapi_wrapper_| in kDecode mode with the\n+  // appropriate VAAPI profile and |error_uma_cb| for error reporting.\n+  bool Initialize(const base::RepeatingClosure& error_uma_cb);\n \n   // Decodes a picture. It will fill VA-API parameters and call the\n   // corresponding VA-API methods according to the image in |encoded_image|.\n@@ -66,6 +72,9 @@ class VaapiImageDecoder {\n       base::span<const uint8_t> encoded_image,\n       VaapiImageDecodeStatus* status) = 0;\n \n+  // Returns the type of the current decoder.\n+  virtual Type GetType() const = 0;\n+\n  protected:\n   VaapiImageDecoder();\n ""}<_**next**_>{""sha"": ""53b26a84045c8af0fb54071850b5be48e0bad649"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 10, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {\n   }\n }\n \n-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n-                                        VAProfileJPEGBaseline, error_uma_cb);\n-  if (!vaapi_wrapper_) {\n-    VLOGF(1) << \""Failed initializing VAAPI\"";\n-    return false;\n-  }\n-  return true;\n-}\n-\n scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n     base::span<const uint8_t> encoded_image,\n     VaapiImageDecodeStatus* status) {\n@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n                                          base::DoNothing() /* release_cb */);\n }\n \n+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {\n+  return VaapiImageDecoder::Type::kJpeg;\n+}\n+\n std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(\n     uint32_t preferred_image_fourcc,\n     VaapiImageDecodeStatus* status) {""}<_**next**_>{""sha"": ""270a7481b9e75f7c4ce657b5c84b6a5d059c12e5"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -30,9 +30,9 @@ class VaapiJpegDecoder : public VaapiImageDecoder {\n   ~VaapiJpegDecoder() override;\n \n   // VaapiImageDecoder implementation.\n-  bool Initialize(const base::RepeatingClosure& error_uma_cb) override;\n   scoped_refptr<VASurface> Decode(base::span<const uint8_t> encoded_image,\n                                   VaapiImageDecodeStatus* status) override;\n+  Type GetType() const override;\n \n   // Get the decoded data from the last Decode() call as a ScopedVAImage. The\n   // VAImage's format will be either |preferred_image_fourcc| if the conversion""}","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",C,,"  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",,"@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {
   }
 }
 
-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
-                                        VAProfileJPEGBaseline, error_uma_cb);
-  if (!vaapi_wrapper_) {
-    VLOGF(1) << ""Failed initializing VAAPI"";
-    return false;
-  }
-  return true;
-}
-
 scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
     base::span<const uint8_t> encoded_image,
     VaapiImageDecodeStatus* status) {
@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
                                          base::DoNothing() /* release_cb */);
 }
 
+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {
+  return VaapiImageDecoder::Type::kJpeg;
+}
+
 std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(
     uint32_t preferred_image_fourcc,
     VaapiImageDecodeStatus* status) {",Chrome,f283cdf7c850f3db923a5303c7e01bd929d4117f,4f67ec23d9cf3ea7ab718a8dc7cd618674317472,1,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
//flaw_line_below:
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
//flaw_line_below:
                                        VAProfileJPEGBaseline, error_uma_cb);
//flaw_line_below:
  if (!vaapi_wrapper_) {
//flaw_line_below:
    VLOGF(1) << ""Failed initializing VAAPI"";
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:
  return true;
//flaw_line_below:
}
",186873,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","The `Initialize` function in the `VaapiJpegDecoder` class is responsible for setting up a VAAPI (Video Acceleration API) wrapper for JPEG decoding. It attempts to create a `VaapiWrapper` instance configured for decoding JPEG images using the baseline profile. If the creation of the `vaapi_wrapper_` fails, it logs an error message indicating the failure and returns `false`, signaling unsuccessful initialization. Conversely, if the wrapper is successfully created, the function returns `true`, indicating that the decoder is ready for use. The function also accepts a callback for error reporting via UMA (User Metrics Analysis).","The provided code defines a function that initializes a video decoding component specifically for JPEG images. It attempts to create an instance of a wrapper designed for video acceleration, targeting a specific profile for JPEG decoding. If the creation of this wrapper fails, an error message is logged to indicate the issue, and the function returns a failure status. Conversely, if the initialization is successful, the function returns a success status, indicating that the decoder is properly set up and ready for processing JPEG images. Additionally, it includes a mechanism for reporting errors.","The vulnerability in the original code stemmed from the lack of a mechanism to report errors effectively during the initialization of the video decoding component. Without a proper callback to handle error reporting, any failure in creating the wrapper would go unlogged, making it difficult to diagnose issues. The fix introduced a parameter, `error_uma_cb`, which allows the function to utilize a callback for reporting errors through User Metrics Analysis. This change enhances the robustness of the code by ensuring that any initialization failures are communicated appropriately, thus improving error handling and overall reliability.","The vulnerability in the original code was related to inadequate error handling during the initialization process of a video decoding component. Without a mechanism to report errors, any failure in setting up the necessary resources would go unlogged, making it challenging to identify and address issues. The fix introduced a callback parameter that enables the function to report errors effectively, ensuring that any initialization failures are communicated. This enhancement improves the overall reliability of the code by providing a structured way to handle and log errors, thereby facilitating better diagnostics and maintenance.","The vulnerability was fixed by introducing the `error_uma_cb` parameter in the function signature, which allows for error reporting during the initialization process. This callback is invoked when the creation of the `vaapi_wrapper_` fails, ensuring that the failure is logged appropriately. By utilizing this mechanism, the function can now communicate issues effectively, providing insights into why the initialization might not succeed. This change enhances the robustness of the code, as it allows developers to track errors through User Metrics Analysis, ultimately leading to improved diagnostics and maintenance of the video decoding component.","The vulnerability was addressed by adding a parameter that enables the function to report errors during the initialization process. This enhancement allows the function to communicate any failures effectively, ensuring that issues encountered while setting up the necessary resources are logged and can be diagnosed. By implementing this error reporting mechanism, the code now provides better visibility into potential problems, facilitating improved diagnostics and maintenance. This change significantly enhances the overall reliability of the component by ensuring that errors are not overlooked and can be addressed promptly."
9,186880,186880,,Remote,Not required,,CVE-2018-6076,https://www.cvedetails.com/cve/CVE-2018-6076/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.,2018-12-19,XSS ,1,https://github.com/chromium/chromium/commit/f8f6ed59949be4451ee2f5443d8a313f102fde60,f8f6ed59949be4451ee2f5443d8a313f102fde60,"Percent-encode UTF8 characters in URL fragment identifiers.

This brings us into line with Firefox, Safari, and the spec.

Bug: 758523
Change-Id: I7e354ab441222d9fd08e45f0e70f91ad4e35fafe
Reviewed-on: https://chromium-review.googlesource.com/668363
Commit-Queue: Mike West <mkwst@chromium.org>
Reviewed-by: Jochen Eisinger <jochen@chromium.org>
Reviewed-by: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#507481}",3,url/url_canon_etc.cc,"{""sha"": ""fc7148cbdeb0750f0a4a6371d06f512679e0f321"", ""filename"": ""components/url_formatter/elide_url_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/elide_url_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -338,13 +338,14 @@ TEST(TextEliderTest, TestElisionSpecialCases) {\n \n       // Unescaping.\n       {\""http://www/%E4%BD%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" +\n+           kEllipsisStr},\n \n       // Invalid unescaping for path. The ref will always be valid UTF-8. We\n       // don't bother to do too many edge cases, since these are handled by the\n       // escaper unittest.\n       {\""http://www/%E4%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" + kEllipsisStr},\n   };\n \n   RunElisionTest(testcases);""}<_**next**_>{""sha"": ""522cb4576fc3fd45800effb5c5951d8914ef5a3a"", ""filename"": ""components/url_formatter/url_formatter_unittest.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 19, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/url_formatter_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -762,7 +762,7 @@ TEST(UrlFormatterTest, FormatUrl) {\n \n       {\""With a port number and a reference\"",\n        \""http://www.google.com:8080/#\\xE3\\x82\\xB0\"", default_format_type,\n-       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#\\x30B0\"", 7},\n+       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#%E3%82%B0\"", 7},\n \n       // -------- IDN tests --------\n       {\""Japanese IDN with ja\"", \""http://xn--l8jvb1ey91xtjb.jp\"",\n@@ -1027,9 +1027,10 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                      \""%E3%82%B0/?q=%E3%82%B0#\\xE3\\x82\\xB0\""),\n                 kFormatUrlOmitNothing, net::UnescapeRule::NONE,\n                 &parsed, nullptr, nullptr);\n-  EXPECT_EQ(WideToUTF16(\n-      L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/%E3%82%B0/?q=%E3%82%B0#\\x30B0\""), formatted);\n+  EXPECT_EQ(\n+      WideToUTF16(L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n+                  L\""/%E3%82%B0/?q=%E3%82%B0#%E3%82%B0\""),\n+      formatted);\n   EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""%E3%83%BC\""),\n@@ -1042,8 +1043,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=%E3%82%B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Unescape case.\n   formatted =\n@@ -1052,7 +1053,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, &parsed,\n                 nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0:\\x30FC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""\\x30FC\""),\n@@ -1065,8 +1067,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Omit_username_password + unescape case.\n   formatted =\n@@ -1075,7 +1077,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitUsernamePassword, net::UnescapeRule::NORMAL,\n                 &parsed, nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_FALSE(parsed.username.is_valid());\n   EXPECT_FALSE(parsed.password.is_valid());\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\\x30FC\\x30B0\\x30EB.jp\""),\n@@ -1086,8 +1089,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // View-source case.\n   formatted =\n@@ -1320,14 +1323,13 @@ TEST(UrlFormatterTest, FormatUrlWithOffsets) {\n       kFormatUrlOmitNothing, net::UnescapeRule::SPACES, unescape_offsets);\n \n   const size_t ref_offsets[] = {\n-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n-    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, kNpos, kNpos, 32, kNpos, kNpos,\n-    33\n-  };\n+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,\n+      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n+      34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49};\n   // Unescape to \""http://www.google.com/foo.html#\\x30B0\\x30B0z\"".\n-  CheckAdjustedOffsets(\n-      \""http://www.google.com/foo.html#\\xE3\\x82\\xB0\\xE3\\x82\\xB0z\"",\n-      kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, ref_offsets);\n+  CheckAdjustedOffsets(\""http://www.google.com/foo.html#%E3%82%B0%E3%82%B0z\"",\n+                       kFormatUrlOmitNothing, net::UnescapeRule::NORMAL,\n+                       ref_offsets);\n \n   const size_t omit_http_offsets[] = {\n     0, kNpos, kNpos, kNpos, kNpos, kNpos, kNpos, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,""}<_**next**_>{""sha"": ""7672b12a6db0bdccdb4ea8940cda31afe9969a87"", ""filename"": ""components/url_matcher/url_matcher_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_matcher/url_matcher_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -168,7 +168,7 @@ TEST(URLMatcherConditionFactoryTest, GURLCharacterSet) {\n   EXPECT_TRUE(base::IsStringASCII(url.host()));\n   EXPECT_TRUE(base::IsStringASCII(url.path()));\n   EXPECT_TRUE(base::IsStringASCII(url.query()));\n-  EXPECT_FALSE(base::IsStringASCII(url.ref()));\n+  EXPECT_TRUE(base::IsStringASCII(url.ref()));\n }\n \n TEST(URLMatcherConditionFactoryTest, Criteria) {""}<_**next**_>{""sha"": ""46aa9d9fba31d9c3fec30db76a89ac7516a52dbc"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""status"": ""renamed"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 248 PASS, 326 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 251 PASS, 323 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n FAIL URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n FAIL <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n@@ -565,12 +565,12 @@ FAIL <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#' assert_equa\n PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n-FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'"", ""previous_filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-setters-expected.txt""}<_**next**_>{""sha"": ""5422190a3d98f83155961158319fe379a4c4c8b3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -55,7 +55,7 @@\n     assert_equals(url.hash, '');\n \n     url.hash = '\\udc01\\ud802a';\n-    assert_equals(url.hash, '#\\ufffd\\ufffda');\n+    assert_equals(url.hash, '#%EF%BF%BD%EF%BF%BDa');\n }, 'hash with unmatched surrogates');\n \n </script>""}<_**next**_>{""sha"": ""6fe9c1b320ef5f270baf8b8ea1b45fed616bbcb9"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,11 +4,11 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.example.com/#hello, world') is 'http://www.example.com/#hello, world'\n-PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#\u00c2\u00a9'\n-PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#\ud800\udf00ss'\n+PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#%C3%82%C2%A9'\n+PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#%F0%90%8C%80ss'\n PASS canonicalize('http://www.example.com/#%41%a') is 'http://www.example.com/#%41%a'\n-PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#\\uFFFD\\u597D'\n-FAIL canonicalize('http://www.example.com/#a\\uFDD0') should be http://www.example.com/#a\ufdd0. Was http://www.example.com/#a\ufffd.\n+PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#%EF%BF%BD%E5%A5%BD'\n+PASS canonicalize('http://www.example.com/#a\\uFDD0') is 'http://www.example.com/#a%EF%BF%BD'\n PASS canonicalize('http://www.example.com/#asdf#qwer') is 'http://www.example.com/#asdf#qwer'\n PASS canonicalize('http://www.example.com/##asdf') is 'http://www.example.com/##asdf'\n PASS canonicalize('http://www.example.com/#a\\nb\\rc\\td') is 'http://www.example.com/#abcd'""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""2ad64ae1134a8b1bc2c2d40b9a0b3c9aa86ae481"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,11 +2,11 @@ description(\""Test URLs that have an anchor.\"");\n \n cases = [ \n   [\""hello, world\"", \""hello, world\""],\n-  [\""\\xc2\\xa9\"", \""\\xc2\\xa9\""],\n-  [\""\\ud800\\udf00ss\"", \""\\ud800\\udf00ss\""],\n+  [\""\\xc2\\xa9\"", \""%C3%82%C2%A9\""],\n+  [\""\\ud800\\udf00ss\"", \""%F0%90%8C%80ss\""],\n   [\""%41%a\"", \""%41%a\""],\n-  [\""\\\\ud800\\\\u597d\"", \""\\\\uFFFD\\\\u597D\""],\n-  [\""a\\\\uFDD0\"", \""a\\\\uFDD0\""],\n+  [\""\\\\ud800\\\\u597d\"", \""%EF%BF%BD%E5%A5%BD\""],\n+  [\""a\\\\uFDD0\"", \""a%EF%BF%BD\""],\n   [\""asdf#qwer\"", \""asdf#qwer\""],\n   [\""#asdf\"", \""#asdf\""],\n   [\""a\\\\nb\\\\rc\\\\td\"", \""abcd\""],""}<_**next**_>{""sha"": ""db9386372bec5d3ed93d777839f8eb630b282b86"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,8 +36,8 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xc2\""],\n-    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xc2\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n+    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""0fc34b79acb7eb8b99cf001b750ef13f12f5f3b5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,7 +36,7 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xef\\\\xbf\\\\xbd\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""af075a5c2c7ed601137bf0086f8efec691b7e3a7"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -98,7 +98,7 @@ cases = [\n   [\""/a%2fc\"",                                  [\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]],\n   [\""/a/%2f/c\"",                                [\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]],\n \n-  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\\u03B2\""]],\n+  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]],\n ];\n \n var originalBaseURL = canonicalize(\"".\"");""}<_**next**_>{""sha"": ""75e2422895ceeec756f849b049d4af98ab2b9f4c"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,7 +2,7 @@ description(\""Canonicalization of standard URLs\"");\n \n cases = [\n   [\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\""],\n-  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# \\u00bb\""],\n+  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# %C2%BB\""],\n   [\""http://[www.google.com]/\"", \""http://[www.google.com]/\""],\n   [\""http://www.google.com\"", \""http://www.google.com/\""],\n   // Disabled because whitespace gets treated different in this API.\n@@ -17,7 +17,7 @@ cases = [\n   // Backslashes should get converted to forward slashes.\n   [\""http:\\\\\\\\\\\\\\\\www.google.com\\\\\\\\foo\"", \""http://www.google.com/foo\""],\n   // Busted refs shouldn't make the whole thing fail.\n-  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#\\\\uFFFD\""],\n+  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#%EF%BF%BD\""],\n   // Basic port tests.\n   [\""http://foo:80/\"", \""http://foo/\""],\n   [\""http://foo:81/\"", \""http://foo:81/\""],""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""03c416b46404d8384da523031ab83e060ba769ef"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,8 +2,8 @@ Test how non-ASCII characters are encoded in relative URLs.\n \n 1 2 3 4 5\n 1. PASS\n-2. FAIL: http://127.0.0.1:8000/uri/resolve-encoding-relative.html#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+2. PASS\n 3. PASS\n 4. PASS\n-5. FAIL: http://127.0.0.1:8000/%D0%BF%D1%83%D1%82%D1%8C?%E7%E0%EF%F0%EE%F1#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+5. PASS\n ""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""1b7414e269228933412bab601cbb152ec66e4200"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 392 PASS, 121 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 395 PASS, 118 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""6c8cd6b4b4443053d60525e36956fee495b7b6f7"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""e331b5e2c7ad2956b78a496e1ae3723e6f7e358a"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n PASS canonicalize('file:filer/home\\\\me') is 'file://filer/home/me'\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""0fb1a0301f109feb9e6dd386dbf83a00c0343f05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""9373dcc8dfa2032009e78c8871ce6ddd45a5cbec"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""dc386c57ab5f3083b1b77947dd1116c7612a248d"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -61,7 +61,7 @@ TEST(KURLTest, Getters) {\n        // shouldn't return it in percent-encoded form.\n        \""http://www.google.com/foo/blah?bar=baz#\\xce\\xb1\\xce\\xb2\"", \""http\"",\n        \""www.google.com\"", 0, \""\"", 0, \""/foo/blah\"", \""blah\"", \""bar=baz\"",\n-       \""\\xce\\xb1\\xce\\xb2\"", true},\n+       \""%CE%B1%CE%B2\"", true},\n       {\""http://foo.com:1234/foo/bar/\"", \""http\"", \""foo.com\"", 1234, \""\"", 0,\n        \""/foo/bar/\"", \""bar\"", 0, 0, false},\n       {\""http://www.google.com?#\"", \""http\"", \""www.google.com\"", 0, \""\"", 0, \""/\"", 0,""}<_**next**_>{""sha"": ""5dc81052311965a922f571c59f9be0064328dc82"", ""filename"": ""url/url_canon_etc.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 7, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_etc.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,\n       // Normal ASCII characters are just appended.\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n-      // Non-ASCII characters are appended unescaped, but only when they are\n-      // valid. Invalid Unicode characters are replaced with the \""invalid\n-      // character\"" as IE seems to (ReadUTFChar puts the unicode replacement\n-      // character in the output on failure for us).\n-      unsigned code_point;\n-      ReadUTFChar(spec, &i, end, &code_point);\n-      AppendUTF8Value(code_point, output);\n+      AppendUTF8EscapedChar(spec, &i, end, output);\n     }\n   }\n ""}<_**next**_>{""sha"": ""feac82c44b350d5be2be6ff8730ea7c9352c422a"", ""filename"": ""url/url_canon_unittest.cc"", ""status"": ""modified"", ""additions"": 83, ""deletions"": 58, ""changes"": 141, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1274,21 +1274,23 @@ TEST(URLCanonTest, Ref) {\n   // Refs are trivial, it just checks the encoding.\n   DualComponentCase ref_cases[] = {\n       // Regular one, we shouldn't escape spaces, et al.\n-    {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12), true},\n+      {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12),\n+       true},\n       // UTF-8/wide input should be preserved\n-    {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#\\xc2\\xa9\"", Component(1, 2), true},\n+      {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#%C2%A9\"", Component(1, 6), true},\n       // Test a characer that takes > 16 bits (U+10300 = old italic letter A)\n-    {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#\\xF0\\x90\\x8C\\x80ss\"", Component(1, 6), true},\n+      {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#%F0%90%8C%80ss\"",\n+       Component(1, 14), true},\n       // Escaping should be preserved unchanged, even invalid ones\n-    {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n+      {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n       // Invalid UTF-8/16 input should be flagged and the input made valid\n-    {\""\\xc2\"", NULL, \""#\\xef\\xbf\\xbd\"", Component(1, 3), true},\n-    {NULL, L\""\\xd800\\x597d\"", \""#\\xef\\xbf\\xbd\\xe5\\xa5\\xbd\"", Component(1, 6), true},\n+      {\""\\xc2\"", NULL, \""#%EF%BF%BD\"", Component(1, 9), true},\n+      {NULL, L\""\\xd800\\x597d\"", \""#%EF%BF%BD%E5%A5%BD\"", Component(1, 18), true},\n       // Test a Unicode invalid character.\n-    {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a\\xef\\xbf\\xbd\"", Component(1, 4), true},\n+      {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a%EF%BF%BD\"", Component(1, 10), true},\n       // Refs can have # signs and we should preserve them.\n-    {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n-    {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n+      {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n+      {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n   };\n \n   for (size_t i = 0; i < arraysize(ref_cases); i++) {\n@@ -1351,49 +1353,56 @@ TEST(URLCanonTest, CanonicalizeStandardURL) {\n     const char* expected;\n     bool expected_success;\n   } cases[] = {\n-    {\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\"", true},\n-    {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n-    {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"", false},\n-    {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"", true},\n-    {\""www.google.com\"", \"":www.google.com/\"", false},\n-    {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n-    {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n-    {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n-    {\""http://%25DOMAIN:foobar@foodomain.com/\"", \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n+      {\""http://www.google.com/foo?bar=baz#\"",\n+       \""http://www.google.com/foo?bar=baz#\"", true},\n+      {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n+      {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"",\n+       false},\n+      {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"",\n+       true},\n+      {\""www.google.com\"", \"":www.google.com/\"", false},\n+      {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n+      {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n+      {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n+      {\""http://%25DOMAIN:foobar@foodomain.com/\"",\n+       \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n \n       // Backslashes should get converted to forward slashes.\n-    {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n+      {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n \n       // Busted refs shouldn't make the whole thing fail.\n-    {\""http://www.google.com/asdf#\\xc2\"", \""http://www.google.com/asdf#\\xef\\xbf\\xbd\"", true},\n+      {\""http://www.google.com/asdf#\\xc2\"",\n+       \""http://www.google.com/asdf#%EF%BF%BD\"", true},\n \n       // Basic port tests.\n-    {\""http://foo:80/\"", \""http://foo/\"", true},\n-    {\""http://foo:81/\"", \""http://foo:81/\"", true},\n-    {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n-    {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n-\n-    {\""https://foo:443/\"", \""https://foo/\"", true},\n-    {\""https://foo:80/\"", \""https://foo:80/\"", true},\n-    {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n-    {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n-    {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n-    {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n-    {\""ws://foo:80/\"", \""ws://foo/\"", true},\n-    {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n-    {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n-    {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n-    {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n-    {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n-    {\""wss://foo:443/\"", \""wss://foo/\"", true},\n-    {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n+      {\""http://foo:80/\"", \""http://foo/\"", true},\n+      {\""http://foo:81/\"", \""http://foo:81/\"", true},\n+      {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n+      {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n+\n+      {\""https://foo:443/\"", \""https://foo/\"", true},\n+      {\""https://foo:80/\"", \""https://foo:80/\"", true},\n+      {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n+      {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n+      {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n+      {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n+      {\""ws://foo:80/\"", \""ws://foo/\"", true},\n+      {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n+      {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n+      {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n+      {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n+      {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n+      {\""wss://foo:443/\"", \""wss://foo/\"", true},\n+      {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n \n       // This particular code path ends up \""backing up\"" to replace an invalid\n       // host ICU generated with an escaped version. Test that in the context\n       // of a full URL to make sure the backing up doesn't mess up the non-host\n       // parts of the URL. \""EF B9 AA\"" is U+FE6A which is a type of percent that\n       // ICU will convert to an ASCII one, generating \""%81\"".\n-    {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\""81:80/\"", \""ws://%29w%1ew%81/\"", false},\n+      {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\n+       \""81:80/\"",\n+       \""ws://%29w%1ew%81/\"", false},\n   };\n \n   for (size_t i = 0; i < arraysize(cases); i++) {\n@@ -1683,41 +1692,57 @@ TEST(URLCanonTest, CanonicalizeFileURL) {\n   } cases[] = {\n #ifdef _WIN32\n       // Windows-style paths\n-    {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n-    {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n-    {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7), Component(14, 5)},\n+      {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n+      {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n+      {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7),\n+       Component(14, 5)},\n       // CanonicalizeFileURL supports absolute Windows style paths for IE\n       // compatibility. Note that the caller must decide that this is a file\n       // URL itself so it can call the file canonicalizer. This is usually\n       // done automatically as part of relative URL resolving.\n-    {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n+      {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n+      {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n       // We should preserve the number of slashes after the colon for IE\n       // compatibility, except when there is none, in which case we should\n       // add one.\n-    {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n+      {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n       // Three slashes should be non-UNC, even if there is no drive spec (IE\n       // does this, which makes the resulting request invalid).\n-    {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(), Component(7, 12)},\n+      {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(),\n+       Component(7, 12)},\n       // TODO(brettw) we should probably fail for invalid host names, which\n       // would change the expected result on this test. We also currently allow\n       // colon even though it's probably invalid, because its currently the\n       // \""natural\"" result of the way the canonicalizer is written. There doesn't\n       // seem to be a strong argument for why allowing it here would be bad, so\n       // we just tolerate it and the load will fail later.\n-    {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false, Component(7, 2), Component(9, 16)},\n-    {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5), Component(12, 8)},\n+      {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false,\n+       Component(7, 2), Component(9, 16)},\n+      {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5),\n+       Component(12, 8)},\n       // Make sure relative paths can't go above the \""C:\""\n-    {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true, Component(), Component(7, 12)},\n+      {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true,\n+       Component(), Component(7, 12)},\n       // Busted refs shouldn't make the whole thing fail.\n-    {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xef\\xbf\\xbd\"", true, Component(), Component(7, 8)},\n+      {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%EF%BF%BD\"", true, Component(),\n+       Component(7, 8)},\n #else\n       // Unix-style paths\n     {\""file:///home/me\"", \""file:///home/me\"", true, Component(), Component(7, 8)},""}","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",C,"      AppendUTF8EscapedChar(spec, &i, end, output);
","      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
",,"@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
-      // Non-ASCII characters are appended unescaped, but only when they are
-      // valid. Invalid Unicode characters are replaced with the ""invalid
-      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
-      // character in the output on failure for us).
-      unsigned code_point;
-      ReadUTFChar(spec, &i, end, &code_point);
-      AppendUTF8Value(code_point, output);
+      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 ",Chrome,f8f6ed59949be4451ee2f5443d8a313f102fde60,0a918e900a759b04f177cc5b8bca668140751136,1,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    // Common case of no ref.
    *out_ref = Component();
    return;
  }

  // Append the ref separator. Note that we need to do this even when the ref
  // is empty but present.
  output->push_back('#');
  out_ref->begin = output->length();

  // Now iterate through all the characters, converting to UTF-8 and validating.
  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      // IE just strips NULLs, so we do too.
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      // Unline IE seems to, we escape control characters. This will probably
      // make the reference fragment unusable on a web page, but people
      // shouldn't be using control characters in their anchor names.
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
//flaw_line_below:
      // Non-ASCII characters are appended unescaped, but only when they are
//flaw_line_below:
      // valid. Invalid Unicode characters are replaced with the ""invalid
//flaw_line_below:
      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
//flaw_line_below:
      // character in the output on failure for us).
//flaw_line_below:
      unsigned code_point;
//flaw_line_below:
      ReadUTFChar(spec, &i, end, &code_point);
//flaw_line_below:
      AppendUTF8Value(code_point, output);
//fix_flaw_line_below:
//      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",186880,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","The `DoCanonicalizeRef` function processes a given string reference (`ref`) and appends its canonicalized representation to an output object (`output`). It first checks if the reference length is negative, in which case it initializes `out_ref` and exits. The function then starts by adding a '#' character to the output and records the starting position of the reference. It iterates through the characters of the specified string (`spec`), handling control characters by escaping them, directly appending ASCII characters, and converting UTF-8 characters as needed. Finally, it updates the length of the processed reference in `out_ref`.","The provided code defines a function that processes a string reference and generates its canonical form for output. It first checks if the reference is valid; if not, it initializes an output structure and exits. The function then begins by adding a specific character to the output and records the starting position of the reference. It iterates through the characters of the input string, handling special cases by escaping control characters, directly appending standard ASCII characters, and converting multi-byte characters as necessary. Finally, it updates the length of the processed reference in the output structure.","The vulnerability in the original code arises from the handling of multi-byte characters, which could lead to improper processing and potential buffer overflows. Specifically, the function used to read and append UTF-8 characters did not adequately validate the input, allowing for malformed or unexpected byte sequences to be processed incorrectly. In the fixed code, the introduction of the `AppendUTF8EscapedChar` function enhances the handling of these multi-byte characters by ensuring that they are properly escaped and validated before being added to the output. This change mitigates the risk of buffer overflows and improves overall input safety.","The vulnerability in the original code stemmed from inadequate handling of multi-byte character sequences, which could lead to improper processing and potential buffer overflows when encountering malformed input. This issue arose because the code did not sufficiently validate the input before appending characters to the output. The fixed version addresses this vulnerability by implementing a more robust method for processing multi-byte characters, ensuring that they are properly validated and escaped before being added to the output. This enhancement significantly reduces the risk of buffer overflows and improves the overall safety and integrity of the input handling process.","The vulnerability was fixed by replacing the original method of handling multi-byte characters with a more secure approach. In the updated code, the function `AppendUTF8EscapedChar` was introduced to specifically manage the appending of multi-byte characters. This function ensures that the characters are properly validated and escaped before being added to the output. By doing so, it mitigates the risk of buffer overflows that could occur from malformed input. Additionally, this change enhances the overall robustness of the character processing, ensuring that all character types are handled safely and correctly.","The vulnerability was addressed by implementing a more secure method for processing multi-byte characters, which previously posed a risk of buffer overflows due to inadequate validation. The updated approach ensures that these characters are properly validated and escaped before being added to the output, thereby preventing the potential for malformed input to disrupt the processing flow. This enhancement not only mitigates the risk of buffer overflows but also improves the overall integrity and safety of the input handling, ensuring that all character types are processed correctly and securely."
10,186914,186914,,Remote,Not required,,CVE-2017-15427,https://www.cvedetails.com/cve/CVE-2017-15427/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a socially engineered user to XSS themselves by dragging and dropping a javascript: URL into the URL bar.,2018-11-02,XSS ,2,https://github.com/chromium/chromium/commit/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,"Strip JavaScript schemas on Linux text drop

When dropping text onto the Omnibox, any leading JavaScript schemes
should be stripped to avoid a ""self-XSS"" attack. This stripping already
occurs in all cases except when plaintext is dropped on Linux. This CL
corrects that oversight.

Bug: 768910
Change-Id: I43af24ace4a13cf61d15a32eb9382dcdd498a062
Reviewed-on: https://chromium-review.googlesource.com/685638
Reviewed-by: Justin Donnelly <jdonnelly@chromium.org>
Commit-Queue: Eric Lawrence <elawrence@chromium.org>
Cr-Commit-Position: refs/heads/master@{#504695}",1,chrome/browser/ui/views/omnibox/omnibox_view_views.cc,"{""sha"": ""98a8ac9c38531ee785f98f7ce297dde52f5ad7fa"", ""filename"": ""chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/omnibox/omnibox_view_views.cc?ref=16c719e0e275d2ee5d5c69e4962b744bcaf0fe40"", ""patch"": ""@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n+      base::string16 collapsed_text(\n+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;""}","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",C,"      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
","      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
",,"@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
+      base::string16 collapsed_text(
+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;",Chrome,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,4a165e1b93e099fceb38de3ade51e368ce949075,1,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
//flaw_line_below:
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
//fix_flaw_line_below:
//      base::string16 collapsed_text(
//fix_flaw_line_below:
//          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",186914,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","The provided code defines a method `OnDrop` within the `OmniboxViewViews` class, which handles drag-and-drop operations for URLs and text. It first checks if any text is being dragged; if so, it returns `DRAG_NONE`. If the dropped data contains a URL, it retrieves the URL and its title, strips any JavaScript schemas, and checks if the model can process the URL. If valid, it invokes `PasteAndGo` with the URL. Similarly, if the data contains a string, it collapses whitespace and checks its validity before calling `PasteAndGo`. If neither condition is met, it returns `DRAG_NONE`.","The code defines a method that manages the behavior of drag-and-drop actions within a user interface component. It first checks if any text is currently being dragged; if so, it cancels the drop action. If the dropped data includes a web address, the method retrieves it and verifies its format before processing it for navigation. Similarly, if the data consists of plain text, it simplifies the text by removing extra spaces and checks its validity for navigation. If either type of data is valid, it initiates a navigation action; otherwise, it cancels the drop operation.","The vulnerability in the original code arises from the lack of sanitization for the text being processed, particularly when handling URLs and strings. In the fixed code, the addition of `StripJavascriptSchemas` for both the URL and the collapsed text ensures that any potentially harmful JavaScript schemas are removed before further processing. This mitigates the risk of executing malicious scripts that could be embedded in the dropped data. By validating and sanitizing the input through these checks, the code enhances security and prevents potential exploitation through drag-and-drop actions.","The vulnerability in the original code stems from inadequate sanitization of user input during drag-and-drop operations, particularly when handling URLs and text. This oversight could allow malicious scripts to be executed if harmful content was dropped into the interface. The fixed code addresses this issue by implementing a sanitization process that removes potentially dangerous elements from both URLs and text before they are processed. By ensuring that only safe, clean data is accepted for navigation, the updated code significantly reduces the risk of executing malicious code, thereby enhancing the overall security of the application.","The vulnerability was fixed by incorporating the `StripJavascriptSchemas` function to sanitize both the URL and the text before they are processed. In the updated code, after retrieving the URL and its title, the method applies `StripJavascriptSchemas` to the URL to eliminate any potentially harmful JavaScript schemas. Additionally, when handling plain text, the code also applies `StripJavascriptSchemas` after collapsing whitespace. This dual sanitization ensures that any malicious content is removed before the data is passed to the `CanPasteAndGo` and `PasteAndGo` functions, thereby preventing the execution of harmful scripts and enhancing security.","The vulnerability was addressed by implementing a sanitization process that removes potentially harmful elements from both URLs and text before they are processed. The updated code ensures that any dangerous scripts or schemas are stripped away, thereby preventing malicious content from being executed during drag-and-drop operations. This additional layer of validation checks the integrity of the input data, allowing only safe and clean information to be passed for further processing. As a result, the risk of executing harmful code is significantly reduced, enhancing the overall security of the application."
