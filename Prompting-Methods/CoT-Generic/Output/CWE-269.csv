,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,180887,180887,,Remote,Not required,,CVE-2017-15906,https://www.cvedetails.com/cve/CVE-2017-15906/,CWE-269,Low,,Partial,,2017-10-25,5.0,"The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",2019-10-02,,2,https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,"disallow creation (of empty files) in read-only mode; reported by
Michal Zalewski, feedback & ok deraadt@",2,usr.bin/ssh/sftp-server.c,"{""sha"": ""42249ebd60d0f46a2219d61203a30e0da65d38ec"", ""filename"": ""usr.bin/ssh/sftp-server.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/openbsd/src/blob/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sftp-server.c?ref=a6981567e8e215acc1ef690c8dbb30f2d9b00a19"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */\n /*\n  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.\n  *\n@@ -683,8 +683,8 @@ process_open(u_int32_t id)\n \tlogit(\""open \\\""%s\\\"" flags %s mode 0%o\"",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n-\t    ((flags & O_ACCMODE) == O_WRONLY ||\n-\t    (flags & O_ACCMODE) == O_RDWR)) {\n+\t    ((flags & O_ACCMODE) != O_RDONLY ||\n+\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\""Refusing open request in read-only mode\"");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {""}","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
",C,"	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
","	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */
 /*
  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
  *
@@ -683,8 +683,8 @@ process_open(u_int32_t id)
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
-	    ((flags & O_ACCMODE) == O_WRONLY ||
-	    (flags & O_ACCMODE) == O_RDWR)) {
+	    ((flags & O_ACCMODE) != O_RDONLY ||
+	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {",src,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,f7bf1b90edbc30ad71b90a869e7a850ec6700918,1,"process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
//flaw_line_below:
	    ((flags & O_ACCMODE) == O_WRONLY ||
//flaw_line_below:
	    (flags & O_ACCMODE) == O_RDWR)) {
//fix_flaw_line_below:
//	    ((flags & O_ACCMODE) != O_RDONLY ||
//fix_flaw_line_below:
//	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
",180887,"process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","The provided code defines a function `process_open` that handles file opening requests in an SSH file transfer context. It retrieves parameters such as the file name and flags from a buffer, checks for errors, and logs the request details. The function determines the appropriate file access mode based on the provided attributes and checks if the operation is allowed in read-only mode. If the conditions are met, it attempts to open the file and, upon success, creates a new handle for the file. Finally, it sends the operation status back to the requester and frees allocated memory for the file name.","The code defines a function that processes file opening requests within an SSH file transfer protocol. It retrieves necessary parameters from a buffer and checks for any errors during this process. The function logs the request details and determines the appropriate access mode based on specified attributes. It verifies if the operation can proceed in a read-only context. If allowed, it attempts to open the requested file and, if successful, creates a handle for it. Finally, the function communicates the outcome of the operation back to the requester and manages memory cleanup for the file name.","The vulnerability in the original code arises from insufficient checks on the file access mode when the system is in read-only mode. Specifically, it only checked if the flags indicated a write or read-write operation, potentially allowing unauthorized file modifications. The fixed code enhances this by ensuring that if the system is in read-only mode, it denies any request that is not strictly for reading, including attempts to create or truncate files. This additional validation prevents unauthorized write operations, thereby mitigating the risk of data corruption or unintended modifications in a read-only context.","The vulnerability in the original code stemmed from inadequate validation of file access modes when operating in a read-only context, allowing potentially unauthorized write operations. This oversight could lead to unintended modifications or data corruption if a user attempted to open a file for writing. The fixed code addresses this issue by implementing stricter checks that deny any file operations that are not strictly read-only when the system is in read-only mode. This enhancement ensures that only safe read operations are permitted, thereby protecting the integrity of the file system and preventing unauthorized changes.","The vulnerability was fixed by modifying the condition that checks for read-only access. In the original code, the check only verified if the flags indicated a write or read-write operation. The updated code enhances this by ensuring that if the system is in read-only mode, it denies any request where the flags indicate anything other than read access, specifically checking that the flags do not include creation or truncation. This is achieved through the condition that evaluates both the access mode and the presence of specific flags, effectively preventing unauthorized write operations in a read-only context.","The vulnerability was fixed by implementing stricter validation checks for file access modes when the system is in read-only mode. The updated code ensures that any file operation request that involves writing, creating, or truncating files is explicitly denied. This enhancement prevents unauthorized modifications by verifying that only read operations are permitted in a read-only context. By refining the conditions under which file access is granted, the fix effectively safeguards the integrity of the file system and mitigates the risk of unintended data alterations or corruption."
1,181590,181590,,Local,Not required,Complete,CVE-2017-5207,https://www.cvedetails.com/cve/CVE-2017-5207/,CWE-269,Low,Complete,Complete,,2017-03-23,7.2,"Firejail before 0.9.44.4, when running a bandwidth command, allows local users to gain root privileges via the --shell argument.",2019-10-02,+Priv ,1,https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,5d43fdcd215203868d440ffc42036f5f5ffc89fc,security fix,7,src/firejail/bandwidth.c,"{""sha"": ""b9a982d776a62e8200bbf0db7916d8ccece262a4"", ""filename"": ""RELNOTES"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/RELNOTES?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -1,5 +1,6 @@\n firejail (0.9.45) baseline; urgency=low\n   * development version, work in progress\n+  * security: --bandwidth root shel found by Martin Carpenter\n   * security: disabled --allow-debuggers when running on kernel\n     versions prior to 4.8; a kernel bug in ptrace system call\n     allows a full bypass of seccomp filter; problem reported by Lizzie Dixon""}<_**next**_>{""sha"": ""84c9dc53a331e5787941bf31dd3b7ba5dbe77e2f"", ""filename"": ""src/firejail/bandwidth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 8, ""changes"": 9, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/bandwidth.c?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in\n \tif (setregid(0, 0))\n \t\terrExit(\""setregid\"");\n \n-\tif (!cfg.shell)\n-\t\tcfg.shell = guess_shell();\n-\tif (!cfg.shell) {\n-\t\tfprintf(stderr, \""Error: no POSIX shell found, please use --shell command line option\\n\"");\n-\t\texit(1);\n-\t}\n-\n \tchar *arg[4];\n-\targ[0] = cfg.shell;\n+\targ[0] = \""/bin/sh\"";\n \targ[1] = \""-c\"";\n \targ[2] = cmd;\n \targ[3] = NULL;""}","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
 	char *arg[4];
	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
 	char *arg[4];
	arg[0] = cfg.shell;
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
",C,"	arg[0] = ""/bin/sh"";
","	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
	arg[0] = cfg.shell;
",,"@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
-	if (!cfg.shell)
-		cfg.shell = guess_shell();
-	if (!cfg.shell) {
-		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
-		exit(1);
-	}
-
 	char *arg[4];
-	arg[0] = cfg.shell;
+	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;",firejail,5d43fdcd215203868d440ffc42036f5f5ffc89fc,6435525696e8eda2d1bc0ef50488523422b9126d,1,"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	//************************
	// verify sandbox
	//************************
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	// check for firejail sandbox
	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	// check network namespace
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	//************************
	// join the network namespace
	//************************
	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	// set run file
	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	//************************
	// build command
	//************************
	char *devname = NULL;
	if (dev) {
		// read network map file
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			// remove '\n'
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				// check device in namespace
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	// build fshaper.sh command
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	// wipe out environment variables
	environ = NULL;

	//************************
	// build command
	//************************
	// elevate privileges
	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
//flaw_line_below:
	if (!cfg.shell)
//flaw_line_below:
		cfg.shell = guess_shell();
//flaw_line_below:
	if (!cfg.shell) {
//flaw_line_below:
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
//flaw_line_below:
		exit(1);
//flaw_line_below:
	}
//flaw_line_below:

 	char *arg[4];
//flaw_line_below:
	arg[0] = cfg.shell;
//fix_flaw_line_below:
//	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	// it will never get here
	errExit(""execvp"");
}
",181590,"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
 	char *arg[4];
	arg[0] = cfg.shell;
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
 	char *arg[4];
	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","The `bandwidth_pid` function manages network bandwidth settings for a specified process identified by its PID, ensuring it operates within a Firejail sandbox. It first verifies the process is running under Firejail and checks for a valid network namespace. Depending on the command (""set"" or ""clear""), it either applies bandwidth limits or removes them for a specified network device. The function constructs a command to execute a shell script for shaping bandwidth, sets the necessary user and group IDs to root, and executes the command in a new shell environment. Error handling is implemented throughout to manage potential issues.","The code defines a function that manages network bandwidth settings for a specified process within a sandbox environment. It verifies that the process is running in the correct context and checks for a valid network namespace. Based on the provided command, it either sets bandwidth limits or removes them for a specified network device. The function constructs a command to execute a script responsible for shaping bandwidth, adjusts user permissions to root, and runs the command in a new shell environment. Throughout the process, it includes error handling to address potential issues that may arise.","The vulnerability in the original code arises from the use of an unvalidated command string constructed with `asprintf`, which could allow an attacker to inject malicious commands if they control the input parameters. Specifically, the command executed via `execvp` could be manipulated, leading to potential command injection. The fix addresses this by ensuring that the shell used for execution is explicitly set to a known safe shell (""/bin/sh"") instead of relying on an arbitrary or potentially unsafe shell derived from user input. This change mitigates the risk of executing unintended commands, enhancing overall security.","The vulnerability in the original code stems from the potential for command injection due to the construction of a command string that could be influenced by user input. This allowed an attacker to manipulate the command executed by the system, leading to unauthorized actions. The fix involved explicitly specifying a safe shell for executing commands, rather than relying on an arbitrary shell that could be affected by user input. This change significantly reduces the risk of executing unintended or malicious commands, thereby enhancing the security of the code by ensuring that only trusted commands are run in a controlled environment.","The vulnerability was fixed by explicitly setting the shell to a known safe option, specifically using ""/bin/sh"" instead of relying on user-defined input for the shell variable. In the revised code, the shell is assigned directly to the argument array for the command execution, ensuring that only a trusted shell is used. This change mitigates the risk of command injection by preventing the execution of arbitrary commands that could be introduced through user input. Additionally, the use of `clearenv` before executing the command helps to eliminate any potentially harmful environment variables, further enhancing security.","The vulnerability was addressed by explicitly specifying a trusted shell for executing commands, rather than relying on potentially unsafe user-defined input. This change ensures that only a known and secure shell is used, significantly reducing the risk of command injection. Additionally, the code was modified to clear the environment before executing the command, which helps prevent the influence of any harmful environment variables that could be exploited. Together, these measures enhance the security of the code by ensuring that only safe and intended commands are executed in a controlled manner."
2,182325,182325,,Local,Not required,Partial,CVE-2018-13405,https://www.cvedetails.com/cve/CVE-2018-13405/,CWE-269,Low,Partial,Partial,,2018-07-06,4.6,"The inode_init_owner function in fs/inode.c in the Linux kernel through 4.17.4 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.",2019-10-02,,6,https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,"Fix up non-directory creation in SGID directories

sgid directories have special semantics, making newly created files in
the directory belong to the group of the directory, and newly created
subdirectories will also become sgid.  This is historically used for
group-shared directories.

But group directories writable by non-group members should not imply
that such non-group members can magically join the group, so make sure
to clear the sgid bit on non-directories for non-members (but remember
that sgid without group execute means ""mandatory locking"", just to
confuse things even more).

Reported-by: Jann Horn <jannh@google.com>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/inode.c,"{""sha"": ""8c86c809ca17b30e003913e169626aa42df2e908"", ""filename"": ""fs/inode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/inode.c?ref=0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7"", ""patch"": ""@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n+\n+\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n+\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n+\t\t\t !in_group_p(inode->i_gid) &&\n+\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n+\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;""}","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
",C,"
		/* Directories are special, and always inherit S_ISGID */
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
",,,"@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
+
+		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
+		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
+			 !in_group_p(inode->i_gid) &&
+			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
+			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;",linux,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,d02d21ea007b6b33cdaf15c2f84fb1fea996ecc2,1,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
//fix_flaw_line_below:
//		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
//fix_flaw_line_below:
//			 !in_group_p(inode->i_gid) &&
//fix_flaw_line_below:
//			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
//fix_flaw_line_below:
//			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
",182325,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","The `inode_init_owner` function initializes the ownership and permissions of a newly created inode in a filesystem. It sets the inode's user ID (`i_uid`) to the current filesystem user ID. If a directory (`dir`) is provided and has the set-group-ID (SGID) bit set, the inode's group ID (`i_gid`) is inherited from the directory, and if the inode represents a directory, the SGID bit is also set in its mode. If no directory is specified or the SGID bit is not set, the group ID is assigned from the current filesystem group ID. Finally, the inode's mode is set to the specified mode.","This function initializes the properties of a newly created filesystem object, specifically focusing on its ownership and permissions. It assigns the user identifier based on the current user context. If a parent directory is provided and has a specific permission setting, the group identifier is inherited from that directory, and an additional permission setting is applied if the new object is a directory. If no parent directory is specified or the specific permission is not set, the group identifier is taken from the current context. Finally, the function sets the permissions of the new object according to the specified settings.","The vulnerability in the original code arises from the improper handling of the set-group-ID (SGID) bit when creating new inodes, particularly for non-directory objects. In the vulnerable code, if a parent directory has the SGID bit set, the new inode inherits this bit without any checks, potentially allowing unauthorized users to gain elevated group permissions. The fixed code introduces additional conditions to ensure that the SGID bit is only retained if the new inode is a directory or if the user belongs to the group associated with the inode. This prevents unauthorized elevation of privileges by ensuring proper group membership and capability checks.","The vulnerability in the original code stems from the unchecked inheritance of specific permissions when creating new filesystem objects, particularly regarding group permissions. This could allow unauthorized users to gain elevated group access if a parent directory had certain permissions set. The fixed code addresses this issue by implementing additional checks to ensure that the elevated permissions are only applied under specific conditions, such as when the new object is a directory or when the user is part of the appropriate group. This enhancement effectively mitigates the risk of privilege escalation by enforcing stricter control over permission inheritance.","The vulnerability was fixed by adding conditions that restrict the inheritance of the set-group-ID (SGID) bit based on user permissions and the type of object being created. In the updated code, if the parent directory has the SGID bit set, the new inode's group ID is inherited only if the new object is a directory. For non-directory objects, the code checks if the SGID bit and execute permission for the group are both set, and it verifies that the user is part of the group or has the necessary capabilities. If these conditions are not met, the SGID bit is removed, preventing unauthorized privilege escalation.","The vulnerability was addressed by implementing additional checks that control the inheritance of specific permissions based on user context and the type of object being created. The updated code ensures that elevated permissions are only applied when the new object is a directory or when the user has the appropriate group membership and capabilities. If these conditions are not satisfied, the permissions are adjusted to prevent unauthorized access. This approach effectively mitigates the risk of privilege escalation by enforcing stricter rules around permission inheritance, ensuring that only authorized users can gain elevated group access."
3,183250,183250,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/ioquake/ioq3/commit/f61fe5f6a0419ef4a88d46a128052f2e8352e85d,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,Don't open .pk3 files as OpenAL drivers.,1,code/client/snd_openal.c,"{""sha"": ""319ea371b8a038c3cfc0d8533c7eaf7a09636066"", ""filename"": ""code/client/snd_openal.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/snd_openal.c?ref=f61fe5f6a0419ef4a88d46a128052f2e8352e85d"", ""patch"": ""@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )\n \ts_alRolloff = Cvar_Get( \""s_alRolloff\"", \""2\"", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\""s_alGraceDistance\"", \""512\"", CVAR_CHEAT);\n \n-\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n+\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n \n \ts_alInputDevice = Cvar_Get( \""s_alInputDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\""s_alDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH);\n \n+\tif ( COM_CompareExtension( s_alDriver->string, \"".pk3\"" ) )\n+\t{\n+\t\tCom_Printf( \""Rejecting DLL named \\\""%s\\\""\"", s_alDriver->string );\n+\t\treturn qfalse;\n+\t}\n+\n \t// Load QAL\n \tif( !QAL_Init( s_alDriver->string ) )\n \t{""}","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
",C,"	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

","	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
",,"@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
-	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
+	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
+	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
+	{
+		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
+		return qfalse;
+	}
+
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{",OpenJK,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,376267d534476a875d8b9228149c4ee18b74a4fd,1,"qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	// New console variables
	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
//flaw_line_below:
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
//fix_flaw_line_below:
//	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
//fix_flaw_line_below:
//	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
//fix_flaw_line_below:
//		return qfalse;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	// Device enumeration support
	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		// get all available devices + the default device name.
		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			// We don't have ALC_ENUMERATE_ALL_EXT but normal enumeration.
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		// check whether the default device is generic hardware. If it is, change to
		// Generic Software as that one works more reliably with various sound systems.
		// If it's not, use OpenAL's default selection as we don't want to ignore
		// native hardware acceleration.
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif

		// dump a list of available devices to a cvar for the user to see.

		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	// Create OpenAL context
	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	// Initialize sources, buffers, music
	S_AL_BufferInit( );
	S_AL_SrcInit( );

	// Set up OpenAL parameters (doppler, etc)
	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.
	// !!! FIXME: add support for capture device enumeration.
	// !!! FIXME: add some better error reporting.
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes
		// !!! FIXME:  capture support, but they don't list it in the
		// !!! FIXME:  extension string. We need to check the version string,
		// !!! FIXME:  then the extension string, but that's too much trouble,
		// !!! FIXME:  so we'll just check the function pointer for now.
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			// get all available input devices + the default input device name.
			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			// dump a list of available devices to a cvar for the user to see.
			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
",183250,"qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","The provided code initializes an OpenAL sound interface by setting up various sound parameters and device configurations. It begins by checking if the sound interface pointer is valid, then initializes arrays for managing audio streams. It retrieves configuration variables for sound settings, such as gain and distance parameters, and attempts to load the OpenAL library. The code checks for available audio devices and opens a specified device or defaults if necessary. It also sets up audio capture capabilities if enabled. Finally, it assigns function pointers for sound operations to the provided interface structure and returns a success status.","The code initializes a sound interface using a specific audio library, ensuring that various audio parameters and configurations are set up correctly. It checks for the validity of the interface and prepares arrays to manage audio streams. The initialization process includes loading the audio library, detecting available audio devices, and opening a specified or default device for playback. Additionally, it configures audio capture capabilities if enabled. Finally, the code assigns a series of functions for handling sound operations, such as starting, stopping, and managing audio playback, and returns a success status upon completion.","The vulnerability in the original code stemmed from the lack of validation for the audio driver string, which could allow an attacker to inject malicious code by specifying a dynamic link library with a "".pk3"" extension. This could lead to arbitrary code execution if the library was loaded. The fixed code addresses this issue by introducing a check that rejects any driver string ending with "".pk3"", thereby preventing the loading of potentially harmful libraries. This additional validation enhances the security of the initialization process by ensuring that only legitimate audio drivers are accepted.","The vulnerability in the original code arose from insufficient validation of user input, specifically allowing the loading of potentially harmful dynamic libraries without checks. This could enable an attacker to execute arbitrary code by specifying a malicious library. The fix implemented a validation step that explicitly rejects any input that matches a certain dangerous pattern, thereby preventing the loading of such libraries. This enhancement significantly improves security by ensuring that only safe and legitimate libraries are processed, thus mitigating the risk of code injection and unauthorized execution during the initialization of the audio system.","The vulnerability was fixed by adding a validation check for the audio driver string before attempting to load it. Specifically, the code now includes a condition that uses the function to compare the driver string against a dangerous pattern, rejecting any string that ends with "".pk3"". This is implemented with the `COM_CompareExtension` function, which ensures that potentially harmful libraries cannot be loaded. By incorporating this check, the code prevents the execution of arbitrary code through malicious library injection, thereby enhancing the overall security of the audio initialization process.","The vulnerability was addressed by implementing a validation mechanism that checks the input for the audio driver before it is processed. This mechanism specifically rejects any input that matches a dangerous pattern associated with potentially harmful libraries. By introducing this check, the code ensures that only safe and legitimate libraries can be loaded during the initialization process. This enhancement effectively mitigates the risk of code injection and unauthorized execution, thereby improving the overall security of the system and protecting it from malicious attacks that could exploit the previous lack of validation."
