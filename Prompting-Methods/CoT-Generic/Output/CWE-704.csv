,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,177869,177869,,Remote,Not required,Partial,CVE-2018-16513,https://www.cvedetails.com/cve/CVE-2018-16513/,CWE-704,Medium,Partial,Partial,,2018-09-05,6.8,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the setcolor function to crash the interpreter or possibly have unspecified other impact.",2019-04-25,,3,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b326a71659b7837d3acde954b18bda1a6f5e9498,b326a71659b7837d3acde954b18bda1a6f5e9498,,2,,,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
",C,"            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
","            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
",f25045e88de674a1202c1239565ee99e9ddabe91,"@@ -283,8 +283,9 @@ zsetcolor(i_ctx_t * i_ctx_p)
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
-            code = dict_find_string(op, ""Implementation"", &pImpl);
-            if (code != 0) {
+            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
+                return code;
+            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=e27baf98880bfb3a3b4ae82e96936ceefacdac78;hb=e27baf98880bfb3a3b4ae82e96936ceefacdac78,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=4c0f25827e320ceaa9b510c98f9b1926532a26d5;hb=4c0f25827e320ceaa9b510c98f9b1926532a26d5,1,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
//flaw_line_below:
            code = dict_find_string(op, ""Implementation"", &pImpl);
//flaw_line_below:
            if (code != 0) {
//fix_flaw_line_below:
//            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
//fix_flaw_line_below:
//                return code;
//fix_flaw_line_below:
//            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
",177869,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","The `zsetcolor` function is responsible for setting the color in a graphics context based on the provided parameters. It begins by determining the current color space and initializing a client color structure. The function checks if the color space requires a pattern and retrieves the necessary numeric components from the operand stack. It validates these components against the color space's requirements and prepares the color for the graphics library. Additionally, it checks for any tint transformations needed for specific applications. Finally, it sets up a continuation procedure for further processing, ensuring the execution stack has sufficient space for the operation.","The code defines a function that sets a color in a graphics context by first determining the current color space and initializing a structure for the color data. It checks if the color space requires a pattern and retrieves the necessary numeric components from the input. The function validates these components against the color space's specifications and prepares the color for use in the graphics library. Additionally, it checks for any required tint transformations for compatibility with certain applications. Finally, it sets up a continuation process for further operations, ensuring adequate space in the execution stack.","The vulnerability in the original code stemmed from inadequate error handling when retrieving the ""Implementation"" string from the dictionary. If the `dict_find_string` function failed, the code would proceed without checking the result, potentially leading to dereferencing a null pointer or accessing invalid memory. The fixed code addresses this by adding a check for the return value of `dict_find_string`, ensuring that if an error occurs (indicated by a negative return value), the function exits early. This change prevents potential crashes or undefined behavior by ensuring that only valid references are used in subsequent operations.","The vulnerability in the original code arose from insufficient error handling when attempting to retrieve a specific value from a data structure. If the retrieval operation failed, the code continued executing without verifying the result, which could lead to dereferencing invalid memory or null pointers, resulting in crashes or undefined behavior. The fixed code addresses this issue by implementing a check for the success of the retrieval operation. This ensures that if an error occurs, the function exits early, thereby preventing further operations on potentially invalid data and enhancing overall stability and security.","The vulnerability was fixed by adding a check for the return value of the `dict_find_string` function, which retrieves the ""Implementation"" string from the dictionary. In the original code, if this function failed, the subsequent code would execute without verifying the result, potentially leading to dereferencing invalid memory. The revised code now includes a conditional statement that checks if the return value is negative, indicating an error. If an error is detected, the function exits early, preventing further operations that rely on valid data and ensuring safer execution of the code.","The vulnerability was fixed by implementing a validation step to check the success of a critical data retrieval operation. In the original code, if this operation failed, the subsequent logic would execute without confirming the validity of the retrieved data, which could lead to accessing invalid memory. The revised code introduces a conditional check that verifies the outcome of the retrieval process. If an error is detected, the function exits early, thereby preventing any further actions that depend on potentially invalid data and enhancing the overall robustness and safety of the execution flow."
1,178435,178435,,Remote,Not required,Partial,CVE-2016-8602,https://www.cvedetails.com/cve/CVE-2016-8602/,CWE-704,Medium,Partial,Partial,,2017-04-14,6.8,The .sethalftone5 function in psi/zht2.c in Ghostscript before 9.21 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted Postscript document that calls .sethalftone5 with an empty operand stack.,2018-01-04,DoS Exec Code,10,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=f5c7555c303,f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78,,2,,,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum = dict_first(op);
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
",C,"    int dict_enum;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
","    int dict_enum = dict_first(op);
    int space_index = r_space_index(op - 1);
",a5360401495654e89301b2516703c1d2877fc5ba,"@@ -82,14 +82,22 @@ zsethalftone5(i_ctx_t *i_ctx_p)
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
-    int dict_enum = dict_first(op);
+    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
-    int space_index = r_space_index(op - 1);
+    int space_index;
+
+    if (ref_stack_count(&o_stack) < 2)
+        return_error(gs_error_stackunderflow);
+    check_type(*op, t_dictionary);
+    check_type(*(op - 1), t_dictionary);
+
+    dict_enum = dict_first(op);
+    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=dfa27a40ff46f497c929e12053753023212fcb26;hb=f5c7555c303,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=fb4a2649d4de8879f7033256c66634b691fee691,1,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
//flaw_line_below:
    int dict_enum = dict_first(op);
//fix_flaw_line_below:
//    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
//flaw_line_below:
    int space_index = r_space_index(op - 1);
//fix_flaw_line_below:
//    int space_index;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (ref_stack_count(&o_stack) < 2)
//fix_flaw_line_below:
//        return_error(gs_error_stackunderflow);
//fix_flaw_line_below:
//    check_type(*op, t_dictionary);
//fix_flaw_line_below:
//    check_type(*(op - 1), t_dictionary);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    dict_enum = dict_first(op);
//fix_flaw_line_below:
//    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
",178435,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum = dict_first(op);
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","The `zsethalftone5` function is designed to configure halftone settings for a graphics context in a rendering system. It processes a dictionary of halftone components, validating their types and parameters, and ensuring that a default component is included. The function allocates memory for halftone structures and initializes them based on the specified halftone type, which can be multiple colorscreen or multiple. It also handles the scheduling of sampling for various screen types and transfer functions, managing stack states to ensure proper cleanup in case of errors. Ultimately, it prepares the graphics state for rendering with the defined halftone settings.","The code defines a function that configures halftone settings for a graphics rendering context. It processes a collection of halftone components, ensuring that each component is valid and that at least one default component is present. The function allocates necessary memory for halftone structures and initializes them based on specified types. It also manages the scheduling of sampling for different screen types and transfer functions, while maintaining stack integrity for error handling. Ultimately, the function prepares the rendering context to utilize the defined halftone settings effectively during graphics output.","The vulnerability in the original code stemmed from a lack of checks for stack underflow, which could lead to accessing invalid memory or dereferencing null pointers. Specifically, the absence of a check for the stack size before accessing elements could result in errors if the stack was not sufficiently populated. The fixed code addresses this issue by introducing a condition that verifies the stack's count before proceeding with operations that depend on stack elements. This ensures that the function only executes when there are enough elements in the stack, thereby preventing potential crashes or undefined behavior.","The vulnerability in the original code was due to insufficient checks for stack underflow, which could lead to accessing invalid memory or dereferencing null pointers when the stack did not contain enough elements. This oversight could result in crashes or unpredictable behavior during execution. The fixed code addresses this issue by implementing a check to ensure that the stack has a minimum number of elements before proceeding with operations that rely on those elements. This safeguard prevents the function from executing in unsafe conditions, thereby enhancing the stability and reliability of the code.","The vulnerability was fixed by adding a check for stack underflow at the beginning of the function. Specifically, the code now verifies that the count of elements in the output stack is at least two before proceeding with any operations that access stack elements. This is done using a condition that returns an error if the stack count is insufficient. By implementing this safeguard, the function ensures that it only operates when there are enough elements available, thus preventing potential crashes or undefined behavior that could arise from dereferencing null or invalid pointers.","The vulnerability was fixed by introducing a preliminary check to ensure that the stack contains a sufficient number of elements before any operations are performed. This safeguard prevents the function from attempting to access or manipulate elements when the stack is underpopulated, which could lead to accessing invalid memory or causing crashes. By validating the stack's state at the start, the code ensures that it only proceeds with operations when it is safe to do so, thereby enhancing the overall stability and reliability of the function during execution."
2,182365,182365,,Remote,Not required,Partial,CVE-2018-12453,https://www.cvedetails.com/cve/CVE-2018-12453/,CWE-704,Low,,,,2018-06-16,5.0,Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.,2018-08-14,,1,https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,Abort in XGROUP if the key is not a stream,1,src/t_stream.c,"{""sha"": ""c48928018c04d68e68b0191e202144978fe327a4"", ""filename"": ""src/t_stream.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/t_stream.c?ref=c04082cf138f1f51cedf05ee9ad36fb6763cafc6"", ""patch"": ""@@ -1576,7 +1576,7 @@ NULL\n     /* Lookup the key now, this is common for all the subcommands but HELP. */\n     if (c->argc >= 4) {\n         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n-        if (o == NULL) return;\n+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n         s = o->ptr;\n         grpname = c->argv[3]->ptr;\n ""}","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
",C,"        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
","        if (o == NULL) return;
",,"@@ -1576,7 +1576,7 @@ NULL
     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
-        if (o == NULL) return;
+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 ",redis,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,be899b824edd312d4e3a1998c56626d66fae3b61,1,"void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
//flaw_line_below:
        if (o == NULL) return;
//fix_flaw_line_below:
//        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
",182365,"void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","The provided code defines a function `xgroupCommand` that handles various subcommands related to consumer groups in a stream data structure. It processes commands such as creating a new consumer group, setting the current group ID, deleting a group or a specific consumer, and providing help information. The function first checks the validity of the input parameters and the existence of the specified stream and group. Depending on the subcommand, it performs actions like creating a group with a specified ID, updating the group's last ID, removing a group or consumer, and returning appropriate responses or error messages to the client.","The code implements a function that manages consumer groups within a stream data structure, allowing users to create, modify, delete, and retrieve information about these groups. It processes various commands, including creating a new group, setting the current group ID, and removing groups or specific consumers. The function validates input parameters and checks for the existence of the specified stream and group before executing the requested action. It provides appropriate responses or error messages based on the outcome of each operation, ensuring that users receive feedback on their commands and the state of the consumer groups.","The vulnerability in the original code arises from the lack of type checking for the object retrieved using `lookupKeyWriteOrReply`. If the key does not correspond to a stream type, subsequent operations could lead to undefined behavior or crashes. The fixed code addresses this issue by adding a call to `checkType`, which ensures that the object is indeed of the expected stream type before proceeding. This additional validation prevents the function from executing commands on incompatible data types, thereby enhancing the robustness and security of the code by mitigating potential exploitation through type confusion.","The vulnerability in the original code stems from the absence of type validation for the data structure being accessed, which could lead to operations being performed on incompatible types. This oversight could result in undefined behavior, crashes, or exploitation by malicious users. The fixed code addresses this issue by incorporating a type-checking mechanism that verifies the data structure's type before any further processing occurs. This enhancement ensures that only valid operations are executed on the correct data type, thereby improving the overall security and stability of the function by preventing potential misuse or errors.","The vulnerability was fixed by adding a type-checking mechanism using the `checkType` function after retrieving the object with `lookupKeyWriteOrReply`. This additional validation ensures that the object is of the expected stream type before any operations are performed. If the object does not meet the required type, the function will return early, preventing further execution that could lead to undefined behavior or crashes. By enforcing this type check, the code now safeguards against executing commands on incompatible data structures, thereby enhancing its robustness and security.","The vulnerability was fixed by implementing a validation step that checks the type of the data structure being accessed before any operations are performed. This additional check ensures that the data structure is of the expected type, preventing the execution of commands on incompatible or incorrect data. If the type validation fails, the function exits early, thereby avoiding potential undefined behavior or crashes that could arise from operating on the wrong type. This enhancement significantly improves the security and stability of the code by ensuring that only valid operations are executed on appropriate data structures."
3,183037,183037,,Remote,Not required,Partial,CVE-2016-7398,https://www.cvedetails.com/cve/CVE-2016-7398/,CWE-704,Low,Partial,Partial,,2019-09-06,7.5,A type confusion vulnerability in the merge_param() function of php_http_params.c in PHP's pecl-http extension 3.1.0beta2 (PHP 7) and earlier as well as 2.6.0beta2 (PHP 5) and earlier allows attackers to crash PHP and possibly execute arbitrary code via crafted HTTP requests.,2019-09-20,Exec Code ,1,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,17137d4ab1ce81a2cee0fae842340a344ef3da83,fix bug #73055,1,src/php_http_params.c,"{""sha"": ""45ac1a5f203ae766bd3662ce1fe7a59e677ceb02"", ""filename"": "".gitignore"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 0, ""changes"": 33, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/.gitignore?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -42,3 +42,36 @@ lcov_data\n *.phar\n vendor/\n tests/helper/server.log\n+php_http_api.h\n+php_http_buffer.h\n+php_http_client.h\n+php_http_client_curl.h\n+php_http_client_curl_event.h\n+php_http_client_curl_user.h\n+php_http_client_request.h\n+php_http_client_response.h\n+php_http_cookie.h\n+php_http_curl.h\n+php_http_encoding.h\n+php_http_env.h\n+php_http_env_request.h\n+php_http_env_response.h\n+php_http_etag.h\n+php_http_exception.h\n+php_http_filter.h\n+php_http_header.h\n+php_http_header_parser.h\n+php_http_info.h\n+php_http_message.h\n+php_http_message_body.h\n+php_http_message_parser.h\n+php_http_misc.h\n+php_http_negotiate.h\n+php_http_object.h\n+php_http_options.h\n+php_http_params.h\n+php_http_querystring.h\n+php_http_response_codes.h\n+php_http_url.h\n+php_http_utf8.h\n+php_http_version.h""}<_**next**_>{""sha"": ""7191f314ad8cc64d1d99491e09010f271a89ae9c"", ""filename"": ""package.xml"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/package.xml?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -31,9 +31,9 @@ https://mdref.m6w6.name/http\n   <email>mike@php.net</email>\n   <active>yes</active>\n  </lead>\n- <date>2016-09-07</date>\n+ <date>2016-09-12</date>\n  <version>\n-  <release>2.6.0beta2</release>\n+  <release>2.6.0RC1</release>\n   <api>2.6.0</api>\n  </version>\n  <stability>\n@@ -69,6 +69,10 @@ https://mdref.m6w6.name/http\n Changes from beta1:\n * Fixed PHP-5.3 compatibility\n * Fixed recursive calls to the event loop dispatcher\n+\n+Changes from beta2:\n+* Fix bug #73055: crash in http\\QueryString (Mike, @rc0r)\n+* Fix HTTP/2 version parser for older libcurl versions (Mike)\n ]]></notes>\n  <contents>\n   <dir name=\""/\"">\n@@ -185,6 +189,7 @@ Changes from beta1:\n      <file role=\""test\"" name=\""bug69313.phpt\""/>\n      <file role=\""test\"" name=\""bug69357.phpt\""/>\n      <file role=\""test\"" name=\""bug71719.phpt\""/>\n+     <file role=\""test\"" name=\""bug73055.phpt\""/>\n      <file role=\""test\"" name=\""client001.phpt\""/>\n      <file role=\""test\"" name=\""client002.phpt\""/>\n      <file role=\""test\"" name=\""client003.phpt\""/>""}<_**next**_>{""sha"": ""90710684deabe6d08bd5e81d8e1563086f0095a6"", ""filename"": ""src/php_http_params.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/src/php_http_params.c?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z\n \t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n \t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n \t\t\t) {\n-\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n+\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {\n \n \t\t\t\t\t/* now find key in ptr */\n \t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {""}","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
",C,"				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
","				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
",,"@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z
 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
-				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
+				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {",ext-http,17137d4ab1ce81a2cee0fae842340a344ef3da83,3c7b514d38d844b855d430fcbaed6dea67c9c17b,1,"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
//flaw_line_below:
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
//fix_flaw_line_below:
//				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
",183037,"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","The provided code defines a function `merge_param` that merges parameters from a `zval` array (`zdata`) into a hash table (`params`). It checks if the current key from `zdata` exists in `params`, creating a new entry if it doesn't. If the key exists, it merges the values, handling both string and integer keys. The function recursively traverses nested arrays, updating or inserting values as necessary, and ensures proper reference counting for memory management. Finally, it updates the pointer to the current parameter, allowing for further manipulation or retrieval of merged data.","The code defines a function that merges data from one array into a hash table, checking for the existence of keys and creating new entries when necessary. It handles both string and integer keys, allowing for the insertion or updating of values. The function traverses nested arrays recursively, ensuring that values are properly referenced and managed in memory. If a key already exists, it merges the corresponding values, maintaining the structure of the data. Ultimately, the function updates a pointer to reflect the current state of the merged data, facilitating further operations on it.","The vulnerability in the original code arises from improper handling of references and memory management, particularly when merging data from one array into another. Specifically, the code did not adequately check if the current data was an array before attempting to access or modify it, which could lead to dereferencing null or invalid pointers. This was addressed in the fixed code by adding checks to ensure that both the source and destination pointers are arrays before proceeding with operations like `zend_hash_find` and `zend_hash_update`. This change mitigates the risk of segmentation faults and undefined behavior due to invalid memory access.","The vulnerability in the original code stemmed from inadequate checks for the types of data being manipulated, which could lead to dereferencing null or invalid pointers. This oversight allowed for potential segmentation faults or undefined behavior when merging data from one structure into another, particularly when the expected data types did not match. The fixed code addressed this issue by implementing additional checks to ensure that both the source and destination data were valid arrays before performing any operations. This enhancement significantly improved the robustness of the code by preventing invalid memory access and ensuring safer data handling.","The vulnerability was fixed by adding checks to ensure that both the source and destination pointers are valid arrays before performing operations. In the updated code, conditions were introduced to verify the type of the pointer using `Z_TYPE_PP(ptr)` and `Z_TYPE_PP(test_ptr)`, ensuring they are arrays before proceeding with functions like `zend_hash_find` and `zend_hash_update`. This prevents dereferencing null or invalid pointers, which could lead to segmentation faults. Additionally, the code now properly handles cases where the data structure might not be as expected, enhancing overall stability and safety during the merging process.","The vulnerability was fixed by implementing additional type checks to ensure that the data being accessed and modified was valid and of the expected type. The updated code introduced conditions that verify the integrity of the data structures before performing any operations, thereby preventing the dereferencing of null or invalid pointers. This proactive approach ensures that only valid arrays are manipulated, significantly reducing the risk of segmentation faults or undefined behavior. By enhancing the robustness of the data handling process, the code now operates more safely and reliably during the merging of data."
4,186285,186285,,Remote,Not required,,CVE-2017-5094,https://www.cvedetails.com/cve/CVE-2017-5094/,CWE-704,Medium,,Partial,,2017-10-27,4.3,"Type confusion in extensions JavaScript bindings in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted HTML page.",2018-01-04,,18,https://github.com/chromium/chromium/commit/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,"SkiaRenderer: Support changing color space

SkiaOutputSurfaceImpl did not handle the color space changing after it
was created previously. The SkSurfaceCharacterization color space was
only set during the first time Reshape() ran when the charactization is
returned from the GPU thread. If the color space was changed later the
SkSurface and SkDDL color spaces no longer matched and draw failed.

Bug: 1009452
Change-Id: Ib6d2083efc7e7eb6f94782342e92a809b69d6fdc
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1841811
Reviewed-by: Peng Huang <penghuang@chromium.org>
Commit-Queue: kylechar <kylechar@chromium.org>
Cr-Commit-Position: refs/heads/master@{#702946}",9,components/viz/service/display_embedder/skia_output_surface_impl.cc,"{""sha"": ""2e06d978df84358e1db9b704d4bdf275fbfbfd60"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 10, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n-    initialize_waitable_event_ = nullptr;\n+    initialize_waitable_event_.reset();\n   }\n \n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n-    // TODO(weiliang): support color space. https://crbug.com/795132\n-    characterization_ =\n-        characterization_.createResized(size.width(), size.height());\n+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();\n+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),\n+                              sk_color_space.get())) {\n+      characterization_ = characterization_.createColorSpace(sk_color_space);\n+    }\n+    if (size.width() != characterization_.width() ||\n+        size.height() != characterization_.height()) {\n+      characterization_ =\n+          characterization_.createResized(size.width(), size.height());\n+    }\n+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n \n   // impl_on_gpu_ is released on the GPU thread by a posted task from\n   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.\n-  auto callback = base::BindOnce(\n-      &SkiaOutputSurfaceImplOnGpu::Reshape,\n-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n-      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n-      characterization, initialize_waitable_event_.get());\n-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,\n+                             base::Unretained(impl_on_gpu_.get()), size,\n+                             device_scale_factor, color_space, has_alpha,\n+                             use_stencil, pre_transform_, characterization,\n+                             initialize_waitable_event_.get());\n+  ScheduleGpuTask(std::move(task), {});\n }\n \n void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(""}<_**next**_>{""sha"": ""df9015ce046774c45d6f45db1818fcfbeabbff88"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 4, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -11,13 +11,15 @@\n #include \""base/base64.h\""\n #include \""base/bind.h\""\n #include \""base/command_line.h\""\n+#include \""base/run_loop.h\""\n #include \""base/test/scoped_feature_list.h\""\n #include \""cc/test/fake_output_surface_client.h\""\n #include \""cc/test/pixel_test_utils.h\""\n #include \""components/viz/common/display/renderer_settings.h\""\n #include \""components/viz/common/frame_sinks/copy_output_request.h\""\n #include \""components/viz/common/frame_sinks/copy_output_result.h\""\n #include \""components/viz/common/frame_sinks/copy_output_util.h\""\n+#include \""components/viz/service/display/output_surface_frame.h\""\n #include \""components/viz/service/display_embedder/skia_output_surface_dependency_impl.h\""\n #include \""components/viz/service/gl/gpu_service_impl.h\""\n #include \""components/viz/test/test_gpu_service_holder.h\""\n@@ -197,12 +199,34 @@ TEST_P(SkiaOutputSurfaceImplTest, SubmitPaint) {\n       base::BindOnce(&SkiaOutputSurfaceImplTest::CheckSyncTokenOnGpuThread,\n                      base::Unretained(this), sync_token);\n \n-  std::vector<gpu::SyncToken> resource_sync_tokens;\n-  resource_sync_tokens.push_back(sync_token);\n-  output_surface_->ScheduleGpuTaskForTesting(std::move(closure),\n-                                             std::move(resource_sync_tokens));\n+  output_surface_->ScheduleGpuTaskForTesting(std::move(closure), {sync_token});\n   BlockMainThread();\n   EXPECT_TRUE(on_finished_called);\n }\n \n+// Draws two frames and calls Reshape() between the two frames changing the\n+// color space. Verifies draw after color space change is successful.\n+TEST_P(SkiaOutputSurfaceImplTest, SupportsColorSpaceChange) {\n+  for (auto& color_space : {gfx::ColorSpace(), gfx::ColorSpace::CreateSRGB()}) {\n+    output_surface_->Reshape(kSurfaceRect.size(), 1, color_space,\n+                             /*has_alpha=*/false, /*use_stencil=*/false);\n+\n+    // Draw something, it's not important what.\n+    SkCanvas* root_canvas = output_surface_->BeginPaintCurrentFrame();\n+    SkPaint paint;\n+    paint.setColor(SK_ColorRED);\n+    root_canvas->drawRect(SkRect::MakeWH(10, 10), paint);\n+\n+    base::RunLoop run_loop;\n+    output_surface_->SubmitPaint(run_loop.QuitClosure());\n+\n+    OutputSurfaceFrame frame;\n+    frame.size = kSurfaceRect.size();\n+    output_surface_->SkiaSwapBuffers(std::move(frame),\n+                                     /*wants_sync_token=*/false);\n+\n+    run_loop.Run();\n+  }\n+}\n+\n }  // namespace viz""}","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
",C,"    initialize_waitable_event_.reset();
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
","    initialize_waitable_event_ = nullptr;
    characterization_ =
        characterization_.createResized(size.width(), size.height());
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
",,"@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
-    initialize_waitable_event_ = nullptr;
+    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
-    // TODO(weiliang): support color space. https://crbug.com/795132
-    characterization_ =
-        characterization_.createResized(size.width(), size.height());
+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
+                              sk_color_space.get())) {
+      characterization_ = characterization_.createColorSpace(sk_color_space);
+    }
+    if (size.width() != characterization_.width() ||
+        size.height() != characterization_.height()) {
+      characterization_ =
+          characterization_.createResized(size.width(), size.height());
+    }
+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
-  auto callback = base::BindOnce(
-      &SkiaOutputSurfaceImplOnGpu::Reshape,
-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
-      std::move(color_space), has_alpha, use_stencil, pre_transform_,
-      characterization, initialize_waitable_event_.get());
-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
+                             base::Unretained(impl_on_gpu_.get()), size,
+                             device_scale_factor, color_space, has_alpha,
+                             use_stencil, pre_transform_, characterization,
+                             initialize_waitable_event_.get());
+  ScheduleGpuTask(std::move(task), {});
 }
 
 void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(",Chrome,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,f223cb069262bb1fab90e47669e71d376f9db789,1,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
//flaw_line_below:
    initialize_waitable_event_ = nullptr;
//fix_flaw_line_below:
//    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
//flaw_line_below:
    // TODO(weiliang): support color space. https://crbug.com/795132
//flaw_line_below:
    characterization_ =
//flaw_line_below:
        characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
//fix_flaw_line_below:
//    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
//fix_flaw_line_below:
//                              sk_color_space.get())) {
//fix_flaw_line_below:
//      characterization_ = characterization_.createColorSpace(sk_color_space);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (size.width() != characterization_.width() ||
//fix_flaw_line_below:
//        size.height() != characterization_.height()) {
//fix_flaw_line_below:
//      characterization_ =
//fix_flaw_line_below:
//          characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
//flaw_line_below:
  auto callback = base::BindOnce(
//flaw_line_below:
      &SkiaOutputSurfaceImplOnGpu::Reshape,
//flaw_line_below:
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
//flaw_line_below:
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
//flaw_line_below:
      characterization, initialize_waitable_event_.get());
//flaw_line_below:
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
//fix_flaw_line_below:
//  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
//fix_flaw_line_below:
//                             base::Unretained(impl_on_gpu_.get()), size,
//fix_flaw_line_below:
//                             device_scale_factor, color_space, has_alpha,
//fix_flaw_line_below:
//                             use_stencil, pre_transform_, characterization,
//fix_flaw_line_below:
//                             initialize_waitable_event_.get());
//fix_flaw_line_below:
//  ScheduleGpuTask(std::move(task), {});
 }
",186285,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
","The provided code defines a method `Reshape` within the `SkiaOutputSurfaceImpl` class, which is responsible for adjusting the dimensions and properties of a graphics output surface. It first ensures that the method is called on a valid thread and waits for an initialization event if necessary. The method checks if a valid surface characterization exists; if so, it resizes it and recreates the root recorder. If not, it initializes a waitable event. Finally, it schedules a GPU task to reshape the surface using a callback that includes parameters like size, device scale factor, color space, and alpha settings, ensuring proper synchronization.","The code defines a method that adjusts the properties of a graphics output surface, ensuring it operates on a valid thread. It waits for an initialization event if required and checks if a valid surface characterization exists. If it does, the method resizes this characterization and updates the root recorder; if not, it sets up a waitable event for future synchronization. Finally, it schedules a task to reshape the surface, passing along various parameters related to size, scaling, color properties, and alpha settings, ensuring that the operation is properly coordinated with the GPU.","The vulnerability in the original code stemmed from the lack of proper handling of color space changes and surface resizing, which could lead to inconsistencies and potential crashes. Specifically, the absence of checks to compare the existing color space with the new one allowed for mismatches that could compromise rendering quality. The fixed code introduces a comparison using `SkColorSpace::Equals` to ensure that the color space is updated only when necessary, and it also checks the dimensions before resizing the characterization. This added validation prevents unintended behavior and enhances the stability of the graphics output surface.","The vulnerability in the original code arose from inadequate checks for changes in color space and surface dimensions, which could lead to inconsistencies and crashes during rendering. Without validating whether the new color space differed from the existing one, the code risked using incompatible settings, potentially causing rendering artifacts or failures. The fixed code addresses this issue by implementing checks to compare the current and new color spaces, ensuring they match before making updates. Additionally, it verifies the dimensions before resizing, thereby enhancing the robustness and stability of the graphics output surface management.","The vulnerability was fixed by introducing checks to validate the color space and dimensions before making updates to the surface characterization. The code now uses `SkColorSpace::Equals` to compare the existing color space with the new one, ensuring that the characterization is only updated if they differ. Additionally, it checks the width and height of the new size against the current characterization dimensions before resizing it with `createResized`. These enhancements prevent unnecessary updates and potential inconsistencies, thereby improving the stability and reliability of the graphics output surface management process.","The vulnerability was addressed by implementing validation checks to ensure that updates to the graphics surface only occur when necessary. The code now compares the existing color space with the new one, preventing updates that could lead to inconsistencies. Additionally, it verifies the dimensions of the surface before resizing, ensuring that changes are made only when the new size differs from the current one. These improvements enhance the overall stability and reliability of the graphics output management, reducing the risk of rendering issues and crashes associated with mismatched settings."
5,186317,186317,,Remote,Not required,Partial,CVE-2017-5108,https://www.cvedetails.com/cve/CVE-2017-5108/,CWE-704,Medium,Partial,Partial,,2017-10-27,6.8,"Type confusion in PDFium in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted PDF file.",2018-01-04,,2,https://github.com/chromium/chromium/commit/5cb799a393ba9e732f89f687ff3a322b4514ebfb,5cb799a393ba9e732f89f687ff3a322b4514ebfb,"autofocus: Fix a crash with an autofocus element in a document without browsing context.

ShouldAutofocus() should check existence of the browsing context.
Otherwise, doc.TopFrameOrigin() returns null.

Before crrev.com/695830, ShouldAutofocus() was called only for
rendered elements. That is to say, the document always had
browsing context.

Bug: 1003228
Change-Id: I2a941c34e9707d44869a6d7585dc7fb9f06e3bf4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1800902
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Keishi Hattori <keishi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#696291}",0,third_party/blink/renderer/core/html/forms/html_form_control_element.cc,"{""sha"": ""c134f907b1b8df93bd079d25ac525224c83b24db"", ""filename"": ""third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/forms/html_form_control_element.cc?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n   Document& doc = element->GetDocument();\n \n   // 3. If target's browsing context is null, then return.\n+  if (!doc.GetFrame())\n+    return false;\n \n   // 4. If target's active sandboxing flag set has the sandboxed automatic\n   // features browsing context flag, then return.""}<_**next**_>{""sha"": ""104dd5a4a5e371bf5002c7435e718d8e032fff5a"", ""filename"": ""third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 1, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -8,11 +8,19 @@\n <script>\n 'use strict';\n \n+promise_test(async () => {\n+  let doc = document.cloneNode(false);\n+  doc.appendChild(doc.createElement('html'))\n+  doc.firstChild.innerHTML = '<body><input autofocus/></body>';\n+  await waitUntilStableAutofocusState();\n+  assert_equals(doc.activeElement, doc.body);\n+}, 'Autofocus element in not-fully-active document should not be queued.');\n+\n promise_test(async () => {\n   let iframe = document.querySelector('iframe');\n   let iframeDocument = iframe.contentDocument;\n   await waitForLoad(window);\n   assert_not_equals(document.activeElement, iframe);\n   assert_equals(iframeDocument.activeElement, iframeDocument.body);\n-}, 'Autofocus element in not-fully-active document should be skipped.');\n+}, 'Autofocus element in not-fully-active document should be skipped while flusing.');\n </script>""}","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
  if (!doc.GetFrame())
    return false;
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
",C,"  if (!doc.GetFrame())
    return false;
",,,"@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
+  if (!doc.GetFrame())
+    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.",Chrome,5cb799a393ba9e732f89f687ff3a322b4514ebfb,9c7cd1e691d850ca82244fccd97d91d68b29a1d0,1,"static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  // When an element with the autofocus attribute specified is inserted into a
  // document, run the following steps:
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;

  // 1. If the user has indicated (for example, by starting to type in a form
  // control) that they do not wish focus to be changed, then optionally return.

  // We don't implement this optional step. If other browsers have such
  // behavior, we should follow it or standardize it.

  // 2. Let target be the element's node document.
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
//fix_flaw_line_below:
//  if (!doc.GetFrame())
//fix_flaw_line_below:
//    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  // 5. Let topDocument be the active document of target's browsing context's
  // top-level browsing context.
  // 6. If target's origin is not the same as the origin of topDocument,
  // then return.
  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  // Will call Document::EnqueueAutofocusCandidate() with |element|.
  return true;
}
",186317,"static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
  if (!doc.GetFrame())
    return false;
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","The `ShouldAutofocus` function determines whether a given HTML form control element can be automatically focused. It first checks if the element is connected to the document and if it is eligible for autofocus. If the document is sandboxed without the 'allow-scripts' permission, it logs an error message and returns false. Additionally, if the element is in a cross-origin subframe that cannot access the top frame's security origin, it also logs an error and returns false. If all conditions are met, the function returns true, indicating that autofocus is permitted for the element.","The code defines a function that assesses whether a form control element can be automatically focused. It begins by verifying the element's connection to the document and its eligibility for autofocus. If the document is restricted by sandboxing without specific permissions, an error message is logged, and autofocus is denied. Additionally, if the element resides in a cross-origin subframe that lacks access to the main frame's security context, another error message is recorded, and autofocus is also blocked. If none of these conditions are violated, the function allows the autofocus action to proceed.","The vulnerability in the original code stemmed from the lack of a check for the presence of a frame associated with the document, which could lead to unintended behavior when attempting to autofocus elements in certain contexts. Specifically, if the document did not have an associated frame, the function could still proceed to evaluate sandboxing and cross-origin access, potentially allowing autofocus in insecure situations. The fix introduced a check using `doc.GetFrame()`, ensuring that the function returns false immediately if no frame exists, thereby preventing any further checks and enhancing security by avoiding risky autofocus actions in invalid contexts.","The vulnerability in the original code arose from the absence of a check for the existence of a frame associated with the document, which could lead to unsafe autofocus behavior in certain scenarios. Without this verification, the function could inadvertently allow autofocus on elements in contexts that should be restricted, such as when no frame is present. The fix addressed this issue by introducing a condition to ensure that the function returns false if no frame is found, thereby preventing further checks and enhancing security by disallowing autofocus actions in invalid or insecure contexts.","The vulnerability was fixed by adding a crucial check for the presence of a frame associated with the document using `doc.GetFrame()`. This new condition ensures that if no frame exists, the function immediately returns false, preventing any further evaluation of sandboxing or cross-origin access. By implementing this check, the code effectively blocks autofocus actions in contexts that lack a valid frame, thereby enhancing security. This modification prevents the function from proceeding to potentially unsafe conditions, ensuring that autofocus is only allowed in appropriate and secure environments.","The vulnerability was addressed by introducing a critical check to verify the existence of a frame associated with the document before proceeding with any further evaluations. This additional condition ensures that if no frame is present, the function will immediately terminate and deny autofocus, thereby preventing any unsafe actions. By implementing this safeguard, the code effectively blocks autofocus in contexts that are invalid or insecure, ensuring that subsequent checks related to sandboxing and cross-origin access are only performed when a valid frame exists. This enhancement significantly improves the overall security of the autofocus functionality."
6,187049,187049,,Remote,Not required,Partial,CVE-2019-5757,https://www.cvedetails.com/cve/CVE-2019-5757/,CWE-704,Medium,Partial,Partial,,2019-02-19,6.8,An incorrect object type assumption in SVG in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit object corruption via a crafted HTML page.,2019-04-18,,2,https://github.com/chromium/chromium/commit/032c3339bfb454c65ce38e7eafe49a54bac83073,032c3339bfb454c65ce38e7eafe49a54bac83073,"Fix SVG crash for v0 distribution into foreignObject.

We require a parent element to be an SVG element for non-svg-root
elements in order to create a LayoutObject for them. However, we checked
the light tree parent element, not the flat tree one which is the parent
for the layout tree construction. Note that this is just an issue in
Shadow DOM v0 since v1 does not allow shadow roots on SVG elements.

Bug: 915469
Change-Id: Id81843abad08814fae747b5bc81c09666583f130
Reviewed-on: https://chromium-review.googlesource.com/c/1382494
Reviewed-by: Fredrik Sderquist <fs@opera.com>
Commit-Queue: Rune Lillesveen <futhark@chromium.org>
Cr-Commit-Position: refs/heads/master@{#617487}",2,third_party/blink/renderer/core/svg/svg_element.cc,"{""sha"": ""b39b8168ec7c68ea811ec1f6f2be9f01a4c76405"", ""filename"": ""third_party/blink/renderer/core/svg/svg_element.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/svg/svg_element.cc?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""third_party/blink/renderer/core/dom/document.h\""\n #include \""third_party/blink/renderer/core/dom/element_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/events/event.h\""\n+#include \""third_party/blink/renderer/core/dom/flat_tree_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/node_computed_style.h\""\n #include \""third_party/blink/renderer/core/dom/shadow_root.h\""\n #include \""third_party/blink/renderer/core/frame/csp/content_security_policy.h\""\n@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {\n }\n \n bool SVGElement::HasSVGParent() const {\n-  // Should we use the flat tree parent instead? If so, we should probably fix a\n-  // few other checks.\n-  return ParentOrShadowHostElement() &&\n-         ParentOrShadowHostElement()->IsSVGElement();\n+  Element* parent = FlatTreeTraversal::ParentElement(*this);\n+  return parent && parent->IsSVGElement();\n }\n \n MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {""}<_**next**_>{""sha"": ""44ac3b0540b8f5a816a67b5be382b179623bd0cd"", ""filename"": ""third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<script src=\""../../resources/testharness.js\""></script>\n+<script src=\""../../resources/testharnessreport.js\""></script>\n+<p>PASS if no crash or DCHECK failure.</p>\n+<svg id=\""svg\""><g /></svg>\n+<script>\n+  test(() => {\n+    const root = svg.createShadowRoot();\n+    root.innerHTML = '<foreignObject><div><content></content></div></foreignObject>';\n+  }, \""Rendering an svg g element distributed into a foreignObject will crash.\"");\n+</script>""}"," bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
"," bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
",C,"  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
","  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
",,"@@ -37,6 +37,7 @@
 #include ""third_party/blink/renderer/core/dom/document.h""
 #include ""third_party/blink/renderer/core/dom/element_traversal.h""
 #include ""third_party/blink/renderer/core/dom/events/event.h""
+#include ""third_party/blink/renderer/core/dom/flat_tree_traversal.h""
 #include ""third_party/blink/renderer/core/dom/node_computed_style.h""
 #include ""third_party/blink/renderer/core/dom/shadow_root.h""
 #include ""third_party/blink/renderer/core/frame/csp/content_security_policy.h""
@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {
 }
 
 bool SVGElement::HasSVGParent() const {
-  // Should we use the flat tree parent instead? If so, we should probably fix a
-  // few other checks.
-  return ParentOrShadowHostElement() &&
-         ParentOrShadowHostElement()->IsSVGElement();
+  Element* parent = FlatTreeTraversal::ParentElement(*this);
+  return parent && parent->IsSVGElement();
 }
 
 MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {",Chrome,032c3339bfb454c65ce38e7eafe49a54bac83073,7917a910e959b8e46a16cde1391d2b681e64d4a8,1," bool SVGElement::HasSVGParent() const {
//flaw_line_below:
  // Should we use the flat tree parent instead? If so, we should probably fix a
//flaw_line_below:
  // few other checks.
//flaw_line_below:
  return ParentOrShadowHostElement() &&
//flaw_line_below:
         ParentOrShadowHostElement()->IsSVGElement();
//fix_flaw_line_below:
//  Element* parent = FlatTreeTraversal::ParentElement(*this);
//fix_flaw_line_below:
//  return parent && parent->IsSVGElement();
 }
",187049," bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
"," bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
","The `HasSVGParent` function is a member of the `SVGElement` class, designed to determine if the current SVG element has an SVG parent. It first calls the `ParentOrShadowHostElement()` method to retrieve the parent element or shadow host. If this parent exists, the function then checks whether it is an SVG element by invoking the `IsSVGElement()` method on the parent. The function returns a boolean value: `true` if the parent is an SVG element and `false` otherwise, effectively indicating the presence of an SVG hierarchy for the current element.","This function checks whether the current element has a parent that is part of a specific graphical structure. It first determines if there is a parent or a shadow host associated with the current element. If such a parent exists, the function then verifies if this parent belongs to the same graphical structure. The outcome is a boolean value indicating whether the current element is nested within a hierarchy of elements of the same type, thereby providing insight into the structural relationship of the current element within the overall graphical context.","The vulnerability in the original code stemmed from directly calling `ParentOrShadowHostElement()` without ensuring that it returned a valid parent element, which could lead to dereferencing a null pointer if the parent did not exist. This oversight could result in undefined behavior or crashes. In the fixed code, the function now uses `FlatTreeTraversal::ParentElement(*this)` to safely obtain the parent element, storing it in a variable. This approach ensures that the parent is checked for validity before proceeding to verify if it is an SVG element, thus enhancing the robustness and safety of the function.","The vulnerability in the original code arose from the potential for dereferencing a null pointer when attempting to access the parent element without proper validation. This could lead to crashes or undefined behavior if the parent did not exist. The fixed code addresses this issue by first safely retrieving the parent element and storing it in a variable, ensuring that it is valid before performing any further checks. This change enhances the code's reliability by preventing null dereferences, thereby ensuring that the function operates correctly even when the parent element is absent.","The vulnerability was fixed by modifying the way the parent element is retrieved and validated. In the original code, the function directly called `ParentOrShadowHostElement()`, which could return a null pointer, leading to potential dereferencing issues. The updated code replaces this with `FlatTreeTraversal::ParentElement(*this)`, which safely obtains the parent element and assigns it to a variable. This approach allows for a clear check of the parents validity before invoking `IsSVGElement()`. By ensuring that the parent is valid before proceeding, the fixed code effectively prevents null pointer dereferences and enhances overall stability.","The vulnerability was addressed by changing the method of retrieving the parent element to ensure it is valid before any further checks are made. The original approach could lead to dereferencing a null pointer, which posed a risk of crashes or undefined behavior. The revised code first safely obtains the parent element and stores it in a variable, allowing for a straightforward validation step. This ensures that the function only proceeds to check the type of the parent if it exists, thereby preventing potential errors and enhancing the overall reliability and safety of the code."
7,188116,188116,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,36,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",5,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
",C,"    DCHECK_EQ(*nof_items, 0);
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
      DCHECK_EQ(object->map(), *original_map);
      Handle<Object> value;
        // This might modify the elements and/or change the elements kind.
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
","    int count = 0;
    for (int i = 0; i < keys->length(); ++i) {
      Handle<Object> value;
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
//flaw_line_below:
    int count = 0;
//fix_flaw_line_below:
//    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
//flaw_line_below:
    for (int i = 0; i < keys->length(); ++i) {
//fix_flaw_line_below:
//    int count = 0;
//fix_flaw_line_below:
//    int i = 0;
//fix_flaw_line_below:
//    Handle<Map> original_map(object->map(), isolate);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
//flaw_line_below:
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
//fix_flaw_line_below:
//      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
//fix_flaw_line_below:
//      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
//fix_flaw_line_below:
//        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
//flaw_line_below:
      if (get_entries) {
//flaw_line_below:
        value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      values_or_entries->set(count++, *value);
//fix_flaw_line_below:
//      if (object->map() != *original_map) break;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Slow path caused by changes in elements kind during iteration.
//fix_flaw_line_below:
//    for (; i < keys->length(); i++) {
//fix_flaw_line_below:
//      Handle<Object> key(keys->get(i), isolate);
//fix_flaw_line_below:
//      uint32_t index;
//fix_flaw_line_below:
//      if (!key->ToUint32(&index)) continue;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (filter & ONLY_ENUMERABLE) {
//fix_flaw_line_below:
//        InternalElementsAccessor* accessor =
//fix_flaw_line_below:
//            reinterpret_cast<InternalElementsAccessor*>(
//fix_flaw_line_below:
//                object->GetElementsAccessor());
//fix_flaw_line_below:
//        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
//fix_flaw_line_below:
//                                                    object->elements(), index);
//fix_flaw_line_below:
//        if (entry == kMaxUInt32) continue;
//fix_flaw_line_below:
//        PropertyDetails details = accessor->GetDetails(*object, entry);
//fix_flaw_line_below:
//        if (!details.IsEnumerable()) continue;
       }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      Handle<Object> value;
//fix_flaw_line_below:
//      LookupIterator it(isolate, object, index, LookupIterator::OWN);
//fix_flaw_line_below:
//      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
//fix_flaw_line_below:
//                                       Nothing<bool>());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
",188116," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
","The provided code defines a function `CollectValuesOrEntriesImpl` that collects either values or entries from a JavaScript object in a V8 isolate context. It initializes a key accumulator to gather keys from the object's own properties and iterates through these keys to retrieve corresponding values or entries based on the specified `get_entries` flag. For each key, it checks if it can be converted to an index and retrieves the associated property details. Depending on the property type, it either fetches the value directly or uses a lookup iterator. The results are stored in a `FixedArray`, and the function returns a success status along with the count of collected items.","The code implements a function that retrieves either values or entries from a specified object within a JavaScript environment. It begins by initializing a mechanism to collect keys from the object's own properties and iterates through these keys to obtain their corresponding values or entries based on a specified condition. For each key, it checks if it can be treated as an index and retrieves relevant property details. Depending on the type of property, it either directly accesses the value or uses an iterator for lookup. The results are stored in a designated array, and the function indicates successful completion along with the count of items collected.","The vulnerability in the original code arises from the potential modification of the object's internal structure during iteration, which could lead to inconsistent results or even crashes. Specifically, the lack of checks on the object's map allows for changes in the object's elements kind while iterating through keys, potentially invalidating the assumptions made about the object's state. The fixed code addresses this by introducing a check that compares the object's map with a stored original map at each iteration. If a change is detected, the loop breaks, preventing further processing of potentially invalid or altered data.","The vulnerability in the original code stems from the risk of modifying an object's internal structure while iterating through its properties, which could lead to unpredictable behavior or crashes. This issue arises when the object's state changes during the iteration, potentially invalidating the assumptions made about its properties. The fixed code mitigates this vulnerability by implementing a mechanism to track the object's original state and checking for any changes during the iteration process. If a modification is detected, the iteration is halted, ensuring that the function operates on a consistent and valid state of the object, thereby enhancing stability and reliability.","The vulnerability was fixed by introducing a check that compares the object's current map with a stored reference to the original map during iteration. In the modified code, the original map is captured before the loop begins, and within the loop, a condition checks if the object's map has changed. If a change is detected, the iteration is terminated using a break statement. This ensures that any modifications to the object's internal structure do not lead to inconsistent results or crashes, thereby maintaining the integrity of the data being processed throughout the function.","The vulnerability was addressed by implementing a mechanism to track the original state of the object before starting the iteration. During the iteration process, the code now checks for any changes to the object's structure. If a modification is detected, the iteration is halted immediately, preventing further processing of potentially invalid or altered data. This approach ensures that the function operates on a consistent and stable state of the object, thereby reducing the risk of unpredictable behavior or crashes that could arise from changes made during the property retrieval process."
