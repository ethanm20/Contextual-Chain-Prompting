,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,177921,177921,,Remote,Not required,Partial,CVE-2018-14599,https://www.cvedetails.com/cve/CVE-2018-14599/,CWE-682,Low,Partial,Partial,,2018-08-24,7.5,"An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.",2019-08-06,,4,https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0,b469da1430cdcee06e31c6251b83aede072a1ff0,,8,,,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
 	    /*
 	     * unpack into null terminated strings.
 	     */
	    chend = ch + rlen;
 	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *ch;
		    *ch = '\0'; /* and replace with null-termination */
		    count++;
 		} else
 		    list[i] = NULL;
 	    }
		    }
		} else
","char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
 	    /*
 	     * unpack into null terminated strings.
 	     */
	    chend = ch + (rlen + 1);
 	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    if (ch <= chend) {
			length = *ch;
			*ch = '\0'; /* and replace with null-termination */
			count++;
		    } else {
			list[i] = NULL;
		    }
 		} else
 		    list[i] = NULL;
 	    }
		    }
		} else
",C,"	    chend = ch + rlen;
		    length = *ch;
		    *ch = '\0'; /* and replace with null-termination */
		    count++;
","	    chend = ch + (rlen + 1);
		    if (ch <= chend) {
			length = *ch;
			*ch = '\0'; /* and replace with null-termination */
			count++;
		    } else {
			list[i] = NULL;
		    }
",d81da209fd4d0c2c9ad0596a8078e58864479d0d,"@@ -74,19 +74,15 @@ char **XListExtensions(
 	    /*
 	     * unpack into null terminated strings.
 	     */
-	    chend = ch + (rlen + 1);
+	    chend = ch + rlen;
 	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
-		    if (ch <= chend) {
-			length = *ch;
-			*ch = '\0'; /* and replace with null-termination */
-			count++;
-		    } else {
-			list[i] = NULL;
-		    }
+		    length = *ch;
+		    *ch = '\0'; /* and replace with null-termination */
+		    count++;
 		} else
 		    list[i] = NULL;
 	    }",libx11,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/ListExt.c?id=b469da1430cdcee06e31c6251b83aede072a1ff0,https://cgit.freedesktop.org/xorg/lib/libX11/tree/src/ListExt.c?id=d81da209fd4d0c2c9ad0596a8078e58864479d0d,1,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
 	    /*
 	     * unpack into null terminated strings.
 	     */
//flaw_line_below:
	    chend = ch + (rlen + 1);
//fix_flaw_line_below:
//	    chend = ch + rlen;
 	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
//flaw_line_below:
		    if (ch <= chend) {
//flaw_line_below:
			length = *ch;
//flaw_line_below:
			*ch = '\0'; /* and replace with null-termination */
//flaw_line_below:
			count++;
//flaw_line_below:
		    } else {
//flaw_line_below:
			list[i] = NULL;
//flaw_line_below:
		    }
//fix_flaw_line_below:
//		    length = *ch;
//fix_flaw_line_below:
//		    *ch = '\0'; /* and replace with null-termination */
//fix_flaw_line_below:
//		    count++;
 		} else
 		    list[i] = NULL;
 	    }
		    }
		} else
",177921,"char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
	    /*
	     * unpack into null terminated strings.
	     */
	    chend = ch + (rlen + 1);
	    length = *ch;
	    for (i = 0; i < rep.nExtensions; i++) {
		if (ch + length < chend) {
		    list[i] = ch+1;  /* skip over length */
		    ch += length + 1; /* find next length ... */
		    if (ch <= chend) {
			length = *ch;
			*ch = '\0'; /* and replace with null-termination */
			count++;
		    } else {
			list[i] = NULL;
		    }
		} else
		    list[i] = NULL;
	    }
	}

	*nextensions = count;
	UnlockDisplay(dpy);
	SyncHandle();
	return (list);
}","char **XListExtensions(
    register Display *dpy,
    int *nextensions)	/* RETURN */
{
	xListExtensionsReply rep;
	char **list = NULL;
	char *ch = NULL;
	char *chend;
	int count = 0;
	register unsigned i;
	register int length;
	_X_UNUSED register xReq *req;
	unsigned long rlen = 0;

	LockDisplay(dpy);
	GetEmptyReq (ListExtensions, req);

	if (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	if (rep.nExtensions) {
	    list = Xmalloc (rep.nExtensions * sizeof (char *));
	    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
		rlen = rep.length << 2;
		ch = Xmalloc (rlen + 1);
                /* +1 to leave room for last null-terminator */
	    }

	    if ((!list) || (!ch)) {
		Xfree(list);
		Xfree(ch);
		_XEatDataWords(dpy, rep.length);
		UnlockDisplay(dpy);
		SyncHandle();
		return (char **) NULL;
	    }

	    _XReadPad (dpy, ch, rlen);
 	    /*
 	     * unpack into null terminated strings.
 	     */
	    chend = ch + rlen;
 	    length = *ch;
 	    for (i = 0; i < rep.nExtensions; i++) {
 		if (ch + length < chend) {
 		    list[i] = ch+1;  /* skip over length */
 		    ch += length + 1; /* find next length ... */
		    length = *ch;
		    *ch = '\0'; /* and replace with null-termination */
		    count++;
 		} else
 		    list[i] = NULL;
 	    }
		    }
		} else
","The `XListExtensions` function retrieves a list of available extensions for a given X display. It takes a pointer to a `Display` structure and an integer pointer to store the number of extensions. The function first sends a request to the X server and waits for a reply. If successful, it allocates memory for the list of extension names and reads the data from the server. The names are unpacked into null-terminated strings, and the count of valid extensions is stored in the provided integer pointer. Finally, it unlocks the display and returns the list of extension names or NULL in case of failure.","The code defines a function that retrieves a list of available extensions for a specified display connection. It initiates a request to the server and waits for a response, checking for success. Upon receiving a valid reply, it allocates memory for storing the extension names and reads the corresponding data from the server. The names are then processed into a format suitable for use, ensuring they are properly terminated. The function counts the valid extensions and stores this count in a provided variable before releasing any locks on the display and returning the list of extension names or NULL if an error occurs.","The vulnerability in the original code arises from an off-by-one error when processing the length of extension names, which could allow a malicious server to send a response that leads to reading beyond allocated memory, potentially causing a denial of service or other impacts. In the fixed code, the condition checking the bounds of the `ch` pointer against `chend` is improved to ensure that the length of the next extension does not exceed the allocated buffer. This prevents the code from accessing memory outside the intended range, thereby mitigating the risk of exploitation from malformed server responses.","The vulnerability in the original code stems from an off-by-one error that occurs when processing data received from a potentially malicious server, which could lead to reading beyond allocated memory. This flaw could be exploited to cause a denial of service or other unintended consequences. In the revised code, the bounds checking for the length of the data being processed is enhanced, ensuring that the code does not attempt to access memory outside the allocated range. This fix effectively mitigates the risk of exploitation by preventing out-of-bounds memory access, thereby improving the overall security of the function.","The vulnerability was fixed by improving the bounds checking in the processing of extension names. In the revised code, the condition that checks whether the pointer to the current position in the data plus the length of the next extension is less than the end of the allocated buffer (`chend`) was refined. This ensures that the code does not read beyond the allocated memory when unpacking the extension names. Additionally, the handling of the length variable was adjusted to prevent it from being used incorrectly, thereby eliminating the off-by-one error and enhancing the overall safety of the memory access operations.","The vulnerability was addressed by enhancing the checks that ensure data being processed does not exceed the allocated memory boundaries. The revised code includes stricter conditions to verify that the length of the data being read remains within the limits of the allocated buffer. This prevents any attempts to access memory beyond what was intended, effectively mitigating the risk of out-of-bounds reads. By ensuring that all data manipulations respect the allocated memory size, the fix reduces the potential for exploitation through malformed server responses, thereby improving the overall security of the function.","CWE-125,CWE-119,CWE-787,CWE-788,CWE-823,CWE-789,CWE-131,CWE-122,CWE-120,CWE-129",N,-1.0,"4,4","5,5","4,4","4,3"
1,1,187997,187997,,Remote,Not required,Complete,CVE-2017-0819,https://www.cvedetails.com/cve/CVE-2017-0819/,CWE-682,Low,,,,2017-10-03,7.8,"A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63045918.",2019-10-02,,0,https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9,87fb7909c49e6a4510ba86ace1ffc83459c7e1b9,"Fix slice decrement for skipped slices

Test: run the poc with and without the patch
Bug: 63045918
Change-Id: I27804d42c55480c25303d1a5dbb43b1d86d7fa94
(cherry picked from commit 272f2c23c8ba8579adb0618b4124163b9bf086fb)
",1,decoder/ihevcd_decode.c,"{""filename"": ""decoder/ihevcd_decode.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9/decoder/ihevcd_decode.c"", ""patch"": ""@@ -668,7 +668,6 @@\n\n \n         if(IHEVCD_IGNORE_SLICE == ret)\n         {\n-            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));\n             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n \n""}","WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 /* Initialize error code */
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; //Restore size field
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 /* If reset flag is set, flush the existing buffers */
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
 /* In case the decoder is not in flush mode check for input buffer validity */
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 /* Reset MB Count at the beginning of every process call */
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 /* In case of non-shared mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 /* Output buffer check */
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 /* Set remaining number of rows to be processed */
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 /* If in flush mode and there are no more buffers to flush,
             * check for the reset flag and reset the decoder */
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 /* In case of shared mode, check if there is a free buffer for reconstruction */
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 /* If there is no free buffer, then return with an error code */
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 /* Decoder may read upto 8 extra bytes at the end of frame */
 /* These are not used, but still set them to zero to avoid uninitialized reads */
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 /* This may be used to update the offsets for tiles and entropy sync row offsets */
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 /* If the frame is incomplete and
         * the bytes remaining is zero or a header is received,
         * complete the frame treating it to be in error */
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 /* Update bytes remaining and bytes consumed and input bitstream pointer */
 /* Do not consume the NAL in the following cases */
 /* Slice header reached during header decode mode */
 /* TODO: Next picture's slice reached */
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 /* Allocate dynamic bitstream buffer once SPS is decoded */
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 /* Free any dynamic buffers that are allocated */
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 /* Add job queue for format conversion / frame copy for each ctb row */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 /* If format conversion jobs were not issued in pic_init() add them here */
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 /* Reached end of frame : Signal terminate */
 /* The terminate flag is checked only after all the jobs are dequeued */
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 /* Set remaining number of rows to be processed */
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 /* Mark MV Buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for display */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 /* Insert the current picture as short term reference */
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 /* If a frame was displayed (in non-shared mode), then release it from display manager */
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 /* Wait for threads */
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 /* Increment the number of pictures decoded */
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
","WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 /* Initialize error code */
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; //Restore size field
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 /* If reset flag is set, flush the existing buffers */
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
 /* In case the decoder is not in flush mode check for input buffer validity */
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 /* Reset MB Count at the beginning of every process call */
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 /* In case of non-shared mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 /* Output buffer check */
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 /* Set remaining number of rows to be processed */
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 /* If in flush mode and there are no more buffers to flush,
             * check for the reset flag and reset the decoder */
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 /* In case of shared mode, check if there is a free buffer for reconstruction */
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 /* If there is no free buffer, then return with an error code */
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 /* Decoder may read upto 8 extra bytes at the end of frame */
 /* These are not used, but still set them to zero to avoid uninitialized reads */
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 /* This may be used to update the offsets for tiles and entropy sync row offsets */
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 /* If the frame is incomplete and
         * the bytes remaining is zero or a header is received,
         * complete the frame treating it to be in error */
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 /* Update bytes remaining and bytes consumed and input bitstream pointer */
 /* Do not consume the NAL in the following cases */
 /* Slice header reached during header decode mode */
 /* TODO: Next picture's slice reached */
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 /* Allocate dynamic bitstream buffer once SPS is decoded */
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 /* Free any dynamic buffers that are allocated */
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 /* Add job queue for format conversion / frame copy for each ctb row */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 /* If format conversion jobs were not issued in pic_init() add them here */
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 /* Reached end of frame : Signal terminate */
 /* The terminate flag is checked only after all the jobs are dequeued */
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 /* Set remaining number of rows to be processed */
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 /* Mark MV Buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for display */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 /* Insert the current picture as short term reference */
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 /* If a frame was displayed (in non-shared mode), then release it from display manager */
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 /* Wait for threads */
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 /* Increment the number of pictures decoded */
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
",C,,"            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
",,"@@ -668,7 +668,6 @@

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
-            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
",Android,https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9/,https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9%5E/,1,"WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 /* Initialize error code */
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; //Restore size field
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 /* If reset flag is set, flush the existing buffers */
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
 //arm_dsb();
 /* In case the decoder is not in flush mode check for input buffer validity */
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 /* Reset MB Count at the beginning of every process call */
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 /* In case of non-shared mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 /* Output buffer check */
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 /* Set remaining number of rows to be processed */
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 /* If in flush mode and there are no more buffers to flush,
             * check for the reset flag and reset the decoder */
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 /* In case of shared mode, check if there is a free buffer for reconstruction */
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 /* If there is no free buffer, then return with an error code */
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 /* Decoder may read upto 8 extra bytes at the end of frame */
 /* These are not used, but still set them to zero to avoid uninitialized reads */
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 /* This may be used to update the offsets for tiles and entropy sync row offsets */
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 /* If the frame is incomplete and
         * the bytes remaining is zero or a header is received,
         * complete the frame treating it to be in error */
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
//flaw_line_below:
            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 /* Update bytes remaining and bytes consumed and input bitstream pointer */
 /* Do not consume the NAL in the following cases */
 /* Slice header reached during header decode mode */
 /* TODO: Next picture's slice reached */
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 /* Allocate dynamic bitstream buffer once SPS is decoded */
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 /* Free any dynamic buffers that are allocated */
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 /* Add job queue for format conversion / frame copy for each ctb row */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 /* If format conversion jobs were not issued in pic_init() add them here */
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 /* Reached end of frame : Signal terminate */
 /* The terminate flag is checked only after all the jobs are dequeued */
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 /* Set remaining number of rows to be processed */
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 /* Mark MV Buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for display */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 /* Insert the current picture as short term reference */
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 /* If a frame was displayed (in non-shared mode), then release it from display manager */
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 /* Wait for threads */
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 /* Increment the number of pictures decoded */
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
",187997,"WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 /* Initialize error code */
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; //Restore size field
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 /* If reset flag is set, flush the existing buffers */
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
 /* In case the decoder is not in flush mode check for input buffer validity */
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 /* Reset MB Count at the beginning of every process call */
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 /* In case of non-shared mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 /* Output buffer check */
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 /* Set remaining number of rows to be processed */
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 /* If in flush mode and there are no more buffers to flush,
             * check for the reset flag and reset the decoder */
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 /* In case of shared mode, check if there is a free buffer for reconstruction */
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 /* If there is no free buffer, then return with an error code */
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 /* Decoder may read upto 8 extra bytes at the end of frame */
 /* These are not used, but still set them to zero to avoid uninitialized reads */
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 /* This may be used to update the offsets for tiles and entropy sync row offsets */
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 /* If the frame is incomplete and
         * the bytes remaining is zero or a header is received,
         * complete the frame treating it to be in error */
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 /* Update bytes remaining and bytes consumed and input bitstream pointer */
 /* Do not consume the NAL in the following cases */
 /* Slice header reached during header decode mode */
 /* TODO: Next picture's slice reached */
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 /* Allocate dynamic bitstream buffer once SPS is decoded */
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 /* Free any dynamic buffers that are allocated */
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 /* Add job queue for format conversion / frame copy for each ctb row */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 /* If format conversion jobs were not issued in pic_init() add them here */
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 /* Reached end of frame : Signal terminate */
 /* The terminate flag is checked only after all the jobs are dequeued */
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 /* Set remaining number of rows to be processed */
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 /* Mark MV Buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for display */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 /* Insert the current picture as short term reference */
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 /* If a frame was displayed (in non-shared mode), then release it from display manager */
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 /* Wait for threads */
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 /* Increment the number of pictures decoded */
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
","WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 /* Initialize error code */
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; //Restore size field
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 /* If reset flag is set, flush the existing buffers */
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
 /* In case the decoder is not in flush mode check for input buffer validity */
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 /* Reset MB Count at the beginning of every process call */
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 /* In case of non-shared mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 /* Output buffer check */
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 /* Set remaining number of rows to be processed */
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 /* If in flush mode and there are no more buffers to flush,
             * check for the reset flag and reset the decoder */
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 /* In case of shared mode, check if there is a free buffer for reconstruction */
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 /* If there is no free buffer, then return with an error code */
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 /* Decoder may read upto 8 extra bytes at the end of frame */
 /* These are not used, but still set them to zero to avoid uninitialized reads */
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 /* This may be used to update the offsets for tiles and entropy sync row offsets */
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 /* If the frame is incomplete and
         * the bytes remaining is zero or a header is received,
         * complete the frame treating it to be in error */
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 /* Update bytes remaining and bytes consumed and input bitstream pointer */
 /* Do not consume the NAL in the following cases */
 /* Slice header reached during header decode mode */
 /* TODO: Next picture's slice reached */
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 /* Allocate dynamic bitstream buffer once SPS is decoded */
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 /* Free any dynamic buffers that are allocated */
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 /* Add job queue for format conversion / frame copy for each ctb row */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 /* If format conversion jobs were not issued in pic_init() add them here */
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 /* Reached end of frame : Signal terminate */
 /* The terminate flag is checked only after all the jobs are dequeued */
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 /* i4_num_cores - 1 contexts are currently being used by other threads */
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */
 /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 /* Set remaining number of rows to be processed */
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 /* Mark MV Buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for reference */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 /* Mark pic buf as needed for display */
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 /* Insert the current picture as short term reference */
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 /* If a frame was displayed (in non-shared mode), then release it from display manager */
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 /* Wait for threads */
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 /* Increment the number of pictures decoded */
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
","The `ihevcd_decode` function is a video decoding routine that processes an input bitstream for HEVC (High Efficiency Video Coding) and outputs the decoded frames. It begins by validating the codec's initialization and input parameters, ensuring that the necessary buffers are allocated and that the input stream is valid. The function handles various error conditions, including frame limits and buffer null checks. It processes the bitstream, extracting NAL units, and manages the decoding context, including multi-threading for efficiency. Finally, it formats the output, potentially inserting a logo, and returns the success or failure status of the decoding operation.","The provided code implements a video decoding function that processes a compressed video bitstream, ensuring proper initialization and validating input parameters before decoding. It checks for errors such as uninitialized states and buffer availability, managing memory and processing contexts efficiently. The function extracts and decodes video frames, handling various conditions like frame limits and buffer states. It also supports multi-threading for improved performance and can insert visual elements into the output. Ultimately, the function returns a status indicating the success or failure of the decoding process, along with any relevant output data.","The vulnerability identified in the code relates to improper handling of input parameters, specifically the potential for uninitialized memory access, which can lead to undefined behavior or crashes. This is classified under CWE-682, where the code did not adequately check if certain buffers were initialized before use, particularly when accessing the output buffer and stream buffer. The fix involved adding checks to ensure that the output buffer and stream buffer are not null and that their sizes are valid before proceeding with operations. This prevents the use of uninitialized memory, thereby enhancing the stability and security of the decoding process.","The vulnerability identified in the code involves improper handling of uninitialized memory, which can lead to undefined behavior or crashes, categorized under CWE-682. Specifically, the code failed to verify that critical buffers were properly initialized before being accessed, potentially allowing for the use of invalid or null pointers. The fix addressed this issue by implementing checks to ensure that these buffers are not null and that their sizes are valid before any operations are performed. This enhancement prevents the exploitation of uninitialized memory, thereby improving the overall stability and security of the media framework.","The vulnerability was fixed by adding explicit checks for the initialization and validity of critical buffers before they are accessed. For instance, the code now verifies that the output buffer is not null by checking `ps_dec_ip->s_out_buffer.u4_num_bufs` and ensuring that each buffer in `ps_dec_ip->s_out_buffer.pu1_bufs[i]` is valid. Additionally, it checks that the input stream buffer is not null and that the number of bytes is greater than a defined minimum. These checks prevent the use of uninitialized memory, thereby enhancing the robustness and security of the decoding process.","The vulnerability was fixed by implementing comprehensive validation checks to ensure that critical buffers are properly initialized and valid before any operations are performed. This includes verifying that output buffers are not null and that their sizes meet required conditions. Additionally, checks were added to confirm that the input stream buffer is valid and contains sufficient data. By enforcing these checks, the code prevents the potential exploitation of uninitialized memory, thereby enhancing the overall stability and security of the system during the decoding process. This proactive approach mitigates risks associated with undefined behavior.","CWE-457,CWE-824,CWE-119,CWE-789,CWE-126,CWE-908,CWE-665,CWE-758,CWE-909,CWE-763",N,-1.0,"5, 4","5, 5","4,4","4,5"
