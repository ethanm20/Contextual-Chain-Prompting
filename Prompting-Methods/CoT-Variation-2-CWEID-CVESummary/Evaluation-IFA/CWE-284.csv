,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,0,178351,178351,,Remote,Single system,,CVE-2016-2860,https://www.cvedetails.com/cve/CVE-2016-2860/,CWE-284,Low,,Partial,,2016-05-13,4.0,The newEntry function in ptserver/ptprocs.c in OpenAFS before 1.6.17 allows remote authenticated users from foreign Kerberos realms to bypass intended access restrictions and create arbitrary groups as administrators by leveraging mishandling of the creator ID.,2016-05-19,Bypass,13,http://git.openafs.org/?p=openafs.git;a=commitdiff;h=396240cf070a806b91fea81131d034e1399af1e0,396240cf070a806b91fea81131d034e1399af1e0,,7,,,"newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
	 afs_int32 *aid, afs_int32 *cid)
{
    afs_int32 code;
    struct ubik_trans *tt;
    int admin;
    char cname[PR_MAXNAMELEN];
    stolower(aname);
    code = Initdb();
    if (code)
	return code;
    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);
    if (code)
	return code;
    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);
    if (code)
	ABORT_WITH(tt, code);
    code = read_DbHeader(tt);
    if (code)
	ABORT_WITH(tt, code);

    /* this is for cross-cell self registration. It is not added in the
     * SPR_INewEntry because we want self-registration to only do
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
    if (code && code != 2)
       ABORT_WITH(tt, PRPERM);
    admin = IsAMemberOf(tt, *cid, SYSADMINID);
    if (code == 2 /* foreign cell request */) {
       if (!restricted && (strcmp(aname, cname) == 0)) {
           /* can't autoregister while providing an owner id */
           if (oid != 0)
               ABORT_WITH(tt, PRPERM);

           admin = 1;
           oid = SYSADMINID;
           *cid = SYSADMINID;
       }
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);
    if (code)
	return code;
    return PRSUCCESS;
}
","newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
	 afs_int32 *aid, afs_int32 *cid)
{
    afs_int32 code;
    struct ubik_trans *tt;
    int admin;
    char cname[PR_MAXNAMELEN];
    stolower(aname);
    code = Initdb();
    if (code)
	return code;
    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);
    if (code)
	return code;
    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);
    if (code)
	ABORT_WITH(tt, code);
    code = read_DbHeader(tt);
    if (code)
	ABORT_WITH(tt, code);

    /* this is for cross-cell self registration. It is not added in the
     * SPR_INewEntry because we want self-registration to only do
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
       if (code)
           ABORT_WITH(tt, PRPERM);
       admin = IsAMemberOf(tt, *cid, SYSADMINID);
    } else {
       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
       oid = *cid = SYSADMINID;
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);
    if (code)
	return code;
    return PRSUCCESS;
}
",C,"    if (code && code != 2)
       ABORT_WITH(tt, PRPERM);
    admin = IsAMemberOf(tt, *cid, SYSADMINID);
    if (code == 2 /* foreign cell request */) {
       if (!restricted && (strcmp(aname, cname) == 0)) {
           /* can't autoregister while providing an owner id */
           if (oid != 0)
               ABORT_WITH(tt, PRPERM);

           admin = 1;
           oid = SYSADMINID;
           *cid = SYSADMINID;
       }
","    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
       if (code)
           ABORT_WITH(tt, PRPERM);
       admin = IsAMemberOf(tt, *cid, SYSADMINID);
    } else {
       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
       oid = *cid = SYSADMINID;
",be42de4f4f335b86defdac16a491c3b04219f212,"@@ -345,13 +345,19 @@ newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
-    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
-       if (code)
-           ABORT_WITH(tt, PRPERM);
-       admin = IsAMemberOf(tt, *cid, SYSADMINID);
-    } else {
-       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
-       oid = *cid = SYSADMINID;
+    if (code && code != 2)
+       ABORT_WITH(tt, PRPERM);
+    admin = IsAMemberOf(tt, *cid, SYSADMINID);
+    if (code == 2 /* foreign cell request */) {
+       if (!restricted && (strcmp(aname, cname) == 0)) {
+           /* can't autoregister while providing an owner id */
+           if (oid != 0)
+               ABORT_WITH(tt, PRPERM);
+
+           admin = 1;
+           oid = SYSADMINID;
+           *cid = SYSADMINID;
+       }
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);",openafs,http://git.openafs.org/?p=openafs.git;a=blob;f=src/ptserver/ptprocs.c;h=f9f48fc6897fa1f379f8ecbb600e85cf1845383b;hb=396240cf070a806b91fea81131d034e1399af1e0,http://git.openafs.org/?p=openafs.git;a=blob;f=src/ptserver/ptprocs.c;h=ae1a56292077e765d2d43270b0db1d37506dee74,1,"newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
	 afs_int32 *aid, afs_int32 *cid)
{
    afs_int32 code;
    struct ubik_trans *tt;
    int admin;
    char cname[PR_MAXNAMELEN];
    stolower(aname);
    code = Initdb();
    if (code)
	return code;
    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);
    if (code)
	return code;
    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);
    if (code)
	ABORT_WITH(tt, code);
    code = read_DbHeader(tt);
    if (code)
	ABORT_WITH(tt, code);

    /* this is for cross-cell self registration. It is not added in the
     * SPR_INewEntry because we want self-registration to only do
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
//flaw_line_below:
    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
//flaw_line_below:
       if (code)
//flaw_line_below:
           ABORT_WITH(tt, PRPERM);
//flaw_line_below:
       admin = IsAMemberOf(tt, *cid, SYSADMINID);
//flaw_line_below:
    } else {
//flaw_line_below:
       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
//flaw_line_below:
       oid = *cid = SYSADMINID;
//fix_flaw_line_below:
//    if (code && code != 2)
//fix_flaw_line_below:
//       ABORT_WITH(tt, PRPERM);
//fix_flaw_line_below:
//    admin = IsAMemberOf(tt, *cid, SYSADMINID);
//fix_flaw_line_below:
//    if (code == 2 /* foreign cell request */) {
//fix_flaw_line_below:
//       if (!restricted && (strcmp(aname, cname) == 0)) {
//fix_flaw_line_below:
//           /* can't autoregister while providing an owner id */
//fix_flaw_line_below:
//           if (oid != 0)
//fix_flaw_line_below:
//               ABORT_WITH(tt, PRPERM);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//           admin = 1;
//fix_flaw_line_below:
//           oid = SYSADMINID;
//fix_flaw_line_below:
//           *cid = SYSADMINID;
//fix_flaw_line_below:
//       }
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);
    if (code)
	return code;
    return PRSUCCESS;
}
",178351,"newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
	 afs_int32 *aid, afs_int32 *cid)
{
    afs_int32 code;
    struct ubik_trans *tt;
    int admin;
    char cname[PR_MAXNAMELEN];
    stolower(aname);
    code = Initdb();
    if (code)
	return code;
    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);
    if (code)
	return code;
    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);
    if (code)
	ABORT_WITH(tt, code);
    code = read_DbHeader(tt);
    if (code)
	ABORT_WITH(tt, code);

    /* this is for cross-cell self registration. It is not added in the
     * SPR_INewEntry because we want self-registration to only do
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
    if (code != 2) {           /* 2 specifies that this is a foreign cell request */
       if (code)
           ABORT_WITH(tt, PRPERM);
       admin = IsAMemberOf(tt, *cid, SYSADMINID);
    } else {
       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);
       oid = *cid = SYSADMINID;
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);
    if (code)
	return code;
    return PRSUCCESS;
}
","newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,
	 afs_int32 *aid, afs_int32 *cid)
{
    afs_int32 code;
    struct ubik_trans *tt;
    int admin;
    char cname[PR_MAXNAMELEN];
    stolower(aname);
    code = Initdb();
    if (code)
	return code;
    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);
    if (code)
	return code;
    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);
    if (code)
	ABORT_WITH(tt, code);
    code = read_DbHeader(tt);
    if (code)
	ABORT_WITH(tt, code);

    /* this is for cross-cell self registration. It is not added in the
     * SPR_INewEntry because we want self-registration to only do
      * automatic id assignment.
      */
     code = WhoIsThisWithName(call, tt, cid, cname);
    if (code && code != 2)
       ABORT_WITH(tt, PRPERM);
    admin = IsAMemberOf(tt, *cid, SYSADMINID);
    if (code == 2 /* foreign cell request */) {
       if (!restricted && (strcmp(aname, cname) == 0)) {
           /* can't autoregister while providing an owner id */
           if (oid != 0)
               ABORT_WITH(tt, PRPERM);

           admin = 1;
           oid = SYSADMINID;
           *cid = SYSADMINID;
       }
     }
     if (!CreateOK(tt, *cid, oid, flag, admin))
        ABORT_WITH(tt, PRPERM);
    if (code)
	return code;
    return PRSUCCESS;
}
","The `newEntry` function facilitates the creation of a new entry in a database, handling various administrative checks and transaction management. It begins by initializing the database and starting a write transaction. The function then sets a write lock and reads the database header. It checks the identity of the caller, determining if the request is from a foreign cell or a local one, and verifies administrative permissions accordingly. If the caller is authorized and meets the criteria for entry creation, the function proceeds to validate the creation conditions before returning a success code. If any checks fail, appropriate error codes are returned.","The function is designed to create a new entry in a database while managing transaction integrity and access permissions. It starts by initializing the database and establishing a write transaction with a lock to prevent concurrent modifications. The function then verifies the identity of the requester to determine if they are from a local or foreign context, checking for administrative privileges as necessary. If the requester meets the required conditions for entry creation, the function validates these conditions before successfully completing the operation. If any checks fail, appropriate error responses are generated to indicate the issue.","The vulnerability in the original code allowed remote authenticated users from foreign Kerberos realms to bypass access restrictions and create arbitrary groups as administrators due to improper checks on the creator ID. Specifically, the function did not adequately validate the identity of the requester, allowing unauthorized users to gain administrative privileges. In the fixed code, the condition checking for foreign requests was enhanced by ensuring that if the request was from a foreign cell, the creator ID could not be set arbitrarily. The added checks prevent unauthorized self-registration and ensure that only legitimate administrative users can create entries, thus mitigating the vulnerability.","The vulnerability allowed remote authenticated users from foreign Kerberos realms to exploit inadequate access controls, enabling them to create arbitrary groups with administrative privileges. This occurred because the code did not properly validate the identity of the requester, allowing unauthorized users to manipulate the creator ID. In the revised code, additional checks were implemented to ensure that if the request originated from a foreign context, the creator ID could not be set freely. This strengthened validation process prevents unauthorized self-registration and restricts group creation to legitimate administrative users, effectively closing the security loophole.","The vulnerability was fixed by enhancing the checks related to the identity of the requester and the conditions under which a creator ID can be assigned. In the revised code, the condition checking for foreign requests was modified to ensure that if the code returned a value of 2, indicating a foreign cell request, the creator ID could not be set arbitrarily. Specifically, the code now checks that if the requester is foreign, the creator ID cannot be set to a non-zero value unless the requester is an administrator. This prevents unauthorized users from gaining administrative privileges and creating groups.","The vulnerability was addressed by implementing stricter validation checks for the identity of the requester and the conditions under which administrative privileges can be granted. The revised code ensures that if a request originates from a foreign context, the creator ID cannot be assigned arbitrarily, thereby preventing unauthorized users from gaining administrative access. Additionally, the code enforces that self-registration is restricted, requiring that only legitimate administrative users can create entries. These changes effectively close the security loophole, ensuring that access controls are properly enforced and that only authorized individuals can perform sensitive operations.","4,4","5,5","4,4","4,4","CWE-284,CWE-287,CWE-269,CWE-285,CWE-639,CWE-266,CWE-732,CWE-522,CWE-306,CWE-863",Y,1.0
1,1,1,178404,178404,,Local,Not required,Partial,CVE-2016-10369,https://www.cvedetails.com/cve/CVE-2016-10369/,CWE-284,Low,Partial,Partial,,2017-05-08,4.6,"unixsocket.c in lxterminal through 0.3.0 insecurely uses /tmp for a socket file, allowing a local user to cause a denial of service (preventing terminal launch), or possibly have other impact (bypassing terminal access control).",2017-05-16,DoS Bypass,2,https://git.lxde.org/gitweb/?p=lxde/lxterminal.git;a=commit;h=f99163c6ff8b2f57c5f37b1ce5d62cf7450d4648,f99163c6ff8b2f57c5f37b1ce5d62cf7450d4648,,1,,,"gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar * * argv)
{
    /* Normally, LXTerminal uses one process to control all of its windows.
     * The first process to start will create a Unix domain socket in /tmp.
     * It will then bind and listen on this socket.
     * The subsequent processes will connect to the controller that owns the Unix domain socket.
     * They will pass their command line over the socket and exit.
     *
     * If for any reason both the connect and bind fail, we will fall back to having that
     * process be standalone; it will not be either the controller or a user of the controller.
     * This behavior was introduced in response to a problem report (2973537).
     *
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
    gchar * socket_path = g_strdup_printf(""%s/.lxterminal-socket-%s"", g_get_user_runtime_dir(), gdk_display_get_name(gdk_display_get_default()));
    printf(""%s\n"", socket_path);
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);
    {
        g_warning(""Socket create failed: %s\n"", g_strerror(errno));
        g_free(socket_path);
        return TRUE;
    }

    /* Initialize socket address for Unix domain socket. */
    struct sockaddr_un sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sun_family = AF_UNIX;
    snprintf(sock_addr.sun_path, sizeof(sock_addr.sun_path), ""%s"", socket_path);

    /* Try to connect to an existing LXTerminal process. */
    if (connect(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
    {
        /* Connect failed.  We are the controller, unless something fails. */
        unlink(socket_path);
        g_free(socket_path);

        /* Bind to socket. */
        if (bind(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
        {
            g_warning(""Bind on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Listen on socket. */
        if (listen(fd, 5) < 0)
        {
            g_warning(""Listen on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        if (gio == NULL)
        {
            g_warning(""Cannot create GIOChannel\n"");
            close(fd);
            return TRUE;
        }

        /* Set up GIOChannel. */
        g_io_channel_set_encoding(gio, NULL, NULL);
        g_io_channel_set_buffered(gio, FALSE);
        g_io_channel_set_close_on_unref(gio, TRUE);

        /* Add I/O channel to the main event loop. */
        if ( ! g_io_add_watch(gio, G_IO_IN | G_IO_HUP, (GIOFunc) lxterminal_socket_accept_client, lxtermwin))
        {
            g_warning(""Cannot add watch on GIOChannel\n"");
            close(fd);
            g_io_channel_unref(gio);
            return TRUE;
        }

        /* Channel will automatically shut down when the watch returns FALSE. */
        g_io_channel_set_close_on_unref(gio, TRUE);
        g_io_channel_unref(gio);
        return TRUE;
    }
    else
    {
        g_free(socket_path);

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        g_io_channel_set_encoding(gio, NULL, NULL);

        /* Push current dir in case it is needed later */
	gchar * cur_dir = g_get_current_dir();
        g_io_channel_write_chars(gio, cur_dir, -1, NULL, NULL);
	/* Use """" as a pointer to '\0' since g_io_channel_write_chars() won't accept NULL */
	g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	g_free(cur_dir);

        /* push all of argv. */
	gint i;
	for (i = 0; i < argc; i ++)
	{
            g_io_channel_write_chars(gio, argv[i], -1, NULL, NULL);
	    g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	}

        g_io_channel_flush(gio, NULL);
        g_io_channel_unref(gio);
        return FALSE;
    }
}
","gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar * * argv)
{
    /* Normally, LXTerminal uses one process to control all of its windows.
     * The first process to start will create a Unix domain socket in /tmp.
     * It will then bind and listen on this socket.
     * The subsequent processes will connect to the controller that owns the Unix domain socket.
     * They will pass their command line over the socket and exit.
     *
     * If for any reason both the connect and bind fail, we will fall back to having that
     * process be standalone; it will not be either the controller or a user of the controller.
     * This behavior was introduced in response to a problem report (2973537).
     *
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
    gchar * socket_path = g_strdup_printf(""/tmp/.lxterminal-socket%s-%s"", gdk_display_get_name(gdk_display_get_default()), g_get_user_name());
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);
    {
        g_warning(""Socket create failed: %s\n"", g_strerror(errno));
        g_free(socket_path);
        return TRUE;
    }

    /* Initialize socket address for Unix domain socket. */
    struct sockaddr_un sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sun_family = AF_UNIX;
    snprintf(sock_addr.sun_path, sizeof(sock_addr.sun_path), ""%s"", socket_path);

    /* Try to connect to an existing LXTerminal process. */
    if (connect(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
    {
        /* Connect failed.  We are the controller, unless something fails. */
        unlink(socket_path);
        g_free(socket_path);

        /* Bind to socket. */
        if (bind(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
        {
            g_warning(""Bind on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Listen on socket. */
        if (listen(fd, 5) < 0)
        {
            g_warning(""Listen on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        if (gio == NULL)
        {
            g_warning(""Cannot create GIOChannel\n"");
            close(fd);
            return TRUE;
        }

        /* Set up GIOChannel. */
        g_io_channel_set_encoding(gio, NULL, NULL);
        g_io_channel_set_buffered(gio, FALSE);
        g_io_channel_set_close_on_unref(gio, TRUE);

        /* Add I/O channel to the main event loop. */
        if ( ! g_io_add_watch(gio, G_IO_IN | G_IO_HUP, (GIOFunc) lxterminal_socket_accept_client, lxtermwin))
        {
            g_warning(""Cannot add watch on GIOChannel\n"");
            close(fd);
            g_io_channel_unref(gio);
            return TRUE;
        }

        /* Channel will automatically shut down when the watch returns FALSE. */
        g_io_channel_set_close_on_unref(gio, TRUE);
        g_io_channel_unref(gio);
        return TRUE;
    }
    else
    {
        g_free(socket_path);

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        g_io_channel_set_encoding(gio, NULL, NULL);

        /* Push current dir in case it is needed later */
	gchar * cur_dir = g_get_current_dir();
        g_io_channel_write_chars(gio, cur_dir, -1, NULL, NULL);
	/* Use """" as a pointer to '\0' since g_io_channel_write_chars() won't accept NULL */
	g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	g_free(cur_dir);

        /* push all of argv. */
	gint i;
	for (i = 0; i < argc; i ++)
	{
            g_io_channel_write_chars(gio, argv[i], -1, NULL, NULL);
	    g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	}

        g_io_channel_flush(gio, NULL);
        g_io_channel_unref(gio);
        return FALSE;
    }
}
",C,"    gchar * socket_path = g_strdup_printf(""%s/.lxterminal-socket-%s"", g_get_user_runtime_dir(), gdk_display_get_name(gdk_display_get_default()));
    printf(""%s\n"", socket_path);
","    gchar * socket_path = g_strdup_printf(""/tmp/.lxterminal-socket%s-%s"", gdk_display_get_name(gdk_display_get_default()), g_get_user_name());
",435269f15617d7057c18d3eb3bdd2ca7b8490708,"@@ -140,7 +140,8 @@ gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
-    gchar * socket_path = g_strdup_printf(""/tmp/.lxterminal-socket%s-%s"", gdk_display_get_name(gdk_display_get_default()), g_get_user_name());
+    gchar * socket_path = g_strdup_printf(""%s/.lxterminal-socket-%s"", g_get_user_runtime_dir(), gdk_display_get_name(gdk_display_get_default()));
+    printf(""%s\n"", socket_path);
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);",lxde,https://git.lxde.org/gitweb/?p=lxde/lxterminal.git;a=blob;f=src/unixsocket.c;h=f88284c790b4a51ce398e930f3860f528f9bd4e9;hb=f99163c6ff8b2f57c5f37b1ce5d62cf7450d4648,https://git.lxde.org/gitweb/?p=lxde/lxterminal.git;a=blob;f=src/unixsocket.c;h=4c660acb51b75861757f1b34abfe03e624384f14,1,"gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar * * argv)
{
    /* Normally, LXTerminal uses one process to control all of its windows.
     * The first process to start will create a Unix domain socket in /tmp.
     * It will then bind and listen on this socket.
     * The subsequent processes will connect to the controller that owns the Unix domain socket.
     * They will pass their command line over the socket and exit.
     *
     * If for any reason both the connect and bind fail, we will fall back to having that
     * process be standalone; it will not be either the controller or a user of the controller.
     * This behavior was introduced in response to a problem report (2973537).
     *
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
//flaw_line_below:
    gchar * socket_path = g_strdup_printf(""/tmp/.lxterminal-socket%s-%s"", gdk_display_get_name(gdk_display_get_default()), g_get_user_name());
//fix_flaw_line_below:
//    gchar * socket_path = g_strdup_printf(""%s/.lxterminal-socket-%s"", g_get_user_runtime_dir(), gdk_display_get_name(gdk_display_get_default()));
//fix_flaw_line_below:
//    printf(""%s\n"", socket_path);
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);
    {
        g_warning(""Socket create failed: %s\n"", g_strerror(errno));
        g_free(socket_path);
        return TRUE;
    }

    /* Initialize socket address for Unix domain socket. */
    struct sockaddr_un sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sun_family = AF_UNIX;
    snprintf(sock_addr.sun_path, sizeof(sock_addr.sun_path), ""%s"", socket_path);

    /* Try to connect to an existing LXTerminal process. */
    if (connect(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
    {
        /* Connect failed.  We are the controller, unless something fails. */
        unlink(socket_path);
        g_free(socket_path);

        /* Bind to socket. */
        if (bind(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
        {
            g_warning(""Bind on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Listen on socket. */
        if (listen(fd, 5) < 0)
        {
            g_warning(""Listen on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        if (gio == NULL)
        {
            g_warning(""Cannot create GIOChannel\n"");
            close(fd);
            return TRUE;
        }

        /* Set up GIOChannel. */
        g_io_channel_set_encoding(gio, NULL, NULL);
        g_io_channel_set_buffered(gio, FALSE);
        g_io_channel_set_close_on_unref(gio, TRUE);

        /* Add I/O channel to the main event loop. */
        if ( ! g_io_add_watch(gio, G_IO_IN | G_IO_HUP, (GIOFunc) lxterminal_socket_accept_client, lxtermwin))
        {
            g_warning(""Cannot add watch on GIOChannel\n"");
            close(fd);
            g_io_channel_unref(gio);
            return TRUE;
        }

        /* Channel will automatically shut down when the watch returns FALSE. */
        g_io_channel_set_close_on_unref(gio, TRUE);
        g_io_channel_unref(gio);
        return TRUE;
    }
    else
    {
        g_free(socket_path);

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        g_io_channel_set_encoding(gio, NULL, NULL);

        /* Push current dir in case it is needed later */
	gchar * cur_dir = g_get_current_dir();
        g_io_channel_write_chars(gio, cur_dir, -1, NULL, NULL);
	/* Use """" as a pointer to '\0' since g_io_channel_write_chars() won't accept NULL */
	g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	g_free(cur_dir);

        /* push all of argv. */
	gint i;
	for (i = 0; i < argc; i ++)
	{
            g_io_channel_write_chars(gio, argv[i], -1, NULL, NULL);
	    g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	}

        g_io_channel_flush(gio, NULL);
        g_io_channel_unref(gio);
        return FALSE;
    }
}
",178404,"gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar * * argv)
{
    /* Normally, LXTerminal uses one process to control all of its windows.
     * The first process to start will create a Unix domain socket in /tmp.
     * It will then bind and listen on this socket.
     * The subsequent processes will connect to the controller that owns the Unix domain socket.
     * They will pass their command line over the socket and exit.
     *
     * If for any reason both the connect and bind fail, we will fall back to having that
     * process be standalone; it will not be either the controller or a user of the controller.
     * This behavior was introduced in response to a problem report (2973537).
     *
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
    gchar * socket_path = g_strdup_printf(""/tmp/.lxterminal-socket%s-%s"", gdk_display_get_name(gdk_display_get_default()), g_get_user_name());
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);
    {
        g_warning(""Socket create failed: %s\n"", g_strerror(errno));
        g_free(socket_path);
        return TRUE;
    }

    /* Initialize socket address for Unix domain socket. */
    struct sockaddr_un sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sun_family = AF_UNIX;
    snprintf(sock_addr.sun_path, sizeof(sock_addr.sun_path), ""%s"", socket_path);

    /* Try to connect to an existing LXTerminal process. */
    if (connect(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
    {
        /* Connect failed.  We are the controller, unless something fails. */
        unlink(socket_path);
        g_free(socket_path);

        /* Bind to socket. */
        if (bind(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
        {
            g_warning(""Bind on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Listen on socket. */
        if (listen(fd, 5) < 0)
        {
            g_warning(""Listen on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        if (gio == NULL)
        {
            g_warning(""Cannot create GIOChannel\n"");
            close(fd);
            return TRUE;
        }

        /* Set up GIOChannel. */
        g_io_channel_set_encoding(gio, NULL, NULL);
        g_io_channel_set_buffered(gio, FALSE);
        g_io_channel_set_close_on_unref(gio, TRUE);

        /* Add I/O channel to the main event loop. */
        if ( ! g_io_add_watch(gio, G_IO_IN | G_IO_HUP, (GIOFunc) lxterminal_socket_accept_client, lxtermwin))
        {
            g_warning(""Cannot add watch on GIOChannel\n"");
            close(fd);
            g_io_channel_unref(gio);
            return TRUE;
        }

        /* Channel will automatically shut down when the watch returns FALSE. */
        g_io_channel_set_close_on_unref(gio, TRUE);
        g_io_channel_unref(gio);
        return TRUE;
    }
    else
    {
        g_free(socket_path);

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        g_io_channel_set_encoding(gio, NULL, NULL);

        /* Push current dir in case it is needed later */
	gchar * cur_dir = g_get_current_dir();
        g_io_channel_write_chars(gio, cur_dir, -1, NULL, NULL);
	/* Use """" as a pointer to '\0' since g_io_channel_write_chars() won't accept NULL */
	g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	g_free(cur_dir);

        /* push all of argv. */
	gint i;
	for (i = 0; i < argc; i ++)
	{
            g_io_channel_write_chars(gio, argv[i], -1, NULL, NULL);
	    g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	}

        g_io_channel_flush(gio, NULL);
        g_io_channel_unref(gio);
        return FALSE;
    }
}
","gboolean lxterminal_socket_initialize(LXTermWindow * lxtermwin, gint argc, gchar * * argv)
{
    /* Normally, LXTerminal uses one process to control all of its windows.
     * The first process to start will create a Unix domain socket in /tmp.
     * It will then bind and listen on this socket.
     * The subsequent processes will connect to the controller that owns the Unix domain socket.
     * They will pass their command line over the socket and exit.
     *
     * If for any reason both the connect and bind fail, we will fall back to having that
     * process be standalone; it will not be either the controller or a user of the controller.
     * This behavior was introduced in response to a problem report (2973537).
     *
      * This function returns TRUE if this process should keep running and FALSE if it should exit. */
 
     /* Formulate the path for the Unix domain socket. */
    gchar * socket_path = g_strdup_printf(""%s/.lxterminal-socket-%s"", g_get_user_runtime_dir(), gdk_display_get_name(gdk_display_get_default()));
    printf(""%s\n"", socket_path);
 
     /* Create socket. */
     int fd = socket(PF_UNIX, SOCK_STREAM, 0);
    {
        g_warning(""Socket create failed: %s\n"", g_strerror(errno));
        g_free(socket_path);
        return TRUE;
    }

    /* Initialize socket address for Unix domain socket. */
    struct sockaddr_un sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sun_family = AF_UNIX;
    snprintf(sock_addr.sun_path, sizeof(sock_addr.sun_path), ""%s"", socket_path);

    /* Try to connect to an existing LXTerminal process. */
    if (connect(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
    {
        /* Connect failed.  We are the controller, unless something fails. */
        unlink(socket_path);
        g_free(socket_path);

        /* Bind to socket. */
        if (bind(fd, (struct sockaddr *) &sock_addr, sizeof(sock_addr)) < 0)
        {
            g_warning(""Bind on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Listen on socket. */
        if (listen(fd, 5) < 0)
        {
            g_warning(""Listen on socket failed: %s\n"", g_strerror(errno));
            close(fd);
            return TRUE;
        }

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        if (gio == NULL)
        {
            g_warning(""Cannot create GIOChannel\n"");
            close(fd);
            return TRUE;
        }

        /* Set up GIOChannel. */
        g_io_channel_set_encoding(gio, NULL, NULL);
        g_io_channel_set_buffered(gio, FALSE);
        g_io_channel_set_close_on_unref(gio, TRUE);

        /* Add I/O channel to the main event loop. */
        if ( ! g_io_add_watch(gio, G_IO_IN | G_IO_HUP, (GIOFunc) lxterminal_socket_accept_client, lxtermwin))
        {
            g_warning(""Cannot add watch on GIOChannel\n"");
            close(fd);
            g_io_channel_unref(gio);
            return TRUE;
        }

        /* Channel will automatically shut down when the watch returns FALSE. */
        g_io_channel_set_close_on_unref(gio, TRUE);
        g_io_channel_unref(gio);
        return TRUE;
    }
    else
    {
        g_free(socket_path);

        /* Create a glib I/O channel. */
        GIOChannel * gio = g_io_channel_unix_new(fd);
        g_io_channel_set_encoding(gio, NULL, NULL);

        /* Push current dir in case it is needed later */
	gchar * cur_dir = g_get_current_dir();
        g_io_channel_write_chars(gio, cur_dir, -1, NULL, NULL);
	/* Use """" as a pointer to '\0' since g_io_channel_write_chars() won't accept NULL */
	g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	g_free(cur_dir);

        /* push all of argv. */
	gint i;
	for (i = 0; i < argc; i ++)
	{
            g_io_channel_write_chars(gio, argv[i], -1, NULL, NULL);
	    g_io_channel_write_chars(gio, """", 1, NULL, NULL);
	}

        g_io_channel_flush(gio, NULL);
        g_io_channel_unref(gio);
        return FALSE;
    }
}
","The `lxterminal_socket_initialize` function manages the initialization of a Unix domain socket for LXTerminal, allowing multiple terminal windows to communicate with a single controlling process. It first attempts to connect to an existing LXTerminal instance; if this fails, it creates a new socket, binds it, and listens for incoming connections, effectively becoming the controller. If the connection is successful, it sends the current directory and command-line arguments to the controller before exiting. The function returns TRUE if the process should continue running as the controller or FALSE if it should exit after sending the data.","The code initializes a communication mechanism for a terminal application, allowing multiple instances to interact with a single controlling process. It first attempts to connect to an existing instance; if unsuccessful, it creates a new communication socket, binds it, and listens for incoming connections, thereby assuming the role of the controller. If a connection is established, it sends the current working directory and command-line arguments to the controller before terminating. The function ultimately determines whether the process should continue running as the controller or exit after relaying the necessary information.","The vulnerability in the original code arises from the insecure use of the `/tmp` directory for creating a Unix domain socket, which can be exploited by local users to interfere with terminal operations or bypass access controls. This is classified under CWE-284, where improper access control allows unauthorized actions. The fixed code addresses this issue by changing the socket path to a user-specific runtime directory obtained through a secure function, thus isolating the socket file and preventing unauthorized access. This modification enhances security by ensuring that only the intended user can interact with the socket, mitigating the risk of denial of service or unauthorized access.","The vulnerability in the original code stems from the insecure use of a shared directory for creating a socket file, which allows local users to interfere with the terminal's operation or bypass access controls, leading to potential denial of service. This issue is classified under improper access control. The fixed code resolves this vulnerability by changing the socket's location to a user-specific runtime directory, thereby isolating the socket file. This adjustment ensures that only the intended user can access the socket, significantly enhancing security and preventing unauthorized interactions that could disrupt terminal functionality.","The vulnerability was fixed by changing the socket path formulation from using a shared directory to a user-specific runtime directory. In the updated code, the socket path is created using a secure function that retrieves the user's runtime directory, replacing the previous hardcoded path in `/tmp`. This is achieved through the use of `g_get_user_runtime_dir()` combined with the display name, ensuring that the socket file is unique to each user. This change effectively isolates the socket, preventing unauthorized access and mitigating the risk of denial of service or access control bypass by local users.","The vulnerability was fixed by changing the location where the socket file is created from a shared directory to a user-specific runtime directory. This adjustment ensures that each user has a unique socket file, significantly reducing the risk of unauthorized access or interference from other local users. By isolating the socket in a secure location, the code prevents potential denial of service attacks and protects against bypassing access controls. This enhancement improves the overall security of the application by ensuring that only the intended user can interact with the socket, thereby safeguarding terminal operations.","5,5","5, 5","4, 4","4,4","CWE-377,CWE-266,CWE-732,CWE-269,CWE-284,CWE-285,CWE-441,CWE-200,CWE-668,CWE-264",Y,5.0
2,2,2,178447,178447,,Remote,Not required,,CVE-2015-8838,https://www.cvedetails.com/cve/CVE-2015-8838/,CWE-284,Medium,,Partial,,2016-05-16,4.3,"ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.",2016-11-30,,26,https://git.php.net/?p=php-src.git;a=commit;h=97aa752fee61fccdec361279adbfb17a3c60f3f4,97aa752fee61fccdec361279adbfb17a3c60f3f4,,11,,,"mysqlnd_switch_to_ssl_if_needed(
			MYSQLND_CONN_DATA * conn,
			const MYSQLND_PACKET_GREET * const greet_packet,
			const MYSQLND_OPTIONS * const options,
			unsigned long mysql_flags
			TSRMLS_DC
		)
{
	enum_func_status ret = FAIL;
	const MYSQLND_CHARSET * charset;
	MYSQLND_PACKET_AUTH * auth_packet;
	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");

	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
	if (!auth_packet) {
		SET_OOM_ERROR(*conn->error_info);
		goto end;
	}
	auth_packet->client_flags = mysql_flags;
	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;

	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
		auth_packet->charset_no	= charset->nr;
	} else {
#if MYSQLND_UNICODE
		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
#else
		auth_packet->charset_no	= greet_packet->charset_no;
#endif
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
       if (mysql_flags & CLIENT_SSL) {
               zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
               if (server_has_ssl == FALSE) {
                       goto close_conn;
               } else {
                       zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
                       DBG_INF(""Switching to SSL"");
                       if (!PACKET_WRITE(auth_packet, conn)) {
                               goto close_conn;
                       }
 
                       conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
                       if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                               goto end;
                       }
                }
        }
#else
       auth_packet->client_flags &= ~CLIENT_SSL;
       if (!PACKET_WRITE(auth_packet, conn)) {
               goto close_conn;
       }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);

close_conn:
       CONN_SET_STATE(conn, CONN_QUIT_SENT);
       conn->m->send_close(conn TSRMLS_CC);
       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
       PACKET_FREE(auth_packet);
       DBG_RETURN(ret);
 }
","mysqlnd_switch_to_ssl_if_needed(
			MYSQLND_CONN_DATA * conn,
			const MYSQLND_PACKET_GREET * const greet_packet,
			const MYSQLND_OPTIONS * const options,
			unsigned long mysql_flags
			TSRMLS_DC
		)
{
	enum_func_status ret = FAIL;
	const MYSQLND_CHARSET * charset;
	MYSQLND_PACKET_AUTH * auth_packet;
	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");

	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
	if (!auth_packet) {
		SET_OOM_ERROR(*conn->error_info);
		goto end;
	}
	auth_packet->client_flags = mysql_flags;
	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;

	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
		auth_packet->charset_no	= charset->nr;
	} else {
#if MYSQLND_UNICODE
		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
#else
		auth_packet->charset_no	= greet_packet->charset_no;
#endif
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
               DBG_INF(""Switching to SSL"");
               if (!PACKET_WRITE(auth_packet, conn)) {
                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
                       goto end;
               }
 
               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                       goto end;
                }
        }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);
 }
",C,"       if (mysql_flags & CLIENT_SSL) {
               zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
               if (server_has_ssl == FALSE) {
                       goto close_conn;
               } else {
                       zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
                       DBG_INF(""Switching to SSL"");
                       if (!PACKET_WRITE(auth_packet, conn)) {
                               goto close_conn;
                       }
                       conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
                       if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                               goto end;
                       }
#else
       auth_packet->client_flags &= ~CLIENT_SSL;
       if (!PACKET_WRITE(auth_packet, conn)) {
               goto close_conn;
       }

close_conn:
       CONN_SET_STATE(conn, CONN_QUIT_SENT);
       conn->m->send_close(conn TSRMLS_CC);
       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
       PACKET_FREE(auth_packet);
       DBG_RETURN(ret);
","       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
               DBG_INF(""Switching to SSL"");
               if (!PACKET_WRITE(auth_packet, conn)) {
                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
                       goto end;
               }
               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                       goto end;
",6dedeb40db13971af45276f80b5375030aa7e76f,"@@ -378,7 +378,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, set_server_option)(MYSQLND_CONN_DATA * const c
 
                int2store(buffer, (unsigned int) option);
                ret = conn->m->simple_command(conn, COM_SET_OPTION, buffer, sizeof(buffer), PROT_EOF_PACKET, FALSE, TRUE TSRMLS_CC);
-       
+
                conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
        DBG_RETURN(ret);
@@ -446,26 +446,41 @@ mysqlnd_switch_to_ssl_if_needed(
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
-       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
-               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
-               DBG_INF(""Switching to SSL"");
-               if (!PACKET_WRITE(auth_packet, conn)) {
-                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
-                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
-                       goto end;
-               }
+       if (mysql_flags & CLIENT_SSL) {
+               zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
+               if (server_has_ssl == FALSE) {
+                       goto close_conn;
+               } else {
+                       zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
+                       DBG_INF(""Switching to SSL"");
+                       if (!PACKET_WRITE(auth_packet, conn)) {
+                               goto close_conn;
+                       }
 
-               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
+                       conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
-               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
-                       goto end;
+                       if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
+                               goto end;
+                       }
                }
        }
+#else
+       auth_packet->client_flags &= ~CLIENT_SSL;
+       if (!PACKET_WRITE(auth_packet, conn)) {
+               goto close_conn;
+       }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);
+
+close_conn:
+       CONN_SET_STATE(conn, CONN_QUIT_SENT);
+       conn->m->send_close(conn TSRMLS_CC);
+       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
+       PACKET_FREE(auth_packet);
+       DBG_RETURN(ret);
 }
 /* }}} */
 
@@ -587,7 +602,7 @@ mysqlnd_connect_run_authentication(
                if (plugin_data) {
                        mnd_efree(plugin_data);
                }
-               
+
                if (ret == PASS) {
                        DBG_INF_FMT(""saving requested_protocol=%s"", requested_protocol);
                        conn->m->set_client_option(conn, MYSQLND_OPT_AUTH_PROTOCOL, requested_protocol TSRMLS_CC);
@@ -1438,7 +1453,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, sqlstate)(const MYSQLND_CONN_DATA * const conn
 
 
 /* {{{ mysqlnd_old_escape_string */
-PHPAPI ulong 
+PHPAPI ulong
 mysqlnd_old_escape_string(char * newstr, const char * escapestr, size_t escapestr_len TSRMLS_DC)
 {
        DBG_ENTER(""mysqlnd_old_escape_string"");
@@ -1599,7 +1614,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, statistic)(MYSQLND_CONN_DATA * conn, char **me
 
                        if (PASS == (ret = PACKET_READ(stats_header, conn))) {
                                /* will be freed by Zend, thus don't use the mnd_ allocator */
-                               *message = estrndup(stats_header->message, stats_header->message_len); 
+                               *message = estrndup(stats_header->message, stats_header->message_len);
                                *message_len = stats_header->message_len;
                                DBG_INF(*message);
                        }
@@ -1724,7 +1739,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, shutdown)(MYSQLND_CONN_DATA * const conn, uint
 
                conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
-       DBG_RETURN(ret);        
+       DBG_RETURN(ret);
 }
 /* }}} */
 
@@ -2243,7 +2258,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, change_user)(MYSQLND_CONN_DATA * const conn,
        */
 end:
        if (TRUE == local_tx_started) {
-               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);  
+               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
        DBG_INF(ret == PASS? ""PASS"":""FAIL"");
        DBG_RETURN(ret);
@@ -2335,7 +2350,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, set_client_option)(MYSQLND_CONN_DATA * const c
                                ret = FAIL;
                                break;
                        }
-                               
+
                        new_charset_name = mnd_pestrdup(value, conn->persistent);
                        if (!new_charset_name) {
                                goto oom;
@@ -2401,11 +2416,11 @@ MYSQLND_METHOD(mysqlnd_conn_data, set_client_option)(MYSQLND_CONN_DATA * const c
                default:
                        ret = FAIL;
        }
-       conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);  
+       conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        DBG_RETURN(ret);
 oom:
        SET_OOM_ERROR(*conn->error_info);
-       conn->m->local_tx_end(conn, this_func, FAIL TSRMLS_CC); 
+       conn->m->local_tx_end(conn, this_func, FAIL TSRMLS_CC);
 end:
        DBG_RETURN(FAIL);
 }
@@ -2446,7 +2461,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, use_result)(MYSQLND_CONN_DATA * const conn TSR
                        conn->current_result = NULL;
                } while (0);
 
-               conn->m->local_tx_end(conn, this_func, result == NULL? FAIL:PASS TSRMLS_CC);    
+               conn->m->local_tx_end(conn, this_func, result == NULL? FAIL:PASS TSRMLS_CC);
        }
 
        DBG_RETURN(result);
@@ -2486,7 +2501,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, store_result)(MYSQLND_CONN_DATA * const conn T
                        conn->current_result = NULL;
                } while (0);
 
-               conn->m->local_tx_end(conn, this_func, result == NULL? FAIL:PASS TSRMLS_CC);    
+               conn->m->local_tx_end(conn, this_func, result == NULL? FAIL:PASS TSRMLS_CC);
        }
        DBG_RETURN(result);
 }
@@ -2515,7 +2530,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, set_autocommit)(MYSQLND_CONN_DATA * conn, unsi
 
        if (PASS == conn->m->local_tx_start(conn, this_func TSRMLS_CC)) {
                ret = conn->m->query(conn, (mode) ? ""SET AUTOCOMMIT=1"":""SET AUTOCOMMIT=0"", sizeof(""SET AUTOCOMMIT=1"") - 1 TSRMLS_CC);
-               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);  
+               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
 
        DBG_RETURN(ret);
@@ -2533,7 +2548,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, tx_commit)(MYSQLND_CONN_DATA * conn TSRMLS_DC)
 
        if (PASS == conn->m->local_tx_start(conn, this_func TSRMLS_CC)) {
                ret = conn->m->query(conn, ""COMMIT"", sizeof(""COMMIT"") - 1 TSRMLS_CC);
-               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);  
+               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
 
        DBG_RETURN(ret);
@@ -2551,7 +2566,7 @@ MYSQLND_METHOD(mysqlnd_conn_data, tx_rollback)(MYSQLND_CONN_DATA * conn TSRMLS_D
 
        if (PASS == conn->m->local_tx_start(conn, this_func TSRMLS_CC)) {
                ret = conn->m->query(conn, ""ROLLBACK"", sizeof(""ROLLBACK"") - 1 TSRMLS_CC);
-               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);  
+               conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);
        }
 
        DBG_RETURN(ret);",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/mysqlnd/mysqlnd.c;h=61daf9688767c979f152e143dd92c365d0645689;hb=97aa752fee61fccdec361279adbfb17a3c60f3f4,https://git.php.net/?p=php-src.git;a=blob;f=ext/mysqlnd/mysqlnd.c;h=d265dfd3929c06a49c1af8df52220ef3947c14b5,1,"mysqlnd_switch_to_ssl_if_needed(
			MYSQLND_CONN_DATA * conn,
			const MYSQLND_PACKET_GREET * const greet_packet,
			const MYSQLND_OPTIONS * const options,
			unsigned long mysql_flags
			TSRMLS_DC
		)
{
	enum_func_status ret = FAIL;
	const MYSQLND_CHARSET * charset;
	MYSQLND_PACKET_AUTH * auth_packet;
	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");

	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
	if (!auth_packet) {
		SET_OOM_ERROR(*conn->error_info);
		goto end;
	}
	auth_packet->client_flags = mysql_flags;
	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;

	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
		auth_packet->charset_no	= charset->nr;
	} else {
#if MYSQLND_UNICODE
		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
#else
		auth_packet->charset_no	= greet_packet->charset_no;
#endif
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
//flaw_line_below:
       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
//flaw_line_below:
               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
//flaw_line_below:
               DBG_INF(""Switching to SSL"");
//flaw_line_below:
               if (!PACKET_WRITE(auth_packet, conn)) {
//flaw_line_below:
                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
//flaw_line_below:
                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
//flaw_line_below:
                       goto end;
//flaw_line_below:
               }
//fix_flaw_line_below:
//       if (mysql_flags & CLIENT_SSL) {
//fix_flaw_line_below:
//               zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
//fix_flaw_line_below:
//               if (server_has_ssl == FALSE) {
//fix_flaw_line_below:
//                       goto close_conn;
//fix_flaw_line_below:
//               } else {
//fix_flaw_line_below:
//                       zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
//fix_flaw_line_below:
//                       DBG_INF(""Switching to SSL"");
//fix_flaw_line_below:
//                       if (!PACKET_WRITE(auth_packet, conn)) {
//fix_flaw_line_below:
//                               goto close_conn;
//fix_flaw_line_below:
//                       }
 
//flaw_line_below:
               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
//fix_flaw_line_below:
//                       conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
//flaw_line_below:
               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
//flaw_line_below:
                       goto end;
//fix_flaw_line_below:
//                       if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
//fix_flaw_line_below:
//                               goto end;
//fix_flaw_line_below:
//                       }
                }
        }
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//       auth_packet->client_flags &= ~CLIENT_SSL;
//fix_flaw_line_below:
//       if (!PACKET_WRITE(auth_packet, conn)) {
//fix_flaw_line_below:
//               goto close_conn;
//fix_flaw_line_below:
//       }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//close_conn:
//fix_flaw_line_below:
//       CONN_SET_STATE(conn, CONN_QUIT_SENT);
//fix_flaw_line_below:
//       conn->m->send_close(conn TSRMLS_CC);
//fix_flaw_line_below:
//       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
//fix_flaw_line_below:
//       PACKET_FREE(auth_packet);
//fix_flaw_line_below:
//       DBG_RETURN(ret);
 }
",178447,"mysqlnd_switch_to_ssl_if_needed(
			MYSQLND_CONN_DATA * conn,
			const MYSQLND_PACKET_GREET * const greet_packet,
			const MYSQLND_OPTIONS * const options,
			unsigned long mysql_flags
			TSRMLS_DC
		)
{
	enum_func_status ret = FAIL;
	const MYSQLND_CHARSET * charset;
	MYSQLND_PACKET_AUTH * auth_packet;
	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");

	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
	if (!auth_packet) {
		SET_OOM_ERROR(*conn->error_info);
		goto end;
	}
	auth_packet->client_flags = mysql_flags;
	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;

	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
		auth_packet->charset_no	= charset->nr;
	} else {
#if MYSQLND_UNICODE
		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
#else
		auth_packet->charset_no	= greet_packet->charset_no;
#endif
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
               DBG_INF(""Switching to SSL"");
               if (!PACKET_WRITE(auth_packet, conn)) {
                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
                       goto end;
               }
 
               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                       goto end;
                }
        }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);
 }
","mysqlnd_switch_to_ssl_if_needed(
			MYSQLND_CONN_DATA * conn,
			const MYSQLND_PACKET_GREET * const greet_packet,
			const MYSQLND_OPTIONS * const options,
			unsigned long mysql_flags
			TSRMLS_DC
		)
{
	enum_func_status ret = FAIL;
	const MYSQLND_CHARSET * charset;
	MYSQLND_PACKET_AUTH * auth_packet;
	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");

	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
	if (!auth_packet) {
		SET_OOM_ERROR(*conn->error_info);
		goto end;
	}
	auth_packet->client_flags = mysql_flags;
	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;

	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
		auth_packet->charset_no	= charset->nr;
	} else {
#if MYSQLND_UNICODE
		auth_packet->charset_no	= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */
#else
		auth_packet->charset_no	= greet_packet->charset_no;
#endif
        }
 
 #ifdef MYSQLND_SSL_SUPPORTED
       if (mysql_flags & CLIENT_SSL) {
               zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
               if (server_has_ssl == FALSE) {
                       goto close_conn;
               } else {
                       zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
                       DBG_INF(""Switching to SSL"");
                       if (!PACKET_WRITE(auth_packet, conn)) {
                               goto close_conn;
                       }
 
                       conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
 
                       if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                               goto end;
                       }
                }
        }
#else
       auth_packet->client_flags &= ~CLIENT_SSL;
       if (!PACKET_WRITE(auth_packet, conn)) {
               goto close_conn;
       }
 #endif
        ret = PASS;
 end:
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);

close_conn:
       CONN_SET_STATE(conn, CONN_QUIT_SENT);
       conn->m->send_close(conn TSRMLS_CC);
       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
       PACKET_FREE(auth_packet);
       DBG_RETURN(ret);
 }
","The function `mysqlnd_switch_to_ssl_if_needed` is designed to establish an SSL connection for a MySQL client if the server supports SSL and the client requests it. It begins by retrieving an authentication packet and setting its client flags and maximum packet size. The function checks for a specified character set and assigns it to the authentication packet. If SSL is supported by the server and requested by the client, it prepares to switch to SSL, verifies server certificate options, and attempts to enable SSL on the connection. The function concludes by freeing the authentication packet and returning a status indicating success or failure.","The code implements a function that facilitates the transition to a secure connection for a MySQL client when both the server and client support secure communication. It begins by preparing an authentication packet and configuring its parameters. The function checks for a specified character set and assigns it accordingly. If the server indicates support for secure connections and the client requests it, the function sets up the necessary options for secure verification and attempts to enable the secure connection. Finally, it cleans up resources and returns a status indicating whether the operation was successful or not.","The vulnerability in the original code arises from the improper handling of the client SSL option, which allowed SSL to be treated as optional. This oversight could enable man-in-the-middle attackers to exploit the connection by downgrading it to cleartext, potentially spoofing the server. In the revised code, the check for the server's SSL capability is explicitly enforced by evaluating the `server_has_ssl` variable. If the server does not support SSL, the connection is closed immediately, preventing any potential downgrade attack. This change ensures that SSL is mandatory when requested, thereby enhancing the security of the connection.","The vulnerability in the original code stemmed from treating the SSL option as optional, which could allow attackers to perform a cleartext-downgrade attack, potentially spoofing the server. This weakness made it possible for an attacker to intercept and manipulate communications between the client and server. The revised code addresses this issue by enforcing a strict check on the server's capability to support SSL. If the server does not support SSL, the connection is immediately terminated, ensuring that SSL is mandatory when requested and significantly reducing the risk of man-in-the-middle attacks.","The vulnerability was fixed by introducing a strict check for the server's SSL capability in the revised code. Specifically, the `server_has_ssl` variable is evaluated to determine if the server supports SSL. If this check fails, the code immediately jumps to the `close_conn` label, which handles closing the connection and setting the appropriate error state. This ensures that if the server does not support SSL, the connection will not proceed, effectively preventing any potential cleartext-downgrade attacks. Additionally, the client flags are adjusted to ensure SSL is treated as mandatory when requested.","The vulnerability was fixed by implementing a mandatory check for the server's capability to support secure connections. The revised code ensures that if the server does not support secure communication, the connection is immediately terminated, preventing any potential downgrade to an insecure, cleartext connection. This change enforces a strict requirement that secure communication must be used when requested by the client, thereby eliminating the risk of man-in-the-middle attacks. Additionally, the handling of client options was adjusted to reinforce the necessity of secure communication, ensuring that it cannot be bypassed inadvertently.","5, 5","5,5","4,4","4, 4","CWE-319, CWE-295, CWE-297, CWE-300, CWE-757, CWE-320, CWE-318, CWE-326, CWE-327, CWE-299",N,-1
3,3,3,179961,179961,,Remote,Single system,Complete,CVE-2014-9422,https://www.cvedetails.com/cve/CVE-2014-9422/,CWE-284,High,Partial,Partial,,2015-02-19,6.1,"The check_rpcsec_auth function in kadmin/server/kadm_rpc_svc.c in kadmind in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 allows remote authenticated users to bypass a kadmin/* authorization check and obtain administrative access by leveraging access to a two-component principal with an initial *kadmind* substring, as demonstrated by a *ka/x* principal.",2017-01-02,Bypass ,2,https://github.com/krb5/krb5/commit/6609658db0799053fbef0d7d0aa2f1fd68ef32d8,6609658db0799053fbef0d7d0aa2f1fd68ef32d8,"Fix kadmind server validation [CVE-2014-9422]

[MITKRB5-SA-2015-001] In kadmind's check_rpcsec_auth(), use
data_eq_string() instead of strncmp() to check components of the
server principal, so that we don't erroneously match left substrings
of ""kadmin"", ""history"", or the realm.

ticket: 8057 (new)
target_version: 1.13.1
tags: pullup",7,src/kadmin/server/kadm_rpc_svc.c,"{""sha"": ""f4d2a7cba7b4c5b6de0479ab8dbbe30e097aee24"", ""filename"": ""src/kadmin/server/kadm_rpc_svc.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 9, ""changes"": 12, ""blob_url"": ""https://github.com/krb5/krb5/blob/6609658db0799053fbef0d7d0aa2f1fd68ef32d8/src/kadmin/server/kadm_rpc_svc.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/6609658db0799053fbef0d7d0aa2f1fd68ef32d8/src/kadmin/server/kadm_rpc_svc.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/kadmin/server/kadm_rpc_svc.c?ref=6609658db0799053fbef0d7d0aa2f1fd68ef32d8"", ""patch"": ""@@ -4,7 +4,7 @@\n  *\n  */\n \n-#include <k5-platform.h>\n+#include <k5-int.h>\n #include <gssrpc/rpc.h>\n #include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n #include <syslog.h>\n@@ -296,14 +296,8 @@ check_rpcsec_auth(struct svc_req *rqstp)\n      c1 = krb5_princ_component(kctx, princ, 0);\n      c2 = krb5_princ_component(kctx, princ, 1);\n      realm = krb5_princ_realm(kctx, princ);\n-     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n-\t && strncmp(\""kadmin\"", c1->data, c1->length) == 0) {\n-\n-\t  if (strncmp(\""history\"", c2->data, c2->length) == 0)\n-\t       goto fail_princ;\n-\t  else\n-\t       success = 1;\n-     }\n+     success = data_eq_string(*realm, handle->params.realm) &&\n+\t     data_eq_string(*c1, \""kadmin\"") && !data_eq_string(*c2, \""history\"");\n \n fail_princ:\n      if (!success) {""}","check_rpcsec_auth(struct svc_req *rqstp)
{
     gss_ctx_id_t ctx;
     krb5_context kctx;
     OM_uint32 maj_stat, min_stat;
     gss_name_t name;
     krb5_principal princ;
     int ret, success;
     krb5_data *c1, *c2, *realm;
     gss_buffer_desc gss_str;
     kadm5_server_handle_t handle;
     size_t slen;
     char *sdots;

     success = 0;
     handle = (kadm5_server_handle_t)global_server_handle;

     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)
	  return 0;

     ctx = rqstp->rq_svccred;

     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,
				    NULL, NULL, NULL, NULL, NULL);
     if (maj_stat != GSS_S_COMPLETE) {
	  krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed ""
				      ""inquire_context, stat=%u""), maj_stat);
	  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);
	  goto fail_name;
     }

     kctx = handle->context;
     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);
     if (ret == 0)
	  goto fail_name;

     slen = gss_str.length;
     trunc_name(&slen, &sdots);
     /*
      * Since we accept with GSS_C_NO_NAME, the client can authenticate
      * against the entire kdb.  Therefore, ensure that the service
      * name is something reasonable.
      */
     if (krb5_princ_size(kctx, princ) != 2)
	  goto fail_princ;

      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
     success = data_eq_string(*realm, handle->params.realm) &&
	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
 
 fail_princ:
      if (!success) {
	 krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""),
			  (int) slen, (char *) gss_str.value, sdots);
     }
     gss_release_buffer(&min_stat, &gss_str);
     krb5_free_principal(kctx, princ);
fail_name:
     gss_release_name(&min_stat, &name);
     return success;
}
","check_rpcsec_auth(struct svc_req *rqstp)
{
     gss_ctx_id_t ctx;
     krb5_context kctx;
     OM_uint32 maj_stat, min_stat;
     gss_name_t name;
     krb5_principal princ;
     int ret, success;
     krb5_data *c1, *c2, *realm;
     gss_buffer_desc gss_str;
     kadm5_server_handle_t handle;
     size_t slen;
     char *sdots;

     success = 0;
     handle = (kadm5_server_handle_t)global_server_handle;

     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)
	  return 0;

     ctx = rqstp->rq_svccred;

     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,
				    NULL, NULL, NULL, NULL, NULL);
     if (maj_stat != GSS_S_COMPLETE) {
	  krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed ""
				      ""inquire_context, stat=%u""), maj_stat);
	  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);
	  goto fail_name;
     }

     kctx = handle->context;
     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);
     if (ret == 0)
	  goto fail_name;

     slen = gss_str.length;
     trunc_name(&slen, &sdots);
     /*
      * Since we accept with GSS_C_NO_NAME, the client can authenticate
      * against the entire kdb.  Therefore, ensure that the service
      * name is something reasonable.
      */
     if (krb5_princ_size(kctx, princ) != 2)
	  goto fail_princ;

      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
     if (strncmp(handle->params.realm, realm->data, realm->length) == 0
	 && strncmp(""kadmin"", c1->data, c1->length) == 0) {
	  if (strncmp(""history"", c2->data, c2->length) == 0)
	       goto fail_princ;
	  else
	       success = 1;
     }
 
 fail_princ:
      if (!success) {
	 krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""),
			  (int) slen, (char *) gss_str.value, sdots);
     }
     gss_release_buffer(&min_stat, &gss_str);
     krb5_free_principal(kctx, princ);
fail_name:
     gss_release_name(&min_stat, &name);
     return success;
}
",C,"     success = data_eq_string(*realm, handle->params.realm) &&
	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
","     if (strncmp(handle->params.realm, realm->data, realm->length) == 0
	 && strncmp(""kadmin"", c1->data, c1->length) == 0) {
	  if (strncmp(""history"", c2->data, c2->length) == 0)
	       goto fail_princ;
	  else
	       success = 1;
     }
",,"@@ -4,7 +4,7 @@
  *
  */
 
-#include <k5-platform.h>
+#include <k5-int.h>
 #include <gssrpc/rpc.h>
 #include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */
 #include <syslog.h>
@@ -296,14 +296,8 @@ check_rpcsec_auth(struct svc_req *rqstp)
      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
-     if (strncmp(handle->params.realm, realm->data, realm->length) == 0
-	 && strncmp(""kadmin"", c1->data, c1->length) == 0) {
-
-	  if (strncmp(""history"", c2->data, c2->length) == 0)
-	       goto fail_princ;
-	  else
-	       success = 1;
-     }
+     success = data_eq_string(*realm, handle->params.realm) &&
+	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
 
 fail_princ:
      if (!success) {",krb5,6609658db0799053fbef0d7d0aa2f1fd68ef32d8,a197e92349a4aa2141b5dff12e9dd44c2a2166e3,1,"check_rpcsec_auth(struct svc_req *rqstp)
{
     gss_ctx_id_t ctx;
     krb5_context kctx;
     OM_uint32 maj_stat, min_stat;
     gss_name_t name;
     krb5_principal princ;
     int ret, success;
     krb5_data *c1, *c2, *realm;
     gss_buffer_desc gss_str;
     kadm5_server_handle_t handle;
     size_t slen;
     char *sdots;

     success = 0;
     handle = (kadm5_server_handle_t)global_server_handle;

     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)
	  return 0;

     ctx = rqstp->rq_svccred;

     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,
				    NULL, NULL, NULL, NULL, NULL);
     if (maj_stat != GSS_S_COMPLETE) {
	  krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed ""
				      ""inquire_context, stat=%u""), maj_stat);
	  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);
	  goto fail_name;
     }

     kctx = handle->context;
     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);
     if (ret == 0)
	  goto fail_name;

     slen = gss_str.length;
     trunc_name(&slen, &sdots);
     /*
      * Since we accept with GSS_C_NO_NAME, the client can authenticate
      * against the entire kdb.  Therefore, ensure that the service
      * name is something reasonable.
      */
     if (krb5_princ_size(kctx, princ) != 2)
	  goto fail_princ;

      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
//flaw_line_below:
     if (strncmp(handle->params.realm, realm->data, realm->length) == 0
//flaw_line_below:
	 && strncmp(""kadmin"", c1->data, c1->length) == 0) {
//flaw_line_below:

//flaw_line_below:
	  if (strncmp(""history"", c2->data, c2->length) == 0)
//flaw_line_below:
	       goto fail_princ;
//flaw_line_below:
	  else
//flaw_line_below:
	       success = 1;
//flaw_line_below:
     }
//fix_flaw_line_below:
//     success = data_eq_string(*realm, handle->params.realm) &&
//fix_flaw_line_below:
//	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
 
 fail_princ:
      if (!success) {
	 krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""),
			  (int) slen, (char *) gss_str.value, sdots);
     }
     gss_release_buffer(&min_stat, &gss_str);
     krb5_free_principal(kctx, princ);
fail_name:
     gss_release_name(&min_stat, &name);
     return success;
}
",179961,"check_rpcsec_auth(struct svc_req *rqstp)
{
     gss_ctx_id_t ctx;
     krb5_context kctx;
     OM_uint32 maj_stat, min_stat;
     gss_name_t name;
     krb5_principal princ;
     int ret, success;
     krb5_data *c1, *c2, *realm;
     gss_buffer_desc gss_str;
     kadm5_server_handle_t handle;
     size_t slen;
     char *sdots;

     success = 0;
     handle = (kadm5_server_handle_t)global_server_handle;

     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)
	  return 0;

     ctx = rqstp->rq_svccred;

     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,
				    NULL, NULL, NULL, NULL, NULL);
     if (maj_stat != GSS_S_COMPLETE) {
	  krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed ""
				      ""inquire_context, stat=%u""), maj_stat);
	  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);
	  goto fail_name;
     }

     kctx = handle->context;
     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);
     if (ret == 0)
	  goto fail_name;

     slen = gss_str.length;
     trunc_name(&slen, &sdots);
     /*
      * Since we accept with GSS_C_NO_NAME, the client can authenticate
      * against the entire kdb.  Therefore, ensure that the service
      * name is something reasonable.
      */
     if (krb5_princ_size(kctx, princ) != 2)
	  goto fail_princ;

      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
     if (strncmp(handle->params.realm, realm->data, realm->length) == 0
	 && strncmp(""kadmin"", c1->data, c1->length) == 0) {
	  if (strncmp(""history"", c2->data, c2->length) == 0)
	       goto fail_princ;
	  else
	       success = 1;
     }
 
 fail_princ:
      if (!success) {
	 krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""),
			  (int) slen, (char *) gss_str.value, sdots);
     }
     gss_release_buffer(&min_stat, &gss_str);
     krb5_free_principal(kctx, princ);
fail_name:
     gss_release_name(&min_stat, &name);
     return success;
}
","check_rpcsec_auth(struct svc_req *rqstp)
{
     gss_ctx_id_t ctx;
     krb5_context kctx;
     OM_uint32 maj_stat, min_stat;
     gss_name_t name;
     krb5_principal princ;
     int ret, success;
     krb5_data *c1, *c2, *realm;
     gss_buffer_desc gss_str;
     kadm5_server_handle_t handle;
     size_t slen;
     char *sdots;

     success = 0;
     handle = (kadm5_server_handle_t)global_server_handle;

     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)
	  return 0;

     ctx = rqstp->rq_svccred;

     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,
				    NULL, NULL, NULL, NULL, NULL);
     if (maj_stat != GSS_S_COMPLETE) {
	  krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed ""
				      ""inquire_context, stat=%u""), maj_stat);
	  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);
	  goto fail_name;
     }

     kctx = handle->context;
     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);
     if (ret == 0)
	  goto fail_name;

     slen = gss_str.length;
     trunc_name(&slen, &sdots);
     /*
      * Since we accept with GSS_C_NO_NAME, the client can authenticate
      * against the entire kdb.  Therefore, ensure that the service
      * name is something reasonable.
      */
     if (krb5_princ_size(kctx, princ) != 2)
	  goto fail_princ;

      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
     success = data_eq_string(*realm, handle->params.realm) &&
	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
 
 fail_princ:
      if (!success) {
	 krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""),
			  (int) slen, (char *) gss_str.value, sdots);
     }
     gss_release_buffer(&min_stat, &gss_str);
     krb5_free_principal(kctx, princ);
fail_name:
     gss_release_name(&min_stat, &name);
     return success;
}
","The `check_rpcsec_auth` function is designed to authenticate RPC (Remote Procedure Call) requests using GSSAPI (Generic Security Services Application Program Interface) with Kerberos. It first checks if the request's credentials are of the RPCSEC_GSS flavor. If so, it retrieves the GSS context and verifies it. The function then converts the GSS name to a Kerberos principal and checks its validity against predefined criteria, ensuring the principal belongs to the correct realm and is not a restricted service name. If authentication fails at any point, it logs an error and releases allocated resources before returning a success status.","The function is responsible for authenticating RPC requests using a security protocol that relies on a context established through a secure mechanism. It first verifies the type of credentials provided in the request. If valid, it retrieves and examines the security context to ensure it is properly formed. The function then translates the security name into a principal and checks its validity against specific criteria, including realm and service name restrictions. If any checks fail, it logs an error and cleans up any allocated resources before returning a success status indicating whether the authentication was successful.","The vulnerability in the original code allowed remote authenticated users to bypass authorization checks by exploiting a two-component principal that began with ""kadmin,"" potentially granting them administrative access. This was due to insufficient validation of the principal's components, which could lead to unauthorized access. In the fixed code, the validation logic was enhanced by explicitly checking that the principal's realm matches the expected realm and ensuring that the first component is ""kadmin"" while the second component is not ""history."" This stricter validation prevents unauthorized access by ensuring that only properly authorized principals can gain administrative privileges.","The vulnerability allowed remote authenticated users to bypass authorization checks, enabling them to gain administrative access by using a specially crafted principal that began with ""kadmin."" This weakness stemmed from inadequate validation of the principal's components, which could lead to unauthorized access. The fix involved implementing stricter validation criteria, ensuring that the principal's realm matched the expected realm and that the first component was ""kadmin"" while the second component was not a restricted value. This enhanced validation effectively mitigated the risk of unauthorized administrative access by enforcing proper authorization checks.","The vulnerability was fixed by enhancing the validation logic for the principal in the authentication function. The code now checks that the principal consists of exactly two components, ensuring that it is a valid format. It then verifies that the realm matches the expected realm and that the first component is ""kadmin."" Additionally, it explicitly checks that the second component is not ""history."" This stricter validation is implemented through the success condition, which combines these checks using logical comparisons, thereby preventing unauthorized access by ensuring only properly authorized principals can authenticate successfully.","The vulnerability was addressed by implementing stricter validation criteria for the principal used in the authentication process. The updated logic ensures that the principal consists of exactly two components, which is a necessary format for valid entries. It also checks that the realm matches the expected value and that the first component is specifically designated for administrative access. Furthermore, the second component is validated to ensure it does not correspond to a restricted or sensitive value. These enhancements collectively strengthen the authorization checks, preventing unauthorized users from gaining administrative privileges.","5,4","5,5","5,5","4,5","CWE-287, CWE-285, CWE-305, CWE-807, CWE-290, CWE-284, CWE-306, CWE-308, CWE-522, CWE-269",N,-1
4,4,4,180085,180085,,Local,Not required,Complete,CVE-2016-8645,https://www.cvedetails.com/cve/CVE-2016-8645/,CWE-284,Low,,,,2016-11-27,4.9,"The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3,ac6e780070e30e4c35bd395acfe9191e6268bdd3,"tcp: take care of truncations done by sk_filter()

With syzkaller help, Marco Grassi found a bug in TCP stack,
crashing in tcp_collapse()

Root cause is that sk_filter() can truncate the incoming skb,
but TCP stack was not really expecting this to happen.
It probably was expecting a simple DROP or ACCEPT behavior.

We first need to make sure no part of TCP header could be removed.
Then we need to adjust TCP_SKB_CB(skb)->end_seq

Many thanks to syzkaller team and Marco for giving us a reproducer.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Marco Grassi <marco.gra@gmail.com>
Reported-by: Vladis Dronov <vdronov@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/ipv4/tcp_ipv4.c,"{""sha"": ""123979fe12bf780b50ed0967d8ba289c63f798a3"", ""filename"": ""include/net/tcp.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/ac6e780070e30e4c35bd395acfe9191e6268bdd3/include/net/tcp.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ac6e780070e30e4c35bd395acfe9191e6268bdd3/include/net/tcp.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/tcp.h?ref=ac6e780070e30e4c35bd395acfe9191e6268bdd3"", ""patch"": ""@@ -1220,6 +1220,7 @@ static inline void tcp_prequeue_init(struct tcp_sock *tp)\n \n bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);\n bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);\n+int tcp_filter(struct sock *sk, struct sk_buff *skb);\n \n #undef STATE_TRACE\n ""}<_**next**_>{""sha"": ""2259114c7242c72cadc149073c8101101c198483"", ""filename"": ""net/ipv4/tcp_ipv4.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 1, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/ac6e780070e30e4c35bd395acfe9191e6268bdd3/net/ipv4/tcp_ipv4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ac6e780070e30e4c35bd395acfe9191e6268bdd3/net/ipv4/tcp_ipv4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/tcp_ipv4.c?ref=ac6e780070e30e4c35bd395acfe9191e6268bdd3"", ""patch"": ""@@ -1564,6 +1564,21 @@ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)\n }\n EXPORT_SYMBOL(tcp_add_backlog);\n \n+int tcp_filter(struct sock *sk, struct sk_buff *skb)\n+{\n+\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n+\tunsigned int eaten = skb->len;\n+\tint err;\n+\n+\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n+\tif (!err) {\n+\t\teaten -= skb->len;\n+\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n+\t}\n+\treturn err;\n+}\n+EXPORT_SYMBOL(tcp_filter);\n+\n /*\n  *\tFrom tcp_input.c\n  */\n@@ -1676,8 +1691,10 @@ int tcp_v4_rcv(struct sk_buff *skb)\n \n \tnf_reset(skb);\n \n-\tif (sk_filter(sk, skb))\n+\tif (tcp_filter(sk, skb))\n \t\tgoto discard_and_relse;\n+\tth = (const struct tcphdr *)skb->data;\n+\tiph = ip_hdr(skb);\n \n \tskb->dev = NULL;\n ""}<_**next**_>{""sha"": ""b9f1fee9a8862a5bc17a20e17bdb402adc418cde"", ""filename"": ""net/ipv6/tcp_ipv6.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/ac6e780070e30e4c35bd395acfe9191e6268bdd3/net/ipv6/tcp_ipv6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ac6e780070e30e4c35bd395acfe9191e6268bdd3/net/ipv6/tcp_ipv6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/tcp_ipv6.c?ref=ac6e780070e30e4c35bd395acfe9191e6268bdd3"", ""patch"": ""@@ -1229,7 +1229,7 @@ static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n \tif (skb->protocol == htons(ETH_P_IP))\n \t\treturn tcp_v4_do_rcv(sk, skb);\n \n-\tif (sk_filter(sk, skb))\n+\tif (tcp_filter(sk, skb))\n \t\tgoto discard;\n \n \t/*\n@@ -1457,8 +1457,10 @@ static int tcp_v6_rcv(struct sk_buff *skb)\n \tif (tcp_v6_inbound_md5_hash(sk, skb))\n \t\tgoto discard_and_relse;\n \n-\tif (sk_filter(sk, skb))\n+\tif (tcp_filter(sk, skb))\n \t\tgoto discard_and_relse;\n+\tth = (const struct tcphdr *)skb->data;\n+\thdr = ipv6_hdr(skb);\n \n \tskb->dev = NULL;\n ""}","int tcp_v4_rcv(struct sk_buff *skb)
{
	struct net *net = dev_net(skb->dev);
	const struct iphdr *iph;
	const struct tcphdr *th;
	bool refcounted;
	struct sock *sk;
	int ret;

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	/* Count it even if it's bad */
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr) / 4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff * 4))
		goto discard_it;

	/* An explanation is required here, I think.
	 * Packet length and doff are validated by header prediction,
	 * provided case of th->doff==0 is eliminated.
	 * So, we defer the checks. */

	if (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
	/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()
	 * barrier() makes sure compiler wont play fool^Waliasing games.
	 */
	memmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),
		sizeof(struct inet_skb_parm));
	barrier();

	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
				    skb->len - th->doff * 4);
	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
	TCP_SKB_CB(skb)->sacked	 = 0;

lookup:
	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
			       th->dest, &refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		/* We own a reference on the listener, increase it again
		 * as we might lose it too soon.
		 */
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v4_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	if (tcp_v4_inbound_md5_hash(sk, skb))
		goto discard_and_relse;
 
 	nf_reset(skb);
 
	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v4_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);

	return ret;

no_tcp_socket:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v4_send_reset(NULL, skb);
	}

discard_it:
	/* Discard frame. */
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}
	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN: {
		struct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),
							&tcp_hashinfo, skb,
							__tcp_hdrlen(th),
							iph->saddr, th->source,
							iph->daddr, th->dest,
							inet_iif(skb));
		if (sk2) {
			inet_twsk_deschedule_put(inet_twsk(sk));
			sk = sk2;
			refcounted = false;
			goto process;
		}
		/* Fall through to ACK */
	}
	case TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v4_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:;
	}
	goto discard_it;
}
","int tcp_v4_rcv(struct sk_buff *skb)
{
	struct net *net = dev_net(skb->dev);
	const struct iphdr *iph;
	const struct tcphdr *th;
	bool refcounted;
	struct sock *sk;
	int ret;

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	/* Count it even if it's bad */
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr) / 4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff * 4))
		goto discard_it;

	/* An explanation is required here, I think.
	 * Packet length and doff are validated by header prediction,
	 * provided case of th->doff==0 is eliminated.
	 * So, we defer the checks. */

	if (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
	/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()
	 * barrier() makes sure compiler wont play fool^Waliasing games.
	 */
	memmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),
		sizeof(struct inet_skb_parm));
	barrier();

	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
				    skb->len - th->doff * 4);
	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
	TCP_SKB_CB(skb)->sacked	 = 0;

lookup:
	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
			       th->dest, &refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		/* We own a reference on the listener, increase it again
		 * as we might lose it too soon.
		 */
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v4_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	if (tcp_v4_inbound_md5_hash(sk, skb))
		goto discard_and_relse;
 
 	nf_reset(skb);
 
	if (sk_filter(sk, skb))
 		goto discard_and_relse;
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v4_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);

	return ret;

no_tcp_socket:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v4_send_reset(NULL, skb);
	}

discard_it:
	/* Discard frame. */
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}
	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN: {
		struct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),
							&tcp_hashinfo, skb,
							__tcp_hdrlen(th),
							iph->saddr, th->source,
							iph->daddr, th->dest,
							inet_iif(skb));
		if (sk2) {
			inet_twsk_deschedule_put(inet_twsk(sk));
			sk = sk2;
			refcounted = false;
			goto process;
		}
		/* Fall through to ACK */
	}
	case TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v4_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:;
	}
	goto discard_it;
}
",C,"	if (tcp_filter(sk, skb))
	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
","	if (sk_filter(sk, skb))
",,"@@ -1564,6 +1564,21 @@ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)
 }
 EXPORT_SYMBOL(tcp_add_backlog);
 
+int tcp_filter(struct sock *sk, struct sk_buff *skb)
+{
+	struct tcphdr *th = (struct tcphdr *)skb->data;
+	unsigned int eaten = skb->len;
+	int err;
+
+	err = sk_filter_trim_cap(sk, skb, th->doff * 4);
+	if (!err) {
+		eaten -= skb->len;
+		TCP_SKB_CB(skb)->end_seq -= eaten;
+	}
+	return err;
+}
+EXPORT_SYMBOL(tcp_filter);
+
 /*
  *	From tcp_input.c
  */
@@ -1676,8 +1691,10 @@ int tcp_v4_rcv(struct sk_buff *skb)
 
 	nf_reset(skb);
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
+	th = (const struct tcphdr *)skb->data;
+	iph = ip_hdr(skb);
 
 	skb->dev = NULL;
 ",linux,ac6e780070e30e4c35bd395acfe9191e6268bdd3,969447f226b451c453ddc83cac6144eaeac6f2e3,1,"int tcp_v4_rcv(struct sk_buff *skb)
{
	struct net *net = dev_net(skb->dev);
	const struct iphdr *iph;
	const struct tcphdr *th;
	bool refcounted;
	struct sock *sk;
	int ret;

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	/* Count it even if it's bad */
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr) / 4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff * 4))
		goto discard_it;

	/* An explanation is required here, I think.
	 * Packet length and doff are validated by header prediction,
	 * provided case of th->doff==0 is eliminated.
	 * So, we defer the checks. */

	if (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
	/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()
	 * barrier() makes sure compiler wont play fool^Waliasing games.
	 */
	memmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),
		sizeof(struct inet_skb_parm));
	barrier();

	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
				    skb->len - th->doff * 4);
	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
	TCP_SKB_CB(skb)->sacked	 = 0;

lookup:
	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
			       th->dest, &refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		/* We own a reference on the listener, increase it again
		 * as we might lose it too soon.
		 */
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v4_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	if (tcp_v4_inbound_md5_hash(sk, skb))
		goto discard_and_relse;
 
 	nf_reset(skb);
 
//flaw_line_below:
	if (sk_filter(sk, skb))
//fix_flaw_line_below:
//	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
//fix_flaw_line_below:
//	th = (const struct tcphdr *)skb->data;
//fix_flaw_line_below:
//	iph = ip_hdr(skb);
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v4_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);

	return ret;

no_tcp_socket:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v4_send_reset(NULL, skb);
	}

discard_it:
	/* Discard frame. */
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}
	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN: {
		struct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),
							&tcp_hashinfo, skb,
							__tcp_hdrlen(th),
							iph->saddr, th->source,
							iph->daddr, th->dest,
							inet_iif(skb));
		if (sk2) {
			inet_twsk_deschedule_put(inet_twsk(sk));
			sk = sk2;
			refcounted = false;
			goto process;
		}
		/* Fall through to ACK */
	}
	case TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v4_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:;
	}
	goto discard_it;
}
",180085,"int tcp_v4_rcv(struct sk_buff *skb)
{
	struct net *net = dev_net(skb->dev);
	const struct iphdr *iph;
	const struct tcphdr *th;
	bool refcounted;
	struct sock *sk;
	int ret;

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	/* Count it even if it's bad */
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr) / 4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff * 4))
		goto discard_it;

	/* An explanation is required here, I think.
	 * Packet length and doff are validated by header prediction,
	 * provided case of th->doff==0 is eliminated.
	 * So, we defer the checks. */

	if (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
	/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()
	 * barrier() makes sure compiler wont play fool^Waliasing games.
	 */
	memmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),
		sizeof(struct inet_skb_parm));
	barrier();

	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
				    skb->len - th->doff * 4);
	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
	TCP_SKB_CB(skb)->sacked	 = 0;

lookup:
	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
			       th->dest, &refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		/* We own a reference on the listener, increase it again
		 * as we might lose it too soon.
		 */
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v4_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	if (tcp_v4_inbound_md5_hash(sk, skb))
		goto discard_and_relse;
 
 	nf_reset(skb);
 
	if (sk_filter(sk, skb))
 		goto discard_and_relse;
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v4_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);

	return ret;

no_tcp_socket:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v4_send_reset(NULL, skb);
	}

discard_it:
	/* Discard frame. */
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}
	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN: {
		struct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),
							&tcp_hashinfo, skb,
							__tcp_hdrlen(th),
							iph->saddr, th->source,
							iph->daddr, th->dest,
							inet_iif(skb));
		if (sk2) {
			inet_twsk_deschedule_put(inet_twsk(sk));
			sk = sk2;
			refcounted = false;
			goto process;
		}
		/* Fall through to ACK */
	}
	case TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v4_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:;
	}
	goto discard_it;
}
","int tcp_v4_rcv(struct sk_buff *skb)
{
	struct net *net = dev_net(skb->dev);
	const struct iphdr *iph;
	const struct tcphdr *th;
	bool refcounted;
	struct sock *sk;
	int ret;

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	/* Count it even if it's bad */
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr) / 4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff * 4))
		goto discard_it;

	/* An explanation is required here, I think.
	 * Packet length and doff are validated by header prediction,
	 * provided case of th->doff==0 is eliminated.
	 * So, we defer the checks. */

	if (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
	/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()
	 * barrier() makes sure compiler wont play fool^Waliasing games.
	 */
	memmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),
		sizeof(struct inet_skb_parm));
	barrier();

	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
				    skb->len - th->doff * 4);
	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
	TCP_SKB_CB(skb)->sacked	 = 0;

lookup:
	sk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,
			       th->dest, &refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		/* We own a reference on the listener, increase it again
		 * as we might lose it too soon.
		 */
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v4_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	if (tcp_v4_inbound_md5_hash(sk, skb))
		goto discard_and_relse;
 
 	nf_reset(skb);
 
	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
	th = (const struct tcphdr *)skb->data;
	iph = ip_hdr(skb);
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v4_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);

	return ret;

no_tcp_socket:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v4_send_reset(NULL, skb);
	}

discard_it:
	/* Discard frame. */
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}
	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN: {
		struct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),
							&tcp_hashinfo, skb,
							__tcp_hdrlen(th),
							iph->saddr, th->source,
							iph->daddr, th->dest,
							inet_iif(skb));
		if (sk2) {
			inet_twsk_deschedule_put(inet_twsk(sk));
			sk = sk2;
			refcounted = false;
			goto process;
		}
		/* Fall through to ACK */
	}
	case TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v4_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:;
	}
	goto discard_it;
}
","The `tcp_v4_rcv` function processes incoming TCP packets in the Linux kernel, handling various states and conditions for TCP connections. It begins by validating the packet type and ensuring the TCP header is correctly formatted. The function then retrieves the corresponding socket for the TCP connection and checks its state, managing scenarios such as SYN reception and TIME_WAIT. It performs checksum validation and applies security policies before either processing the packet or discarding it. The function also manages socket references and updates statistics, ensuring proper handling of TCP segments and maintaining the integrity of the connection state throughout the process.","The code processes incoming TCP packets within a network stack, ensuring they are valid and belong to the correct connection. It begins by checking the packet type and validating the TCP header format. The function retrieves the associated connection and assesses its state, handling various scenarios such as connection establishment and time-wait states. It performs necessary security checks and checksum validations before either processing the packet or discarding it. Throughout the process, it manages connection references and updates relevant statistics, ensuring the integrity and proper handling of TCP segments within the network.","The vulnerability in the original code arises from improper handling of packet truncation, which can lead to a denial of service by allowing local users to craft packets that cause the system to crash. Specifically, the code fails to adequately check the size of the TCP header and the overall packet length before processing, which can result in accessing invalid memory. The fixed code addresses this issue by adding additional checks, such as ensuring the TCP header length is valid and that the packet can be pulled correctly, thereby preventing the processing of malformed packets and enhancing overall stability and security.","The vulnerability in the original code stems from inadequate handling of packet truncation, which could allow local users to craft malicious packets that lead to system crashes, resulting in a denial of service. This occurs when the code processes packets without properly validating their size, potentially accessing invalid memory. The fixed code addresses this issue by implementing additional checks to ensure that the packet and header lengths are valid before processing. These enhancements prevent the acceptance of malformed packets, thereby improving the stability and security of the TCP stack within the kernel.","The vulnerability was fixed by adding critical checks to validate the TCP header and packet lengths before processing. Specifically, the code now verifies that the TCP header length is sufficient using a condition that checks if the header length is less than the expected size. Additionally, it employs the `pskb_may_pull` function to ensure that the packet can be safely accessed without truncation issues. These modifications prevent the processing of malformed packets, thereby safeguarding against potential crashes and enhancing the overall robustness of the TCP stack in the kernel.","The vulnerability was addressed by implementing additional validation checks to ensure that incoming packets are properly formatted and of appropriate length before processing. The code now includes conditions to verify that the TCP header is sufficiently sized and that the packet can be safely accessed without risk of truncation. These enhancements prevent the acceptance of malformed packets, which could lead to memory access violations and system crashes. By enforcing these checks, the code improves the overall stability and security of the TCP stack, mitigating the risk of denial-of-service attacks.","5,5","4, 4","4,4","4,4","CWE-789, CWE-119, CWE-400, CWE-130, CWE-787, CWE-20, CWE-190, CWE-131, CWE-120, CWE-788",N,-1
5,5,5,180185,180185,,Local,Not required,Complete,CVE-2016-6198,https://www.cvedetails.com/cve/CVE-2016-6198/,CWE-284,Low,,,,2016-08-06,4.9,"The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.",2018-01-04,DoS ,5,https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca,9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca,"vfs: rename: check backing inode being equal

If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
should do nothing and return success.

This condition is checked in vfs_rename().  However it won't detect hard
links on overlayfs where these are given separate inodes on the overlayfs
layer.

Overlayfs itself detects this condition and returns success without doing
anything, but then vfs_rename() will proceed as if this was a successful
rename (detach_mounts(), d_move()).

The correct thing to do is to detect this condition before even calling
into overlayfs.  This patch does this by calling vfs_select_inode() to get
the underlying inodes.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Cc: <stable@vger.kernel.org> # v4.2+",1,fs/namei.c,"{""sha"": ""3ef87d673bbea617fdcff88f63127634f1275cee"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca"", ""patch"": ""@@ -4213,7 +4213,11 @@ int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tbool new_is_dir = false;\n \tunsigned max_links = new_dir->i_sb->s_max_links;\n \n-\tif (source == target)\n+\t/*\n+\t * Check source == target.\n+\t * On overlayfs need to look at underlying inodes.\n+\t */\n+\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))\n \t\treturn 0;\n \n \terror = may_delete(old_dir, old_dentry, is_dir);""}","int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
	/*
	 * Check source == target.
	 * On overlayfs need to look at underlying inodes.
	 */
	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
		return -EPERM;

	if (flags && !old_dir->i_op->rename2)
		return -EINVAL;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	if (!old_dir->i_op->rename2) {
		error = old_dir->i_op->rename(old_dir, old_dentry,
					      new_dir, new_dentry);
	} else {
		WARN_ON(old_dir->i_op->rename != NULL);
		error = old_dir->i_op->rename2(old_dir, old_dentry,
					       new_dir, new_dentry, flags);
	}
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
","int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
	if (source == target)
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
		return -EPERM;

	if (flags && !old_dir->i_op->rename2)
		return -EINVAL;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	if (!old_dir->i_op->rename2) {
		error = old_dir->i_op->rename(old_dir, old_dentry,
					      new_dir, new_dentry);
	} else {
		WARN_ON(old_dir->i_op->rename != NULL);
		error = old_dir->i_op->rename2(old_dir, old_dentry,
					       new_dir, new_dentry, flags);
	}
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
",C,"	/*
	 * Check source == target.
	 * On overlayfs need to look at underlying inodes.
	 */
	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
","	if (source == target)
",,"@@ -4213,7 +4213,11 @@ int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
-	if (source == target)
+	/*
+	 * Check source == target.
+	 * On overlayfs need to look at underlying inodes.
+	 */
+	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);",linux,9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca,54d5ca871e72f2bb172ec9323497f01cd5091ec7,1,"int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
//flaw_line_below:
	if (source == target)
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Check source == target.
//fix_flaw_line_below:
//	 * On overlayfs need to look at underlying inodes.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
		return -EPERM;

	if (flags && !old_dir->i_op->rename2)
		return -EINVAL;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	if (!old_dir->i_op->rename2) {
		error = old_dir->i_op->rename(old_dir, old_dentry,
					      new_dir, new_dentry);
	} else {
		WARN_ON(old_dir->i_op->rename != NULL);
		error = old_dir->i_op->rename2(old_dir, old_dentry,
					       new_dir, new_dentry, flags);
	}
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
",180185,"int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
	if (source == target)
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
		return -EPERM;

	if (flags && !old_dir->i_op->rename2)
		return -EINVAL;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	if (!old_dir->i_op->rename2) {
		error = old_dir->i_op->rename(old_dir, old_dentry,
					      new_dir, new_dentry);
	} else {
		WARN_ON(old_dir->i_op->rename != NULL);
		error = old_dir->i_op->rename2(old_dir, old_dentry,
					       new_dir, new_dentry, flags);
	}
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
","int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
	/*
	 * Check source == target.
	 * On overlayfs need to look at underlying inodes.
	 */
	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
		return -EPERM;

	if (flags && !old_dir->i_op->rename2)
		return -EINVAL;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	if (!old_dir->i_op->rename2) {
		error = old_dir->i_op->rename(old_dir, old_dentry,
					      new_dir, new_dentry);
	} else {
		WARN_ON(old_dir->i_op->rename != NULL);
		error = old_dir->i_op->rename2(old_dir, old_dentry,
					       new_dir, new_dentry, flags);
	}
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
","The `vfs_rename` function implements the renaming of files or directories within a virtual file system. It checks permissions for deletion and creation, handles potential name conflicts, and ensures that the source and target inodes are valid. The function supports both standard renaming and exchange operations, managing directory link limits and security checks. It locks the involved inodes to prevent concurrent modifications, performs the rename operation through the appropriate inode operations, and updates the directory entries accordingly. Finally, it notifies the file system of the changes and cleans up resources, returning any error encountered during the process.","The provided code implements a function that facilitates the renaming of files or directories within a virtual file system. It performs checks for permissions related to deletion and creation, ensuring that the source and target locations are valid and do not conflict. The function supports both standard renaming and exchange operations while managing directory link limits and enforcing security protocols. It locks the relevant resources to prevent concurrent modifications, executes the rename operation, updates directory entries, and notifies the system of the changes, returning any errors encountered during the process.","The vulnerability in the original code arises from the lack of a check to prevent renaming an OverlayFS file to a self-hardlink, which could lead to a denial of service by causing a system crash. This occurs because the code does not adequately verify if the source and target inodes are the same before proceeding with the rename operation. In the fixed code, this issue is addressed by introducing a check that compares the underlying inodes of the source and target. If they are the same, the function returns early, effectively preventing the problematic rename operation and enhancing system stability.","The vulnerability in the original code allows for the renaming of an OverlayFS file to a self-hardlink, which can lead to a system crash and denial of service. This occurs because the code does not check if the source and target inodes are the same before executing subsequent operations, potentially creating an unstable state. The fixed code addresses this issue by implementing a check that compares the underlying inodes of the source and target. If they are found to be identical, the function exits early, thereby preventing the unsafe rename operation and enhancing system reliability.","The vulnerability was fixed by adding a check that compares the underlying inodes of the source and target using the `vfs_select_inode` function. This check is performed at the beginning of the function, and if the two inodes are found to be the same, the function returns early, preventing any further operations that could lead to a self-hardlink scenario. This modification ensures that the code does not proceed with post-rename operations when the source and target are identical, thereby mitigating the risk of a system crash and enhancing overall stability in the filesystem layer.","The vulnerability was fixed by introducing a check at the beginning of the function to compare the underlying inodes of the source and target. This check ensures that if the source and target refer to the same inode, the function exits early without proceeding with any further operations. By preventing the execution of subsequent rename actions when a self-hardlink situation is detected, the fix effectively mitigates the risk of system crashes and enhances the stability of the filesystem layer, ensuring that unsafe rename operations cannot occur.","4,4","4, 4","4,4","4,4","CWE-706, CWE-674, CWE-672, CWE-675, CWE-664, CWE-666, CWE-667, CWE-668, CWE-669, CWE-404",N,-1
6,6,6,180338,180338,,Remote,Not required,,CVE-2016-5104,https://www.cvedetails.com/cve/CVE-2016-5104/,CWE-284,Low,,Partial,,2016-06-13,5.0,The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.,2018-10-30,Bypass ,1,https://github.com/libimobiledevice/libimobiledevice/commit/df1f5c4d70d0c19ad40072f5246ca457e7f9849e,df1f5c4d70d0c19ad40072f5246ca457e7f9849e,common: [security fix] Make sure sockets only listen locally,1,common/socket.c,"{""sha"": ""e2968a64a8c8366ffda3a0f955096685ad3d60ba"", ""filename"": ""common/socket.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/libimobiledevice/libimobiledevice/blob/df1f5c4d70d0c19ad40072f5246ca457e7f9849e/common/socket.c"", ""raw_url"": ""https://github.com/libimobiledevice/libimobiledevice/raw/df1f5c4d70d0c19ad40072f5246ca457e7f9849e/common/socket.c"", ""contents_url"": ""https://api.github.com/repos/libimobiledevice/libimobiledevice/contents/common/socket.c?ref=df1f5c4d70d0c19ad40072f5246ca457e7f9849e"", ""patch"": ""@@ -172,7 +172,7 @@ int socket_create(uint16_t port)\n \n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n-\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \tsaddr.sin_port = htons(port);\n \n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n@@ -329,7 +329,7 @@ int socket_accept(int fd, uint16_t port)\n \n \tmemset(&addr, 0, sizeof(addr));\n \taddr.sin_family = AF_INET;\n-\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \taddr.sin_port = htons(port);\n \n \taddr_len = sizeof(addr);""}","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",C,"	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
","	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
",,"@@ -172,7 +172,7 @@ int socket_create(uint16_t port)
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
-	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
@@ -329,7 +329,7 @@ int socket_accept(int fd, uint16_t port)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	addr.sin_port = htons(port);
 
 	addr_len = sizeof(addr);",libimobiledevice,df1f5c4d70d0c19ad40072f5246ca457e7f9849e,decffad5f5a0320b1b6e9e8cda821534ba2ed0ca,1,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
//flaw_line_below:
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
//fix_flaw_line_below:
//	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",180338,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","The `socket_create` function initializes a TCP socket for server use on a specified port. It first checks for Windows-specific initialization of the Winsock library if the platform is Windows. The function then creates a socket using the IPv4 address family and TCP protocol. It sets the socket option to allow address reuse, ensuring that the socket can bind to the port even if it is in a TIME_WAIT state. After preparing the socket address structure, it binds the socket to all available interfaces and the specified port, and finally, it listens for incoming connections, returning the socket file descriptor or -1 on failure.","The provided code defines a function that creates and configures a TCP socket for server operations on a specified port. It begins by checking if the environment requires specific initialization for network communication. The function then creates a socket using the appropriate protocol and sets an option to allow the reuse of the socket address. After preparing the necessary address structure, it binds the socket to all available network interfaces and the designated port. Finally, the function sets the socket to listen for incoming connections, returning a descriptor for the socket or indicating failure if any step encounters an error.","The vulnerability in the original code arises from binding the socket to all available network interfaces, allowing remote attackers to connect and bypass intended access restrictions. This is indicated by the use of `saddr.sin_addr.s_addr = htonl(INADDR_ANY)`, which permits connections from any IP address. The fixed code mitigates this risk by changing the binding to `saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK)`, restricting access to only local connections. This adjustment effectively prevents unauthorized remote access, ensuring that only processes on the same machine can communicate with the service, thereby addressing the vulnerability.","The vulnerability in the original code allows remote attackers to bypass access restrictions by binding a socket to all available network interfaces, enabling unauthorized external connections to services on iOS devices. This exposure creates a significant security risk, as it permits any remote entity to communicate with the service. The fixed code addresses this issue by restricting the socket binding to the loopback interface, which limits access solely to local processes. This change effectively prevents remote connections, thereby securing the service against unauthorized access and ensuring that only trusted local applications can interact with it.","The vulnerability was fixed by changing the socket binding from `saddr.sin_addr.s_addr = htonl(INADDR_ANY)` to `saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK)`. This modification restricts the socket to listen only for connections originating from the local machine, effectively preventing remote attackers from establishing unauthorized communication with the service. By binding the socket to the loopback address, the code ensures that only local processes can connect, thereby closing the security gap that allowed external access. This change significantly enhances the security posture of the application by enforcing intended access restrictions.","The vulnerability was fixed by modifying the socket binding to restrict access to only local connections instead of allowing connections from any network interface. This change ensures that the service can only be accessed by processes running on the same machine, effectively preventing remote attackers from bypassing access restrictions. By limiting the scope of the socket's accessibility, the updated code enhances security and protects the service from unauthorized external communication, thereby addressing the original risk of exposing sensitive services to potential exploitation by remote entities.","5,5","5,5","5,5","5,5","CWE-284,CWE-668,CWE-749,CWE-669,CWE-732,CWE-552,CWE-605,CWE-287,CWE-306,CWE-16",Y,1
7,7,7,180517,180517,,Local,Not required,Complete,CVE-2016-3713,https://www.cvedetails.com/cve/CVE-2016-3713/,CWE-284,Low,Partial,,,2016-06-27,5.6,"The msr_mtrr_valid function in arch/x86/kvm/mtrr.c in the Linux kernel before 4.6.1 supports MSR 0x2f8, which allows guest OS users to read or write to the kvm_arch_vcpu data structure, and consequently obtain sensitive information or cause a denial of service (system crash), via a crafted ioctl call.",2016-06-27,DoS +Info ,0,https://github.com/torvalds/linux/commit/9842df62004f366b9fed2423e24df10542ee0dc5,9842df62004f366b9fed2423e24df10542ee0dc5,"KVM: MTRR: remove MSR 0x2f8

MSR 0x2f8 accessed the 124th Variable Range MTRR ever since MTRR support
was introduced by 9ba075a664df (""KVM: MTRR support"").

0x2f8 became harmful when 910a6aae4e2e (""KVM: MTRR: exactly define the
size of variable MTRRs"") shrinked the array of VR MTRRs from 256 to 8,
which made access to index 124 out of bounds.  The surrounding code only
WARNs in this situation, thus the guest gained a limited read/write
access to struct kvm_arch_vcpu.

0x2f8 is not a valid VR MTRR MSR, because KVM has/advertises only 16 VR
MTRR MSRs, 0x200-0x20f.  Every VR MTRR is set up using two MSRs, 0x2f8
was treated as a PHYSBASE and 0x2f9 would be its PHYSMASK, but 0x2f9 was
not implemented in KVM, therefore 0x2f8 could never do anything useful
and getting rid of it is safe.

This fixes CVE-2016-3713.

Fixes: 910a6aae4e2e (""KVM: MTRR: exactly define the size of variable MTRRs"")
Cc: stable@vger.kernel.org
Reported-by: David Matlack <dmatlack@google.com>
Signed-off-by: Andy Honig <ahonig@google.com>
Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",2,arch/x86/kvm/mtrr.c,"{""sha"": ""c146f3c262c3bdd43f83e736688147559a8e9a4f"", ""filename"": ""arch/x86/kvm/mtrr.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9842df62004f366b9fed2423e24df10542ee0dc5/arch/x86/kvm/mtrr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9842df62004f366b9fed2423e24df10542ee0dc5/arch/x86/kvm/mtrr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kvm/mtrr.c?ref=9842df62004f366b9fed2423e24df10542ee0dc5"", ""patch"": ""@@ -44,8 +44,6 @@ static bool msr_mtrr_valid(unsigned msr)\n \tcase MSR_MTRRdefType:\n \tcase MSR_IA32_CR_PAT:\n \t\treturn true;\n-\tcase 0x2f8:\n-\t\treturn true;\n \t}\n \treturn false;\n }""}","static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
 	}
 	return false;
 }
","static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
	case 0x2f8:
		return true;
 	}
 	return false;
 }
",C,,"	case 0x2f8:
		return true;
",,"@@ -44,8 +44,6 @@ static bool msr_mtrr_valid(unsigned msr)
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
-	case 0x2f8:
-		return true;
 	}
 	return false;
 }",linux,9842df62004f366b9fed2423e24df10542ee0dc5,67c9dddc95ac16a09db996e8e4dcacfd94cf2306,1,"static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
//flaw_line_below:
	case 0x2f8:
//flaw_line_below:
		return true;
 	}
 	return false;
 }
",180517,"static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
	case 0x2f8:
		return true;
 	}
 	return false;
 }
","static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
 	}
 	return false;
 }
","The function `msr_mtrr_valid` checks the validity of a given Model-Specific Register (MSR) by evaluating its value against a predefined set of valid MSR constants and ranges. It uses a switch statement to determine if the input `msr` falls within specific ranges or matches certain fixed MSR values related to Memory Type Range Registers (MTRRs). If the `msr` is valid, the function returns `true`; otherwise, it returns `false`. This functionality is crucial for ensuring that only appropriate MSR values are processed, thereby maintaining system stability and integrity in memory management operations.","The provided code defines a function that determines whether a specific register value is valid based on a set of predefined criteria. It checks if the input value falls within certain numerical ranges or matches specific constants associated with memory management. The function utilizes a conditional structure to evaluate these criteria, returning a positive indication for valid values and a negative one for invalid entries. This validation process is essential for ensuring that only appropriate register values are utilized, thereby supporting the stability and reliability of memory operations within the system.","The vulnerability in the original code stemmed from the inclusion of the MSR value `0x2f8` as a valid input, which allowed unauthorized access to sensitive data within the `kvm_arch_vcpu` structure. This oversight enabled guest operating systems to exploit the function through crafted ioctl calls, potentially leading to information disclosure or system crashes. In the fixed code, the validation logic was likely modified to exclude this specific MSR value or to implement stricter checks, thereby preventing unauthorized access and ensuring that only legitimate, safe MSR values are processed, thus mitigating the risk of exploitation.","The vulnerability in the original code allowed unauthorized access to sensitive data by permitting a specific register value, which enabled guest operating systems to manipulate internal structures through crafted calls. This oversight posed a significant risk, as it could lead to information disclosure or system crashes. The fix involved revising the validation logic to exclude the problematic register value, thereby preventing any unauthorized read or write operations. This change ensured that only safe and legitimate register values were accepted, effectively mitigating the risk of exploitation and enhancing the overall security of the system.","The vulnerability was fixed by modifying the validation logic within the `msr_mtrr_valid` function to exclude the specific register value `0x2f8`, which was previously allowed. By ensuring that this value is no longer considered valid, the function prevents unauthorized access to the `kvm_arch_vcpu` data structure. The revised code maintains a strict check against a defined set of valid register values, thereby eliminating the potential for guest operating systems to exploit the function through crafted ioctl calls. This change effectively mitigates the risk of information disclosure and system crashes associated with the vulnerability.","The vulnerability was addressed by revising the validation criteria to exclude a specific register value that previously allowed unauthorized access to sensitive internal structures. This change involved implementing stricter checks to ensure that only safe and legitimate register values are accepted. By removing the problematic value from the list of valid inputs, the fix effectively prevents potential exploitation through crafted calls, thereby safeguarding against information disclosure and system crashes. This enhancement strengthens the overall security of the system by ensuring that only appropriate operations can be performed on critical data structures.","3,4","1,5","3,4","3, 4","CWE-269, CWE-284, CWE-20, CWE-754, CWE-200, CWE-129, CWE-287, CWE-732, CWE-665, CWE-119",N,-1
8,8,8,180619,180619,,Local,Not required,,CVE-2016-1237,https://www.cvedetails.com/cve/CVE-2016-1237/,CWE-284,Low,Complete,,,2016-06-29,4.9,"nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",2016-11-28,Bypass ,10,https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4,999653786df6954a31044528ac3f7a5dadca08f4,"nfsd: check permissions when setting ACLs

Use set_posix_acl, which includes proper permission checks, instead of
calling ->set_acl directly.  Without this anyone may be able to grant
themselves permissions to a file by setting the ACL.

Lock the inode to make the new checks atomic with respect to set_acl.
(Also, nfsd was the only caller of set_acl not locking the inode, so I
suspect this may fix other races.)

This also simplifies the code, and ensures our ACLs are checked by
posix_acl_valid.

The permission checks and the inode locking were lost with commit
4ac7249e, which changed nfsd to use the set_acl inode operation directly
instead of going through xattr handlers.

Reported-by: David Sinquin <david@sinquin.eu>
[agreunba@redhat.com: use set_posix_acl]
Fixes: 4ac7249e
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",10,fs/nfsd/nfs2acl.c,"{""sha"": ""d08cd88155c75278c4607f49c078622bf87ab5ee"", ""filename"": ""fs/nfsd/nfs2acl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs2acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""0c890347cde3d9559b0b0103c2c2c11825d51fae"", ""filename"": ""fs/nfsd/nfs3acl.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 9, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs3acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -95,22 +95,20 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""71292a0d6f09226e828b327ba139a296dc76a08b"", ""filename"": ""fs/nfsd/nfs4acl.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs4acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -770,9 +770,6 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n-\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n-\t\treturn nfserr_attrnotsupp;\n-\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n@@ -782,16 +779,19 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n-\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n+\tfh_lock(fhp);\n+\n+\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n \tif (host_error < 0)\n-\t\tgoto out_release;\n+\t\tgoto out_drop_lock;\n \n \tif (S_ISDIR(inode->i_mode)) {\n-\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n-\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n+\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n \t}\n \n-out_release:\n+out_drop_lock:\n+\tfh_unlock(fhp);\n+\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:""}","static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 	if (error)
		goto out_drop_lock;

	fh_unlock(fh);
 
 	fh_drop_write(fh);
 
	nfserr = fh_getattr(fh, &resp->stat);

out:
	/* argp->acl_{access,default} may have been allocated in
	   nfssvc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
out_drop_lock:
	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
	goto out;
}
","static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 	if (error)
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
 	if (error)
		goto out_drop_write;
 
 	fh_drop_write(fh);
 
	nfserr = fh_getattr(fh, &resp->stat);

out:
	/* argp->acl_{access,default} may have been allocated in
	   nfssvc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
out_drop_write:
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
	goto out;
}
",C,"	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
		goto out_drop_lock;

	fh_unlock(fh);
out_drop_lock:
	fh_unlock(fh);
","	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
		goto out_drop_write;
out_drop_write:
",,"@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
-	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
-		error = -EOPNOTSUPP;
-		goto out_errno;
-	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
-	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
+	fh_lock(fh);
+
+	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
-		goto out_drop_write;
-	error = inode->i_op->set_acl(inode, argp->acl_default,
-				     ACL_TYPE_DEFAULT);
+		goto out_drop_lock;
+	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 	if (error)
-		goto out_drop_write;
+		goto out_drop_lock;
+
+	fh_unlock(fh);
 
 	fh_drop_write(fh);
 
@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
-out_drop_write:
+out_drop_lock:
+	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);",linux,999653786df6954a31044528ac3f7a5dadca08f4,485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f,1,"static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
//flaw_line_below:
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
//flaw_line_below:
		error = -EOPNOTSUPP;
//flaw_line_below:
		goto out_errno;
//flaw_line_below:
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
//flaw_line_below:
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
//fix_flaw_line_below:
//	fh_lock(fh);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
//flaw_line_below:
		goto out_drop_write;
//flaw_line_below:
	error = inode->i_op->set_acl(inode, argp->acl_default,
//flaw_line_below:
				     ACL_TYPE_DEFAULT);
//fix_flaw_line_below:
//		goto out_drop_lock;
//fix_flaw_line_below:
//	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 	if (error)
//flaw_line_below:
		goto out_drop_write;
//fix_flaw_line_below:
//		goto out_drop_lock;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	fh_unlock(fh);
 
 	fh_drop_write(fh);
 
	nfserr = fh_getattr(fh, &resp->stat);

out:
	/* argp->acl_{access,default} may have been allocated in
	   nfssvc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
//flaw_line_below:
out_drop_write:
//fix_flaw_line_below:
//out_drop_lock:
//fix_flaw_line_below:
//	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
	goto out;
}
",180619,"static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 	if (error)
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
 	if (error)
		goto out_drop_write;
 
 	fh_drop_write(fh);
 
	nfserr = fh_getattr(fh, &resp->stat);

out:
	/* argp->acl_{access,default} may have been allocated in
	   nfssvc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
out_drop_write:
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
	goto out;
}
","static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 	if (error)
		goto out_drop_lock;

	fh_unlock(fh);
 
 	fh_drop_write(fh);
 
	nfserr = fh_getattr(fh, &resp->stat);

out:
	/* argp->acl_{access,default} may have been allocated in
	   nfssvc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
out_drop_lock:
	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
	goto out;
}
","The `nfsacld_proc_setacl` function handles the setting of Access Control Lists (ACLs) for a specified file in an NFS (Network File System) environment. It begins by verifying the file handle and checking if the inode supports POSIX ACLs. If supported, it attempts to acquire a write lock on the file handle before setting the access and default ACLs using the inode's operations. If any errors occur during these operations, appropriate cleanup is performed, including releasing any allocated ACLs. Finally, it retrieves the updated file attributes and returns the result of the operation, indicating success or failure.","The function is responsible for setting Access Control Lists (ACLs) for a specified file in a network file system. It begins by verifying the file handle and checking if the file supports the required ACL features. If supported, it attempts to acquire a write lock on the file before applying the specified access and default ACLs. In case of any errors during these operations, it ensures proper cleanup of resources. Finally, it retrieves the updated attributes of the file and returns a status indicating whether the operation was successful or if an error occurred.","The vulnerability in the original code allowed local users to bypass file-permission restrictions by improperly setting POSIX ACLs without adequate checks. Specifically, the lack of a proper locking mechanism and the absence of a dedicated function for setting ACLs led to potential unauthorized modifications. In the fixed code, the introduction of a locking mechanism with `fh_lock(fh)` and `fh_unlock(fh)` ensures that the file handle is properly managed during ACL modifications. Additionally, the use of a dedicated function `set_posix_acl` for setting ACLs enhances security by encapsulating the logic and ensuring that necessary checks are performed, thus mitigating the vulnerability.","The vulnerability allowed local users to bypass intended file-permission restrictions by improperly setting POSIX ACLs, which could lead to unauthorized access to files. This was primarily due to insufficient locking mechanisms and a lack of proper checks during the ACL modification process. The fixed code addressed this issue by implementing a robust locking mechanism to ensure that file handles are managed correctly during ACL changes. Additionally, the introduction of a dedicated function for setting ACLs improved the security by encapsulating the necessary checks, thereby preventing unauthorized modifications and reinforcing the integrity of file permissions.","The vulnerability was fixed by implementing a proper locking mechanism and using a dedicated function for setting ACLs. The addition of `fh_lock(fh)` before modifying the ACLs ensures that the file handle is securely managed, preventing concurrent access issues. The use of `set_posix_acl` for applying both access and default ACLs encapsulates the logic for setting permissions, ensuring that necessary checks are performed during the process. This combination of locking and encapsulation effectively mitigates the risk of unauthorized modifications, thereby reinforcing the intended file-permission restrictions.","The vulnerability was fixed by introducing a robust locking mechanism to ensure that file handles are properly managed during the modification of Access Control Lists (ACLs). This prevents concurrent access issues that could lead to unauthorized changes. Additionally, a dedicated function was implemented for setting ACLs, which encapsulates the necessary checks and logic required for secure permission modifications. This combination of enhanced locking and the use of a specialized function effectively mitigates the risk of bypassing intended file-permission restrictions, thereby reinforcing the integrity of the file system's security model.","5,4","4, 4","4,4","5, 4","CWE-362,CWE-667,CWE-764,CWE-732,CWE-281,CWE-269,CWE-273,CWE-280,CWE-279,CWE-642",N,-1
9,9,9,180620,180620,,Local,Not required,,CVE-2016-1237,https://www.cvedetails.com/cve/CVE-2016-1237/,CWE-284,Low,Complete,,,2016-06-29,4.9,"nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",2016-11-28,Bypass ,7,https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4,999653786df6954a31044528ac3f7a5dadca08f4,"nfsd: check permissions when setting ACLs

Use set_posix_acl, which includes proper permission checks, instead of
calling ->set_acl directly.  Without this anyone may be able to grant
themselves permissions to a file by setting the ACL.

Lock the inode to make the new checks atomic with respect to set_acl.
(Also, nfsd was the only caller of set_acl not locking the inode, so I
suspect this may fix other races.)

This also simplifies the code, and ensures our ACLs are checked by
posix_acl_valid.

The permission checks and the inode locking were lost with commit
4ac7249e, which changed nfsd to use the set_acl inode operation directly
instead of going through xattr handlers.

Reported-by: David Sinquin <david@sinquin.eu>
[agreunba@redhat.com: use set_posix_acl]
Fixes: 4ac7249e
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",9,fs/nfsd/nfs3acl.c,"{""sha"": ""d08cd88155c75278c4607f49c078622bf87ab5ee"", ""filename"": ""fs/nfsd/nfs2acl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs2acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""0c890347cde3d9559b0b0103c2c2c11825d51fae"", ""filename"": ""fs/nfsd/nfs3acl.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 9, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs3acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -95,22 +95,20 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""71292a0d6f09226e828b327ba139a296dc76a08b"", ""filename"": ""fs/nfsd/nfs4acl.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs4acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -770,9 +770,6 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n-\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n-\t\treturn nfserr_attrnotsupp;\n-\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n@@ -782,16 +779,19 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n-\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n+\tfh_lock(fhp);\n+\n+\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n \tif (host_error < 0)\n-\t\tgoto out_release;\n+\t\tgoto out_drop_lock;\n \n \tif (S_ISDIR(inode->i_mode)) {\n-\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n-\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n+\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n \t}\n \n-out_release:\n+out_drop_lock:\n+\tfh_unlock(fhp);\n+\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:""}","static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd3_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 
out_drop_lock:
	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
out:
	/* argp->acl_{access,default} may have been allocated in
	   nfs3svc_decode_setaclargs. */
	posix_acl_release(argp->acl_access);
	posix_acl_release(argp->acl_default);
	RETURN_STATUS(nfserr);
}
","static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd3_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 	if (error)
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
 
out_drop_write:
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
out:
	/* argp->acl_{access,default} may have been allocated in
	   nfs3svc_decode_setaclargs. */
	posix_acl_release(argp->acl_access);
	posix_acl_release(argp->acl_default);
	RETURN_STATUS(nfserr);
}
",C,"	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
out_drop_lock:
	fh_unlock(fh);
","	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
out_drop_write:
",,"@@ -95,22 +95,20 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
-	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
-		error = -EOPNOTSUPP;
-		goto out_errno;
-	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
-	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
+	fh_lock(fh);
+
+	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
-		goto out_drop_write;
-	error = inode->i_op->set_acl(inode, argp->acl_default,
-				     ACL_TYPE_DEFAULT);
+		goto out_drop_lock;
+	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 
-out_drop_write:
+out_drop_lock:
+	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);",linux,999653786df6954a31044528ac3f7a5dadca08f4,485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f,1,"static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd3_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
//flaw_line_below:
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
//flaw_line_below:
		error = -EOPNOTSUPP;
//flaw_line_below:
		goto out_errno;
//flaw_line_below:
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
//flaw_line_below:
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
//fix_flaw_line_below:
//	fh_lock(fh);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
//flaw_line_below:
		goto out_drop_write;
//flaw_line_below:
	error = inode->i_op->set_acl(inode, argp->acl_default,
//flaw_line_below:
				     ACL_TYPE_DEFAULT);
//fix_flaw_line_below:
//		goto out_drop_lock;
//fix_flaw_line_below:
//	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 
//flaw_line_below:
out_drop_write:
//fix_flaw_line_below:
//out_drop_lock:
//fix_flaw_line_below:
//	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
out:
	/* argp->acl_{access,default} may have been allocated in
	   nfs3svc_decode_setaclargs. */
	posix_acl_release(argp->acl_access);
	posix_acl_release(argp->acl_default);
	RETURN_STATUS(nfserr);
}
",180620,"static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd3_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 	if (error)
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
 
out_drop_write:
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
out:
	/* argp->acl_{access,default} may have been allocated in
	   nfs3svc_decode_setaclargs. */
	posix_acl_release(argp->acl_access);
	posix_acl_release(argp->acl_default);
	RETURN_STATUS(nfserr);
}
","static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,
		struct nfsd3_setaclargs *argp,
		struct nfsd3_attrstat *resp)
{
	struct inode *inode;
	svc_fh *fh;
	__be32 nfserr = 0;
	int error;

	fh = fh_copy(&resp->fh, &argp->fh);
	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
	if (nfserr)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 
out_drop_lock:
	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);
out:
	/* argp->acl_{access,default} may have been allocated in
	   nfs3svc_decode_setaclargs. */
	posix_acl_release(argp->acl_access);
	posix_acl_release(argp->acl_default);
	RETURN_STATUS(nfserr);
}
","The `nfsd3_proc_setacl` function handles the setting of Access Control Lists (ACLs) for a specified file in an NFS (Network File System) server context. It begins by verifying the file handle and checking if the inode supports POSIX ACLs. If supported, it attempts to acquire a write lock on the file handle and then sets the access and default ACLs using the inode's operations. If any errors occur during these processes, appropriate error handling is performed, including releasing any allocated ACLs. Finally, the function returns the status of the operation, indicating success or the type of error encountered.","The function processes a request to set Access Control Lists (ACLs) for a file in a network file system. It begins by verifying the validity of the file handle and checks if the file supports the required ACL functionality. If the file is compatible, it attempts to acquire a write lock before proceeding to set both the access and default ACLs. Throughout the process, it handles potential errors, ensuring that any allocated resources are properly released. Ultimately, the function returns a status indicating whether the operation was successful or if an error occurred during execution.","The vulnerability in the original code allowed local users to bypass file permission restrictions by improperly setting POSIX ACLs without adequate checks. Specifically, the lack of a locking mechanism before modifying the ACLs could lead to race conditions, enabling unauthorized access. In the fixed code, a locking mechanism was introduced with `fh_lock(fh)` before setting the ACLs, ensuring that the file handle is properly locked during the operation. This change prevents concurrent modifications and enforces the necessary permission checks, thereby mitigating the risk of unauthorized access and ensuring that ACL modifications are performed securely.","The vulnerability allowed local users to bypass intended file-permission restrictions by improperly setting Access Control Lists (ACLs), which could lead to unauthorized access to files. This issue arose from the lack of proper synchronization mechanisms during the ACL modification process, making it susceptible to race conditions. In the revised code, a locking mechanism was introduced before modifying the ACLs, ensuring that the operation is performed in a controlled manner. This change effectively prevents concurrent access and modifications, thereby enforcing the necessary permission checks and securing the ACL setting process against unauthorized alterations.","The vulnerability was fixed by introducing a locking mechanism around the ACL modification process. In the revised code, the function now calls `fh_lock(fh)` before setting the ACLs, ensuring that the file handle is locked during the operation. This prevents concurrent modifications that could lead to unauthorized access. Additionally, the code now uses `set_posix_acl` for setting both the access and default ACLs, which ensures that the necessary permission checks are enforced. After the ACL modifications, the lock is released with `fh_unlock(fh)`, followed by `fh_drop_write(fh)`, ensuring proper resource management and security.","The vulnerability was addressed by implementing a locking mechanism to ensure that the modification of Access Control Lists occurs in a controlled manner. By introducing a lock before the ACL changes, the code prevents concurrent access that could lead to unauthorized alterations. This change ensures that the necessary permission checks are enforced during the ACL setting process, thereby mitigating the risk of bypassing file-permission restrictions. Additionally, the code now properly manages resources by releasing the lock after the modifications, ensuring that the system remains secure and that access controls are respected.","4, 5","5,5","4,4","4, 5","CWE-362,CWE-732,CWE-642,CWE-412,CWE-667,CWE-764,CWE-637,CWE-441,CWE-693,CWE-648",N,-1
10,10,10,180621,180621,,Local,Not required,,CVE-2016-1237,https://www.cvedetails.com/cve/CVE-2016-1237/,CWE-284,Low,Complete,,,2016-06-29,4.9,"nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",2016-11-28,Bypass ,8,https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4,999653786df6954a31044528ac3f7a5dadca08f4,"nfsd: check permissions when setting ACLs

Use set_posix_acl, which includes proper permission checks, instead of
calling ->set_acl directly.  Without this anyone may be able to grant
themselves permissions to a file by setting the ACL.

Lock the inode to make the new checks atomic with respect to set_acl.
(Also, nfsd was the only caller of set_acl not locking the inode, so I
suspect this may fix other races.)

This also simplifies the code, and ensures our ACLs are checked by
posix_acl_valid.

The permission checks and the inode locking were lost with commit
4ac7249e, which changed nfsd to use the set_acl inode operation directly
instead of going through xattr handlers.

Reported-by: David Sinquin <david@sinquin.eu>
[agreunba@redhat.com: use set_posix_acl]
Fixes: 4ac7249e
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",7,fs/nfsd/nfs4acl.c,"{""sha"": ""d08cd88155c75278c4607f49c078622bf87ab5ee"", ""filename"": ""fs/nfsd/nfs2acl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs2acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs2acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""0c890347cde3d9559b0b0103c2c2c11825d51fae"", ""filename"": ""fs/nfsd/nfs3acl.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 9, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs3acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs3acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -95,22 +95,20 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);""}<_**next**_>{""sha"": ""71292a0d6f09226e828b327ba139a296dc76a08b"", ""filename"": ""fs/nfsd/nfs4acl.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/999653786df6954a31044528ac3f7a5dadca08f4/fs/nfsd/nfs4acl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfsd/nfs4acl.c?ref=999653786df6954a31044528ac3f7a5dadca08f4"", ""patch"": ""@@ -770,9 +770,6 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n-\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n-\t\treturn nfserr_attrnotsupp;\n-\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n@@ -782,16 +779,19 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n-\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n+\tfh_lock(fhp);\n+\n+\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n \tif (host_error < 0)\n-\t\tgoto out_release;\n+\t\tgoto out_drop_lock;\n \n \tif (S_ISDIR(inode->i_mode)) {\n-\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n-\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n+\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n \t}\n \n-out_release:\n+out_drop_lock:\n+\tfh_unlock(fhp);\n+\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:""}","nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
		struct nfs4_acl *acl)
{
	__be32 error;
	int host_error;
	struct dentry *dentry;
	struct inode *inode;
	struct posix_acl *pacl = NULL, *dpacl = NULL;
	unsigned int flags = 0;

	/* Get inode */
	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
	if (error)
		return error;

 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
	if (host_error == -EINVAL)
		return nfserr_attrnotsupp;
 	if (host_error < 0)
 		goto out_nfserr;
 
	fh_lock(fhp);

	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
 	if (host_error < 0)
		goto out_drop_lock;
 
 	if (S_ISDIR(inode->i_mode)) {
		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
 	}
 
out_drop_lock:
	fh_unlock(fhp);

 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
	if (host_error == -EOPNOTSUPP)
		return nfserr_attrnotsupp;
	else
		return nfserrno(host_error);
}
","nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
		struct nfs4_acl *acl)
{
	__be32 error;
	int host_error;
	struct dentry *dentry;
	struct inode *inode;
	struct posix_acl *pacl = NULL, *dpacl = NULL;
	unsigned int flags = 0;

	/* Get inode */
	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
	if (error)
		return error;

 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
		return nfserr_attrnotsupp;
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
	if (host_error == -EINVAL)
		return nfserr_attrnotsupp;
 	if (host_error < 0)
 		goto out_nfserr;
 
	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
 	if (host_error < 0)
		goto out_release;
 
 	if (S_ISDIR(inode->i_mode)) {
		host_error = inode->i_op->set_acl(inode, dpacl,
						  ACL_TYPE_DEFAULT);
 	}
 
out_release:
 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
	if (host_error == -EOPNOTSUPP)
		return nfserr_attrnotsupp;
	else
		return nfserrno(host_error);
}
",C,"	fh_lock(fhp);

	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
		goto out_drop_lock;
		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
out_drop_lock:
	fh_unlock(fhp);

","	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
		return nfserr_attrnotsupp;
	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
		goto out_release;
		host_error = inode->i_op->set_acl(inode, dpacl,
						  ACL_TYPE_DEFAULT);
out_release:
",,"@@ -770,9 +770,6 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
-	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
-		return nfserr_attrnotsupp;
-
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
@@ -782,16 +779,19 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
 	if (host_error < 0)
 		goto out_nfserr;
 
-	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
+	fh_lock(fhp);
+
+	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
 	if (host_error < 0)
-		goto out_release;
+		goto out_drop_lock;
 
 	if (S_ISDIR(inode->i_mode)) {
-		host_error = inode->i_op->set_acl(inode, dpacl,
-						  ACL_TYPE_DEFAULT);
+		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
 	}
 
-out_release:
+out_drop_lock:
+	fh_unlock(fhp);
+
 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:",linux,999653786df6954a31044528ac3f7a5dadca08f4,485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f,1,"nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
		struct nfs4_acl *acl)
{
	__be32 error;
	int host_error;
	struct dentry *dentry;
	struct inode *inode;
	struct posix_acl *pacl = NULL, *dpacl = NULL;
	unsigned int flags = 0;

	/* Get inode */
	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
	if (error)
		return error;

 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
//flaw_line_below:
	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
//flaw_line_below:
		return nfserr_attrnotsupp;
//flaw_line_below:

 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
	if (host_error == -EINVAL)
		return nfserr_attrnotsupp;
 	if (host_error < 0)
 		goto out_nfserr;
 
//flaw_line_below:
	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
//fix_flaw_line_below:
//	fh_lock(fhp);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
 	if (host_error < 0)
//flaw_line_below:
		goto out_release;
//fix_flaw_line_below:
//		goto out_drop_lock;
 
 	if (S_ISDIR(inode->i_mode)) {
//flaw_line_below:
		host_error = inode->i_op->set_acl(inode, dpacl,
//flaw_line_below:
						  ACL_TYPE_DEFAULT);
//fix_flaw_line_below:
//		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
 	}
 
//flaw_line_below:
out_release:
//fix_flaw_line_below:
//out_drop_lock:
//fix_flaw_line_below:
//	fh_unlock(fhp);
//fix_flaw_line_below:
//
 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
	if (host_error == -EOPNOTSUPP)
		return nfserr_attrnotsupp;
	else
		return nfserrno(host_error);
}
",180621,"nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
		struct nfs4_acl *acl)
{
	__be32 error;
	int host_error;
	struct dentry *dentry;
	struct inode *inode;
	struct posix_acl *pacl = NULL, *dpacl = NULL;
	unsigned int flags = 0;

	/* Get inode */
	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
	if (error)
		return error;

 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
		return nfserr_attrnotsupp;
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
	if (host_error == -EINVAL)
		return nfserr_attrnotsupp;
 	if (host_error < 0)
 		goto out_nfserr;
 
	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
 	if (host_error < 0)
		goto out_release;
 
 	if (S_ISDIR(inode->i_mode)) {
		host_error = inode->i_op->set_acl(inode, dpacl,
						  ACL_TYPE_DEFAULT);
 	}
 
out_release:
 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
	if (host_error == -EOPNOTSUPP)
		return nfserr_attrnotsupp;
	else
		return nfserrno(host_error);
}
","nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
		struct nfs4_acl *acl)
{
	__be32 error;
	int host_error;
	struct dentry *dentry;
	struct inode *inode;
	struct posix_acl *pacl = NULL, *dpacl = NULL;
	unsigned int flags = 0;

	/* Get inode */
	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
	if (error)
		return error;

 	dentry = fhp->fh_dentry;
 	inode = d_inode(dentry);
 
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
	if (host_error == -EINVAL)
		return nfserr_attrnotsupp;
 	if (host_error < 0)
 		goto out_nfserr;
 
	fh_lock(fhp);

	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
 	if (host_error < 0)
		goto out_drop_lock;
 
 	if (S_ISDIR(inode->i_mode)) {
		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
 	}
 
out_drop_lock:
	fh_unlock(fhp);

 	posix_acl_release(pacl);
 	posix_acl_release(dpacl);
 out_nfserr:
	if (host_error == -EOPNOTSUPP)
		return nfserr_attrnotsupp;
	else
		return nfserrno(host_error);
}
","The `nfsd4_set_nfs4_acl` function is responsible for setting Access Control Lists (ACLs) for files or directories in an NFSv4 environment. It first verifies the file handle and retrieves the associated inode. If the inode does not support ACLs or is not a POSIX ACL, it returns an error. The function then converts the provided NFSv4 ACL to a POSIX ACL format, handling any conversion errors. If successful, it applies the access and default ACLs to the inode. Finally, it releases any allocated ACL resources and returns appropriate error codes if any operation fails during the process.","The function is designed to set Access Control Lists (ACLs) for files or directories in a network file system environment. It begins by verifying the validity of the file handle and retrieving the associated file metadata. If the file does not support ACLs or is not compatible with the required format, an error is returned. The function then converts the provided ACL to the appropriate format and applies it to the file. After attempting to set both access and default ACLs, it releases any allocated resources and returns relevant error codes if any step encounters an issue.","The vulnerability, identified as CWE-284, allowed local users to bypass file-permission restrictions by improperly setting POSIX ACLs without adequate locking mechanisms. In the vulnerable code, the function directly modified the ACLs without ensuring that the file handle was locked, which could lead to race conditions and unauthorized access. The fixed code addresses this issue by introducing `fh_lock(fhp)` before modifying the ACLs and `fh_unlock(fhp)` afterward, ensuring that the file handle is locked during the ACL modification process. This change prevents concurrent modifications and enforces proper access control, thereby mitigating the vulnerability.","The vulnerability, classified as CWE-284, allowed local users to bypass intended file-permission restrictions by improperly setting POSIX ACLs, leading to unauthorized access to files. This issue arose from the lack of proper synchronization mechanisms during the modification of ACLs, which could result in race conditions and inconsistent permission states. The fix implemented a locking mechanism around the ACL modification process, ensuring that access to the file's metadata was controlled and preventing concurrent modifications. This change effectively enforced access control, thereby mitigating the risk of unauthorized permission changes and enhancing the overall security of the system.","The vulnerability was fixed by introducing locking mechanisms around the ACL modification process. Specifically, the code now uses `fh_lock(fhp)` before setting the POSIX ACLs, ensuring that the file handle is locked during the operation. This prevents concurrent access and modifications that could lead to race conditions. After the ACLs are set, the code calls `fh_unlock(fhp)` to release the lock. This change ensures that only one operation can modify the ACLs at a time, thereby enforcing proper access control and preventing unauthorized users from bypassing file-permission restrictions.","The vulnerability was fixed by implementing a locking mechanism around the process of modifying Access Control Lists (ACLs). This involved acquiring a lock before any changes to the ACLs were made, ensuring that no other operations could interfere during the modification. After the ACLs were successfully set, the lock was released. This approach prevents race conditions and ensures that only one operation can modify the ACLs at a time, thereby maintaining the integrity of file permissions and preventing unauthorized access by local users. This enhancement significantly improves the security of the system.","5,5","5,5","4,4","5,5","CWE-362, CWE-732, CWE-367, CWE-412, CWE-764, CWE-667, CWE-366, CWE-411, CWE-269, CWE-284",N,-1
11,11,11,180652,180652,,Local,Not required,Complete,CVE-2015-8845,https://www.cvedetails.com/cve/CVE-2015-8845/,CWE-284,Low,,,,2016-04-27,4.9,"The tm_reclaim_thread function in arch/powerpc/kernel/process.c in the Linux kernel before 4.4.1 on powerpc platforms does not ensure that TM suspend mode exists before proceeding with a tm_reclaim call, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application.",2018-01-04,DoS ,18,https://github.com/torvalds/linux/commit/7f821fc9c77a9b01fe7b1d6e72717b33d8d64142,7f821fc9c77a9b01fe7b1d6e72717b33d8d64142,"powerpc/tm: Check for already reclaimed tasks

Currently we can hit a scenario where we'll tm_reclaim() twice.  This
results in a TM bad thing exception because the second reclaim occurs
when not in suspend mode.

The scenario in which this can happen is the following.  We attempt to
deliver a signal to userspace.  To do this we need obtain the stack
pointer to write the signal context.  To get this stack pointer we
must tm_reclaim() in case we need to use the checkpointed stack
pointer (see get_tm_stackpointer()).  Normally we'd then return
directly to userspace to deliver the signal without going through
__switch_to().

Unfortunatley, if at this point we get an error (such as a bad
userspace stack pointer), we need to exit the process.  The exit will
result in a __switch_to().  __switch_to() will attempt to save the
process state which results in another tm_reclaim().  This
tm_reclaim() now causes a TM Bad Thing exception as this state has
already been saved and the processor is no longer in TM suspend mode.
Whee!

This patch checks the state of the MSR to ensure we are TM suspended
before we attempt the tm_reclaim().  If we've already saved the state
away, we should no longer be in TM suspend mode.  This has the
additional advantage of checking for a potential TM Bad Thing
exception.

Found using syscall fuzzer.

Fixes: fb09692e71f1 (""powerpc: Add reclaim and recheckpoint functions for context switching transactional memory processes"")
Cc: stable@vger.kernel.org # v3.9+
Signed-off-by: Michael Neuling <mikey@neuling.org>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>",0,arch/powerpc/kernel/process.c,"{""sha"": ""646bf4d222c1caeda5c7851de74fbbe0ad0d65d9"", ""filename"": ""arch/powerpc/kernel/process.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/7f821fc9c77a9b01fe7b1d6e72717b33d8d64142/arch/powerpc/kernel/process.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7f821fc9c77a9b01fe7b1d6e72717b33d8d64142/arch/powerpc/kernel/process.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/process.c?ref=7f821fc9c77a9b01fe7b1d6e72717b33d8d64142"", ""patch"": ""@@ -551,6 +551,24 @@ static void tm_reclaim_thread(struct thread_struct *thr,\n \t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n \t}\n \n+\t/*\n+\t * Use the current MSR TM suspended bit to track if we have\n+\t * checkpointed state outstanding.\n+\t * On signal delivery, we'd normally reclaim the checkpointed\n+\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n+\t * This will then directly return to userspace without going\n+\t * through __switch_to(). However, if the stack frame is bad,\n+\t * we need to exit this thread which calls __switch_to() which\n+\t * will again attempt to reclaim the already saved tm state.\n+\t * Hence we need to check that we've not already reclaimed\n+\t * this state.\n+\t * We do this using the current MSR, rather tracking it in\n+\t * some specific thread_struct bit, as it has the additional\n+\t * benifit of checking for a potential TM bad thing exception.\n+\t */\n+\tif (!MSR_TM_SUSPENDED(mfmsr()))\n+\t\treturn;\n+\n \ttm_reclaim(thr, thr->regs->msr, cause);\n \n \t/* Having done the reclaim, we now have the checkpointed""}","static void tm_reclaim_thread(struct thread_struct *thr,
			      struct thread_info *ti, uint8_t cause)
{
	unsigned long msr_diff = 0;

	/*
	 * If FP/VSX registers have been already saved to the
	 * thread_struct, move them to the transact_fp array.
	 * We clear the TIF_RESTORE_TM bit since after the reclaim
	 * the thread will no longer be transactional.
	 */
	if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {
		msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;
		if (msr_diff & MSR_FP)
			memcpy(&thr->transact_fp, &thr->fp_state,
			       sizeof(struct thread_fp_state));
		if (msr_diff & MSR_VEC)
			memcpy(&thr->transact_vr, &thr->vr_state,
			       sizeof(struct thread_vr_state));
		clear_ti_thread_flag(ti, TIF_RESTORE_TM);
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
	/*
	 * Use the current MSR TM suspended bit to track if we have
	 * checkpointed state outstanding.
	 * On signal delivery, we'd normally reclaim the checkpointed
	 * state to obtain stack pointer (see:get_tm_stackpointer()).
	 * This will then directly return to userspace without going
	 * through __switch_to(). However, if the stack frame is bad,
	 * we need to exit this thread which calls __switch_to() which
	 * will again attempt to reclaim the already saved tm state.
	 * Hence we need to check that we've not already reclaimed
	 * this state.
	 * We do this using the current MSR, rather tracking it in
	 * some specific thread_struct bit, as it has the additional
	 * benifit of checking for a potential TM bad thing exception.
	 */
	if (!MSR_TM_SUSPENDED(mfmsr()))
		return;

 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
	 * FP/VSX values in the registers.  These might be valid
	 * even if we have previously called enable_kernel_fp() or
	 * flush_fp_to_thread(), so update thr->regs->msr to
	 * indicate their current validity.
	 */
	thr->regs->msr |= msr_diff;
}
","static void tm_reclaim_thread(struct thread_struct *thr,
			      struct thread_info *ti, uint8_t cause)
{
	unsigned long msr_diff = 0;

	/*
	 * If FP/VSX registers have been already saved to the
	 * thread_struct, move them to the transact_fp array.
	 * We clear the TIF_RESTORE_TM bit since after the reclaim
	 * the thread will no longer be transactional.
	 */
	if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {
		msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;
		if (msr_diff & MSR_FP)
			memcpy(&thr->transact_fp, &thr->fp_state,
			       sizeof(struct thread_fp_state));
		if (msr_diff & MSR_VEC)
			memcpy(&thr->transact_vr, &thr->vr_state,
			       sizeof(struct thread_vr_state));
		clear_ti_thread_flag(ti, TIF_RESTORE_TM);
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
	 * FP/VSX values in the registers.  These might be valid
	 * even if we have previously called enable_kernel_fp() or
	 * flush_fp_to_thread(), so update thr->regs->msr to
	 * indicate their current validity.
	 */
	thr->regs->msr |= msr_diff;
}
",C,"	/*
	 * Use the current MSR TM suspended bit to track if we have
	 * checkpointed state outstanding.
	 * On signal delivery, we'd normally reclaim the checkpointed
	 * state to obtain stack pointer (see:get_tm_stackpointer()).
	 * This will then directly return to userspace without going
	 * through __switch_to(). However, if the stack frame is bad,
	 * we need to exit this thread which calls __switch_to() which
	 * will again attempt to reclaim the already saved tm state.
	 * Hence we need to check that we've not already reclaimed
	 * this state.
	 * We do this using the current MSR, rather tracking it in
	 * some specific thread_struct bit, as it has the additional
	 * benifit of checking for a potential TM bad thing exception.
	 */
	if (!MSR_TM_SUSPENDED(mfmsr()))
		return;

",,,"@@ -551,6 +551,24 @@ static void tm_reclaim_thread(struct thread_struct *thr,
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
+	/*
+	 * Use the current MSR TM suspended bit to track if we have
+	 * checkpointed state outstanding.
+	 * On signal delivery, we'd normally reclaim the checkpointed
+	 * state to obtain stack pointer (see:get_tm_stackpointer()).
+	 * This will then directly return to userspace without going
+	 * through __switch_to(). However, if the stack frame is bad,
+	 * we need to exit this thread which calls __switch_to() which
+	 * will again attempt to reclaim the already saved tm state.
+	 * Hence we need to check that we've not already reclaimed
+	 * this state.
+	 * We do this using the current MSR, rather tracking it in
+	 * some specific thread_struct bit, as it has the additional
+	 * benifit of checking for a potential TM bad thing exception.
+	 */
+	if (!MSR_TM_SUSPENDED(mfmsr()))
+		return;
+
 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed",linux,7f821fc9c77a9b01fe7b1d6e72717b33d8d64142,d2b9d2a5ad5ef04ff978c9923d19730cb05efd55,1,"static void tm_reclaim_thread(struct thread_struct *thr,
			      struct thread_info *ti, uint8_t cause)
{
	unsigned long msr_diff = 0;

	/*
	 * If FP/VSX registers have been already saved to the
	 * thread_struct, move them to the transact_fp array.
	 * We clear the TIF_RESTORE_TM bit since after the reclaim
	 * the thread will no longer be transactional.
	 */
	if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {
		msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;
		if (msr_diff & MSR_FP)
			memcpy(&thr->transact_fp, &thr->fp_state,
			       sizeof(struct thread_fp_state));
		if (msr_diff & MSR_VEC)
			memcpy(&thr->transact_vr, &thr->vr_state,
			       sizeof(struct thread_vr_state));
		clear_ti_thread_flag(ti, TIF_RESTORE_TM);
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Use the current MSR TM suspended bit to track if we have
//fix_flaw_line_below:
//	 * checkpointed state outstanding.
//fix_flaw_line_below:
//	 * On signal delivery, we'd normally reclaim the checkpointed
//fix_flaw_line_below:
//	 * state to obtain stack pointer (see:get_tm_stackpointer()).
//fix_flaw_line_below:
//	 * This will then directly return to userspace without going
//fix_flaw_line_below:
//	 * through __switch_to(). However, if the stack frame is bad,
//fix_flaw_line_below:
//	 * we need to exit this thread which calls __switch_to() which
//fix_flaw_line_below:
//	 * will again attempt to reclaim the already saved tm state.
//fix_flaw_line_below:
//	 * Hence we need to check that we've not already reclaimed
//fix_flaw_line_below:
//	 * this state.
//fix_flaw_line_below:
//	 * We do this using the current MSR, rather tracking it in
//fix_flaw_line_below:
//	 * some specific thread_struct bit, as it has the additional
//fix_flaw_line_below:
//	 * benifit of checking for a potential TM bad thing exception.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (!MSR_TM_SUSPENDED(mfmsr()))
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//
 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
	 * FP/VSX values in the registers.  These might be valid
	 * even if we have previously called enable_kernel_fp() or
	 * flush_fp_to_thread(), so update thr->regs->msr to
	 * indicate their current validity.
	 */
	thr->regs->msr |= msr_diff;
}
",180652,"static void tm_reclaim_thread(struct thread_struct *thr,
			      struct thread_info *ti, uint8_t cause)
{
	unsigned long msr_diff = 0;

	/*
	 * If FP/VSX registers have been already saved to the
	 * thread_struct, move them to the transact_fp array.
	 * We clear the TIF_RESTORE_TM bit since after the reclaim
	 * the thread will no longer be transactional.
	 */
	if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {
		msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;
		if (msr_diff & MSR_FP)
			memcpy(&thr->transact_fp, &thr->fp_state,
			       sizeof(struct thread_fp_state));
		if (msr_diff & MSR_VEC)
			memcpy(&thr->transact_vr, &thr->vr_state,
			       sizeof(struct thread_vr_state));
		clear_ti_thread_flag(ti, TIF_RESTORE_TM);
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
	 * FP/VSX values in the registers.  These might be valid
	 * even if we have previously called enable_kernel_fp() or
	 * flush_fp_to_thread(), so update thr->regs->msr to
	 * indicate their current validity.
	 */
	thr->regs->msr |= msr_diff;
}
","static void tm_reclaim_thread(struct thread_struct *thr,
			      struct thread_info *ti, uint8_t cause)
{
	unsigned long msr_diff = 0;

	/*
	 * If FP/VSX registers have been already saved to the
	 * thread_struct, move them to the transact_fp array.
	 * We clear the TIF_RESTORE_TM bit since after the reclaim
	 * the thread will no longer be transactional.
	 */
	if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {
		msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;
		if (msr_diff & MSR_FP)
			memcpy(&thr->transact_fp, &thr->fp_state,
			       sizeof(struct thread_fp_state));
		if (msr_diff & MSR_VEC)
			memcpy(&thr->transact_vr, &thr->vr_state,
			       sizeof(struct thread_vr_state));
		clear_ti_thread_flag(ti, TIF_RESTORE_TM);
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
	/*
	 * Use the current MSR TM suspended bit to track if we have
	 * checkpointed state outstanding.
	 * On signal delivery, we'd normally reclaim the checkpointed
	 * state to obtain stack pointer (see:get_tm_stackpointer()).
	 * This will then directly return to userspace without going
	 * through __switch_to(). However, if the stack frame is bad,
	 * we need to exit this thread which calls __switch_to() which
	 * will again attempt to reclaim the already saved tm state.
	 * Hence we need to check that we've not already reclaimed
	 * this state.
	 * We do this using the current MSR, rather tracking it in
	 * some specific thread_struct bit, as it has the additional
	 * benifit of checking for a potential TM bad thing exception.
	 */
	if (!MSR_TM_SUSPENDED(mfmsr()))
		return;

 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
	 * FP/VSX values in the registers.  These might be valid
	 * even if we have previously called enable_kernel_fp() or
	 * flush_fp_to_thread(), so update thr->regs->msr to
	 * indicate their current validity.
	 */
	thr->regs->msr |= msr_diff;
}
","The `tm_reclaim_thread` function is designed to manage the state of a thread during a transactional memory reclaim process. It first checks if the thread's floating-point (FP) and vector (VSX) registers have been saved, and if so, it transfers these states to the `transact_fp` and `transact_vr` arrays while clearing the `TIF_RESTORE_TM` flag, indicating the thread is no longer in a transactional state. The function then calls `tm_reclaim` to perform the actual reclaim operation, and finally updates the thread's register status to reflect the validity of the checkpointed FP and VSX values, ensuring the thread's state is accurately maintained post-reclaim.","The function is responsible for managing the state of a thread during a reclaim operation in a transactional memory context. It first checks if the thread's floating-point and vector register states have been previously saved, and if so, it transfers these states to designated storage while updating the thread's status to indicate it is no longer in a transactional state. The function then performs the reclaim operation to restore the thread's state, and finally, it updates the register status to reflect the validity of the restored values, ensuring the thread's operational integrity after the reclaim process.","The vulnerability in the original code arises from the lack of a check to ensure that the transactional memory (TM) suspend mode is active before executing the reclaim operation. This oversight could allow a local user to trigger a denial of service by invoking a crafted application, leading to a TM Bad Thing exception and potential system panic. The fixed code addresses this vulnerability by introducing a condition that verifies whether the TM suspend bit is set in the current machine state register (MSR) before proceeding with the reclaim function. This additional check prevents the reclaim operation from executing in an invalid state, enhancing system stability.","The vulnerability in the original code stems from the absence of a verification step to confirm that the transactional memory suspend mode is active before executing a reclaim operation. This oversight could allow a local user to exploit the function, potentially leading to a denial of service by triggering a system exception and causing a panic. The fixed code rectifies this issue by implementing a check that ensures the suspend mode is indeed active prior to proceeding with the reclaim operation. This safeguard prevents the function from executing under invalid conditions, thereby enhancing the overall stability and security of the system.","The vulnerability was fixed by adding a conditional check to verify whether the transactional memory suspend bit is set in the current machine state register before executing the reclaim operation. Specifically, the code now includes a check using the `MSR_TM_SUSPENDED` macro to ensure that the thread is in a valid state for reclaiming. If the suspend bit is not set, the function returns early, preventing the execution of the reclaim operation and thereby avoiding potential exceptions and system panic. This enhancement ensures that the reclaim process only occurs when it is safe to do so, improving system stability.","The vulnerability was addressed by introducing a crucial check to confirm that the transactional memory suspend mode is active before proceeding with the reclaim operation. This added verification ensures that the function will only execute if the system is in a valid state, effectively preventing any attempts to reclaim memory when it is not appropriate to do so. By implementing this safeguard, the code avoids potential exceptions and system crashes that could arise from executing the reclaim operation under invalid conditions, thereby enhancing the overall stability and security of the system.","4, 5","4,4","4,4","4, 5","CWE-666, CWE-691, CWE-754, CWE-665, CWE-404, CWE-400, CWE-672, CWE-674, CWE-476, CWE-456",N,-1
12,12,12,180787,180787,,Local,Not required,Complete,CVE-2012-6689,https://www.cvedetails.com/cve/CVE-2012-6689/,CWE-284,Low,Complete,Complete,,2016-05-02,7.2,"The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages.",2016-11-28,,2,https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef,20e1db19db5d6b9e4e83021595eab0dc8f107bef,"netlink: fix possible spoofing from non-root processes

Non-root user-space processes can send Netlink messages to other
processes that are well-known for being subscribed to Netlink
asynchronous notifications. This allows ilegitimate non-root
process to send forged messages to Netlink subscribers.

The userspace process usually verifies the legitimate origin in
two ways:

a) Socket credentials. If UID != 0, then the message comes from
   some ilegitimate process and the message needs to be dropped.

b) Netlink portID. In general, portID == 0 means that the origin
   of the messages comes from the kernel. Thus, discarding any
   message not coming from the kernel.

However, ctnetlink sets the portID in event messages that has
been triggered by some user-space process, eg. conntrack utility.
So other processes subscribed to ctnetlink events, eg. conntrackd,
know that the event was triggered by some user-space action.

Neither of the two ways to discard ilegitimate messages coming
from non-root processes can help for ctnetlink.

This patch adds capability validation in case that dst_pid is set
in netlink_sendmsg(). This approach is aggressive since existing
applications using any Netlink bus to deliver messages between
two user-space processes will break. Note that the exception is
NETLINK_USERSOCK, since it is reserved for netlink-to-netlink
userspace communication.

Still, if anyone wants that his Netlink bus allows netlink-to-netlink
userspace, then they can set NL_NONROOT_SEND. However, by default,
I don't think it makes sense to allow to use NETLINK_ROUTE to
communicate two processes that are sending no matter what information
that is not related to link/neighbouring/routing. They should be using
NETLINK_USERSOCK instead for that.

Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/netlink/af_netlink.c,"{""sha"": ""527023823b5c5ea1a48c373b49e9f1688891a494"", ""filename"": ""net/netlink/af_netlink.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/20e1db19db5d6b9e4e83021595eab0dc8f107bef/net/netlink/af_netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/20e1db19db5d6b9e4e83021595eab0dc8f107bef/net/netlink/af_netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netlink/af_netlink.c?ref=20e1db19db5d6b9e4e83021595eab0dc8f107bef"", ""patch"": ""@@ -1373,7 +1373,8 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \t\tdst_pid = addr->nl_pid;\n \t\tdst_group = ffs(addr->nl_groups);\n \t\terr =  -EPERM;\n-\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n+\t\tif ((dst_group || dst_pid) &&\n+\t\t    !netlink_capable(sock, NL_NONROOT_SEND))\n \t\t\tgoto out;\n \t} else {\n \t\tdst_pid = nlk->dst_pid;\n@@ -2147,6 +2148,7 @@ static void __init netlink_add_usersock_entry(void)\n \trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n \tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n \tnl_table[NETLINK_USERSOCK].registered = 1;\n+\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n \n \tnetlink_table_ungrab();\n }""}","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
		if ((dst_group || dst_pid) &&
		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
",C,"		if ((dst_group || dst_pid) &&
		    !netlink_capable(sock, NL_NONROOT_SEND))
","		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
",,"@@ -1373,7 +1373,8 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
-		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
+		if ((dst_group || dst_pid) &&
+		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
@@ -2147,6 +2148,7 @@ static void __init netlink_add_usersock_entry(void)
 	rcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);
 	nl_table[NETLINK_USERSOCK].module = THIS_MODULE;
 	nl_table[NETLINK_USERSOCK].registered = 1;
+	nl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;
 
 	netlink_table_ungrab();
 }",linux,20e1db19db5d6b9e4e83021595eab0dc8f107bef,bd4242dfe85470b9caecbd049310518f9b9e3f14,1,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
//flaw_line_below:
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
//fix_flaw_line_below:
//		if ((dst_group || dst_pid) &&
//fix_flaw_line_below:
//		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
",180787,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
		if ((dst_group || dst_pid) &&
		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
","The `netlink_sendmsg` function is responsible for sending messages over a Netlink socket in the Linux kernel. It begins by validating the message flags and initializing necessary structures, including the socket's SCM (socket control message) data. The function checks the destination address and permissions, ensuring the message adheres to Netlink protocol requirements. It allocates a socket buffer (skb) for the message, copies the data from the user space, and performs security checks. Depending on the destination, it either broadcasts or unicasts the message. Finally, it cleans up resources and returns any error encountered during the process.","The function facilitates the sending of messages through a specific communication protocol within the kernel. It begins by validating the message's properties and initializing necessary structures for handling control messages. The function checks the destination address and permissions to ensure compliance with protocol rules. It allocates a buffer for the message, copies data from user space, and performs security validations. Depending on the destination, it either broadcasts or sends the message directly. Finally, it cleans up any allocated resources and returns an error code if any issues arise during the process.","The vulnerability in the original code stemmed from the lack of validation for the `dst_pid` field, allowing local users to spoof Netlink messages and potentially gain unauthorized access or perform unintended actions. This oversight could lead to privilege escalation or other security issues. In the fixed code, the condition was enhanced to check both `dst_group` and `dst_pid` against the `netlink_capable` function, ensuring that only users with the appropriate permissions can send messages to specified destinations. This added validation mitigates the risk of unauthorized message spoofing, thereby addressing the vulnerability effectively.","The vulnerability in the original code arose from the failure to validate the destination process identifier, which allowed local users to spoof messages sent through the Netlink protocol. This lack of validation could lead to unauthorized actions or privilege escalation, as malicious users could impersonate legitimate processes. The fixed code addressed this issue by implementing a check that ensures only users with the appropriate permissions can send messages to specified destinations. This added validation effectively mitigates the risk of message spoofing, thereby enhancing the security of the communication mechanism within the kernel.","The vulnerability was fixed by enhancing the validation of the `dst_pid` and `dst_group` fields in the modified code. Specifically, the condition now checks if either `dst_group` or `dst_pid` is set and ensures that the user has the necessary permissions by calling the `netlink_capable` function with the appropriate flags. This additional check prevents unauthorized users from sending spoofed messages, thereby securing the communication channel. By enforcing these permission checks before proceeding with message handling, the code effectively mitigates the risk of privilege escalation and unauthorized access.","The vulnerability was addressed by implementing stricter validation for the destination process identifier and group fields. The updated code now checks whether these fields are set and ensures that the user has the appropriate permissions to send messages to the specified destinations. This added layer of validation prevents unauthorized users from spoofing messages, thereby enhancing the security of the communication protocol. By enforcing these permission checks before allowing message transmission, the code effectively mitigates the risk of privilege escalation and unauthorized access, ensuring that only legitimate users can interact with the messaging system.","5,4","5,5","4,4","4,4","CWE-269,CWE-287,CWE-285,CWE-284,CWE-639,CWE-732,CWE-346,CWE-522,CWE-862,CWE-306",Y,4
13,13,13,181697,181697,,Remote,Not required,Partial,CVE-2016-10144,https://www.cvedetails.com/cve/CVE-2016-10144/,CWE-284,Low,Partial,Partial,,2017-03-24,7.5,coders/ipl.c in ImageMagick allows remote attackers to have unspecific impact by leveraging a missing malloc check.,2017-11-03,,2,https://github.com/ImageMagick/ImageMagick/commit/97566cf2806c0a5a86e884c96831a0c3b1ec6c20,97566cf2806c0a5a86e884c96831a0c3b1ec6c20,...,0,coders/ipl.c,"{""sha"": ""58c60ca5582773402f3b1404f7ce9ddcff32dc22"", ""filename"": ""coders/ipl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/97566cf2806c0a5a86e884c96831a0c3b1ec6c20/coders/ipl.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/97566cf2806c0a5a86e884c96831a0c3b1ec6c20/coders/ipl.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/ipl.c?ref=97566cf2806c0a5a86e884c96831a0c3b1ec6c20"", ""patch"": ""@@ -545,6 +545,8 @@ static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n   scene=0;\n \n   quantum_info=AcquireQuantumInfo(image_info, image);\n+  if (quantum_info == (QuantumInfo *) NULL)\n+    ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n   if ((quantum_info->format == UndefinedQuantumFormat) &&\n       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);""}","static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  /* There is no current method for detecting whether we have T or Z stacks */
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  /* Ok!  Calculations are done.  Lets write this puppy down! */

  /*
    Write IPL header.
  */
  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian
  files!   The reader above can, but they cannot.  For compatability reasons, I will leave
  the code in here, but it is all but useless if you want to use IPLab. */

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      /*
  Convert MIFF to IPL raster pixels.
      */
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    /* Green frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    /* Blue frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
","static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  /* There is no current method for detecting whether we have T or Z stacks */
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  /* Ok!  Calculations are done.  Lets write this puppy down! */

  /*
    Write IPL header.
  */
  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian
  files!   The reader above can, but they cannot.  For compatability reasons, I will leave
  the code in here, but it is all but useless if you want to use IPLab. */

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      /*
  Convert MIFF to IPL raster pixels.
      */
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    /* Green frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    /* Blue frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
",C,"  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
",,,"@@ -545,6 +545,8 @@ static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
+  if (quantum_info == (QuantumInfo *) NULL)
+    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);",ImageMagick,97566cf2806c0a5a86e884c96831a0c3b1ec6c20,d23beebe7b1179fb75db1e85fbca3100e49593d9,1,"static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
//fix_flaw_line_below:
//  if (quantum_info == (QuantumInfo *) NULL)
//fix_flaw_line_below:
//    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  /* There is no current method for detecting whether we have T or Z stacks */
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  /* Ok!  Calculations are done.  Lets write this puppy down! */

  /*
    Write IPL header.
  */
  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian
  files!   The reader above can, but they cannot.  For compatability reasons, I will leave
  the code in here, but it is all but useless if you want to use IPLab. */

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      /*
  Convert MIFF to IPL raster pixels.
      */
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    /* Green frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    /* Blue frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
",181697,"static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  /* There is no current method for detecting whether we have T or Z stacks */
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  /* Ok!  Calculations are done.  Lets write this puppy down! */

  /*
    Write IPL header.
  */
  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian
  files!   The reader above can, but they cannot.  For compatability reasons, I will leave
  the code in here, but it is all but useless if you want to use IPLab. */

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      /*
  Convert MIFF to IPL raster pixels.
      */
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    /* Green frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    /* Blue frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
","static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  /* There is no current method for detecting whether we have T or Z stacks */
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  /* Ok!  Calculations are done.  Lets write this puppy down! */

  /*
    Write IPL header.
  */
  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian
  files!   The reader above can, but they cannot.  For compatability reasons, I will leave
  the code in here, but it is all but useless if you want to use IPLab. */

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      /*
  Convert MIFF to IPL raster pixels.
      */
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  /* Red frame */
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    /* Green frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    /* Blue frame */
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
","The `WriteIPLImage` function is designed to write an image in the IPL (Image Processing Library) format. It begins by validating input parameters and opening the output file for writing. The function then acquires quantum information to determine the image's depth and format, setting the appropriate byte type for the IPL header. It constructs the IPL header with metadata such as dimensions, color channels, and data size. The function processes the image pixel data, converting it to the IPL format, and writes the pixel data for each color channel (red, green, blue) sequentially. Finally, it finalizes the file by writing a footer and closing the output blob.","The code defines a function that writes an image in a specific format by first validating input parameters and opening a file for output. It gathers necessary information about the image's properties, such as dimensions and color depth, and constructs a header containing metadata. The function then processes the image's pixel data, converting it into the required format and writing the pixel information for each color channel in sequence. Finally, it appends a footer to the file to indicate completion and closes the output file, ensuring that the image data is correctly saved.","The vulnerability in the original code arises from a lack of validation after memory allocation, specifically when acquiring quantum information. If the memory allocation fails, the function could proceed with a null pointer, leading to potential unauthorized access or crashes. The fixed code addresses this issue by adding a check to ensure that the quantum information pointer is not null after allocation. If it is null, the function throws an exception indicating a memory allocation failure, thereby preventing further execution with invalid memory and mitigating the risk of exploitation.","The vulnerability in the original code stems from the absence of a check after memory allocation, which could allow the program to operate on a null pointer if the allocation fails. This oversight could lead to unauthorized access or crashes, potentially enabling remote attackers to exploit the situation. The fixed code addresses this issue by implementing a validation step immediately after the memory allocation, ensuring that the pointer is not null. If the allocation fails, the program raises an exception, effectively preventing any further execution with invalid memory and mitigating the associated risks.","The vulnerability was fixed by adding a check after the memory allocation for the quantum information. In the updated code, immediately after acquiring the quantum information, a condition checks if the pointer is null. If it is null, the code throws a `ResourceLimitError` with a message indicating ""MemoryAllocationFailed."" This ensures that if the memory allocation fails, the function does not proceed with potentially invalid data, thus preventing unauthorized access or crashes. This validation step effectively mitigates the risk associated with the previous lack of a malloc check.","The vulnerability was fixed by introducing a validation step immediately after the memory allocation process. The updated code checks whether the allocated memory pointer is null, which indicates a failure in memory allocation. If the pointer is found to be null, the code raises an exception to signal a memory allocation failure, preventing any further execution that could lead to unauthorized access or crashes. This additional check ensures that the program only continues with valid memory, effectively mitigating the risks associated with the previous oversight.","5,5","5,5","4, 4","4,5","CWE-476, CWE-789, CWE-401, CWE-131, CWE-789, CWE-119, CWE-404, CWE-763, CWE-908, CWE-400",N,-1
14,14,14,181698,181698,,Remote,Not required,,CVE-2016-10130,https://www.cvedetails.com/cve/CVE-2016-10130/,CWE-284,Medium,,Partial,,2017-03-24,4.3,The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.,2017-03-27,,1,https://github.com/libgit2/libgit2/commit/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22,9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22,http: check certificate validity before clobbering the error variable,2,src/transports/http.c,"{""sha"": ""155fd7b30b5f980a5b0b5194acbfdbe1089d83f6"", ""filename"": ""src/transports/http.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22/src/transports/http.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22/src/transports/http.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/http.c?ref=9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22"", ""patch"": ""@@ -624,13 +624,12 @@ static int http_connect(http_subtransport *t)\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n-\t\tint is_valid;\n+\t\tint is_valid = (error == GIT_OK);\n \n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \n \t\tgiterr_clear();\n-\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \n \t\tif (error < 0) {""}","static int http_connect(http_subtransport *t)
{
	int error;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	apply_proxy_config(t);

	error = git_stream_connect(t->io);

 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}

	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","static int http_connect(http_subtransport *t)
{
	int error;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	apply_proxy_config(t);

	error = git_stream_connect(t->io);

 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid;
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}

	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
",C,"		int is_valid = (error == GIT_OK);
","		int is_valid;
		is_valid = error != GIT_ECERTIFICATE;
",,"@@ -624,13 +624,12 @@ static int http_connect(http_subtransport *t)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
-		int is_valid;
+		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
-		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {",libgit2,9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22,75db289a041b1f1084768244e167b953ac7eeaa5,1,"static int http_connect(http_subtransport *t)
{
	int error;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	apply_proxy_config(t);

	error = git_stream_connect(t->io);

 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
//flaw_line_below:
		int is_valid;
//fix_flaw_line_below:
//		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
//flaw_line_below:
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}

	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
",181698,"static int http_connect(http_subtransport *t)
{
	int error;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	apply_proxy_config(t);

	error = git_stream_connect(t->io);

 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid;
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}

	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","static int http_connect(http_subtransport *t)
{
	int error;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	apply_proxy_config(t);

	error = git_stream_connect(t->io);

 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}

	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","The `http_connect` function manages the connection process for an HTTP subtransport structure. It first checks if the connection is already established and whether it should be kept alive; if so, it returns immediately. If not, it closes any existing connection and initializes a new one based on whether SSL is used. Depending on the configuration, it creates a stream using either TLS, cURL, or a socket. After establishing the connection, it performs a certificate check if the connection is encrypted and a callback is provided. Finally, it updates the connection status and returns any errors encountered during the process.","The function establishes or re-establishes a network connection for an HTTP transport layer. It first checks if a connection is already active and whether it should remain open; if so, it exits early. If a new connection is needed, it closes any existing connection and creates a new one based on the security requirements. After connecting, it performs a certificate validation if the connection is secure and a user-defined callback is available. The function updates the connection status and returns any errors encountered during the connection process, ensuring proper handling of network and security issues.","The vulnerability in the original code stemmed from improper handling of the error variable, which could be manipulated by a man-in-the-middle attacker to spoof server responses. Specifically, the error variable was not consistently validated before being used in the certificate check, allowing an attacker to bypass security measures. In the fixed code, the validation of the error variable was improved by explicitly checking its value against GIT_OK before proceeding with the certificate check. This ensures that only valid connections are processed, thereby mitigating the risk of spoofing and enhancing overall security.","The vulnerability in the original code allowed man-in-the-middle attackers to spoof server responses due to improper handling of an error variable, which could be manipulated to bypass security checks. This oversight meant that the system could incorrectly assume a secure connection, leading to potential exploitation. In the revised code, the handling of the error variable was strengthened by ensuring that it was explicitly validated before proceeding with critical security checks. This change effectively prevents the exploitation of the vulnerability, ensuring that only legitimate connections are processed and enhancing the overall security of the connection establishment process.","The vulnerability was fixed by improving the validation of the error variable before it was used in the certificate check process. In the revised code, the is_valid variable is explicitly set based on whether the error equals GIT_OK, ensuring that only successful connections are considered valid. This change prevents the misuse of the error variable, which could have been manipulated by an attacker to bypass security checks. Additionally, the code now checks the error value after attempting to retrieve the certificate, ensuring that any issues are caught early and handled appropriately, thereby enhancing the security of the connection establishment.","The vulnerability was addressed by enhancing the validation process for the error state before proceeding with critical security checks. The revised code ensures that only successful connection attempts are considered valid, thereby preventing any manipulation of the error state that could lead to security bypasses. Additionally, the code now includes checks to confirm the integrity of the connection and the associated certificate before allowing further processing. This comprehensive validation approach effectively mitigates the risk of spoofing attacks, ensuring that only legitimate and secure connections are established and processed.","4,4","4, 4","3, 4","4,4","CWE-295, CWE-296, CWE-297, CWE-287, CWE-347, CWE-319, CWE-300, CWE-290, CWE-294, CWE-599",N,-1
15,15,15,181796,181796,,Remote,Not required,Partial,CVE-2016-10065,https://www.cvedetails.com/cve/CVE-2016-10065/,CWE-284,Medium,Partial,Partial,,2017-03-03,6.8,The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.,2019-04-12,DoS ,12,https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05,134463b926fa965571aa4febd61b810be5e7da05,https://github.com/ImageMagick/ImageMagick/issues/129,3,coders/viff.c,"{""sha"": ""01f8e91428f5bcf0268e3c4a5712ed51836a4754"", ""filename"": ""MagickCore/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/134463b926fa965571aa4febd61b810be5e7da05/MagickCore/memory.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/134463b926fa965571aa4febd61b810be5e7da05/MagickCore/memory.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/memory.c?ref=134463b926fa965571aa4febd61b810be5e7da05"", ""patch"": ""@@ -233,6 +233,7 @@ static MagickBooleanType\n %    o quantum: the number of bytes in each quantum.\n %\n */\n+\n static MagickBooleanType CheckMemoryOverflow(const size_t count,\n   const size_t quantum)\n {""}<_**next**_>{""sha"": ""8aa766e2b5041d463745d6e747c98871303e26c6"", ""filename"": ""MagickCore/quantum-import.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/134463b926fa965571aa4febd61b810be5e7da05/MagickCore/quantum-import.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/134463b926fa965571aa4febd61b810be5e7da05/MagickCore/quantum-import.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/quantum-import.c?ref=134463b926fa965571aa4febd61b810be5e7da05"", ""patch"": ""@@ -2024,6 +2024,7 @@ static void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n+  pixel=0;\n   switch (quantum_info->depth)\n   {\n     case 1:""}<_**next**_>{""sha"": ""bb5175ec5429ead3a87872d91d1158b6348318bd"", ""filename"": ""coders/viff.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 4, ""changes"": 32, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/134463b926fa965571aa4febd61b810be5e7da05/coders/viff.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/134463b926fa965571aa4febd61b810be5e7da05/coders/viff.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/viff.c?ref=134463b926fa965571aa4febd61b810be5e7da05"", ""patch"": ""@@ -137,6 +137,22 @@ static MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n %    o exception: return any errors or warnings in this structure.\n %\n */\n+\n+static MagickBooleanType CheckMemoryOverflow(const size_t count,\n+  const size_t quantum)\n+{\n+  size_t\n+    size;\n+\n+  size=count*quantum;\n+  if ((count == 0) || (quantum != (size/count)))\n+    {\n+      errno=ENOMEM;\n+      return(MagickTrue);\n+    }\n+  return(MagickFalse);\n+}\n+\n static Image *ReadVIFFImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n@@ -475,7 +491,7 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n     /*\n       Initialize image structure.\n     */\n-    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : \n+    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n       UndefinedPixelTrait;\n     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n       DirectClass);\n@@ -499,9 +515,17 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n       default: bytes_per_pixel=1; break;\n     }\n     if (viff_info.data_storage_type == VFF_TYP_BIT)\n-      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n+      {\n+        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n+          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n+      }\n     else\n-      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n+      {\n+        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n+          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n+      }\n     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n       max_packets),bytes_per_pixel*sizeof(*pixels));\n     if (pixels == (unsigned char *) NULL)\n@@ -695,7 +719,7 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n                 {\n                   ssize_t\n                     index;\n-                  \n+\n                   index=(ssize_t) GetPixelRed(image,q);\n                   SetPixelRed(image,image->colormap[\n                     ConstrainColormapIndex(image,index,exception)].red,q);""}"," static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=(int) ReadBlobLong(image);
    viff_info.y_offset=(int) ReadBlobLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
     /*
       Initialize image structure.
     */
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      }
     else
      {
        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
      }
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                 {
                   ssize_t
                     index;

                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green,q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue,q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"," static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=(int) ReadBlobLong(image);
    viff_info.y_offset=(int) ReadBlobLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
     /*
       Initialize image structure.
     */
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : 
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
      max_packets=((image->columns+7UL) >> 3UL)*image->rows;
     else
      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                 {
                   ssize_t
                     index;
                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green,q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue,q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
      {
        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      }
      {
        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
      }

","    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : 
      max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
",,"@@ -137,6 +137,22 @@ static MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)
 %    o exception: return any errors or warnings in this structure.
 %
 */
+
+static MagickBooleanType CheckMemoryOverflow(const size_t count,
+  const size_t quantum)
+{
+  size_t
+    size;
+
+  size=count*quantum;
+  if ((count == 0) || (quantum != (size/count)))
+    {
+      errno=ENOMEM;
+      return(MagickTrue);
+    }
+  return(MagickFalse);
+}
+
 static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
@@ -475,7 +491,7 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,
     /*
       Initialize image structure.
     */
-    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : 
+    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
@@ -499,9 +515,17 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
-      max_packets=((image->columns+7UL) >> 3UL)*image->rows;
+      {
+        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
+          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
+      }
     else
-      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
+      {
+        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
+          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
+      }
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
@@ -695,7 +719,7 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,
                 {
                   ssize_t
                     index;
-                  
+
                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);",ImageMagick,134463b926fa965571aa4febd61b810be5e7da05,1bc1fd0ff8c555841c78829217ac81fa0598255d,1," static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=(int) ReadBlobLong(image);
    viff_info.y_offset=(int) ReadBlobLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
     /*
       Initialize image structure.
     */
//flaw_line_below:
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : 
//fix_flaw_line_below:
//    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
//flaw_line_below:
      max_packets=((image->columns+7UL) >> 3UL)*image->rows;
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
//fix_flaw_line_below:
//          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
//fix_flaw_line_below:
//        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
//fix_flaw_line_below:
//      }
     else
//flaw_line_below:
      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
//fix_flaw_line_below:
//          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
//fix_flaw_line_below:
//        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
//fix_flaw_line_below:
//      }
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                 {
                   ssize_t
                     index;
//flaw_line_below:
                  
//fix_flaw_line_below:
//
                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green,q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue,q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",181796," static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=(int) ReadBlobLong(image);
    viff_info.y_offset=(int) ReadBlobLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
     /*
       Initialize image structure.
     */
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : 
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
      max_packets=((image->columns+7UL) >> 3UL)*image->rows;
     else
      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                 {
                   ssize_t
                     index;
                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green,q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue,q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"," static Image *ReadVIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=(int) ReadBlobLong(image);
    viff_info.y_offset=(int) ReadBlobLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
     /*
       Initialize image structure.
     */
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :
       DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
       default: bytes_per_pixel=1; break;
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      }
     else
      {
        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
      }
     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
       max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                 {
                   ssize_t
                     index;

                   index=(ssize_t) GetPixelRed(image,q);
                   SetPixelRed(image,image->colormap[
                     ConstrainColormapIndex(image,index,exception)].red,q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green,q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue,q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The `ReadVIFFImage` function is designed to read and decode images in the VIFF (Visual Image File Format) format. It begins by validating input parameters and opening the image file, then reads the VIFF header to extract metadata such as dimensions, color space, and data storage type. The function checks for various conditions to ensure the image is valid, including the number of data bands and storage types. It allocates memory for pixel data, reads the pixel values, and converts them to a format suitable for further processing. Finally, it handles multiple images in a single file and returns the decoded image.","The provided code implements a function that reads and decodes images stored in the VIFF format. It begins by validating input parameters and opening the image file, then extracts essential metadata such as dimensions, color space, and data storage type from the file header. The function checks for various conditions to ensure the image's integrity and allocates memory for pixel data. It reads the pixel values, converting them into a suitable format for further processing. Additionally, the function supports handling multiple images within a single file and ultimately returns the decoded image for use.","The vulnerability in the original code arises from insufficient validation of the image header and dimensions, which could allow an attacker to craft a malicious file that leads to a denial of service or application crash. Specifically, the code did not adequately check for memory allocation limits based on the image dimensions and data bands, potentially leading to buffer overflows or excessive memory usage. The fixed code addresses this by introducing checks for memory overflow using the `CheckMemoryOverflow` function before allocating memory for pixel data, ensuring that the dimensions and data bands do not exceed safe limits, thus preventing potential crashes or resource exhaustion.","The vulnerability in the original code stems from inadequate validation of input data, allowing attackers to exploit crafted files to trigger application crashes or denial of service. This lack of proper checks could lead to memory allocation issues, such as buffer overflows or excessive memory consumption, when processing maliciously constructed images. The fixed code addresses this vulnerability by implementing checks to ensure that memory allocations are safe and do not exceed predefined limits based on the image dimensions and data characteristics, thereby preventing potential crashes and enhancing overall application stability.","The vulnerability was fixed by introducing checks for memory overflow before allocating memory for pixel data. Specifically, the code now uses the `CheckMemoryOverflow` function to validate that the calculated number of pixels and data bands do not exceed safe limits. This is applied in two places: first, when determining the maximum packets for bit data, and second, when calculating the total number of pixels based on the image dimensions and data bands. By ensuring that these values are within acceptable ranges, the code prevents potential buffer overflows and excessive memory usage, thereby enhancing application stability.","The vulnerability was addressed by implementing checks to ensure that memory allocations are safe and do not exceed predefined limits based on the image dimensions and data characteristics. This involved adding validation steps to confirm that the calculated sizes for pixel data and other allocations are within acceptable ranges before proceeding with memory allocation. By enforcing these checks, the code prevents potential buffer overflows and excessive memory consumption, thereby mitigating the risk of application crashes or denial of service caused by maliciously crafted files. This enhances the overall robustness and security of the application.","5,5","5,5","4,5","4,3","CWE-789, CWE-400, CWE-131, CWE-770, CWE-190, CWE-789, CWE-20, CWE-119, CWE-789, CWE-134",N,-1
16,16,16,181818,181818,,Remote,Not required,Complete,CVE-2016-10030,https://www.cvedetails.com/cve/CVE-2016-10030/,CWE-284,High,Complete,Complete,,2017-01-05,7.6,"The _prolog_error function in slurmd/req.c in Slurm before 15.08.13, 16.x before 16.05.7, and 17.x before 17.02.0-pre4 has a vulnerability in how the slurmd daemon informs users of a Prolog failure on a compute node. That vulnerability could allow a user to assume control of an arbitrary file on the system. Any exploitation of this is dependent on the user being able to cause or anticipate the failure (non-zero return code) of a Prolog script that their job would run on. This issue affects all Slurm versions from 0.6.0 (September 2005) to present. Workarounds to prevent exploitation of this are to either disable your Prolog script, or modify it such that it always returns 0 (*success*) and adjust it to set the node as down using scontrol instead of relying on the slurmd to handle that automatically. If you do not have a Prolog set you are unaffected by this issue.",2017-01-10,,2,https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee,92362a92fffe60187df61f99ab11c249d44120ee,"Fix security issue in _prolog_error().

Fix security issue caused by insecure file path handling triggered by
the failure of a Prolog script. To exploit this a user needs to
anticipate or cause the Prolog to fail for their job.

(This commit is slightly different from the fix to the 15.08 branch.)

CVE-2016-10030.",3,src/slurmd/slurmd/req.c,"{""sha"": ""79a081cfa72e3483f7d5a4a5f9121829c5120da0"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/SchedMD/slurm/blob/92362a92fffe60187df61f99ab11c249d44120ee/NEWS"", ""raw_url"": ""https://github.com/SchedMD/slurm/raw/92362a92fffe60187df61f99ab11c249d44120ee/NEWS"", ""contents_url"": ""https://api.github.com/repos/SchedMD/slurm/contents/NEWS?ref=92362a92fffe60187df61f99ab11c249d44120ee"", ""patch"": ""@@ -28,6 +28,9 @@ documents those changes that are of interest to users and administrators.\n  -- Fix check for PluginDir within slurmctld to work with multiple directories.\n  -- Cancel interactive jobs automatically on communication error to launching\n     srun/salloc process.\n+ -- Fix security issue caused by insecure file path handling triggered by the\n+    failure of a Prolog script. To exploit this a user needs to anticipate or\n+    cause the Prolog to fail for their job. CVE-2016-10030.\n \n * Changes in Slurm 16.05.7\n ==========================""}<_**next**_>{""sha"": ""477efa3e5c13d316d8e0d9a8805cdc5de9b13983"", ""filename"": ""src/slurmd/slurmd/req.c"", ""status"": ""modified"", ""additions"": 109, ""deletions"": 4, ""changes"": 113, ""blob_url"": ""https://github.com/SchedMD/slurm/blob/92362a92fffe60187df61f99ab11c249d44120ee/src/slurmd/slurmd/req.c"", ""raw_url"": ""https://github.com/SchedMD/slurm/raw/92362a92fffe60187df61f99ab11c249d44120ee/src/slurmd/slurmd/req.c"", ""contents_url"": ""https://api.github.com/repos/SchedMD/slurm/contents/src/slurmd/slurmd/req.c?ref=92362a92fffe60187df61f99ab11c249d44120ee"", ""patch"": ""@@ -168,6 +168,7 @@ static void _note_batch_job_finished(uint32_t job_id);\n static int  _prolog_is_running (uint32_t jobid);\n static int  _step_limits_match(void *x, void *key);\n static int  _terminate_all_steps(uint32_t jobid, bool batch);\n+static int  _receive_fd(int socket);\n static void _rpc_launch_tasks(slurm_msg_t *);\n static void _rpc_abort_job(slurm_msg_t *);\n static void _rpc_batch_job(slurm_msg_t *msg, bool new_msg);\n@@ -214,6 +215,7 @@ static void _sync_messages_kill(kill_job_msg_t *req);\n static int  _waiter_init (uint32_t jobid);\n static int  _waiter_complete (uint32_t jobid);\n \n+static void _send_back_fd(int socket, int fd);\n static bool _steps_completed_now(uint32_t jobid);\n static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n \t\t\t       uint16_t block_no, uint32_t *job_id);\n@@ -1383,6 +1385,111 @@ _rpc_launch_tasks(slurm_msg_t *msg)\n \t\tsend_registration_msg(errnum, false);\n }\n \n+/*\n+ * Open file based upon permissions of a different user\n+ * IN path_name - name of file to open\n+ * IN uid - User ID to use for file access check\n+ * IN gid - Group ID to use for file access check\n+ * RET -1 on error, file descriptor otherwise\n+ */\n+static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)\n+{\n+\tpid_t child;\n+\tgids_t *gids;\n+\tint pipe[2];\n+\tint fd = -1, rc = 0;\n+\n+\tif (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {\n+\t\terror(\""%s: gids_cache_lookup for %s failed\"",\n+\t\t      __func__, req->user_name);\n+\t\treturn -1;\n+\t}\n+\n+\tif ((rc = container_g_create(req->job_id))) {\n+\t\terror(\""%s: container_g_create(%u): %m\"", __func__, req->job_id);\n+\t\t_dealloc_gids(gids);\n+\t\treturn -1;\n+\t}\n+\n+\t/* child process will setuid to the user, register the process\n+\t * with the container, and open the file for us. */\n+\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {\n+\t\terror(\""%s: Failed to open pipe: %m\"", __func__);\n+\t\t_dealloc_gids(gids);\n+\t\treturn -1;\n+\t}\n+\n+\tchild = fork();\n+\tif (child == -1) {\n+\t\terror(\""%s: fork failure\"", __func__);\n+\t\t_dealloc_gids(gids);\n+\t\tclose(pipe[0]);\n+\t\tclose(pipe[1]);\n+\t\treturn -1;\n+\t} else if (child > 0) {\n+\t\tclose(pipe[0]);\n+\t\t(void) waitpid(child, &rc, 0);\n+\t\t_dealloc_gids(gids);\n+\t\tif (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))\n+\t\t\tfd = _receive_fd(pipe[1]);\n+\t\tclose(pipe[1]);\n+\t\treturn fd;\n+\t}\n+\n+\t/* child process below here */\n+\n+\tclose(pipe[1]);\n+\n+\t/* container_g_add_pid needs to be called in the\n+\t * forked process part of the fork to avoid a race\n+\t * condition where if this process makes a file or\n+\t * detacts itself from a child before we add the pid\n+\t * to the container in the parent of the fork. */\n+\tif (container_g_add_pid(req->job_id, getpid(), req->uid)) {\n+\t\terror(\""%s container_g_add_pid(%u): %m\"", __func__, req->job_id);\n+\t\texit(SLURM_ERROR);\n+\t}\n+\n+\t/* The child actually performs the I/O and exits with\n+\t * a return code, do not return! */\n+\n+\t/*********************************************************************\\\n+\t * NOTE: It would be best to do an exec() immediately after the fork()\n+\t * in order to help prevent a possible deadlock in the child process\n+\t * due to locks being set at the time of the fork and being freed by\n+\t * the parent process, but not freed by the child process. Performing\n+\t * the work inline is done for simplicity. Note that the logging\n+\t * performed by error() should be safe due to the use of\n+\t * atfork_install_handlers() as defined in src/common/log.c.\n+\t * Change the code below with caution.\n+\t\\*********************************************************************/\n+\n+\tif (setgroups(gids->ngids, gids->gids) < 0) {\n+\t\terror(\""%s: uid: %u setgroups failed: %m\"", __func__, req->uid);\n+\t\texit(errno);\n+\t}\n+\t_dealloc_gids(gids);\n+\n+\tif (setgid(req->gid) < 0) {\n+\t\terror(\""%s: uid:%u setgid(%u): %m\"", __func__, req->uid,req->gid);\n+\t\texit(errno);\n+\t}\n+\tif (setuid(req->uid) < 0) {\n+\t\terror(\""%s: getuid(%u): %m\"", __func__, req->uid);\n+\t\texit(errno);\n+\t}\n+\n+\tfd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);\n+\tif (fd == -1) {\n+\t\terror(\""%s: uid:%u can't open `%s`: %m\"",\n+\t\t      __func__, req->uid, path_name);\n+\t\texit(errno);\n+\t}\n+\t_send_back_fd(pipe[0], fd);\n+\tclose(fd);\n+\texit(SLURM_SUCCESS);\n+}\n+\n static void\n _prolog_error(batch_job_launch_msg_t *req, int rc)\n {\n@@ -1415,10 +1522,8 @@ _prolog_error(batch_job_launch_msg_t *req, int rc)\n \t\t\treq->work_dir, err_name_ptr);\n \telse\n \t\tsnprintf(path_name, MAXPATHLEN, \""/%s\"", err_name_ptr);\n-\n-\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n-\t\terror(\""Unable to open %s: %s\"", path_name,\n-\t\t      slurm_strerror(errno));\n+\tif ((fd = _open_as_other(path_name, req)) == -1) {\n+\t\terror(\""Unable to open %s: Permission denied\"", path_name);\n \t\treturn;\n \t}\n \tsnprintf(err_name, sizeof(err_name),""}"," _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
	char *err_name_ptr, err_name[256], path_name[MAXPATHLEN];
	char *fmt_char;
	int fd;

	if (req->std_err || req->std_out) {
		if (req->std_err)
			strncpy(err_name, req->std_err, sizeof(err_name));
		else
			strncpy(err_name, req->std_out, sizeof(err_name));
		if ((fmt_char = strchr(err_name, (int) '%')) &&
		    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {
			char tmp_name[256];
			fmt_char[1] = 'u';
			snprintf(tmp_name, sizeof(tmp_name), err_name,
				 req->job_id);
			strncpy(err_name, tmp_name, sizeof(err_name));
		}
	} else {
		snprintf(err_name, sizeof(err_name), ""slurm-%u.out"",
			 req->job_id);
	}
	err_name_ptr = err_name;
	if (err_name_ptr[0] == '/')
		snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr);
	else if (req->work_dir)
		snprintf(path_name, MAXPATHLEN, ""%s/%s"",
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
	if ((fd = _open_as_other(path_name, req)) == -1) {
		error(""Unable to open %s: Permission denied"", path_name);
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),
		 ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc));
	safe_write(fd, err_name, strlen(err_name));
	if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {
		snprintf(err_name, sizeof(err_name),
			 ""Couldn't change fd owner to %u:%u: %m\n"",
			 req->uid, req->gid);
	}
rwfail:
	close(fd);
}
"," _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
	char *err_name_ptr, err_name[256], path_name[MAXPATHLEN];
	char *fmt_char;
	int fd;

	if (req->std_err || req->std_out) {
		if (req->std_err)
			strncpy(err_name, req->std_err, sizeof(err_name));
		else
			strncpy(err_name, req->std_out, sizeof(err_name));
		if ((fmt_char = strchr(err_name, (int) '%')) &&
		    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {
			char tmp_name[256];
			fmt_char[1] = 'u';
			snprintf(tmp_name, sizeof(tmp_name), err_name,
				 req->job_id);
			strncpy(err_name, tmp_name, sizeof(err_name));
		}
	} else {
		snprintf(err_name, sizeof(err_name), ""slurm-%u.out"",
			 req->job_id);
	}
	err_name_ptr = err_name;
	if (err_name_ptr[0] == '/')
		snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr);
	else if (req->work_dir)
		snprintf(path_name, MAXPATHLEN, ""%s/%s"",
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
	if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
		error(""Unable to open %s: %s"", path_name,
		      slurm_strerror(errno));
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),
		 ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc));
	safe_write(fd, err_name, strlen(err_name));
	if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {
		snprintf(err_name, sizeof(err_name),
			 ""Couldn't change fd owner to %u:%u: %m\n"",
			 req->uid, req->gid);
	}
rwfail:
	close(fd);
}
",C,"	if ((fd = _open_as_other(path_name, req)) == -1) {
		error(""Unable to open %s: Permission denied"", path_name);
","	if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
		error(""Unable to open %s: %s"", path_name,
		      slurm_strerror(errno));
",,"@@ -168,6 +168,7 @@ static void _note_batch_job_finished(uint32_t job_id);
 static int  _prolog_is_running (uint32_t jobid);
 static int  _step_limits_match(void *x, void *key);
 static int  _terminate_all_steps(uint32_t jobid, bool batch);
+static int  _receive_fd(int socket);
 static void _rpc_launch_tasks(slurm_msg_t *);
 static void _rpc_abort_job(slurm_msg_t *);
 static void _rpc_batch_job(slurm_msg_t *msg, bool new_msg);
@@ -214,6 +215,7 @@ static void _sync_messages_kill(kill_job_msg_t *req);
 static int  _waiter_init (uint32_t jobid);
 static int  _waiter_complete (uint32_t jobid);
 
+static void _send_back_fd(int socket, int fd);
 static bool _steps_completed_now(uint32_t jobid);
 static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,
 			       uint16_t block_no, uint32_t *job_id);
@@ -1383,6 +1385,111 @@ _rpc_launch_tasks(slurm_msg_t *msg)
 		send_registration_msg(errnum, false);
 }
 
+/*
+ * Open file based upon permissions of a different user
+ * IN path_name - name of file to open
+ * IN uid - User ID to use for file access check
+ * IN gid - Group ID to use for file access check
+ * RET -1 on error, file descriptor otherwise
+ */
+static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)
+{
+	pid_t child;
+	gids_t *gids;
+	int pipe[2];
+	int fd = -1, rc = 0;
+
+	if (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {
+		error(""%s: gids_cache_lookup for %s failed"",
+		      __func__, req->user_name);
+		return -1;
+	}
+
+	if ((rc = container_g_create(req->job_id))) {
+		error(""%s: container_g_create(%u): %m"", __func__, req->job_id);
+		_dealloc_gids(gids);
+		return -1;
+	}
+
+	/* child process will setuid to the user, register the process
+	 * with the container, and open the file for us. */
+	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {
+		error(""%s: Failed to open pipe: %m"", __func__);
+		_dealloc_gids(gids);
+		return -1;
+	}
+
+	child = fork();
+	if (child == -1) {
+		error(""%s: fork failure"", __func__);
+		_dealloc_gids(gids);
+		close(pipe[0]);
+		close(pipe[1]);
+		return -1;
+	} else if (child > 0) {
+		close(pipe[0]);
+		(void) waitpid(child, &rc, 0);
+		_dealloc_gids(gids);
+		if (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))
+			fd = _receive_fd(pipe[1]);
+		close(pipe[1]);
+		return fd;
+	}
+
+	/* child process below here */
+
+	close(pipe[1]);
+
+	/* container_g_add_pid needs to be called in the
+	 * forked process part of the fork to avoid a race
+	 * condition where if this process makes a file or
+	 * detacts itself from a child before we add the pid
+	 * to the container in the parent of the fork. */
+	if (container_g_add_pid(req->job_id, getpid(), req->uid)) {
+		error(""%s container_g_add_pid(%u): %m"", __func__, req->job_id);
+		exit(SLURM_ERROR);
+	}
+
+	/* The child actually performs the I/O and exits with
+	 * a return code, do not return! */
+
+	/*********************************************************************\
+	 * NOTE: It would be best to do an exec() immediately after the fork()
+	 * in order to help prevent a possible deadlock in the child process
+	 * due to locks being set at the time of the fork and being freed by
+	 * the parent process, but not freed by the child process. Performing
+	 * the work inline is done for simplicity. Note that the logging
+	 * performed by error() should be safe due to the use of
+	 * atfork_install_handlers() as defined in src/common/log.c.
+	 * Change the code below with caution.
+	\*********************************************************************/
+
+	if (setgroups(gids->ngids, gids->gids) < 0) {
+		error(""%s: uid: %u setgroups failed: %m"", __func__, req->uid);
+		exit(errno);
+	}
+	_dealloc_gids(gids);
+
+	if (setgid(req->gid) < 0) {
+		error(""%s: uid:%u setgid(%u): %m"", __func__, req->uid,req->gid);
+		exit(errno);
+	}
+	if (setuid(req->uid) < 0) {
+		error(""%s: getuid(%u): %m"", __func__, req->uid);
+		exit(errno);
+	}
+
+	fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);
+	if (fd == -1) {
+		error(""%s: uid:%u can't open `%s`: %m"",
+		      __func__, req->uid, path_name);
+		exit(errno);
+	}
+	_send_back_fd(pipe[0], fd);
+	close(fd);
+	exit(SLURM_SUCCESS);
+}
+
 static void
 _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
@@ -1415,10 +1522,8 @@ _prolog_error(batch_job_launch_msg_t *req, int rc)
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
-
-	if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
-		error(""Unable to open %s: %s"", path_name,
-		      slurm_strerror(errno));
+	if ((fd = _open_as_other(path_name, req)) == -1) {
+		error(""Unable to open %s: Permission denied"", path_name);
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),",slurm,92362a92fffe60187df61f99ab11c249d44120ee,b330c054a5a56d645c26fcfe3802da5fe30509a2,1," _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
	char *err_name_ptr, err_name[256], path_name[MAXPATHLEN];
	char *fmt_char;
	int fd;

	if (req->std_err || req->std_out) {
		if (req->std_err)
			strncpy(err_name, req->std_err, sizeof(err_name));
		else
			strncpy(err_name, req->std_out, sizeof(err_name));
		if ((fmt_char = strchr(err_name, (int) '%')) &&
		    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {
			char tmp_name[256];
			fmt_char[1] = 'u';
			snprintf(tmp_name, sizeof(tmp_name), err_name,
				 req->job_id);
			strncpy(err_name, tmp_name, sizeof(err_name));
		}
	} else {
		snprintf(err_name, sizeof(err_name), ""slurm-%u.out"",
			 req->job_id);
	}
	err_name_ptr = err_name;
	if (err_name_ptr[0] == '/')
		snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr);
	else if (req->work_dir)
		snprintf(path_name, MAXPATHLEN, ""%s/%s"",
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
//flaw_line_below:

//flaw_line_below:
	if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
//flaw_line_below:
		error(""Unable to open %s: %s"", path_name,
//flaw_line_below:
		      slurm_strerror(errno));
//fix_flaw_line_below:
//	if ((fd = _open_as_other(path_name, req)) == -1) {
//fix_flaw_line_below:
//		error(""Unable to open %s: Permission denied"", path_name);
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),
		 ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc));
	safe_write(fd, err_name, strlen(err_name));
	if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {
		snprintf(err_name, sizeof(err_name),
			 ""Couldn't change fd owner to %u:%u: %m\n"",
			 req->uid, req->gid);
	}
rwfail:
	close(fd);
}
",181818," _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
	char *err_name_ptr, err_name[256], path_name[MAXPATHLEN];
	char *fmt_char;
	int fd;

	if (req->std_err || req->std_out) {
		if (req->std_err)
			strncpy(err_name, req->std_err, sizeof(err_name));
		else
			strncpy(err_name, req->std_out, sizeof(err_name));
		if ((fmt_char = strchr(err_name, (int) '%')) &&
		    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {
			char tmp_name[256];
			fmt_char[1] = 'u';
			snprintf(tmp_name, sizeof(tmp_name), err_name,
				 req->job_id);
			strncpy(err_name, tmp_name, sizeof(err_name));
		}
	} else {
		snprintf(err_name, sizeof(err_name), ""slurm-%u.out"",
			 req->job_id);
	}
	err_name_ptr = err_name;
	if (err_name_ptr[0] == '/')
		snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr);
	else if (req->work_dir)
		snprintf(path_name, MAXPATHLEN, ""%s/%s"",
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
	if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
		error(""Unable to open %s: %s"", path_name,
		      slurm_strerror(errno));
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),
		 ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc));
	safe_write(fd, err_name, strlen(err_name));
	if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {
		snprintf(err_name, sizeof(err_name),
			 ""Couldn't change fd owner to %u:%u: %m\n"",
			 req->uid, req->gid);
	}
rwfail:
	close(fd);
}
"," _prolog_error(batch_job_launch_msg_t *req, int rc)
 {
	char *err_name_ptr, err_name[256], path_name[MAXPATHLEN];
	char *fmt_char;
	int fd;

	if (req->std_err || req->std_out) {
		if (req->std_err)
			strncpy(err_name, req->std_err, sizeof(err_name));
		else
			strncpy(err_name, req->std_out, sizeof(err_name));
		if ((fmt_char = strchr(err_name, (int) '%')) &&
		    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {
			char tmp_name[256];
			fmt_char[1] = 'u';
			snprintf(tmp_name, sizeof(tmp_name), err_name,
				 req->job_id);
			strncpy(err_name, tmp_name, sizeof(err_name));
		}
	} else {
		snprintf(err_name, sizeof(err_name), ""slurm-%u.out"",
			 req->job_id);
	}
	err_name_ptr = err_name;
	if (err_name_ptr[0] == '/')
		snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr);
	else if (req->work_dir)
		snprintf(path_name, MAXPATHLEN, ""%s/%s"",
 			req->work_dir, err_name_ptr);
 	else
 		snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr);
	if ((fd = _open_as_other(path_name, req)) == -1) {
		error(""Unable to open %s: Permission denied"", path_name);
 		return;
 	}
 	snprintf(err_name, sizeof(err_name),
		 ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc));
	safe_write(fd, err_name, strlen(err_name));
	if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {
		snprintf(err_name, sizeof(err_name),
			 ""Couldn't change fd owner to %u:%u: %m\n"",
			 req->uid, req->gid);
	}
rwfail:
	close(fd);
}
","The `_prolog_error` function handles error logging for batch job launches in a job scheduling system. It takes a pointer to a request structure and an integer return code as parameters. The function first determines the appropriate error output file name based on the request's standard error or output fields, modifying it if necessary to include the job ID. It constructs a full file path, ensuring it is correctly formatted based on the working directory. The function then attempts to open this file for writing; if successful, it logs an error message indicating the job's exit status. Finally, it attempts to change the file's ownership to match the job's user and group IDs before closing the file descriptor.","The code is designed to log error messages related to batch job launches in a job scheduling system. It determines the appropriate output file name based on the request's error or output specifications, incorporating the job ID if needed. The code constructs a full file path, ensuring it is correctly formatted based on the working directory. It then attempts to open the file for writing; if successful, it logs an error message indicating the job's exit status. Finally, it attempts to change the file's ownership to match the job's user and group before closing the file descriptor.","The vulnerability in the original code stemmed from the way it opened files for logging error messages, allowing users to potentially control arbitrary files on the system by manipulating the file path. Specifically, the use of the `open` function without proper permission checks could lead to unauthorized access. In the fixed code, this issue was addressed by replacing the `open` function with `_open_as_other`, which incorporates user permissions from the request structure, ensuring that only authorized users can access the specified file path. This change mitigates the risk of unauthorized file access and enhances security.","The vulnerability in the original code allowed users to potentially gain control over arbitrary files by manipulating the file paths used for logging error messages, which could lead to unauthorized access. This issue arose because the code did not adequately enforce permission checks when opening files, making it possible for users to exploit failures in Prolog scripts. The fixed code addressed this vulnerability by implementing a new method for opening files that incorporates user permissions from the request context, ensuring that only authorized users can access the specified file paths, thereby enhancing security and preventing unauthorized file manipulation.","The vulnerability was fixed by replacing the original `open` function with `_open_as_other`, which incorporates user permissions from the request structure. This change ensures that the file is opened with the appropriate access rights based on the user associated with the job, preventing unauthorized access to arbitrary files. Additionally, the error handling was improved to provide clearer feedback when file access is denied, enhancing overall security. By enforcing these permission checks, the fixed code mitigates the risk of exploitation that could arise from users manipulating file paths to gain control over sensitive files.","The vulnerability was fixed by implementing a new method for opening files that incorporates user permissions from the request context, ensuring that only authorized users can access the specified file paths. This change effectively prevents unauthorized access to arbitrary files, which was a significant risk in the original code. Additionally, the error handling was enhanced to provide clearer feedback when file access is denied, improving the overall security posture. By enforcing these permission checks, the revised code mitigates the risk of exploitation that could arise from users manipulating file paths to gain control over sensitive files.","5, 5","5,5","4,5","4, 5","CWE-22,CWE-284,CWE-285,CWE-732,CWE-269,CWE-552,CWE-459,CWE-434,CWE-35,CWE-441",Y,2
17,17,17,182003,182003,,Remote,Not required,,CVE-2016-6255,https://www.cvedetails.com/cve/CVE-2016-6255/,CWE-284,Low,,Partial,,2017-03-07,5.0,Portable UPnP SDK (aka libupnp) before 1.6.21 allows remote attackers to write to arbitrary files in the webroot via a POST request without a registered handler.,2017-11-02,,4,https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd,be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd,"Don't allow unhandled POSTs to write to the filesystem by default

If there's no registered handler for a POST request, the default behaviour
is to write it to the filesystem. Several million deployed devices appear
to have this behaviour, making it possible to (at least) store arbitrary
data on them. Add a configure option that enables this behaviour, and change
the default to just drop POSTs that aren't directly handled.",0,upnp/src/genlib/net/http/webserver.c,"{""sha"": ""ea2bc09ef1234e075484369484199dcdda829134"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/mjg59/pupnp-code/blob/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/configure.ac"", ""raw_url"": ""https://github.com/mjg59/pupnp-code/raw/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/configure.ac"", ""contents_url"": ""https://api.github.com/repos/mjg59/pupnp-code/contents/configure.ac?ref=be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd"", ""patch"": ""@@ -482,6 +482,10 @@ if test \""x$enable_scriptsupport\"" = xyes ; then\n         AC_DEFINE(IXML_HAVE_SCRIPTSUPPORT, 1, [see upnpconfig.h])\n fi\n \n+RT_BOOL_ARG_ENABLE([postwrite], [no], [write to the filesystem on otherwise unhandled POST requests])\n+if test \""x$enable_postwrite\"" = xyes ; then\n+        AC_DEFINE(UPNP_ENABLE_POST_WRITE, 1, [see upnpconfig.h])\n+fi\n \n RT_BOOL_ARG_ENABLE([samples], [yes], [compilation of upnp/sample/ code])\n ""}<_**next**_>{""sha"": ""5df8c5a1663cd5efcdc003e002758a91fc072f74"", ""filename"": ""upnp/inc/upnpconfig.h.in"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/mjg59/pupnp-code/blob/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/upnp/inc/upnpconfig.h.in"", ""raw_url"": ""https://github.com/mjg59/pupnp-code/raw/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/upnp/inc/upnpconfig.h.in"", ""contents_url"": ""https://api.github.com/repos/mjg59/pupnp-code/contents/upnp/inc/upnpconfig.h.in?ref=be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd"", ""patch"": ""@@ -135,5 +135,10 @@\n  *  (i.e. configure --enable-open_ssl) */\n #undef UPNP_ENABLE_OPEN_SSL\n \n+/** Defined to 1 if the library has been compiled to support filesystem writes on POST\n+ *  (i.e. configure --enable-postwrite) */\n+#undef UPNP_ENABLE_POST_WRITE\n+\n+\n #endif /* UPNP_CONFIG_H */\n ""}<_**next**_>{""sha"": ""8b2ecf202ecf8b27ac9f2805217dca21a44fcc86"", ""filename"": ""upnp/src/genlib/net/http/webserver.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/mjg59/pupnp-code/blob/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/upnp/src/genlib/net/http/webserver.c"", ""raw_url"": ""https://github.com/mjg59/pupnp-code/raw/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/upnp/src/genlib/net/http/webserver.c"", ""contents_url"": ""https://api.github.com/repos/mjg59/pupnp-code/contents/upnp/src/genlib/net/http/webserver.c?ref=be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd"", ""patch"": ""@@ -1369,9 +1369,13 @@ static int http_RecvPostMessage(\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n \t} else {\n+#ifdef UPNP_ENABLE_POST_WRITE\n \t\tFp = fopen(filename, \""wb\"");\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_UNAUTHORIZED;\n+#else\n+\t\treturn HTTP_NOT_FOUND;\n+#endif\n \t}\n \tparser->position = POS_ENTITY;\n \tdo {""}","static int http_RecvPostMessage(
	/*! HTTP Parser object. */
	http_parser_t *parser,
	/*! [in] Socket Information object. */
	SOCKINFO *info,
	/*! File where received data is copied to. */
	char *filename,
	/*! Send Instruction object which gives information whether the file
	 * is a virtual file or not. */
	struct SendInstruction *Instr)
{
	size_t Data_Buf_Size = 1024;
	char Buf[1024];
	int Timeout = -1;
	FILE *Fp;
	parse_status_t status = PARSE_OK;
	int ok_on_close = FALSE;
	size_t entity_offset = 0;
	int num_read = 0;
	int ret_code = HTTP_OK;

	if (Instr && Instr->IsVirtualFile) {
		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
#ifdef UPNP_ENABLE_POST_WRITE
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
#else
		return HTTP_NOT_FOUND;
#endif
 	}
 	parser->position = POS_ENTITY;
 	do {
		/* first parse what has already been gotten */
		if (parser->position != POS_COMPLETE)
			status = parser_parse_entity(parser);
		if (status == PARSE_INCOMPLETE_ENTITY) {
			/* read until close */
			ok_on_close = TRUE;
		} else if ((status != PARSE_SUCCESS)
			   && (status != PARSE_CONTINUE_1)
			   && (status != PARSE_INCOMPLETE)) {
			/* error */
			ret_code = HTTP_BAD_REQUEST;
			goto ExitFunction;
		}
		/* read more if necessary entity */
		while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&
		       parser->position != POS_COMPLETE) {
			num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);
			if (num_read > 0) {
				/* append data to buffer */
				if (membuffer_append(&parser->msg.msg,
					Buf, (size_t)num_read) != 0) {
					/* set failure status */
					parser->http_error_code =
					    HTTP_INTERNAL_SERVER_ERROR;
					ret_code = HTTP_INTERNAL_SERVER_ERROR;
					goto ExitFunction;
				}
				status = parser_parse_entity(parser);
				if (status == PARSE_INCOMPLETE_ENTITY) {
					/* read until close */
					ok_on_close = TRUE;
				} else if ((status != PARSE_SUCCESS)
					   && (status != PARSE_CONTINUE_1)
					   && (status != PARSE_INCOMPLETE)) {
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else if (num_read == 0) {
				if (ok_on_close) {
					UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,
						""<<< (RECVD) <<<\n%s\n-----------------\n"",
						parser->msg.msg.buf);
					print_http_headers(&parser->msg);
					parser->position = POS_COMPLETE;
				} else {
					/* partial msg or response */
					parser->http_error_code = HTTP_BAD_REQUEST;
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else {
				ret_code = HTTP_SERVICE_UNAVAILABLE;
				goto ExitFunction;
			}
		}
		if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {
			Data_Buf_Size =
			    parser->msg.entity.length - entity_offset;
		}
		memcpy(Buf,
		       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],
		       Data_Buf_Size);
		entity_offset += Data_Buf_Size;
		if (Instr && Instr->IsVirtualFile) {
			int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);
			if (n < 0) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		} else {
			size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);
			if (n != Data_Buf_Size) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		}
	} while (parser->position != POS_COMPLETE ||
		 entity_offset != parser->msg.entity.length);
ExitFunction:
	if (Instr && Instr->IsVirtualFile) {
		virtualDirCallback.close(Fp);
	} else {
		fclose(Fp);
	}

	return ret_code;
}
","static int http_RecvPostMessage(
	/*! HTTP Parser object. */
	http_parser_t *parser,
	/*! [in] Socket Information object. */
	SOCKINFO *info,
	/*! File where received data is copied to. */
	char *filename,
	/*! Send Instruction object which gives information whether the file
	 * is a virtual file or not. */
	struct SendInstruction *Instr)
{
	size_t Data_Buf_Size = 1024;
	char Buf[1024];
	int Timeout = -1;
	FILE *Fp;
	parse_status_t status = PARSE_OK;
	int ok_on_close = FALSE;
	size_t entity_offset = 0;
	int num_read = 0;
	int ret_code = HTTP_OK;

	if (Instr && Instr->IsVirtualFile) {
		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
 	}
 	parser->position = POS_ENTITY;
 	do {
		/* first parse what has already been gotten */
		if (parser->position != POS_COMPLETE)
			status = parser_parse_entity(parser);
		if (status == PARSE_INCOMPLETE_ENTITY) {
			/* read until close */
			ok_on_close = TRUE;
		} else if ((status != PARSE_SUCCESS)
			   && (status != PARSE_CONTINUE_1)
			   && (status != PARSE_INCOMPLETE)) {
			/* error */
			ret_code = HTTP_BAD_REQUEST;
			goto ExitFunction;
		}
		/* read more if necessary entity */
		while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&
		       parser->position != POS_COMPLETE) {
			num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);
			if (num_read > 0) {
				/* append data to buffer */
				if (membuffer_append(&parser->msg.msg,
					Buf, (size_t)num_read) != 0) {
					/* set failure status */
					parser->http_error_code =
					    HTTP_INTERNAL_SERVER_ERROR;
					ret_code = HTTP_INTERNAL_SERVER_ERROR;
					goto ExitFunction;
				}
				status = parser_parse_entity(parser);
				if (status == PARSE_INCOMPLETE_ENTITY) {
					/* read until close */
					ok_on_close = TRUE;
				} else if ((status != PARSE_SUCCESS)
					   && (status != PARSE_CONTINUE_1)
					   && (status != PARSE_INCOMPLETE)) {
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else if (num_read == 0) {
				if (ok_on_close) {
					UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,
						""<<< (RECVD) <<<\n%s\n-----------------\n"",
						parser->msg.msg.buf);
					print_http_headers(&parser->msg);
					parser->position = POS_COMPLETE;
				} else {
					/* partial msg or response */
					parser->http_error_code = HTTP_BAD_REQUEST;
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else {
				ret_code = HTTP_SERVICE_UNAVAILABLE;
				goto ExitFunction;
			}
		}
		if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {
			Data_Buf_Size =
			    parser->msg.entity.length - entity_offset;
		}
		memcpy(Buf,
		       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],
		       Data_Buf_Size);
		entity_offset += Data_Buf_Size;
		if (Instr && Instr->IsVirtualFile) {
			int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);
			if (n < 0) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		} else {
			size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);
			if (n != Data_Buf_Size) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		}
	} while (parser->position != POS_COMPLETE ||
		 entity_offset != parser->msg.entity.length);
ExitFunction:
	if (Instr && Instr->IsVirtualFile) {
		virtualDirCallback.close(Fp);
	} else {
		fclose(Fp);
	}

	return ret_code;
}
",C,"#ifdef UPNP_ENABLE_POST_WRITE
#else
		return HTTP_NOT_FOUND;
#endif
",,,"@@ -1369,9 +1369,13 @@ static int http_RecvPostMessage(
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
+#ifdef UPNP_ENABLE_POST_WRITE
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
+#else
+		return HTTP_NOT_FOUND;
+#endif
 	}
 	parser->position = POS_ENTITY;
 	do {",pupnp-code,be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd,bb994b975abf52ce9573dbca7cfd0d4e10b8c3e1,1,"static int http_RecvPostMessage(
	/*! HTTP Parser object. */
	http_parser_t *parser,
	/*! [in] Socket Information object. */
	SOCKINFO *info,
	/*! File where received data is copied to. */
	char *filename,
	/*! Send Instruction object which gives information whether the file
	 * is a virtual file or not. */
	struct SendInstruction *Instr)
{
	size_t Data_Buf_Size = 1024;
	char Buf[1024];
	int Timeout = -1;
	FILE *Fp;
	parse_status_t status = PARSE_OK;
	int ok_on_close = FALSE;
	size_t entity_offset = 0;
	int num_read = 0;
	int ret_code = HTTP_OK;

	if (Instr && Instr->IsVirtualFile) {
		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
//fix_flaw_line_below:
//#ifdef UPNP_ENABLE_POST_WRITE
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//		return HTTP_NOT_FOUND;
//fix_flaw_line_below:
//#endif
 	}
 	parser->position = POS_ENTITY;
 	do {
		/* first parse what has already been gotten */
		if (parser->position != POS_COMPLETE)
			status = parser_parse_entity(parser);
		if (status == PARSE_INCOMPLETE_ENTITY) {
			/* read until close */
			ok_on_close = TRUE;
		} else if ((status != PARSE_SUCCESS)
			   && (status != PARSE_CONTINUE_1)
			   && (status != PARSE_INCOMPLETE)) {
			/* error */
			ret_code = HTTP_BAD_REQUEST;
			goto ExitFunction;
		}
		/* read more if necessary entity */
		while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&
		       parser->position != POS_COMPLETE) {
			num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);
			if (num_read > 0) {
				/* append data to buffer */
				if (membuffer_append(&parser->msg.msg,
					Buf, (size_t)num_read) != 0) {
					/* set failure status */
					parser->http_error_code =
					    HTTP_INTERNAL_SERVER_ERROR;
					ret_code = HTTP_INTERNAL_SERVER_ERROR;
					goto ExitFunction;
				}
				status = parser_parse_entity(parser);
				if (status == PARSE_INCOMPLETE_ENTITY) {
					/* read until close */
					ok_on_close = TRUE;
				} else if ((status != PARSE_SUCCESS)
					   && (status != PARSE_CONTINUE_1)
					   && (status != PARSE_INCOMPLETE)) {
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else if (num_read == 0) {
				if (ok_on_close) {
					UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,
						""<<< (RECVD) <<<\n%s\n-----------------\n"",
						parser->msg.msg.buf);
					print_http_headers(&parser->msg);
					parser->position = POS_COMPLETE;
				} else {
					/* partial msg or response */
					parser->http_error_code = HTTP_BAD_REQUEST;
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else {
				ret_code = HTTP_SERVICE_UNAVAILABLE;
				goto ExitFunction;
			}
		}
		if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {
			Data_Buf_Size =
			    parser->msg.entity.length - entity_offset;
		}
		memcpy(Buf,
		       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],
		       Data_Buf_Size);
		entity_offset += Data_Buf_Size;
		if (Instr && Instr->IsVirtualFile) {
			int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);
			if (n < 0) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		} else {
			size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);
			if (n != Data_Buf_Size) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		}
	} while (parser->position != POS_COMPLETE ||
		 entity_offset != parser->msg.entity.length);
ExitFunction:
	if (Instr && Instr->IsVirtualFile) {
		virtualDirCallback.close(Fp);
	} else {
		fclose(Fp);
	}

	return ret_code;
}
",182003,"static int http_RecvPostMessage(
	/*! HTTP Parser object. */
	http_parser_t *parser,
	/*! [in] Socket Information object. */
	SOCKINFO *info,
	/*! File where received data is copied to. */
	char *filename,
	/*! Send Instruction object which gives information whether the file
	 * is a virtual file or not. */
	struct SendInstruction *Instr)
{
	size_t Data_Buf_Size = 1024;
	char Buf[1024];
	int Timeout = -1;
	FILE *Fp;
	parse_status_t status = PARSE_OK;
	int ok_on_close = FALSE;
	size_t entity_offset = 0;
	int num_read = 0;
	int ret_code = HTTP_OK;

	if (Instr && Instr->IsVirtualFile) {
		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
 	}
 	parser->position = POS_ENTITY;
 	do {
		/* first parse what has already been gotten */
		if (parser->position != POS_COMPLETE)
			status = parser_parse_entity(parser);
		if (status == PARSE_INCOMPLETE_ENTITY) {
			/* read until close */
			ok_on_close = TRUE;
		} else if ((status != PARSE_SUCCESS)
			   && (status != PARSE_CONTINUE_1)
			   && (status != PARSE_INCOMPLETE)) {
			/* error */
			ret_code = HTTP_BAD_REQUEST;
			goto ExitFunction;
		}
		/* read more if necessary entity */
		while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&
		       parser->position != POS_COMPLETE) {
			num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);
			if (num_read > 0) {
				/* append data to buffer */
				if (membuffer_append(&parser->msg.msg,
					Buf, (size_t)num_read) != 0) {
					/* set failure status */
					parser->http_error_code =
					    HTTP_INTERNAL_SERVER_ERROR;
					ret_code = HTTP_INTERNAL_SERVER_ERROR;
					goto ExitFunction;
				}
				status = parser_parse_entity(parser);
				if (status == PARSE_INCOMPLETE_ENTITY) {
					/* read until close */
					ok_on_close = TRUE;
				} else if ((status != PARSE_SUCCESS)
					   && (status != PARSE_CONTINUE_1)
					   && (status != PARSE_INCOMPLETE)) {
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else if (num_read == 0) {
				if (ok_on_close) {
					UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,
						""<<< (RECVD) <<<\n%s\n-----------------\n"",
						parser->msg.msg.buf);
					print_http_headers(&parser->msg);
					parser->position = POS_COMPLETE;
				} else {
					/* partial msg or response */
					parser->http_error_code = HTTP_BAD_REQUEST;
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else {
				ret_code = HTTP_SERVICE_UNAVAILABLE;
				goto ExitFunction;
			}
		}
		if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {
			Data_Buf_Size =
			    parser->msg.entity.length - entity_offset;
		}
		memcpy(Buf,
		       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],
		       Data_Buf_Size);
		entity_offset += Data_Buf_Size;
		if (Instr && Instr->IsVirtualFile) {
			int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);
			if (n < 0) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		} else {
			size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);
			if (n != Data_Buf_Size) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		}
	} while (parser->position != POS_COMPLETE ||
		 entity_offset != parser->msg.entity.length);
ExitFunction:
	if (Instr && Instr->IsVirtualFile) {
		virtualDirCallback.close(Fp);
	} else {
		fclose(Fp);
	}

	return ret_code;
}
","static int http_RecvPostMessage(
	/*! HTTP Parser object. */
	http_parser_t *parser,
	/*! [in] Socket Information object. */
	SOCKINFO *info,
	/*! File where received data is copied to. */
	char *filename,
	/*! Send Instruction object which gives information whether the file
	 * is a virtual file or not. */
	struct SendInstruction *Instr)
{
	size_t Data_Buf_Size = 1024;
	char Buf[1024];
	int Timeout = -1;
	FILE *Fp;
	parse_status_t status = PARSE_OK;
	int ok_on_close = FALSE;
	size_t entity_offset = 0;
	int num_read = 0;
	int ret_code = HTTP_OK;

	if (Instr && Instr->IsVirtualFile) {
		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
#ifdef UPNP_ENABLE_POST_WRITE
 		Fp = fopen(filename, ""wb"");
 		if (Fp == NULL)
 			return HTTP_UNAUTHORIZED;
#else
		return HTTP_NOT_FOUND;
#endif
 	}
 	parser->position = POS_ENTITY;
 	do {
		/* first parse what has already been gotten */
		if (parser->position != POS_COMPLETE)
			status = parser_parse_entity(parser);
		if (status == PARSE_INCOMPLETE_ENTITY) {
			/* read until close */
			ok_on_close = TRUE;
		} else if ((status != PARSE_SUCCESS)
			   && (status != PARSE_CONTINUE_1)
			   && (status != PARSE_INCOMPLETE)) {
			/* error */
			ret_code = HTTP_BAD_REQUEST;
			goto ExitFunction;
		}
		/* read more if necessary entity */
		while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&
		       parser->position != POS_COMPLETE) {
			num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);
			if (num_read > 0) {
				/* append data to buffer */
				if (membuffer_append(&parser->msg.msg,
					Buf, (size_t)num_read) != 0) {
					/* set failure status */
					parser->http_error_code =
					    HTTP_INTERNAL_SERVER_ERROR;
					ret_code = HTTP_INTERNAL_SERVER_ERROR;
					goto ExitFunction;
				}
				status = parser_parse_entity(parser);
				if (status == PARSE_INCOMPLETE_ENTITY) {
					/* read until close */
					ok_on_close = TRUE;
				} else if ((status != PARSE_SUCCESS)
					   && (status != PARSE_CONTINUE_1)
					   && (status != PARSE_INCOMPLETE)) {
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else if (num_read == 0) {
				if (ok_on_close) {
					UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,
						""<<< (RECVD) <<<\n%s\n-----------------\n"",
						parser->msg.msg.buf);
					print_http_headers(&parser->msg);
					parser->position = POS_COMPLETE;
				} else {
					/* partial msg or response */
					parser->http_error_code = HTTP_BAD_REQUEST;
					ret_code = HTTP_BAD_REQUEST;
					goto ExitFunction;
				}
			} else {
				ret_code = HTTP_SERVICE_UNAVAILABLE;
				goto ExitFunction;
			}
		}
		if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {
			Data_Buf_Size =
			    parser->msg.entity.length - entity_offset;
		}
		memcpy(Buf,
		       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],
		       Data_Buf_Size);
		entity_offset += Data_Buf_Size;
		if (Instr && Instr->IsVirtualFile) {
			int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);
			if (n < 0) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		} else {
			size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);
			if (n != Data_Buf_Size) {
				ret_code = HTTP_INTERNAL_SERVER_ERROR;
				goto ExitFunction;
			}
		}
	} while (parser->position != POS_COMPLETE ||
		 entity_offset != parser->msg.entity.length);
ExitFunction:
	if (Instr && Instr->IsVirtualFile) {
		virtualDirCallback.close(Fp);
	} else {
		fclose(Fp);
	}

	return ret_code;
}
","The `http_RecvPostMessage` function processes an HTTP POST request by receiving data from a socket and writing it to a specified file. It first checks if the file is virtual or a regular file, opening it accordingly. The function then enters a loop to read data from the socket, parsing the incoming message and appending it to a buffer until the entire entity is received. If any errors occur during parsing or writing, appropriate HTTP error codes are returned. Finally, the function closes the file and returns the HTTP status code indicating the result of the operation.","The function handles the reception of an HTTP POST message by reading data from a socket and writing it to a specified file. It determines whether the file is virtual or regular and opens it accordingly. The function continuously reads data until the entire message is received, parsing the incoming data and appending it to a buffer. If any errors arise during this process, appropriate error codes are generated. Once the data is fully received, the function closes the file and returns a status code that indicates the success or failure of the operation.","The vulnerability in the original code arises from the lack of proper validation for the file path specified by the user, allowing remote attackers to exploit the POST request functionality to write to arbitrary files, potentially compromising the system. This is classified under CWE-284, which pertains to improper access control. The fixed code addresses this issue by introducing a conditional compilation directive that checks if the feature for writing files is enabled. If not, it returns a ""not found"" error, effectively preventing unauthorized file access and ensuring that only valid, registered handlers can process POST requests.","The vulnerability in the original code stems from inadequate access control, allowing remote attackers to exploit the POST request functionality to write to arbitrary files in the webroot, which could lead to unauthorized file manipulation and potential system compromise. This issue is classified under CWE-284, highlighting improper access control mechanisms. The fixed code mitigates this vulnerability by implementing a conditional check that ensures file writing is only permitted when a specific feature is enabled. If the feature is not active, the code returns an error, thereby preventing unauthorized access and ensuring that only legitimate requests are processed.","The vulnerability was fixed by introducing a conditional compilation directive that checks for the `UPNP_ENABLE_POST_WRITE` feature before allowing file operations. In the modified code, if this feature is not enabled, the function immediately returns an ""HTTP_NOT_FOUND"" status, preventing any file writing attempts. This change ensures that the file handling logic, including the opening of files and writing data, is only executed when the feature is explicitly allowed, thereby blocking unauthorized access to the file system and ensuring that only registered handlers can process POST requests safely.","The vulnerability was addressed by implementing a conditional check that restricts file writing operations based on the availability of a specific feature. If this feature is not enabled, the code immediately returns an error, preventing any attempts to open or write to files. This safeguard ensures that file handling logic is only executed when explicitly permitted, effectively blocking unauthorized access and manipulation of the file system. By enforcing this control, the code limits the processing of POST requests to only those that are properly registered, thereby enhancing overall security.","5,5","5, 5","5,5","5,5","CWE-732, CWE-434, CWE-552, CWE-284, CWE-73, CWE-22, CWE-441, CWE-913, CWE-285, CWE-269",N,-1
18,18,18,183115,183115,,Local,Not required,Complete,CVE-2016-6198,https://www.cvedetails.com/cve/CVE-2016-6198/,CWE-284,Low,,,,2016-08-06,4.9,"The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.",2018-01-04,DoS ,4,https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7,54d5ca871e72f2bb172ec9323497f01cd5091ec7,"vfs: add vfs_select_inode() helper

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Cc: <stable@vger.kernel.org> # v4.2+",8,fs/open.c,"{""sha"": ""081d3d6df74ba54ccd0e1d754640b218e54f4111"", ""filename"": ""fs/open.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 8, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/54d5ca871e72f2bb172ec9323497f01cd5091ec7/fs/open.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/54d5ca871e72f2bb172ec9323497f01cd5091ec7/fs/open.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/open.c?ref=54d5ca871e72f2bb172ec9323497f01cd5091ec7"", ""patch"": ""@@ -840,16 +840,12 @@ EXPORT_SYMBOL(file_path);\n int vfs_open(const struct path *path, struct file *file,\n \t     const struct cred *cred)\n {\n-\tstruct dentry *dentry = path->dentry;\n-\tstruct inode *inode = dentry->d_inode;\n+\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n \n-\tfile->f_path = *path;\n-\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n-\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n-\t\tif (IS_ERR(inode))\n-\t\t\treturn PTR_ERR(inode);\n-\t}\n+\tif (IS_ERR(inode))\n+\t\treturn PTR_ERR(inode);\n \n+\tfile->f_path = *path;\n \treturn do_dentry_open(file, inode, NULL, cred);\n }\n ""}<_**next**_>{""sha"": ""7e9422cb5989c2e84ddd19eba2c91041f7b8622f"", ""filename"": ""include/linux/dcache.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/54d5ca871e72f2bb172ec9323497f01cd5091ec7/include/linux/dcache.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/54d5ca871e72f2bb172ec9323497f01cd5091ec7/include/linux/dcache.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/dcache.h?ref=54d5ca871e72f2bb172ec9323497f01cd5091ec7"", ""patch"": ""@@ -565,4 +565,16 @@ static inline struct dentry *d_real(struct dentry *dentry)\n \t\treturn dentry;\n }\n \n+static inline struct inode *vfs_select_inode(struct dentry *dentry,\n+\t\t\t\t\t     unsigned open_flags)\n+{\n+\tstruct inode *inode = d_inode(dentry);\n+\n+\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n+\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n+\n+\treturn inode;\n+}\n+\n+\n #endif\t/* __LINUX_DCACHE_H */""}"," int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
 
	if (IS_ERR(inode))
		return PTR_ERR(inode);
 
	file->f_path = *path;
 	return do_dentry_open(file, inode, NULL, cred);
 }
"," int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
 
	file->f_path = *path;
	if (dentry->d_flags & DCACHE_OP_SELECT_INODE) {
		inode = dentry->d_op->d_select_inode(dentry, file->f_flags);
		if (IS_ERR(inode))
			return PTR_ERR(inode);
	}
 
 	return do_dentry_open(file, inode, NULL, cred);
 }
",C,"	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
	if (IS_ERR(inode))
		return PTR_ERR(inode);
	file->f_path = *path;
","	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
	file->f_path = *path;
	if (dentry->d_flags & DCACHE_OP_SELECT_INODE) {
		inode = dentry->d_op->d_select_inode(dentry, file->f_flags);
		if (IS_ERR(inode))
			return PTR_ERR(inode);
	}
",,"@@ -840,16 +840,12 @@ EXPORT_SYMBOL(file_path);
 int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
-	struct dentry *dentry = path->dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
 
-	file->f_path = *path;
-	if (dentry->d_flags & DCACHE_OP_SELECT_INODE) {
-		inode = dentry->d_op->d_select_inode(dentry, file->f_flags);
-		if (IS_ERR(inode))
-			return PTR_ERR(inode);
-	}
+	if (IS_ERR(inode))
+		return PTR_ERR(inode);
 
+	file->f_path = *path;
 	return do_dentry_open(file, inode, NULL, cred);
 }
 ",linux,54d5ca871e72f2bb172ec9323497f01cd5091ec7,44549e8f5eea4e0a41b487b63e616cb089922b99,1," int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
//flaw_line_below:
	struct dentry *dentry = path->dentry;
//flaw_line_below:
	struct inode *inode = dentry->d_inode;
//fix_flaw_line_below:
//	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
 
//flaw_line_below:
	file->f_path = *path;
//flaw_line_below:
	if (dentry->d_flags & DCACHE_OP_SELECT_INODE) {
//flaw_line_below:
		inode = dentry->d_op->d_select_inode(dentry, file->f_flags);
//flaw_line_below:
		if (IS_ERR(inode))
//flaw_line_below:
			return PTR_ERR(inode);
//flaw_line_below:
	}
//fix_flaw_line_below:
//	if (IS_ERR(inode))
//fix_flaw_line_below:
//		return PTR_ERR(inode);
 
//fix_flaw_line_below:
//	file->f_path = *path;
 	return do_dentry_open(file, inode, NULL, cred);
 }
",183115," int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
 
	file->f_path = *path;
	if (dentry->d_flags & DCACHE_OP_SELECT_INODE) {
		inode = dentry->d_op->d_select_inode(dentry, file->f_flags);
		if (IS_ERR(inode))
			return PTR_ERR(inode);
	}
 
 	return do_dentry_open(file, inode, NULL, cred);
 }
"," int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
 
	if (IS_ERR(inode))
		return PTR_ERR(inode);
 
	file->f_path = *path;
 	return do_dentry_open(file, inode, NULL, cred);
 }
","The `vfs_open` function is responsible for opening a file in a virtual file system (VFS) context. It takes a path structure, a file structure, and credential information as parameters. The function retrieves the directory entry (`dentry`) and its associated inode from the provided path. If the directory entry has a specific flag indicating the need for a custom inode selection, it calls the `d_select_inode` method to potentially obtain a different inode based on the file's flags. Finally, it invokes `do_dentry_open` to complete the file opening process, passing the file structure, inode, and credentials, returning the result of this operation.","The provided code defines a function that facilitates the opening of a file within a virtual file system. It begins by accessing the necessary metadata associated with the specified file path. If a particular condition is met, indicating the need for a custom selection of file metadata, the function attempts to retrieve an alternative metadata structure based on specific flags. Ultimately, the function proceeds to finalize the file opening process, utilizing the gathered metadata and associated credentials, and returns the outcome of this operation, which indicates success or failure in opening the file.","The vulnerability in the original code arises from the potential for improper handling of file metadata, specifically when a file is renamed to a self-hardlink, which can lead to unexpected behavior and system crashes. In the vulnerable code, the inode is conditionally selected based on flags, which may not adequately validate the file's state. The fixed code addresses this by directly using a dedicated function, `vfs_select_inode`, to obtain the inode, ensuring that the selection process is more robust and less prone to errors. This change enhances the validation of the inode before proceeding with the file opening, thereby mitigating the risk of denial of service.","The vulnerability in the original code stems from inadequate validation during the file opening process, particularly when handling file renaming operations that could lead to a self-hardlink scenario. This oversight allows local users to exploit the system, potentially causing a denial of service by triggering unexpected behavior and crashes. The fixed code addresses this issue by implementing a more reliable method for selecting the file's metadata, ensuring that the inode is properly validated before any further operations are performed. This enhancement significantly reduces the risk of system instability associated with improper file handling.","The vulnerability was fixed by replacing the conditional inode selection process with a direct call to a dedicated function, `vfs_select_inode`, which retrieves the inode based on the provided path and file flags. This change ensures that the inode is consistently validated before proceeding with any operations. In the fixed code, the check for errors using `IS_ERR` immediately after obtaining the inode allows for early detection of issues, preventing further execution if the inode is invalid. This robust validation mechanism mitigates the risk of proceeding with unsafe operations that could lead to system crashes or denial of service.","The vulnerability was addressed by implementing a more reliable method for selecting the file's metadata, ensuring that the process is consistent and robust. Instead of conditionally determining the file's metadata based on flags, the updated code directly retrieves the necessary information in a standardized manner. This change includes an immediate validation step to check for errors after obtaining the metadata, allowing for early detection of any issues. By enhancing the validation process, the fix prevents the execution of unsafe operations that could lead to system instability or crashes, thereby improving overall system security.","4,4","5,5","4,4","4, 4","CWE-754, CWE-664, CWE-666, CWE-703, CWE-822, CWE-732, CWE-674, CWE-20, CWE-697, CWE-665",N,-1
19,19,19,183140,183140,,Remote,Not required,,CVE-2016-5104,https://www.cvedetails.com/cve/CVE-2016-5104/,CWE-284,Low,,Partial,,2016-06-13,5.0,The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.,2018-10-30,Bypass ,1,https://github.com/libimobiledevice/libusbmuxd/commit/4397b3376dc4e4cb1c991d0aed61ce6482614196,4397b3376dc4e4cb1c991d0aed61ce6482614196,common: [security fix] Make sure sockets only listen locally,1,common/socket.c,"{""sha"": ""4cdefd6f7472ac70a44cb1253d00a5c63db763fb"", ""filename"": ""common/socket.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/libimobiledevice/libusbmuxd/blob/4397b3376dc4e4cb1c991d0aed61ce6482614196/common/socket.c"", ""raw_url"": ""https://github.com/libimobiledevice/libusbmuxd/raw/4397b3376dc4e4cb1c991d0aed61ce6482614196/common/socket.c"", ""contents_url"": ""https://api.github.com/repos/libimobiledevice/libusbmuxd/contents/common/socket.c?ref=4397b3376dc4e4cb1c991d0aed61ce6482614196"", ""patch"": ""@@ -203,7 +203,7 @@ int socket_create(uint16_t port)\n \n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n-\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \tsaddr.sin_port = htons(port);\n \n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n@@ -368,7 +368,7 @@ int socket_accept(int fd, uint16_t port)\n \n \tmemset(&addr, 0, sizeof(addr));\n \taddr.sin_family = AF_INET;\n-\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \taddr.sin_port = htons(port);\n \n \taddr_len = sizeof(addr);""}","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}

#ifdef SO_NOSIGPIPE
	if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
#endif
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}

#ifdef SO_NOSIGPIPE
	if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
#endif
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",C,"	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
","	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
",,"@@ -203,7 +203,7 @@ int socket_create(uint16_t port)
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
-	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
@@ -368,7 +368,7 @@ int socket_accept(int fd, uint16_t port)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	addr.sin_port = htons(port);
 
 	addr_len = sizeof(addr);",libimobiledevice,4397b3376dc4e4cb1c991d0aed61ce6482614196,4d365eefe8255e8f693bce008dc71bf415279c7e,1,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}

#ifdef SO_NOSIGPIPE
	if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
#endif
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
//flaw_line_below:
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
//fix_flaw_line_below:
//	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",183140,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}

#ifdef SO_NOSIGPIPE
	if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
#endif
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}

#ifdef SO_NOSIGPIPE
	if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
#endif
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","The `socket_create` function initializes a TCP socket for a specified port, handling both Windows and Unix-like systems. It begins by checking if the Windows Sockets API needs initialization and performs it if necessary. The function then creates a socket using the `socket` system call and sets socket options to allow address reuse and, if supported, to prevent the generation of SIGPIPE signals on socket errors. It prepares a `sockaddr_in` structure to bind the socket to all available interfaces on the specified port. Finally, it binds the socket and sets it to listen for incoming connections, returning the socket file descriptor or -1 on failure.","The provided code defines a function that creates and configures a TCP socket for communication on a specified port. It checks for the need to initialize the Windows Sockets API on Windows systems. The function then creates a socket and sets options to allow address reuse and, if applicable, to suppress certain error signals. It prepares a structure to bind the socket to all network interfaces on the given port. Finally, the socket is bound and set to listen for incoming connections, returning a descriptor for the socket or indicating failure if any step encounters an error.","The vulnerability in the original code allowed remote attackers to bypass access restrictions by binding the socket to all available network interfaces, which could expose services on iOS devices. This was due to the use of `INADDR_ANY`, allowing connections from any IP address. The fixed code mitigates this risk by changing the binding address to `INADDR_LOOPBACK`, which restricts access to local connections only. This change ensures that only processes on the same machine can communicate with the socket, effectively preventing unauthorized remote access and enhancing the security of the service.","The vulnerability in the original code allowed remote attackers to bypass access restrictions by binding a socket to all network interfaces, which exposed services on iOS devices to unauthorized external connections. This created a significant security risk, as it enabled potential exploitation by malicious actors. The fixed code addressed this issue by restricting the binding to the loopback interface, ensuring that only local processes could connect to the socket. This change effectively limited access to the service, preventing remote communication and enhancing the overall security posture of the application.","The vulnerability was fixed by changing the binding address in the socket configuration. In the original code, the socket was bound to `INADDR_ANY`, allowing connections from any IP address, which posed a security risk. In the revised code, this was modified to `INADDR_LOOPBACK`, restricting the socket to accept connections only from the local machine. This adjustment was made in the `saddr.sin_addr.s_addr` assignment, ensuring that only local processes could communicate with the socket. As a result, the change effectively mitigated the risk of unauthorized remote access to services on iOS devices.","The vulnerability was fixed by changing the binding address of the socket from allowing connections from any network interface to restricting it to the local machine only. This adjustment ensures that the socket can only accept connections from processes running on the same device, effectively preventing unauthorized remote access. By limiting the scope of accessibility, the revised code enhances security and mitigates the risk of exploitation by remote attackers, thereby ensuring that sensitive services remain protected from external threats. This change significantly improves the overall security posture of the application.","5,5","5,5","5,5","5,5","CWE-668, CWE-284, CWE-749, CWE-552, CWE-667, CWE-281, CWE-645, CWE-669, CWE-664, CWE-266",N,-1
20,20,20,183143,183143,,Remote,Not required,Partial,CVE-2016-3698,https://www.cvedetails.com/cve/CVE-2016-3698/,CWE-284,Medium,Partial,Partial,,2016-06-13,6.8,"libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",2016-10-03,DoS ,5,https://github.com/jpirko/libndp/commit/2af9a55b38b55abbf05fd116ec097d4029115839,2af9a55b38b55abbf05fd116ec097d4029115839,"libndb: reject redirect and router advertisements from non-link-local

RFC4861 suggests that these messages should only originate from
link-local addresses in 6.1.2 (RA) and 8.1. (redirect):

Mitigates CVE-2016-3698.

Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
Signed-off-by: Jiri Pirko <jiri@mellanox.com>",1,libndp/libndp.c,"{""sha"": ""b7172faa752e0cbdecf4efdea6c9c5324272510c"", ""filename"": ""libndp/libndp.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/jpirko/libndp/blob/2af9a55b38b55abbf05fd116ec097d4029115839/libndp/libndp.c"", ""raw_url"": ""https://github.com/jpirko/libndp/raw/2af9a55b38b55abbf05fd116ec097d4029115839/libndp/libndp.c"", ""contents_url"": ""https://api.github.com/repos/jpirko/libndp/contents/libndp/libndp.c?ref=2af9a55b38b55abbf05fd116ec097d4029115839"", ""patch"": ""@@ -333,6 +333,7 @@ struct ndp_msg_type_info {\n \tuint8_t raw_type;\n \tsize_t raw_struct_size;\n \tvoid (*addrto_adjust)(struct in6_addr *addr);\n+\tbool (*addrto_validate)(struct in6_addr *addr);\n };\n \n static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)\n@@ -359,6 +360,11 @@ static void ndp_msg_addrto_adjust_all_routers(struct in6_addr *addr)\n \taddr->s6_addr32[3] = htonl(0x2);\n }\n \n+static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)\n+{\n+\treturn IN6_IS_ADDR_LINKLOCAL (addr);\n+}\n+\n static struct ndp_msg_type_info ndp_msg_type_info_list[] =\n {\n \t[NDP_MSG_RS] = {\n@@ -371,6 +377,7 @@ static struct ndp_msg_type_info ndp_msg_type_info_list[] =\n \t\t.strabbr = \""RA\"",\n \t\t.raw_type = ND_ROUTER_ADVERT,\n \t\t.raw_struct_size = sizeof(struct nd_router_advert),\n+\t\t.addrto_validate = ndp_msg_addrto_validate_link_local,\n \t},\n \t[NDP_MSG_NS] = {\n \t\t.strabbr = \""NS\"",\n@@ -387,6 +394,7 @@ static struct ndp_msg_type_info ndp_msg_type_info_list[] =\n \t\t.strabbr = \""R\"",\n \t\t.raw_type = ND_REDIRECT,\n \t\t.raw_struct_size = sizeof(struct nd_redirect),\n+\t\t.addrto_validate = ndp_msg_addrto_validate_link_local,\n \t},\n };\n \n@@ -418,7 +426,11 @@ static bool ndp_msg_check_valid(struct ndp_msg *msg)\n \n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n-\treturn true;\n+\n+\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n+\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n+\telse\n+\t\treturn true;\n }\n \n static struct ndp_msg *ndp_msg_alloc(void)""}","static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;

	if (ndp_msg_type_info(msg_type)->addrto_validate)
		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
	else
		return true;
 }
","static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;
	return true;
 }
",C,"
	if (ndp_msg_type_info(msg_type)->addrto_validate)
		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
	else
		return true;
","	return true;
",,"@@ -333,6 +333,7 @@ struct ndp_msg_type_info {
 	uint8_t raw_type;
 	size_t raw_struct_size;
 	void (*addrto_adjust)(struct in6_addr *addr);
+	bool (*addrto_validate)(struct in6_addr *addr);
 };
 
 static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)
@@ -359,6 +360,11 @@ static void ndp_msg_addrto_adjust_all_routers(struct in6_addr *addr)
 	addr->s6_addr32[3] = htonl(0x2);
 }
 
+static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)
+{
+	return IN6_IS_ADDR_LINKLOCAL (addr);
+}
+
 static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 {
 	[NDP_MSG_RS] = {
@@ -371,6 +377,7 @@ static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 		.strabbr = ""RA"",
 		.raw_type = ND_ROUTER_ADVERT,
 		.raw_struct_size = sizeof(struct nd_router_advert),
+		.addrto_validate = ndp_msg_addrto_validate_link_local,
 	},
 	[NDP_MSG_NS] = {
 		.strabbr = ""NS"",
@@ -387,6 +394,7 @@ static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 		.strabbr = ""R"",
 		.raw_type = ND_REDIRECT,
 		.raw_struct_size = sizeof(struct nd_redirect),
+		.addrto_validate = ndp_msg_addrto_validate_link_local,
 	},
 };
 
@@ -418,7 +426,11 @@ static bool ndp_msg_check_valid(struct ndp_msg *msg)
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;
-	return true;
+
+	if (ndp_msg_type_info(msg_type)->addrto_validate)
+		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
+	else
+		return true;
 }
 
 static struct ndp_msg *ndp_msg_alloc(void)",libndp,2af9a55b38b55abbf05fd116ec097d4029115839,a4892df306e0532487f1634ba6d4c6d4bb381c7f,1,"static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;
//flaw_line_below:
	return true;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (ndp_msg_type_info(msg_type)->addrto_validate)
//fix_flaw_line_below:
//		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		return true;
 }
",183143,"static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;
	return true;
 }
","static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;

	if (ndp_msg_type_info(msg_type)->addrto_validate)
		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
	else
		return true;
 }
","The function `ndp_msg_check_valid` verifies the validity of a given NDP (Neighbor Discovery Protocol) message by checking its payload length against the expected size for its message type. It first retrieves the payload length using `ndp_msg_payload_len` and determines the message type with `ndp_msg_type`. The function then compares the actual payload length to the required size, which is obtained from `ndp_msg_type_info(msg_type)->raw_struct_size`. If the payload length is less than the expected size, the function returns `false`, indicating the message is invalid; otherwise, it returns `true`, confirming the message's validity.","The code defines a function that checks the validity of a message by assessing its payload length in relation to the expected size for its specific type. It first determines the actual length of the message's payload and identifies the type of the message. The function then compares the actual payload length to the required size associated with that message type. If the payload length is shorter than the expected size, the function concludes that the message is invalid and returns a negative result; otherwise, it confirms the message's validity with a positive result.","The vulnerability in the original code stemmed from inadequate validation of the source of Neighbor Discovery Protocol messages, which could allow attackers to exploit the system by sending malicious messages, potentially leading to man-in-the-middle attacks or denial of service. The fixed code addresses this issue by adding a check that verifies the validity of the address associated with the message. Specifically, it introduces a conditional statement that calls the `addrto_validate` function if it exists for the message type, ensuring that the address is validated before proceeding. This additional validation step mitigates the risk of accepting unauthorized or malicious messages.","The vulnerability in the original code was due to insufficient validation of the source of Neighbor Discovery Protocol messages, which could enable remote attackers to send malicious messages, leading to potential man-in-the-middle attacks or denial of service. This lack of validation allowed unauthorized nodes to impersonate legitimate routers, disrupting network connectivity. The fixed code addresses this issue by incorporating an additional validation step that checks the legitimacy of the address associated with the message. By ensuring that the address is validated before further processing, the updated code effectively mitigates the risk of accepting harmful or fraudulent messages.","The vulnerability was fixed by adding a validation check for the address associated with the Neighbor Discovery Protocol message. In the updated code, after confirming that the payload length is sufficient, the function now checks if the `addrto_validate` function exists for the message type. If it does, the code calls this function with the address to be validated. This ensures that the address is properly checked before further processing, thereby preventing unauthorized or malicious messages from being accepted. This additional layer of validation significantly enhances the security of the message handling process.","The vulnerability was addressed by implementing an additional validation step that checks the legitimacy of the address associated with the message. After confirming that the message's payload length is adequate, the updated code now verifies whether a validation function for the address exists. If such a function is present, it is invoked to ensure the address is legitimate before any further processing occurs. This enhancement effectively prevents the acceptance of unauthorized or malicious messages, thereby mitigating the risk of man-in-the-middle attacks and improving the overall security of the message handling process.","5,4","4,4","4, 4","4,4","CWE-290,CWE-345,CWE-287,CWE-347,CWE-284,CWE-285,CWE-306,CWE-346,CWE-925,CWE-923",Y,5
21,21,21,183281,183281,,Remote,Not required,,CVE-2016-10130,https://www.cvedetails.com/cve/CVE-2016-10130/,CWE-284,Medium,,Partial,,2017-03-24,4.3,The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.,2017-03-27,,1,https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211,b5c6a1b407b7f8b952bded2789593b68b1876211,http: check certificate validity before clobbering the error variable,2,src/transports/http.c,"{""sha"": ""b4418f69ab37f4836e3933248f4a030332de63b1"", ""filename"": ""src/transports/http.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/b5c6a1b407b7f8b952bded2789593b68b1876211/src/transports/http.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/b5c6a1b407b7f8b952bded2789593b68b1876211/src/transports/http.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/http.c?ref=b5c6a1b407b7f8b952bded2789593b68b1876211"", ""patch"": ""@@ -602,13 +602,12 @@ static int http_connect(http_subtransport *t)\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n-\t\tint is_valid;\n+\t\tint is_valid = (error == GIT_OK);\n \n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \n \t\tgiterr_clear();\n-\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \n \t\tif (error < 0) {""}","static int http_connect(http_subtransport *t)
{
	int error;
	char *proxy_url;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	if (git_stream_supports_proxy(t->io) &&
	    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {
		error = git_stream_set_proxy(t->io, proxy_url);
		git__free(proxy_url);

		if (error < 0)
			return error;
	}

	error = git_stream_connect(t->io);

#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}
#endif
	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","static int http_connect(http_subtransport *t)
{
	int error;
	char *proxy_url;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	if (git_stream_supports_proxy(t->io) &&
	    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {
		error = git_stream_set_proxy(t->io, proxy_url);
		git__free(proxy_url);

		if (error < 0)
			return error;
	}

	error = git_stream_connect(t->io);

#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid;
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}
#endif
	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
",C,"		int is_valid = (error == GIT_OK);
","		int is_valid;
		is_valid = error != GIT_ECERTIFICATE;
",,"@@ -602,13 +602,12 @@ static int http_connect(http_subtransport *t)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
-		int is_valid;
+		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
-		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {",libgit2,b5c6a1b407b7f8b952bded2789593b68b1876211,428e18f8d4765b8ad6cf4022080a81ab16f6fdc4,1,"static int http_connect(http_subtransport *t)
{
	int error;
	char *proxy_url;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	if (git_stream_supports_proxy(t->io) &&
	    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {
		error = git_stream_set_proxy(t->io, proxy_url);
		git__free(proxy_url);

		if (error < 0)
			return error;
	}

	error = git_stream_connect(t->io);

#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
//flaw_line_below:
		int is_valid;
//fix_flaw_line_below:
//		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
//flaw_line_below:
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}
#endif
	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
",183281,"static int http_connect(http_subtransport *t)
{
	int error;
	char *proxy_url;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	if (git_stream_supports_proxy(t->io) &&
	    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {
		error = git_stream_set_proxy(t->io, proxy_url);
		git__free(proxy_url);

		if (error < 0)
			return error;
	}

	error = git_stream_connect(t->io);

#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid;
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
		is_valid = error != GIT_ECERTIFICATE;
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}
#endif
	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","static int http_connect(http_subtransport *t)
{
	int error;
	char *proxy_url;

	if (t->connected &&
		http_should_keep_alive(&t->parser) &&
		t->parse_finished)
		return 0;

	if (t->io) {
		git_stream_close(t->io);
		git_stream_free(t->io);
		t->io = NULL;
		t->connected = 0;
	}

	if (t->connection_data.use_ssl) {
		error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
	} else {
#ifdef GIT_CURL
		error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);
#else
		error = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);
#endif
	}

	if (error < 0)
		return error;

	GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream"");

	if (git_stream_supports_proxy(t->io) &&
	    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {
		error = git_stream_set_proxy(t->io, proxy_url);
		git__free(proxy_url);

		if (error < 0)
			return error;
	}

	error = git_stream_connect(t->io);

#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {
			if (!giterr_last())
				giterr_set(GITERR_NET, ""user cancelled certificate check"");

			return error;
		}
	}
#endif
	if (error < 0)
		return error;

	t->connected = 1;
	return 0;
}
","The `http_connect` function establishes a connection for an HTTP subtransport, managing both secure and non-secure connections based on the provided configuration. It first checks if a connection is already active and whether it should be kept alive; if not, it closes any existing connection. Depending on the SSL requirement, it initializes a new stream using either TLS, cURL, or a socket. If a proxy is supported and configured, it sets the proxy for the stream. The function also performs a certificate check if the connection is encrypted, invoking a user-defined callback for validation. Finally, it updates the connection status.","The code defines a function that manages the establishment of an HTTP connection, ensuring that it is properly initialized and configured based on the connection requirements. It first checks if an existing connection can be reused; if not, it closes any current connection. Depending on whether a secure connection is needed, it creates a new stream using the appropriate method. The function also handles proxy settings if applicable and performs a certificate validation check for secure connections, allowing for user-defined verification. Finally, it updates the connection status to indicate whether the connection was successfully established.","The vulnerability in the original code arises from the improper handling of the error variable, which could be manipulated by an attacker to spoof server responses, leading to potential man-in-the-middle attacks. Specifically, the error variable was not consistently checked before being used in critical operations, allowing an attacker to exploit this oversight. In the fixed code, the validation of the error variable is enhanced, particularly during the certificate check process, where the is_valid variable is explicitly set based on the error state. This ensures that only valid connections are accepted, thereby mitigating the risk of spoofing.","The vulnerability in the original code stemmed from inadequate management of an error variable, which could be manipulated by an attacker to spoof server responses, thereby enabling man-in-the-middle attacks. This oversight allowed the error state to be improperly interpreted, potentially leading to the acceptance of invalid connections. In the revised code, the handling of the error variable was improved by ensuring that its state is consistently validated before critical operations, particularly during the certificate verification process. This enhancement effectively prevents the exploitation of the error variable, thereby safeguarding against potential spoofing attacks.","The vulnerability was fixed by enhancing the validation of the error variable throughout the connection process. In the revised code, after attempting to establish a connection, the error variable is checked more rigorously, particularly during the certificate verification phase. The is_valid variable is explicitly set based on the error state, ensuring that only successful connections are considered valid. Additionally, the code now properly handles the case where the certificate check callback is invoked, ensuring that any errors are appropriately managed and reported. This comprehensive error handling mitigates the risk of spoofing by preventing the acceptance of invalid connections.","The vulnerability was addressed by implementing stricter error handling throughout the connection process. The revised code ensures that the error state is consistently validated before proceeding with critical operations, particularly during the certificate verification stage. By explicitly checking the outcome of connection attempts and setting a validity flag based on this state, the code prevents the acceptance of invalid connections. Additionally, the handling of errors during the certificate check is improved, ensuring that any issues are properly reported and managed. This comprehensive approach effectively mitigates the risk of spoofing attacks by enforcing stricter validation protocols.","4,4","3, 4","3, 4","4,4","CWE-295,CWE-296,CWE-297,CWE-252,CWE-256,CWE-298,CWE-665,CWE-584,CWE-841,CWE-703",N,-1
22,22,22,186226,186226,,Remote,Not required,Partial,CVE-2016-1697,https://www.cvedetails.com/cve/CVE-2016-1697/,CWE-284,Medium,Partial,Partial,,2016-06-05,6.8,"The FrameLoader::startLoad function in WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 51.0.2704.79, does not prevent frame navigations during DocumentLoader detach operations, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",2018-10-30,Bypass ,4,https://github.com/chromium/chromium/commit/1948aefa8901dca0ccb993753fca00b15d2a6e25,1948aefa8901dca0ccb993753fca00b15d2a6e25,"Disable frame navigations during DocumentLoader detach in FrameLoader::startLoad

BUG=613266

Review-Url: https://codereview.chromium.org/2006033002
Cr-Commit-Position: refs/heads/master@{#396241}",1,third_party/WebKit/Source/core/loader/FrameLoader.cpp,"{""sha"": ""dcb2b10d3f77c8ee4d39805cff1ab5c4899cdca3"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach-expected.txt"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach-expected.txt?ref=1948aefa8901dca0ccb993753fca00b15d2a6e25"", ""patch"": ""@@ -0,0 +1 @@\n+We pass if we don't crash. ""}<_**next**_>{""sha"": ""e5f7c75cce009a40af613662ad34d645323b5c69"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach.html"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/navigation/start-load-during-provisional-loader-detach.html?ref=1948aefa8901dca0ccb993753fca00b15d2a6e25"", ""patch"": ""@@ -0,0 +1,27 @@\n+<body>\n+We pass if we don't crash.\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+\n+var child = document.body.appendChild(document.createElement('iframe'));\n+child.contentDocument.open();\n+var grandchild = child.contentDocument.appendChild(document.createElement('iframe'));\n+\n+child.contentWindow.onload = function() {\n+    var a = grandchild.contentDocument.createElement('a');\n+    a.href = 'data:text/xml,';\n+    a.click();\n+}\n+\n+var a = grandchild.contentDocument.createElement('a');\n+a.href = 'data:text/xml,';\n+a.click();\n+\n+child.contentDocument.close();\n+\n+a = grandchild.contentDocument.createElement('a');\n+a.href = 'data:text/html,';\n+a.click();\n+</script>\n+</body>""}<_**next**_>{""sha"": ""013a74ed548e954b81d09d1a9a5978c645690013"", ""filename"": ""third_party/WebKit/Source/core/html/HTMLAnchorElement.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/Source/core/html/HTMLAnchorElement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/Source/core/html/HTMLAnchorElement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/HTMLAnchorElement.cpp?ref=1948aefa8901dca0ccb993753fca00b15d2a6e25"", ""patch"": ""@@ -362,6 +362,8 @@ void HTMLAnchorElement::handleClick(Event* event)\n         }\n         if (hasRel(RelationNoOpener))\n             frameRequest.setShouldSetOpener(NeverSetOpener);\n+        // TODO(japhet): Link clicks can be emulated via JS without a user gesture.\n+        // Why doesn't this go through NavigationScheduler?\n         frame->loader().load(frameRequest);\n     }\n }""}<_**next**_>{""sha"": ""c1c682d307eeb3b3702af5394873188c034fe27b"", ""filename"": ""third_party/WebKit/Source/core/loader/FrameLoader.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/Source/core/loader/FrameLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1948aefa8901dca0ccb993753fca00b15d2a6e25/third_party/WebKit/Source/core/loader/FrameLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/FrameLoader.cpp?ref=1948aefa8901dca0ccb993753fca00b15d2a6e25"", ""patch"": ""@@ -1421,7 +1421,10 @@ void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType ty\n         return;\n \n     m_frame->document()->cancelParsing();\n-    detachDocumentLoader(m_provisionalDocumentLoader);\n+    if (m_provisionalDocumentLoader) {\n+        FrameNavigationDisabler navigationDisabler(*m_frame);\n+        detachDocumentLoader(m_provisionalDocumentLoader);\n+    }\n \n     // beforeunload fired above, and detaching a DocumentLoader can fire\n     // events, which can detach this frame.""}","void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;
    if (!shouldClose(navigationType == NavigationTypeReload))
         return;
 
     m_frame->document()->cancelParsing();
    if (m_provisionalDocumentLoader) {
        FrameNavigationDisabler navigationDisabler(*m_frame);
        detachDocumentLoader(m_provisionalDocumentLoader);
    }
 
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}
","void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;
    if (!shouldClose(navigationType == NavigationTypeReload))
         return;
 
     m_frame->document()->cancelParsing();
    detachDocumentLoader(m_provisionalDocumentLoader);
 
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}
",C,"    if (m_provisionalDocumentLoader) {
        FrameNavigationDisabler navigationDisabler(*m_frame);
        detachDocumentLoader(m_provisionalDocumentLoader);
    }
","    detachDocumentLoader(m_provisionalDocumentLoader);
",,"@@ -1421,7 +1421,10 @@ void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType ty
         return;
 
     m_frame->document()->cancelParsing();
-    detachDocumentLoader(m_provisionalDocumentLoader);
+    if (m_provisionalDocumentLoader) {
+        FrameNavigationDisabler navigationDisabler(*m_frame);
+        detachDocumentLoader(m_provisionalDocumentLoader);
+    }
 
     // beforeunload fired above, and detaching a DocumentLoader can fire
     // events, which can detach this frame.",Chrome,1948aefa8901dca0ccb993753fca00b15d2a6e25,100d03d7637f9ec1f31ae012a7712a44d195c483,1,"void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;
    if (!shouldClose(navigationType == NavigationTypeReload))
         return;
 
     m_frame->document()->cancelParsing();
//flaw_line_below:
    detachDocumentLoader(m_provisionalDocumentLoader);
//fix_flaw_line_below:
//    if (m_provisionalDocumentLoader) {
//fix_flaw_line_below:
//        FrameNavigationDisabler navigationDisabler(*m_frame);
//fix_flaw_line_below:
//        detachDocumentLoader(m_provisionalDocumentLoader);
//fix_flaw_line_below:
//    }
 
     // beforeunload fired above, and detaching a DocumentLoader can fire
     // events, which can detach this frame.
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}
",186226,"void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;
    if (!shouldClose(navigationType == NavigationTypeReload))
         return;
 
     m_frame->document()->cancelParsing();
    detachDocumentLoader(m_provisionalDocumentLoader);
 
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}
","void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)
{
    ASSERT(client()->hasWebView());
    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)
        return;

    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());
    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));
    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);
    ResourceRequest& request = frameLoadRequest.resourceRequest();
    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))
        return;
    if (!shouldClose(navigationType == NavigationTypeReload))
         return;
 
     m_frame->document()->cancelParsing();
    if (m_provisionalDocumentLoader) {
        FrameNavigationDisabler navigationDisabler(*m_frame);
        detachDocumentLoader(m_provisionalDocumentLoader);
    }
 
    if (!m_frame->host())
        return;

    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));
    m_provisionalDocumentLoader->setNavigationType(navigationType);
    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);
    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);

    InspectorInstrumentation::didStartProvisionalLoad(m_frame);

    m_frame->navigationScheduler().cancel();
    m_checkTimer.stop();

    m_loadType = type;

    if (frameLoadRequest.form())
        client()->dispatchWillSubmitForm(frameLoadRequest.form());

    m_progressTracker->progressStarted();
    if (m_provisionalDocumentLoader->isClientRedirect())
        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());
    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());
    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;
    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);
    ASSERT(m_provisionalDocumentLoader);
    m_provisionalDocumentLoader->startLoadingMainResource();

    takeObjectSnapshot();
}
","The `FrameLoader::startLoad` function initiates the loading process for a web frame based on a given load request and navigation type. It first checks if the web view is available and if a page dismissal event is not in progress. The function determines the navigation type and sets the appropriate request context and frame type. It evaluates navigation policies and conditions to decide whether to proceed with loading. If valid, it cancels any ongoing document parsing, creates a provisional document loader, and sets its properties. Finally, it dispatches events related to form submission and loading progress, and starts loading the main resource.","The function initiates the loading process for a web frame by first verifying the availability of the web view and ensuring no ongoing page dismissal event. It determines the type of navigation and configures the request context accordingly. The function assesses various conditions to decide whether to continue with the loading process. If valid, it cancels any current document parsing, creates a new loader for the document, and sets its properties based on the navigation type. Finally, it dispatches relevant events for form submission and loading progress, and begins the loading of the main resource.","The vulnerability in the original code arises from the lack of protection against frame navigations during the detachment of the document loader, which could allow attackers to exploit the Same Origin Policy. Specifically, the absence of a mechanism to disable navigation while detaching the document loader could lead to unauthorized access to sensitive data. In the fixed code, a `FrameNavigationDisabler` is introduced, which is instantiated before detaching the document loader. This effectively prevents any frame navigations during the detachment process, thereby mitigating the risk of bypassing the Same Origin Policy and enhancing overall security.","The vulnerability in the original code stems from the failure to prevent frame navigations while detaching the document loader, which could enable attackers to exploit the Same Origin Policy through malicious JavaScript. This oversight allowed unauthorized access to sensitive information by permitting navigations during a critical operation. The fixed code addresses this issue by introducing a mechanism that disables frame navigation during the detachment process. This enhancement ensures that no navigations can occur while the document loader is being detached, thereby reinforcing the security of the application and preventing potential exploitation of the Same Origin Policy.","The vulnerability was fixed by introducing a `FrameNavigationDisabler` in the modified code, which is instantiated before detaching the document loader. This disabler effectively prevents any frame navigations during the critical operation of detaching the provisional document loader. By wrapping the detachment process with this disabler, the code ensures that no unauthorized navigations can occur while the document loader is being detached, thereby mitigating the risk of bypassing the Same Origin Policy. This change enhances the security of the application by safeguarding against potential exploitation through crafted JavaScript during the detachment phase.","The vulnerability was fixed by implementing a mechanism that temporarily disables frame navigation during the critical operation of detaching the document loader. This enhancement ensures that no navigations can occur while the loader is being detached, effectively preventing unauthorized access to sensitive information. By introducing this protective measure, the code mitigates the risk of exploitation that could arise from allowing navigations during this process. This change significantly strengthens the security posture of the application, ensuring compliance with the Same Origin Policy and safeguarding against potential attacks through malicious scripts.","4, 5","5, 5","4, 5","4,5","CWE-346, CWE-602, CWE-284, CWE-749, CWE-941, CWE-601, CWE-611, CWE-200, CWE-345, CWE-451",N,-1
23,23,23,187290,187290,,Remote,Not required,Partial,CVE-2016-1672,https://www.cvedetails.com/cve/CVE-2016-1672/,CWE-284,Medium,Partial,Partial,,2016-06-05,6.8,"The ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the extension bindings in Google Chrome before 51.0.2704.63 mishandles properties, which allows remote attackers to conduct bindings-interception attacks and bypass the Same Origin Policy via unspecified vectors.",2018-10-30,Bypass ,2,https://github.com/chromium/chromium/commit/75b803b1c81ed9fa5513cbff550232b4fb915e7b,75b803b1c81ed9fa5513cbff550232b4fb915e7b,"[Extensions] Harden against bindings interception

There's more we can do but this is a start.

BUG=590275
BUG=590118

Review URL: https://codereview.chromium.org/1748943002

Cr-Commit-Position: refs/heads/master@{#378621}",2,extensions/renderer/module_system.cc,"{""sha"": ""387576f78c9594f291a0b3d98392fb7d0088d19d"", ""filename"": ""chrome/browser/extensions/extension_bindings_apitest.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/75b803b1c81ed9fa5513cbff550232b4fb915e7b/chrome/browser/extensions/extension_bindings_apitest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/75b803b1c81ed9fa5513cbff550232b4fb915e7b/chrome/browser/extensions/extension_bindings_apitest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_bindings_apitest.cc?ref=75b803b1c81ed9fa5513cbff550232b4fb915e7b"", ""patch"": ""@@ -183,5 +183,30 @@ IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, HandlerFunctionTypeChecking) {\n   EXPECT_EQ(\""success\"", result);\n }\n \n+IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest,\n+                       MoreNativeFunctionInterceptionTests) {\n+  ASSERT_TRUE(embedded_test_server()->Start());\n+\n+  // We need to create runtime bindings in the web page. An extension that's\n+  // externally connectable will do that for us.\n+  ASSERT_TRUE(\n+      LoadExtension(test_data_dir_.AppendASCII(\""bindings\"")\n+                        .AppendASCII(\""externally_connectable_everywhere\"")));\n+\n+  ui_test_utils::NavigateToURL(\n+      browser(),\n+      embedded_test_server()->GetURL(\n+          \""/extensions/api_test/bindings/function_interceptions.html\""));\n+  content::WebContents* web_contents =\n+      browser()->tab_strip_model()->GetActiveWebContents();\n+  EXPECT_FALSE(web_contents->IsCrashed());\n+  // See function_interceptions.html.\n+  std::string result;\n+  EXPECT_TRUE(content::ExecuteScriptAndExtractString(\n+      web_contents, \""window.domAutomationController.send(window.testStatus);\"",\n+      &result));\n+  EXPECT_EQ(\""success\"", result);\n+}\n+\n }  // namespace\n }  // namespace extensions""}<_**next**_>{""sha"": ""07342ca5180c027f9527179fd8a407e1dabe5697"", ""filename"": ""chrome/test/data/extensions/api_test/bindings/function_interceptions.html"", ""status"": ""added"", ""additions"": 56, ""deletions"": 0, ""changes"": 56, ""blob_url"": ""https://github.com/chromium/chromium/blob/75b803b1c81ed9fa5513cbff550232b4fb915e7b/chrome/test/data/extensions/api_test/bindings/function_interceptions.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/75b803b1c81ed9fa5513cbff550232b4fb915e7b/chrome/test/data/extensions/api_test/bindings/function_interceptions.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/bindings/function_interceptions.html?ref=75b803b1c81ed9fa5513cbff550232b4fb915e7b"", ""patch"": ""@@ -0,0 +1,56 @@\n+<body>\n+<script>\n+\n+window.testStatus = '';\n+var objects = ['runtime', 'require', 'test', 'binding'];\n+var leaked = [];\n+\n+function intercept(objectKey) {\n+  Object.defineProperty(Object.prototype, objectKey, {\n+    get: function () {\n+      leaked.push({name: objectKey, obj: this});\n+    },\n+    set: function (v) {\n+      Object.defineProperty(this, objectKey, {\n+        value: v,\n+        configurable: true,\n+        enumerable: true,\n+        writable: true\n+      });\n+    },\n+    configurable: true,\n+  });\n+}\n+\n+// Set up interceptors.\n+for (let objectKey of objects)\n+  intercept(objectKey);\n+\n+// Poke chrome.runtime and chrome.app.\n+try {\n+  chrome.runtime;\n+} catch (e) {}\n+try {\n+  chrome.app;\n+} catch (e) {}\n+\n+// Cleanup - we don't want to be triggering our own interceptors.\n+for (let objKey of objects)\n+  delete Object.prototype[objKey];\n+\n+// Check what we intercepted.\n+var keysToCheck = ['utils', 'binding'];\n+for (let nameAndObj of leaked) {\n+  for (let key of keysToCheck) {\n+    if (!!nameAndObj.obj[key]) {\n+      window.testStatus +=\n+          'Failed: Found ' + key + ' on ' + nameAndObj.name + '\\n';\n+    }\n+  }\n+}\n+\n+if (window.testStatus === '')\n+  window.testStatus = 'success';\n+\n+</script>\n+</body>""}<_**next**_>{""sha"": ""f02741324ae3fd361d4e0fde487b6673d78f182c"", ""filename"": ""extensions/renderer/module_system.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/75b803b1c81ed9fa5513cbff550232b4fb915e7b/extensions/renderer/module_system.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/75b803b1c81ed9fa5513cbff550232b4fb915e7b/extensions/renderer/module_system.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/module_system.cc?ref=75b803b1c81ed9fa5513cbff550232b4fb915e7b"", ""patch"": ""@@ -251,12 +251,12 @@ v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n \n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n-  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n \n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n-  SetProperty(v8_context, modules, module_name, exports);\n+  SetPrivateProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }\n ""}<_**next**_>{""sha"": ""3017772081c73aa1bce6b5d5d315ae77fad6a040"", ""filename"": ""extensions/renderer/v8_helpers.h"", ""status"": ""modified"", ""additions"": 43, ""deletions"": 0, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/75b803b1c81ed9fa5513cbff550232b4fb915e7b/extensions/renderer/v8_helpers.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/75b803b1c81ed9fa5513cbff550232b4fb915e7b/extensions/renderer/v8_helpers.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_helpers.h?ref=75b803b1c81ed9fa5513cbff550232b4fb915e7b"", ""patch"": ""@@ -60,6 +60,9 @@ inline bool IsEmptyOrUndefied(v8::Local<v8::Value> value) {\n \n // SetProperty() family wraps V8::Object::DefineOwnProperty().\n // Returns true on success.\n+// NOTE: Think about whether you want this or SetPrivateProperty() below.\n+// TODO(devlin): Sort through more of the callers of this and see if we can\n+// convert more to be private.\n inline bool SetProperty(v8::Local<v8::Context> context,\n                         v8::Local<v8::Object> object,\n                         v8::Local<v8::String> key,\n@@ -84,8 +87,29 @@ inline bool SetProperty(v8::Local<v8::Context> context,\n   return SetProperty(context, object, base::UintToString(index).c_str(), value);\n }\n \n+// Wraps v8::Object::SetPrivate(). When possible, prefer this to SetProperty().\n+inline bool SetPrivateProperty(v8::Local<v8::Context> context,\n+                               v8::Local<v8::Object> object,\n+                               v8::Local<v8::String> key,\n+                               v8::Local<v8::Value> value) {\n+  return IsTrue(object->SetPrivate(\n+      context, v8::Private::ForApi(context->GetIsolate(), key), value));\n+}\n+\n+inline bool SetPrivateProperty(v8::Local<v8::Context> context,\n+                               v8::Local<v8::Object> object,\n+                               const char* key,\n+                               v8::Local<v8::Value> value) {\n+  v8::Local<v8::String> v8_key;\n+  return ToV8String(context->GetIsolate(), key, &v8_key) &&\n+         IsTrue(object->SetPrivate(\n+             context, v8::Private::ForApi(context->GetIsolate(), v8_key),\n+             value));\n+}\n+\n // GetProperty() family calls V8::Object::Get() and extracts a value from\n // returned MaybeLocal. Returns true on success.\n+// NOTE: Think about whether you want this or GetPrivateProperty() below.\n template <typename Key>\n inline bool GetProperty(v8::Local<v8::Context> context,\n                         v8::Local<v8::Object> object,\n@@ -104,6 +128,25 @@ inline bool GetProperty(v8::Local<v8::Context> context,\n   return GetProperty(context, object, v8_key, out);\n }\n \n+// Wraps v8::Object::GetPrivate(). When possible, prefer this to GetProperty().\n+inline bool GetPrivateProperty(v8::Local<v8::Context> context,\n+                               v8::Local<v8::Object> object,\n+                               v8::Local<v8::String> key,\n+                               v8::Local<v8::Value>* out) {\n+  return object\n+      ->GetPrivate(context, v8::Private::ForApi(context->GetIsolate(), key))\n+      .ToLocal(out);\n+}\n+\n+inline bool GetPrivateProperty(v8::Local<v8::Context> context,\n+                               v8::Local<v8::Object> object,\n+                               const char* key,\n+                               v8::Local<v8::Value>* out) {\n+  v8::Local<v8::String> v8_key;\n+  return ToV8String(context->GetIsolate(), key, &v8_key) &&\n+         GetPrivateProperty(context, object, v8_key, out);\n+}\n+\n // GetPropertyUnsafe() family wraps v8::Object::Get(). They crash when an\n // exception is thrown.\n inline v8::Local<v8::Value> GetPropertyUnsafe(v8::Local<v8::Context> context,""}","v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetPrivateProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
","v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
  if (!GetProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
",C,"  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
  SetPrivateProperty(v8_context, modules, module_name, exports);
","  if (!GetProperty(v8_context, modules, module_name, &exports) ||
  SetProperty(v8_context, modules, module_name, exports);
",,"@@ -251,12 +251,12 @@ v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
-  if (!GetProperty(v8_context, modules, module_name, &exports) ||
+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
-  SetProperty(v8_context, modules, module_name, exports);
+  SetPrivateProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
 ",Chrome,75b803b1c81ed9fa5513cbff550232b4fb915e7b,e69130f5b1a31d11badc7e034252038dc03b8ec6,1,"v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  // The module system might have been deleted. This can happen if a different
  // context keeps a reference to us, but our frame is destroyed (e.g.
  // background page keeps reference to chrome object in a closed popup).
  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
//flaw_line_below:
  if (!GetProperty(v8_context, modules, module_name, &exports) ||
//fix_flaw_line_below:
//  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
//flaw_line_below:
  SetProperty(v8_context, modules, module_name, exports);
//fix_flaw_line_below:
//  SetPrivateProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
",187290,"v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
  if (!GetProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
","v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetPrivateProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
","The `RequireForJsInner` function in the `ModuleSystem` class is designed to manage module loading in a V8 JavaScript environment. It begins by establishing a scoped context for V8 operations and retrieves the global object. The function checks for the existence of a private field containing loaded modules; if absent, it issues a warning and returns `undefined`. If the module is already loaded, it retrieves and returns the exports. If not, it loads the module using its name, stores the exports in the modules object, and finally returns the loaded exports, ensuring proper memory management with an escapable handle scope.","The provided code defines a function that facilitates the loading and retrieval of JavaScript modules within a specific execution context. It first establishes a safe environment for handling V8 objects and checks for the presence of a collection of previously loaded modules. If this collection is missing, it issues a warning and returns an undefined value. If the requested module is already loaded, it retrieves and returns its exports. If not, it loads the module, stores its exports in the collection, and then returns the newly loaded exports, ensuring efficient memory management throughout the process.","The vulnerability in the original code stemmed from improper handling of module properties, which allowed attackers to intercept bindings and potentially bypass the Same Origin Policy. Specifically, the use of `GetProperty` to access module exports could lead to unauthorized access if the properties were not adequately protected. In the fixed code, the function was updated to use `GetPrivateProperty` and `SetPrivateProperty`, which ensures that access to module properties is restricted and properly managed, thereby mitigating the risk of bindings-interception attacks and enhancing the security of the module loading process.","The vulnerability in the original code was due to inadequate protection of module properties, which allowed attackers to exploit the system and intercept bindings, thereby bypassing the Same Origin Policy. This weakness arose from the use of general property access methods that did not enforce strict access controls. The fixed code addressed this issue by implementing specialized methods for accessing and setting properties that ensure proper encapsulation and security. By restricting access to module properties, the updated code effectively mitigates the risk of unauthorized manipulation and enhances the overall security of the module loading mechanism.","The vulnerability was fixed by replacing the general property access methods with more secure alternatives. In the updated code, `GetProperty` was changed to `GetPrivateProperty`, and `SetProperty` was replaced with `SetPrivateProperty`. This change ensures that access to module properties is restricted and properly managed, preventing unauthorized access and manipulation. By using these private property methods, the code enforces stricter encapsulation, thereby mitigating the risk of bindings-interception attacks and reinforcing the integrity of the module loading process within the extension bindings of the system.","The vulnerability was fixed by enhancing the security of property access within the module system. The updated code replaced general property access methods with specialized private access methods, which enforce stricter controls over how properties are retrieved and set. This change ensures that only authorized components can interact with sensitive module properties, effectively preventing unauthorized manipulation and interception. By implementing these more secure access mechanisms, the code mitigates the risk of attacks that could exploit property mishandling, thereby reinforcing the overall security of the module loading process and maintaining adherence to the Same Origin Policy.","4,4","4,5","4,4","4,5","CWE-915,CWE-913,CWE-265,CWE-668,CWE-269,CWE-284,CWE-732,CWE-706,CWE-749,CWE-664",Y,6
24,24,24,187301,187301,,Remote,Not required,Partial,CVE-2016-1675,https://www.cvedetails.com/cve/CVE-2016-1675/,CWE-284,Medium,Partial,Partial,,2016-06-05,6.8,"Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Same Origin Policy by leveraging the mishandling of Document reattachment during destruction, related to FrameLoader.cpp and LocalFrame.cpp.",2018-10-30,Bypass ,1,https://github.com/chromium/chromium/commit/b276d0570cc816bfe25b431f2ee9bc265a6ad478,b276d0570cc816bfe25b431f2ee9bc265a6ad478,"Fix one implicit 64-bit -> 32-bit implicit conversion in a PPAPI test.

../../ppapi/tests/test_url_loader.cc:877:11: warning: implicit conversion loses integer precision: 'int64_t' (aka 'long long') to 'int32_t' (aka 'int') [-Wshorten-64-to-32]
          total_bytes_to_be_received);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~

BUG=879657

Change-Id: I152f456368131fe7a2891ff0c97bf83f26ef0906
Reviewed-on: https://chromium-review.googlesource.com/c/1220173
Commit-Queue: Raymes Khoury <raymes@chromium.org>
Reviewed-by: Raymes Khoury <raymes@chromium.org>
Cr-Commit-Position: refs/heads/master@{#600182}",1,ppapi/tests/test_url_loader.cc,"{""sha"": ""9f68aec324c90b63fd77afcd4ab4b6cf64bc074f"", ""filename"": ""ppapi/tests/test_url_loader.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b276d0570cc816bfe25b431f2ee9bc265a6ad478/ppapi/tests/test_url_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b276d0570cc816bfe25b431f2ee9bc265a6ad478/ppapi/tests/test_url_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_url_loader.cc?ref=b276d0570cc816bfe25b431f2ee9bc265a6ad478"", ""patch"": ""@@ -874,7 +874,7 @@ std::string TestURLLoader::TestUntendedLoad() {\n     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);\n     if (total_bytes_to_be_received <= 0)\n       return ReportError(\""URLLoader::GetDownloadProgress total size\"",\n-          total_bytes_to_be_received);\n+                         static_cast<int32_t>(total_bytes_to_be_received));\n     if (bytes_received == total_bytes_to_be_received)\n       break;\n     // Yield if we're on the main thread, so that URLLoader can receive more""}","std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
                         static_cast<int32_t>(total_bytes_to_be_received));
     if (bytes_received == total_bytes_to_be_received)
       break;
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
","std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
          total_bytes_to_be_received);
     if (bytes_received == total_bytes_to_be_received)
       break;
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
",C,"                         static_cast<int32_t>(total_bytes_to_be_received));
","          total_bytes_to_be_received);
",,"@@ -874,7 +874,7 @@ std::string TestURLLoader::TestUntendedLoad() {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
-          total_bytes_to_be_received);
+                         static_cast<int32_t>(total_bytes_to_be_received));
     if (bytes_received == total_bytes_to_be_received)
       break;
     // Yield if we're on the main thread, so that URLLoader can receive more",Chrome,b276d0570cc816bfe25b431f2ee9bc265a6ad478,3c2801499ff7a9ebed9460105175d3bc39399a0a,1,"std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  // We received the response callback. Yield until the network code has called
  // the loader's didReceiveData and didFinishLoading methods before we give it
  // another callback function, to make sure the loader works with no callback.
  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
//flaw_line_below:
          total_bytes_to_be_received);
//fix_flaw_line_below:
//                         static_cast<int32_t>(total_bytes_to_be_received));
     if (bytes_received == total_bytes_to_be_received)
       break;
     // Yield if we're on the main thread, so that URLLoader can receive more
    // data.
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  // The loader should now have the data and have finished successfully.
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
",187301,"std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
          total_bytes_to_be_received);
     if (bytes_received == total_bytes_to_be_received)
       break;
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
","std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
                         static_cast<int32_t>(total_bytes_to_be_received));
     if (bytes_received == total_bytes_to_be_received)
       break;
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
","The provided code defines a function `TestUntendedLoad` within the `TestURLLoader` class, which tests the functionality of a URL loader in a Pepper Plugin API environment. It initiates a URL request to load a text file, ""hello.txt"", while tracking download progress. A callback mechanism is employed to handle the asynchronous loading process, ensuring the request completes successfully. The function continuously checks the download progress until the entire file is received. Once downloaded, it reads the response body and verifies its content against the expected string ""hello\n"". If any errors occur during this process, they are reported accordingly.","The code implements a function that tests the loading of a text file from a specified URL within a plugin environment. It sets up a request to retrieve the file while enabling download progress tracking. A callback mechanism is used to handle the asynchronous nature of the loading process, ensuring it completes successfully. The function continuously monitors the download progress until the entire file is received. After the download, it reads the content of the file and checks if it matches the expected output. Any errors encountered during the process are reported, ensuring robust error handling.","The vulnerability in the original code arises from improper handling of document reattachment during destruction, which can lead to a bypass of the Same Origin Policy, allowing unauthorized access to resources. This is evident in the lack of checks around the download progress and response handling, which could be exploited by an attacker to manipulate the loading process. In the fixed code, the addition of a check for `total_bytes_to_be_received` ensures that the download progress is validated before proceeding, thus preventing potential exploitation. Additionally, the use of `static_cast<int32_t>` in the error reporting enhances type safety, further mitigating risks associated with improper data handling.","The vulnerability in the original code stems from inadequate handling of document reattachment during the destruction process, which can allow attackers to circumvent the Same Origin Policy and access restricted resources. This oversight creates a potential security risk where unauthorized content could be loaded or manipulated. The fixed code addresses this vulnerability by implementing a validation check for the total bytes to be received before proceeding with the download progress. This ensures that the loading process is properly monitored and controlled, thereby preventing exploitation and reinforcing the integrity of the security policy.","The vulnerability was fixed by adding a validation check for `total_bytes_to_be_received` in the download progress monitoring loop. Specifically, the code now verifies that `total_bytes_to_be_received` is greater than zero before proceeding, which prevents the function from continuing with an invalid state that could be exploited. If the total size is not valid, an error is reported using `ReportError`, ensuring that the process halts appropriately. This change enhances the robustness of the download handling by ensuring that only valid and expected data sizes are processed, thereby mitigating the risk of bypassing security policies.","The vulnerability was fixed by implementing a validation check to ensure that the total size of the data to be received is greater than zero before proceeding with the download process. This additional check prevents the function from continuing under invalid conditions that could be exploited by attackers. If the total size is not valid, the process is halted, and an error is reported, thereby enhancing the overall security of the data loading mechanism. This change ensures that only legitimate and expected data sizes are processed, reinforcing the integrity of the security policy.","4,5","3, 4","4,3","4,4","CWE-20, CWE-789, CWE-1284, CWE-130, CWE-606, CWE-698, CWE-1321, CWE-1284, CWE-680, CWE-1188",N,-1
25,25,25,187307,187307,,Remote,Not required,,CVE-2016-1682,https://www.cvedetails.com/cve/CVE-2016-1682/,CWE-284,Medium,,Partial,,2016-06-05,4.3,"The ServiceWorkerContainer::registerServiceWorkerImpl function in WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp in Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a ServiceWorker registration.",2018-10-30,Bypass ,8,https://github.com/chromium/chromium/commit/5289a5d4c98681e9a0f2d28da0c7aa35e282db57,5289a5d4c98681e9a0f2d28da0c7aa35e282db57,"Check CSP before registering ServiceWorkers

Service Worker registrations should be subject to the same CSP checks as
other workers. The spec doesn't say this explicitly
(https://www.w3.org/TR/CSP2/#directive-child-src-workers says ""Worker or
SharedWorker constructors""), but it seems to be in the spirit of things,
and it matches Firefox's behavior.

BUG=579801

Review URL: https://codereview.chromium.org/1861253004

Cr-Commit-Position: refs/heads/master@{#385775}",0,third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp,"{""sha"": ""8b1a393741c96c03c3712b4c80b3d2bcd06959b6"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/resources/service-worker.js"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/resources/service-worker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/resources/service-worker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/resources/service-worker.js?ref=5289a5d4c98681e9a0f2d28da0c7aa35e282db57"", ""patch"": ""@@ -0,0 +1 @@\n+// empty""}<_**next**_>{""sha"": ""3e8d5cd6c839445e5e98792e23fe226efacd1ba4"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-allowed.html"", ""status"": ""added"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-allowed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-allowed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-allowed.html?ref=5289a5d4c98681e9a0f2d28da0c7aa35e282db57"", ""patch"": ""@@ -0,0 +1,14 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<meta http-equiv=\""Content-Security-Policy\"" content=\""child-src 'self';\"">\n+<script src=\""../../resources/testharness.js\""></script>\n+<script src=\""../../resources/testharnessreport.js\""></script>\n+<script>\n+    var t = async_test('Test that a service worker can be registered');\n+    navigator.serviceWorker.register(\""resources/service-worker.js\"").then(function (registration) {\n+        t.done();\n+    });\n+</script>\n+</head>\n+<body>""}<_**next**_>{""sha"": ""c13ecd8b5cb514b03dcf12573b424914e04f3ca7"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked-expected.txt"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked-expected.txt?ref=5289a5d4c98681e9a0f2d28da0c7aa35e282db57"", ""patch"": ""@@ -0,0 +1,6 @@\n+CONSOLE ERROR: Refused to create a child context containing 'http://127.0.0.1:8000/security/contentSecurityPolicy/resources/service-worker.js' because it violates the following Content Security Policy directive: \""child-src 'none'\"".\n+\n+This is a testharness.js-based test.\n+PASS Test that a service worker cannot be registered if the CSP does not allow it \n+Harness: the test ran to completion.\n+""}<_**next**_>{""sha"": ""ba630374160037b637e9a76b263334e867d7d960"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/service-worker-blocked.html?ref=5289a5d4c98681e9a0f2d28da0c7aa35e282db57"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<meta http-equiv=\""Content-Security-Policy\"" content=\""child-src 'none';\"">\n+<script src=\""../../resources/testharness.js\""></script>\n+<script src=\""../../resources/testharnessreport.js\""></script>\n+<script>\n+    var t = async_test('Test that a service worker cannot be registered if the CSP does not allow it');\n+    navigator.serviceWorker.register(\""resources/service-worker.js\"").then(function (registration) {\n+    }).catch(function (error) {\n+        t.done();\n+    });\n+</script>\n+</head>\n+<body>""}<_**next**_>{""sha"": ""6c35d005c8e7f42f7e7a8c14459559b05149476b"", ""filename"": ""third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5289a5d4c98681e9a0f2d28da0c7aa35e282db57/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp?ref=5289a5d4c98681e9a0f2d28da0c7aa35e282db57"", ""patch"": ""@@ -42,6 +42,7 @@\n #include \""core/dom/MessagePort.h\""\n #include \""core/frame/LocalDOMWindow.h\""\n #include \""core/frame/UseCounter.h\""\n+#include \""core/frame/csp/ContentSecurityPolicy.h\""\n #include \""modules/EventTargetModules.h\""\n #include \""modules/serviceworkers/ServiceWorker.h\""\n #include \""modules/serviceworkers/ServiceWorkerContainerClient.h\""\n@@ -246,6 +247,14 @@ void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executi\n         return;\n     }\n \n+    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();\n+    if (csp) {\n+        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {\n+            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\""Failed to register a ServiceWorker: The provided scriptURL ('\"" + scriptURL.getString() + \""') violates the Content Security Policy.\"")));\n+            return;\n+        }\n+    }\n+\n     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n }\n ""}","void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
         return;
     }
 
    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
    if (csp) {
        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
            return;
        }
    }

     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
","void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
         return;
     }
 
     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
",C,"    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
    if (csp) {
        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
            return;
        }
    }

",,,"@@ -42,6 +42,7 @@
 #include ""core/dom/MessagePort.h""
 #include ""core/frame/LocalDOMWindow.h""
 #include ""core/frame/UseCounter.h""
+#include ""core/frame/csp/ContentSecurityPolicy.h""
 #include ""modules/EventTargetModules.h""
 #include ""modules/serviceworkers/ServiceWorker.h""
 #include ""modules/serviceworkers/ServiceWorkerContainerClient.h""
@@ -246,6 +247,14 @@ void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executi
         return;
     }
 
+    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
+    if (csp) {
+        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
+            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
+            return;
+        }
+    }
+
     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
 ",Chrome,5289a5d4c98681e9a0f2d28da0c7aa35e282db57,e8c18394d174db7d105416a87115131a13e1bbb1,1,"void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
         return;
     }
 
//fix_flaw_line_below:
//    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
//fix_flaw_line_below:
//    if (csp) {
//fix_flaw_line_below:
//        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
//fix_flaw_line_below:
//            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
//fix_flaw_line_below:
//            return;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
",187307,"void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
         return;
     }
 
     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
","void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
{
    if (!m_provider) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
        return;
    }

    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
    String errorMessage;
    if (!executionContext->isSecureContext(errorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
        return;
    }

    KURL pageURL = KURL(KURL(), documentOrigin->toString());
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
        return;
    }

    KURL scriptURL = rawScriptURL;
    scriptURL.removeFragmentIdentifier();
    if (!documentOrigin->canRequest(scriptURL)) {
        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
        return;
    }

    KURL patternURL = scope;
    patternURL.removeFragmentIdentifier();

    if (!documentOrigin->canRequest(patternURL)) {
        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
        return;
    }
    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
        return;
    }

    WebString webErrorMessage;
    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
         return;
     }
 
    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
    if (csp) {
        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
            return;
        }
    }

     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
 }
","The `registerServiceWorkerImpl` function is responsible for registering a Service Worker in a web context, ensuring that various security and validity checks are met before proceeding. It first verifies the document's state and security context, checking if the current origin is secure and if the URL schemes of the page, script, and scope are allowed for Service Workers. If any checks fail, appropriate error messages are generated and passed to the provided callback. If all validations succeed, the function calls the provider to register the Service Worker with the specified scope and script URL, facilitating background processing for web applications.","The function is designed to register a Service Worker while ensuring that several critical conditions are met for security and validity. It checks if the document is in a valid state and whether the current context is secure. The function verifies that the URL schemes of the page, script, and scope are permitted for Service Workers. If any of these checks fail, it generates specific error messages to inform the user. Upon successful validation, it proceeds to register the Service Worker, enabling background processing capabilities for web applications, thereby enhancing their functionality and performance.","The vulnerability in the original code allowed remote attackers to bypass the Content Security Policy (CSP) by registering a Service Worker without validating the script's compliance with the CSP. This was due to the absence of checks that ensured the provided script URL adhered to the defined security policies. In the fixed code, a new validation step was introduced, where the Content Security Policy is retrieved using `executionContext->contentSecurityPolicy()`, and the script URL is checked against the CSP using `csp->allowWorkerContextFromSource()`. This ensures that only scripts compliant with the CSP can be registered, effectively mitigating the vulnerability.","The vulnerability allowed remote attackers to bypass the Content Security Policy (CSP) during Service Worker registration, potentially leading to unauthorized script execution and security breaches. This occurred because the original code did not validate whether the script being registered complied with the CSP, leaving a gap for exploitation. The fix introduced a validation step that checks the script against the CSP before registration. By ensuring that only scripts adhering to the defined security policies can be registered, the updated code effectively mitigates the risk of CSP bypass, enhancing the overall security of the application.","The vulnerability was fixed by adding a validation step that checks the provided script URL against the Content Security Policy (CSP) before proceeding with the Service Worker registration. In the updated code, the CSP is retrieved using `executionContext->contentSecurityPolicy()`, and the script URL is validated through `csp->allowWorkerContextFromSource()`. This ensures that the script complies with the defined security policies. If the script violates the CSP, an error is generated and passed to the callback, preventing the registration of potentially harmful scripts and thereby closing the security gap that allowed CSP bypass.","The vulnerability was fixed by introducing a validation mechanism that checks the provided script against the Content Security Policy (CSP) before allowing the Service Worker registration. This additional step ensures that any script intended for registration complies with the security policies defined for the application. If the script does not meet the CSP requirements, an error is generated and communicated back to the user, effectively preventing the registration of potentially malicious scripts. This enhancement significantly strengthens the security posture by ensuring that only compliant scripts can be registered, thereby mitigating the risk of unauthorized script execution.","5,5","5,5","4,4","5, 5","CWE-693, CWE-353, CWE-346, CWE-94, CWE-284, CWE-345, CWE-1021, CWE-358, CWE-290, CWE-1236",N,-1
26,26,26,187426,187426,,Remote,Not required,Complete,CVE-2016-3899,https://www.cvedetails.com/cve/CVE-2016-3899/,CWE-284,Medium,,,,2016-09-11,7.1,"OMXCodec.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not validate a certain pointer, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29421811.",2017-08-12,DoS ,3,https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64,97837bb6cbac21ea679843a0037779d3834bed64,"OMXCodec: check IMemory::pointer() before using allocation

Bug: 29421811
Change-Id: I0a73ba12bae4122f1d89fc92e5ea4f6a96cd1ed1
",1,media/libstagefright/OMXCodec.cpp,"{""filename"": ""media/libstagefright/OMXCodec.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64/media/libstagefright/OMXCodec.cpp"", ""patch"": ""@@ -1622,7 +1622,9 @@\n\n \n     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {\n         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);\n-        CHECK(mem.get() != NULL);\n+        if (mem == NULL || mem->pointer() == NULL) {\n+            return NO_MEMORY;\n+        }\n \n         BufferInfo info;\n         info.mData = NULL;\n""}","status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
 return allocateOutputBuffersFromNativeWindow();
 }

 if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
 return PERMISSION_DENIED;
 }

 status_t err = OK;
 if ((mFlags & kStoreMetaDataInVideoBuffers)
 && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
 return err;
 }
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

 if (err != OK) {
 return err;
 }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

 if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
 return BAD_VALUE;
 }
 size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        if (mem == NULL || mem->pointer() == NULL) {
            return NO_MEMORY;
        }
 
         BufferInfo info;
         info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
 if (portIndex == kPortIndexInput
 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
 || (mFlags & kUseSecureInputBuffers))) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else if (portIndex == kPortIndexOutput
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
 }

 if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
 return err;
 }

 if (mem != NULL) {
            info.mData = mem->pointer();
 }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

 if (portIndex == kPortIndexOutput) {
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
 && (mQuirks & kDefersOutputBufferAllocation)),
 ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
 }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
 }

 if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
 int32_t delay = 0;
 if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
 }
 int32_t padding = 0;
 if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
 }
 int32_t numchannels = 0;
 if (delay + padding) {
 if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
 size_t frameSize = numchannels * sizeof(int16_t);
 if (mSkipCutBuffer != NULL) {
 size_t prevbuffersize = mSkipCutBuffer->size();
 if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
 }
 }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
 }
 }
 }


 if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
 Vector<MediaBuffer *> buffers;
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
 const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

 MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
 }

 status_t err = mSource->setBuffers(buffers);

 if (err != OK) {
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
 }
            buffers.clear();

            CODEC_LOGE(
 ""Codec requested to use secure input buffers but ""
 ""upstream source didn't support that."");

 return err;
 }
 }

 return OK;
}
","status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
 return allocateOutputBuffersFromNativeWindow();
 }

 if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
 return PERMISSION_DENIED;
 }

 status_t err = OK;
 if ((mFlags & kStoreMetaDataInVideoBuffers)
 && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
 return err;
 }
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

 if (err != OK) {
 return err;
 }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

 if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
 return BAD_VALUE;
 }
 size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        CHECK(mem.get() != NULL);
 
         BufferInfo info;
         info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
 if (portIndex == kPortIndexInput
 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
 || (mFlags & kUseSecureInputBuffers))) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else if (portIndex == kPortIndexOutput
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
 }

 if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
 return err;
 }

 if (mem != NULL) {
            info.mData = mem->pointer();
 }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

 if (portIndex == kPortIndexOutput) {
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
 && (mQuirks & kDefersOutputBufferAllocation)),
 ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
 }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
 }

 if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
 int32_t delay = 0;
 if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
 }
 int32_t padding = 0;
 if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
 }
 int32_t numchannels = 0;
 if (delay + padding) {
 if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
 size_t frameSize = numchannels * sizeof(int16_t);
 if (mSkipCutBuffer != NULL) {
 size_t prevbuffersize = mSkipCutBuffer->size();
 if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
 }
 }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
 }
 }
 }


 if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
 Vector<MediaBuffer *> buffers;
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
 const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

 MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
 }

 status_t err = mSource->setBuffers(buffers);

 if (err != OK) {
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
 }
            buffers.clear();

            CODEC_LOGE(
 ""Codec requested to use secure input buffers but ""
 ""upstream source didn't support that."");

 return err;
 }
 }

 return OK;
}
",C,"        if (mem == NULL || mem->pointer() == NULL) {
            return NO_MEMORY;
        }
","        CHECK(mem.get() != NULL);
",,"@@ -1622,7 +1622,9 @@

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
-        CHECK(mem.get() != NULL);
+        if (mem == NULL || mem->pointer() == NULL) {
+            return NO_MEMORY;
+        }
 
         BufferInfo info;
         info.mData = NULL;
",Android,https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64/,https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64%5E/,1,"status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
 return allocateOutputBuffersFromNativeWindow();
 }

 if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
 return PERMISSION_DENIED;
 }

 status_t err = OK;
 if ((mFlags & kStoreMetaDataInVideoBuffers)
 && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
 return err;
 }
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

 if (err != OK) {
 return err;
 }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

 if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
 return BAD_VALUE;
 }
 size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
//flaw_line_below:
        CHECK(mem.get() != NULL);
//fix_flaw_line_below:
//        if (mem == NULL || mem->pointer() == NULL) {
//fix_flaw_line_below:
//            return NO_MEMORY;
//fix_flaw_line_below:
//        }
 
         BufferInfo info;
         info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
 if (portIndex == kPortIndexInput
 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
 || (mFlags & kUseSecureInputBuffers))) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else if (portIndex == kPortIndexOutput
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
 }

 if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
 return err;
 }

 if (mem != NULL) {
            info.mData = mem->pointer();
 }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

 if (portIndex == kPortIndexOutput) {
 // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;
 // this legacy mode is no longer supported.
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
 && (mQuirks & kDefersOutputBufferAllocation)),
 ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
 }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
 }

 if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
 int32_t delay = 0;
 if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
 }
 int32_t padding = 0;
 if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
 }
 int32_t numchannels = 0;
 if (delay + padding) {
 if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
 size_t frameSize = numchannels * sizeof(int16_t);
 if (mSkipCutBuffer != NULL) {
 size_t prevbuffersize = mSkipCutBuffer->size();
 if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
 }
 }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
 }
 }
 }

 // dumpPortStatus(portIndex);

 if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
 Vector<MediaBuffer *> buffers;
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
 const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

 MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
 }

 status_t err = mSource->setBuffers(buffers);

 if (err != OK) {
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
 }
            buffers.clear();

            CODEC_LOGE(
 ""Codec requested to use secure input buffers but ""
 ""upstream source didn't support that."");

 return err;
 }
 }

 return OK;
}
",187426,"status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
 return allocateOutputBuffersFromNativeWindow();
 }

 if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
 return PERMISSION_DENIED;
 }

 status_t err = OK;
 if ((mFlags & kStoreMetaDataInVideoBuffers)
 && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
 return err;
 }
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

 if (err != OK) {
 return err;
 }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

 if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
 return BAD_VALUE;
 }
 size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        CHECK(mem.get() != NULL);
 
         BufferInfo info;
         info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
 if (portIndex == kPortIndexInput
 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
 || (mFlags & kUseSecureInputBuffers))) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else if (portIndex == kPortIndexOutput
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
 }

 if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
 return err;
 }

 if (mem != NULL) {
            info.mData = mem->pointer();
 }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

 if (portIndex == kPortIndexOutput) {
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
 && (mQuirks & kDefersOutputBufferAllocation)),
 ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
 }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
 }

 if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
 int32_t delay = 0;
 if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
 }
 int32_t padding = 0;
 if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
 }
 int32_t numchannels = 0;
 if (delay + padding) {
 if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
 size_t frameSize = numchannels * sizeof(int16_t);
 if (mSkipCutBuffer != NULL) {
 size_t prevbuffersize = mSkipCutBuffer->size();
 if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
 }
 }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
 }
 }
 }


 if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
 Vector<MediaBuffer *> buffers;
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
 const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

 MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
 }

 status_t err = mSource->setBuffers(buffers);

 if (err != OK) {
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
 }
            buffers.clear();

            CODEC_LOGE(
 ""Codec requested to use secure input buffers but ""
 ""upstream source didn't support that."");

 return err;
 }
 }

 return OK;
}
","status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
 return allocateOutputBuffersFromNativeWindow();
 }

 if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
        ALOGE(""protected output buffers must be stent to an ANativeWindow"");
 return PERMISSION_DENIED;
 }

 status_t err = OK;
 if ((mFlags & kStoreMetaDataInVideoBuffers)
 && portIndex == kPortIndexInput) {
        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 if (err != OK) {
            ALOGE(""Storing meta data in video buffers is not supported"");
 return err;
 }
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;

    err = mOMX->getParameter(
            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));

 if (err != OK) {
 return err;
 }

    CODEC_LOGV(""allocating %u buffers of size %u on %s port"",
            def.nBufferCountActual, def.nBufferSize,
            portIndex == kPortIndexInput ? ""input"" : ""output"");

 if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
 return BAD_VALUE;
 }
 size_t totalSize = def.nBufferCountActual * def.nBufferSize;
    mDealer[portIndex] = new MemoryDealer(totalSize, ""OMXCodec"");

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        if (mem == NULL || mem->pointer() == NULL) {
            return NO_MEMORY;
        }
 
         BufferInfo info;
         info.mData = NULL;
        info.mSize = def.nBufferSize;

        IOMX::buffer_id buffer;
 if (portIndex == kPortIndexInput
 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
 || (mFlags & kUseSecureInputBuffers))) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else if (portIndex == kPortIndexOutput
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
 if (mOMXLivesLocally) {
                mem.clear();

                err = mOMX->allocateBuffer(
                        mNode, portIndex, def.nBufferSize, &buffer,
 &info.mData);
 } else {
                err = mOMX->allocateBufferWithBackup(
                        mNode, portIndex, mem, &buffer, mem->size());
 }
 } else {
            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
 }

 if (err != OK) {
            ALOGE(""allocate_buffer_with_backup failed"");
 return err;
 }

 if (mem != NULL) {
            info.mData = mem->pointer();
 }

        info.mBuffer = buffer;
        info.mStatus = OWNED_BY_US;
        info.mMem = mem;
        info.mMediaBuffer = NULL;

 if (portIndex == kPortIndexOutput) {
            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally
 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
 && (mQuirks & kDefersOutputBufferAllocation)),
 ""allocateBuffersOnPort cannot defer buffer allocation"");

            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
            info.mMediaBuffer->setObserver(this);
 }

        mPortBuffers[portIndex].push(info);

        CODEC_LOGV(""allocated buffer %u on %s port"", buffer,
             portIndex == kPortIndexInput ? ""input"" : ""output"");
 }

 if (portIndex == kPortIndexOutput) {

        sp<MetaData> meta = mSource->getFormat();
 int32_t delay = 0;
 if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
            delay = 0;
 }
 int32_t padding = 0;
 if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
            padding = 0;
 }
 int32_t numchannels = 0;
 if (delay + padding) {
 if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
 size_t frameSize = numchannels * sizeof(int16_t);
 if (mSkipCutBuffer != NULL) {
 size_t prevbuffersize = mSkipCutBuffer->size();
 if (prevbuffersize != 0) {
                        ALOGW(""Replacing SkipCutBuffer holding %zu bytes"", prevbuffersize);
 }
 }
                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
 }
 }
 }


 if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {
 Vector<MediaBuffer *> buffers;
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
 const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);

 MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
            buffers.push(mbuf);
 }

 status_t err = mSource->setBuffers(buffers);

 if (err != OK) {
 for (size_t i = 0; i < def.nBufferCountActual; ++i) {
                buffers.editItemAt(i)->release();
 }
            buffers.clear();

            CODEC_LOGE(
 ""Codec requested to use secure input buffers but ""
 ""upstream source didn't support that."");

 return err;
 }
 }

 return OK;
}
","The `OMXCodec::allocateBuffersOnPort` function is responsible for allocating buffers for a specified port in an OMX (OpenMAX) codec. It first checks if the native window is available for output ports and handles protected output buffer requirements. Depending on flags set for metadata storage and buffer allocation quirks, it retrieves port definitions and allocates memory using a `MemoryDealer`. The function manages both input and output buffers, ensuring proper allocation methods are used based on the codec's configuration. It also handles metadata related to encoder delay and padding, and ensures secure input buffers are supported by the upstream source before returning the status of the allocation process.","The provided code defines a function that allocates buffers for a specified port in a multimedia codec. It checks for conditions related to output buffers and protected content, and manages metadata storage settings. The function retrieves parameters for the port, calculates the required buffer sizes, and allocates memory accordingly. It handles different allocation methods based on the port type and codec configuration, ensuring that buffers are properly initialized. Additionally, it manages metadata related to audio encoding, verifying compatibility with upstream sources for secure input buffers, and returns the status of the allocation process.","The vulnerability in the original code arises from the lack of validation for a pointer before it is used, which could lead to a denial of service if an attacker provides a crafted media file. Specifically, the code does not check if the memory allocation for buffers is successful, allowing a null pointer to be dereferenced, potentially causing device hangs or reboots. In the fixed code, an additional check was introduced to ensure that the allocated memory is not null by verifying `if (mem == NULL || mem->pointer() == NULL)`, which prevents the use of invalid pointers and enhances the overall stability and security of the buffer allocation process.","The vulnerability in the original code stems from the failure to validate a pointer before its use, which could lead to a denial of service if an attacker exploits this oversight with a specially crafted media file. This lack of validation allows for the possibility of dereferencing a null or invalid pointer, resulting in device instability, such as hangs or reboots. The fixed code addresses this issue by introducing checks to ensure that the allocated memory is valid and not null before proceeding with any operations, thereby preventing the exploitation of this vulnerability and enhancing the overall robustness of the system.","The vulnerability was fixed by adding a validation check for the allocated memory in the buffer allocation process. Specifically, the code now includes a condition that verifies whether the memory pointer is null or if the pointer returned by the memory allocation is null, using the expression `if (mem == NULL || mem->pointer() == NULL)`. This check ensures that the program does not proceed with operations on invalid memory, thereby preventing potential dereferencing of null pointers. By implementing this safeguard, the code enhances its resilience against crafted media files that could lead to denial of service.","The vulnerability was fixed by introducing a validation step to ensure that the allocated memory is valid before it is used. This involved adding a condition to check whether the memory allocation was successful and whether the pointer to the allocated memory is not null. By implementing this check, the code prevents any operations from being performed on invalid or null pointers, thereby mitigating the risk of dereferencing issues that could lead to device instability or crashes. This enhancement significantly improves the robustness and security of the buffer allocation process against crafted inputs.","5,5","5, 5","4,4","5,5","CWE-476, CWE-119, CWE-401, CWE-789, CWE-763, CWE-415, CWE-762, CWE-825, CWE-573, CWE-590",N,-1
27,27,27,187434,187434,,Remote,Not required,Complete,CVE-2016-3879,https://www.cvedetails.com/cve/CVE-2016-3879/,CWE-284,Medium,,,,2016-09-11,7.1,"arm-wt-22k/lib_src/eas_mdls.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 allows remote attackers to cause a denial of service (NULL pointer dereference, and device hang or reboot) via a crafted media file, aka internal bug 29770686.",2017-08-12,DoS ,4,https://android.googlesource.com/platform/external/sonivox/+/cadfb7a3c96d4fef06656cf37143e1b3e62cae86,cadfb7a3c96d4fef06656cf37143e1b3e62cae86,"Fix NULL pointer dereference

Bug: 29770686
Bug: 23304983
Change-Id: I1648aab90bc281702a00744bf884ae8bb8009412
",2,arm-wt-22k/lib_src/eas_mdls.c,"{""filename"": ""arm-wt-22k/lib_src/eas_mdls.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/sonivox/+/cadfb7a3c96d4fef06656cf37143e1b3e62cae86/arm-wt-22k/lib_src/eas_mdls.c"", ""patch"": ""@@ -683,8 +683,10 @@\n\n     }\n \n     /* create the default articulation */\n-    Convert_art(&dls, &defaultArt, 0);\n-    dls.artCount = 1;\n+    if (dls.pDLS) {\n+        Convert_art(&dls, &defaultArt, 0);\n+        dls.artCount = 1;\n+    }\n \n     /* parse the lins chunk and load instruments */\n     dls.regionCount = dls.instCount = 0;\n""}","EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
{
    EAS_RESULT result;
    SDLS_SYNTHESIZER_DATA dls;
    EAS_U32 temp;
    EAS_I32 pos;
    EAS_I32 chunkPos;
    EAS_I32 size;
    EAS_I32 instSize;
    EAS_I32 rgnPoolSize;
    EAS_I32 artPoolSize;
    EAS_I32 waveLenSize;
    EAS_I32 endDLS;
    EAS_I32 wvplPos;
    EAS_I32 wvplSize;
    EAS_I32 linsPos;
    EAS_I32 linsSize;
    EAS_I32 ptblPos;
    EAS_I32 ptblSize;
 void *p;

 /* zero counts and pointers */
    EAS_HWMemSet(&dls, 0, sizeof(dls));

 /* save file handle and hwInstData to save copying pointers around */
    dls.hwInstData = hwInstData;
    dls.fileHandle = fileHandle;

 /* NULL return value in case of error */
 *ppDLS = NULL;

 /* seek to start of DLS and read in RIFF tag and set processor endian flag */
 if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
 return result;
 if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
 return result;

 /* check for processor endian-ness */
    dls.bigEndian = (temp == CHUNK_RIFF);

 /* first chunk should be DLS */
    pos = offset;
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;
 if (temp != CHUNK_DLS)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""Expected DLS chunk, got %08lx\n"", temp); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* no instrument or wavepool chunks */
    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;

 /* scan the chunks in the DLS list */
    endDLS = offset + size;
    pos = offset + 12;
 while (pos < endDLS)
 {
        chunkPos = pos;

 /* get the next chunk type */
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;

 /* parse useful chunks */
 switch (temp)
 {
 case CHUNK_CDL:
 if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
 return result;
 if (!temp)
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 break;

 case CHUNK_LINS:
                linsPos = chunkPos + 12;
                linsSize = size - 4;
 break;

 case CHUNK_WVPL:
                wvplPos = chunkPos + 12;
                wvplSize = size - 4;
 break;

 case CHUNK_PTBL:
                ptblPos = chunkPos + 8;
                ptblSize = size - 4;
 break;

 default:
 break;
 }
 }

 /* must have a lins chunk */
 if (linsSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No lins chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a wvpl chunk */
 if (wvplSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No wvpl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a ptbl chunk */
 if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No ptbl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* pre-parse the wave pool chunk */
 if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
 return result;

 /* limit check  */
 if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #waves [%u]\n"", dls.waveCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate memory for wsmp data */
    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 if (dls.wsmpData == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc for wsmp data failed\n""); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));

 /* pre-parse the lins chunk */
    result = Parse_lins(&dls, linsPos, linsSize);
 if (result == EAS_SUCCESS)
 {

 /* limit check  */
 if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #regions [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #articulations [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #instruments [%u]\n"", dls.instCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* Allocate memory for the converted DLS data */
 /* calculate size of instrument data */
        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);

 /* calculate size of region pool */
        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);

 /* calculate size of articulation pool, add one for default articulation */
        dls.artCount++;
        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);

 /* calculate size of wave length and offset arrays */
        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));

 /* calculate final memory size */
        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
 if (size <= 0) {
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate the main EAS chunk */
        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
 if (dls.pDLS == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc failed for DLS memory allocation size %ld\n"", size); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
        EAS_HWMemSet(dls.pDLS, 0, size);
        dls.pDLS->refCount = 1;
        p = PtrOfs(dls.pDLS, sizeof(S_EAS));

 /* setup pointer to programs */
        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
        dls.pDLS->pDLSPrograms = p;
        p = PtrOfs(p, instSize);

 /* setup pointer to regions */
        dls.pDLS->pDLSRegions = p;
        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
        p = PtrOfs(p, rgnPoolSize);

 /* setup pointer to articulations */
        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
        dls.pDLS->pDLSArticulations = p;
        p = PtrOfs(p, artPoolSize);

 /* setup pointer to wave length table */
        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
        dls.pDLS->pDLSSampleLen = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave offsets table */
        dls.pDLS->pDLSSampleOffsets = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave pool */
        dls.pDLS->pDLSSamples = p;

 /* clear filter flag */
        dls.filterUsed = EAS_FALSE;

 /* parse the wave pool and load samples */
        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);

     }
 
     /* create the default articulation */
    if (dls.pDLS) {
        Convert_art(&dls, &defaultArt, 0);
        dls.artCount = 1;
    }
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
 if (result == EAS_SUCCESS)
        result = Parse_lins(&dls, linsPos, linsSize);

 /* clean up any temporary objects that were allocated */
 if (dls.wsmpData)
        EAS_HWFree(dls.hwInstData, dls.wsmpData);

 /* if successful, return a pointer to the EAS collection */
 if (result == EAS_SUCCESS)
 {
 *ppDLS = dls.pDLS;
#ifdef _DEBUG_DLS
 DumpDLS(dls.pDLS);
#endif
 }

 /* something went wrong, deallocate the EAS collection */
 else
 DLSCleanup(dls.hwInstData, dls.pDLS);

 return result;
}
","EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
{
    EAS_RESULT result;
    SDLS_SYNTHESIZER_DATA dls;
    EAS_U32 temp;
    EAS_I32 pos;
    EAS_I32 chunkPos;
    EAS_I32 size;
    EAS_I32 instSize;
    EAS_I32 rgnPoolSize;
    EAS_I32 artPoolSize;
    EAS_I32 waveLenSize;
    EAS_I32 endDLS;
    EAS_I32 wvplPos;
    EAS_I32 wvplSize;
    EAS_I32 linsPos;
    EAS_I32 linsSize;
    EAS_I32 ptblPos;
    EAS_I32 ptblSize;
 void *p;

 /* zero counts and pointers */
    EAS_HWMemSet(&dls, 0, sizeof(dls));

 /* save file handle and hwInstData to save copying pointers around */
    dls.hwInstData = hwInstData;
    dls.fileHandle = fileHandle;

 /* NULL return value in case of error */
 *ppDLS = NULL;

 /* seek to start of DLS and read in RIFF tag and set processor endian flag */
 if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
 return result;
 if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
 return result;

 /* check for processor endian-ness */
    dls.bigEndian = (temp == CHUNK_RIFF);

 /* first chunk should be DLS */
    pos = offset;
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;
 if (temp != CHUNK_DLS)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""Expected DLS chunk, got %08lx\n"", temp); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* no instrument or wavepool chunks */
    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;

 /* scan the chunks in the DLS list */
    endDLS = offset + size;
    pos = offset + 12;
 while (pos < endDLS)
 {
        chunkPos = pos;

 /* get the next chunk type */
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;

 /* parse useful chunks */
 switch (temp)
 {
 case CHUNK_CDL:
 if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
 return result;
 if (!temp)
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 break;

 case CHUNK_LINS:
                linsPos = chunkPos + 12;
                linsSize = size - 4;
 break;

 case CHUNK_WVPL:
                wvplPos = chunkPos + 12;
                wvplSize = size - 4;
 break;

 case CHUNK_PTBL:
                ptblPos = chunkPos + 8;
                ptblSize = size - 4;
 break;

 default:
 break;
 }
 }

 /* must have a lins chunk */
 if (linsSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No lins chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a wvpl chunk */
 if (wvplSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No wvpl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a ptbl chunk */
 if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No ptbl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* pre-parse the wave pool chunk */
 if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
 return result;

 /* limit check  */
 if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #waves [%u]\n"", dls.waveCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate memory for wsmp data */
    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 if (dls.wsmpData == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc for wsmp data failed\n""); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));

 /* pre-parse the lins chunk */
    result = Parse_lins(&dls, linsPos, linsSize);
 if (result == EAS_SUCCESS)
 {

 /* limit check  */
 if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #regions [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #articulations [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #instruments [%u]\n"", dls.instCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* Allocate memory for the converted DLS data */
 /* calculate size of instrument data */
        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);

 /* calculate size of region pool */
        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);

 /* calculate size of articulation pool, add one for default articulation */
        dls.artCount++;
        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);

 /* calculate size of wave length and offset arrays */
        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));

 /* calculate final memory size */
        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
 if (size <= 0) {
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate the main EAS chunk */
        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
 if (dls.pDLS == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc failed for DLS memory allocation size %ld\n"", size); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
        EAS_HWMemSet(dls.pDLS, 0, size);
        dls.pDLS->refCount = 1;
        p = PtrOfs(dls.pDLS, sizeof(S_EAS));

 /* setup pointer to programs */
        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
        dls.pDLS->pDLSPrograms = p;
        p = PtrOfs(p, instSize);

 /* setup pointer to regions */
        dls.pDLS->pDLSRegions = p;
        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
        p = PtrOfs(p, rgnPoolSize);

 /* setup pointer to articulations */
        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
        dls.pDLS->pDLSArticulations = p;
        p = PtrOfs(p, artPoolSize);

 /* setup pointer to wave length table */
        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
        dls.pDLS->pDLSSampleLen = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave offsets table */
        dls.pDLS->pDLSSampleOffsets = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave pool */
        dls.pDLS->pDLSSamples = p;

 /* clear filter flag */
        dls.filterUsed = EAS_FALSE;

 /* parse the wave pool and load samples */
        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);

     }
 
     /* create the default articulation */
    Convert_art(&dls, &defaultArt, 0);
    dls.artCount = 1;
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
 if (result == EAS_SUCCESS)
        result = Parse_lins(&dls, linsPos, linsSize);

 /* clean up any temporary objects that were allocated */
 if (dls.wsmpData)
        EAS_HWFree(dls.hwInstData, dls.wsmpData);

 /* if successful, return a pointer to the EAS collection */
 if (result == EAS_SUCCESS)
 {
 *ppDLS = dls.pDLS;
#ifdef _DEBUG_DLS
 DumpDLS(dls.pDLS);
#endif
 }

 /* something went wrong, deallocate the EAS collection */
 else
 DLSCleanup(dls.hwInstData, dls.pDLS);

 return result;
}
",C,"    if (dls.pDLS) {
        Convert_art(&dls, &defaultArt, 0);
        dls.artCount = 1;
    }
","    Convert_art(&dls, &defaultArt, 0);
    dls.artCount = 1;
",,"@@ -683,8 +683,10 @@

     }
 
     /* create the default articulation */
-    Convert_art(&dls, &defaultArt, 0);
-    dls.artCount = 1;
+    if (dls.pDLS) {
+        Convert_art(&dls, &defaultArt, 0);
+        dls.artCount = 1;
+    }
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
",Android,https://android.googlesource.com/platform/external/sonivox/+/cadfb7a3c96d4fef06656cf37143e1b3e62cae86/,https://android.googlesource.com/platform/external/sonivox/+/cadfb7a3c96d4fef06656cf37143e1b3e62cae86%5E/,1,"EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
{
    EAS_RESULT result;
    SDLS_SYNTHESIZER_DATA dls;
    EAS_U32 temp;
    EAS_I32 pos;
    EAS_I32 chunkPos;
    EAS_I32 size;
    EAS_I32 instSize;
    EAS_I32 rgnPoolSize;
    EAS_I32 artPoolSize;
    EAS_I32 waveLenSize;
    EAS_I32 endDLS;
    EAS_I32 wvplPos;
    EAS_I32 wvplSize;
    EAS_I32 linsPos;
    EAS_I32 linsSize;
    EAS_I32 ptblPos;
    EAS_I32 ptblSize;
 void *p;

 /* zero counts and pointers */
    EAS_HWMemSet(&dls, 0, sizeof(dls));

 /* save file handle and hwInstData to save copying pointers around */
    dls.hwInstData = hwInstData;
    dls.fileHandle = fileHandle;

 /* NULL return value in case of error */
 *ppDLS = NULL;

 /* seek to start of DLS and read in RIFF tag and set processor endian flag */
 if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
 return result;
 if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
 return result;

 /* check for processor endian-ness */
    dls.bigEndian = (temp == CHUNK_RIFF);

 /* first chunk should be DLS */
    pos = offset;
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;
 if (temp != CHUNK_DLS)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""Expected DLS chunk, got %08lx\n"", temp); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* no instrument or wavepool chunks */
    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;

 /* scan the chunks in the DLS list */
    endDLS = offset + size;
    pos = offset + 12;
 while (pos < endDLS)
 {
        chunkPos = pos;

 /* get the next chunk type */
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;

 /* parse useful chunks */
 switch (temp)
 {
 case CHUNK_CDL:
 if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
 return result;
 if (!temp)
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 break;

 case CHUNK_LINS:
                linsPos = chunkPos + 12;
                linsSize = size - 4;
 break;

 case CHUNK_WVPL:
                wvplPos = chunkPos + 12;
                wvplSize = size - 4;
 break;

 case CHUNK_PTBL:
                ptblPos = chunkPos + 8;
                ptblSize = size - 4;
 break;

 default:
 break;
 }
 }

 /* must have a lins chunk */
 if (linsSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No lins chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a wvpl chunk */
 if (wvplSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No wvpl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a ptbl chunk */
 if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No ptbl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* pre-parse the wave pool chunk */
 if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
 return result;

 /* limit check  */
 if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #waves [%u]\n"", dls.waveCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate memory for wsmp data */
    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 if (dls.wsmpData == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc for wsmp data failed\n""); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));

 /* pre-parse the lins chunk */
    result = Parse_lins(&dls, linsPos, linsSize);
 if (result == EAS_SUCCESS)
 {

 /* limit check  */
 if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #regions [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #articulations [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #instruments [%u]\n"", dls.instCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* Allocate memory for the converted DLS data */
 /* calculate size of instrument data */
        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);

 /* calculate size of region pool */
        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);

 /* calculate size of articulation pool, add one for default articulation */
        dls.artCount++;
        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);

 /* calculate size of wave length and offset arrays */
        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));

 /* calculate final memory size */
        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
 if (size <= 0) {
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate the main EAS chunk */
        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
 if (dls.pDLS == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc failed for DLS memory allocation size %ld\n"", size); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
        EAS_HWMemSet(dls.pDLS, 0, size);
        dls.pDLS->refCount = 1;
        p = PtrOfs(dls.pDLS, sizeof(S_EAS));

 /* setup pointer to programs */
        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
        dls.pDLS->pDLSPrograms = p;
        p = PtrOfs(p, instSize);

 /* setup pointer to regions */
        dls.pDLS->pDLSRegions = p;
        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
        p = PtrOfs(p, rgnPoolSize);

 /* setup pointer to articulations */
        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
        dls.pDLS->pDLSArticulations = p;
        p = PtrOfs(p, artPoolSize);

 /* setup pointer to wave length table */
        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
        dls.pDLS->pDLSSampleLen = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave offsets table */
        dls.pDLS->pDLSSampleOffsets = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave pool */
        dls.pDLS->pDLSSamples = p;

 /* clear filter flag */
        dls.filterUsed = EAS_FALSE;

 /* parse the wave pool and load samples */
        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);

     }
 
     /* create the default articulation */
//flaw_line_below:
    Convert_art(&dls, &defaultArt, 0);
//flaw_line_below:
    dls.artCount = 1;
//fix_flaw_line_below:
//    if (dls.pDLS) {
//fix_flaw_line_below:
//        Convert_art(&dls, &defaultArt, 0);
//fix_flaw_line_below:
//        dls.artCount = 1;
//fix_flaw_line_below:
//    }
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
 if (result == EAS_SUCCESS)
        result = Parse_lins(&dls, linsPos, linsSize);

 /* clean up any temporary objects that were allocated */
 if (dls.wsmpData)
        EAS_HWFree(dls.hwInstData, dls.wsmpData);

 /* if successful, return a pointer to the EAS collection */
 if (result == EAS_SUCCESS)
 {
 *ppDLS = dls.pDLS;
#ifdef _DEBUG_DLS
 DumpDLS(dls.pDLS);
#endif
 }

 /* something went wrong, deallocate the EAS collection */
 else
 DLSCleanup(dls.hwInstData, dls.pDLS);

 return result;
}
",187434,"EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
{
    EAS_RESULT result;
    SDLS_SYNTHESIZER_DATA dls;
    EAS_U32 temp;
    EAS_I32 pos;
    EAS_I32 chunkPos;
    EAS_I32 size;
    EAS_I32 instSize;
    EAS_I32 rgnPoolSize;
    EAS_I32 artPoolSize;
    EAS_I32 waveLenSize;
    EAS_I32 endDLS;
    EAS_I32 wvplPos;
    EAS_I32 wvplSize;
    EAS_I32 linsPos;
    EAS_I32 linsSize;
    EAS_I32 ptblPos;
    EAS_I32 ptblSize;
 void *p;

 /* zero counts and pointers */
    EAS_HWMemSet(&dls, 0, sizeof(dls));

 /* save file handle and hwInstData to save copying pointers around */
    dls.hwInstData = hwInstData;
    dls.fileHandle = fileHandle;

 /* NULL return value in case of error */
 *ppDLS = NULL;

 /* seek to start of DLS and read in RIFF tag and set processor endian flag */
 if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
 return result;
 if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
 return result;

 /* check for processor endian-ness */
    dls.bigEndian = (temp == CHUNK_RIFF);

 /* first chunk should be DLS */
    pos = offset;
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;
 if (temp != CHUNK_DLS)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""Expected DLS chunk, got %08lx\n"", temp); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* no instrument or wavepool chunks */
    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;

 /* scan the chunks in the DLS list */
    endDLS = offset + size;
    pos = offset + 12;
 while (pos < endDLS)
 {
        chunkPos = pos;

 /* get the next chunk type */
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;

 /* parse useful chunks */
 switch (temp)
 {
 case CHUNK_CDL:
 if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
 return result;
 if (!temp)
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 break;

 case CHUNK_LINS:
                linsPos = chunkPos + 12;
                linsSize = size - 4;
 break;

 case CHUNK_WVPL:
                wvplPos = chunkPos + 12;
                wvplSize = size - 4;
 break;

 case CHUNK_PTBL:
                ptblPos = chunkPos + 8;
                ptblSize = size - 4;
 break;

 default:
 break;
 }
 }

 /* must have a lins chunk */
 if (linsSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No lins chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a wvpl chunk */
 if (wvplSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No wvpl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a ptbl chunk */
 if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No ptbl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* pre-parse the wave pool chunk */
 if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
 return result;

 /* limit check  */
 if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #waves [%u]\n"", dls.waveCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate memory for wsmp data */
    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 if (dls.wsmpData == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc for wsmp data failed\n""); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));

 /* pre-parse the lins chunk */
    result = Parse_lins(&dls, linsPos, linsSize);
 if (result == EAS_SUCCESS)
 {

 /* limit check  */
 if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #regions [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #articulations [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #instruments [%u]\n"", dls.instCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* Allocate memory for the converted DLS data */
 /* calculate size of instrument data */
        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);

 /* calculate size of region pool */
        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);

 /* calculate size of articulation pool, add one for default articulation */
        dls.artCount++;
        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);

 /* calculate size of wave length and offset arrays */
        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));

 /* calculate final memory size */
        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
 if (size <= 0) {
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate the main EAS chunk */
        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
 if (dls.pDLS == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc failed for DLS memory allocation size %ld\n"", size); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
        EAS_HWMemSet(dls.pDLS, 0, size);
        dls.pDLS->refCount = 1;
        p = PtrOfs(dls.pDLS, sizeof(S_EAS));

 /* setup pointer to programs */
        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
        dls.pDLS->pDLSPrograms = p;
        p = PtrOfs(p, instSize);

 /* setup pointer to regions */
        dls.pDLS->pDLSRegions = p;
        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
        p = PtrOfs(p, rgnPoolSize);

 /* setup pointer to articulations */
        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
        dls.pDLS->pDLSArticulations = p;
        p = PtrOfs(p, artPoolSize);

 /* setup pointer to wave length table */
        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
        dls.pDLS->pDLSSampleLen = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave offsets table */
        dls.pDLS->pDLSSampleOffsets = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave pool */
        dls.pDLS->pDLSSamples = p;

 /* clear filter flag */
        dls.filterUsed = EAS_FALSE;

 /* parse the wave pool and load samples */
        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);

     }
 
     /* create the default articulation */
    Convert_art(&dls, &defaultArt, 0);
    dls.artCount = 1;
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
 if (result == EAS_SUCCESS)
        result = Parse_lins(&dls, linsPos, linsSize);

 /* clean up any temporary objects that were allocated */
 if (dls.wsmpData)
        EAS_HWFree(dls.hwInstData, dls.wsmpData);

 /* if successful, return a pointer to the EAS collection */
 if (result == EAS_SUCCESS)
 {
 *ppDLS = dls.pDLS;
#ifdef _DEBUG_DLS
 DumpDLS(dls.pDLS);
#endif
 }

 /* something went wrong, deallocate the EAS collection */
 else
 DLSCleanup(dls.hwInstData, dls.pDLS);

 return result;
}
","EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
{
    EAS_RESULT result;
    SDLS_SYNTHESIZER_DATA dls;
    EAS_U32 temp;
    EAS_I32 pos;
    EAS_I32 chunkPos;
    EAS_I32 size;
    EAS_I32 instSize;
    EAS_I32 rgnPoolSize;
    EAS_I32 artPoolSize;
    EAS_I32 waveLenSize;
    EAS_I32 endDLS;
    EAS_I32 wvplPos;
    EAS_I32 wvplSize;
    EAS_I32 linsPos;
    EAS_I32 linsSize;
    EAS_I32 ptblPos;
    EAS_I32 ptblSize;
 void *p;

 /* zero counts and pointers */
    EAS_HWMemSet(&dls, 0, sizeof(dls));

 /* save file handle and hwInstData to save copying pointers around */
    dls.hwInstData = hwInstData;
    dls.fileHandle = fileHandle;

 /* NULL return value in case of error */
 *ppDLS = NULL;

 /* seek to start of DLS and read in RIFF tag and set processor endian flag */
 if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
 return result;
 if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
 return result;

 /* check for processor endian-ness */
    dls.bigEndian = (temp == CHUNK_RIFF);

 /* first chunk should be DLS */
    pos = offset;
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;
 if (temp != CHUNK_DLS)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""Expected DLS chunk, got %08lx\n"", temp); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* no instrument or wavepool chunks */
    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;

 /* scan the chunks in the DLS list */
    endDLS = offset + size;
    pos = offset + 12;
 while (pos < endDLS)
 {
        chunkPos = pos;

 /* get the next chunk type */
 if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
 return result;

 /* parse useful chunks */
 switch (temp)
 {
 case CHUNK_CDL:
 if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
 return result;
 if (!temp)
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 break;

 case CHUNK_LINS:
                linsPos = chunkPos + 12;
                linsSize = size - 4;
 break;

 case CHUNK_WVPL:
                wvplPos = chunkPos + 12;
                wvplSize = size - 4;
 break;

 case CHUNK_PTBL:
                ptblPos = chunkPos + 8;
                ptblSize = size - 4;
 break;

 default:
 break;
 }
 }

 /* must have a lins chunk */
 if (linsSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No lins chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a wvpl chunk */
 if (wvplSize == 0)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No wvpl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* must have a ptbl chunk */
 if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""No ptbl chunk found""); */ }
 return EAS_ERROR_UNRECOGNIZED_FORMAT;
 }

 /* pre-parse the wave pool chunk */
 if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
 return result;

 /* limit check  */
 if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #waves [%u]\n"", dls.waveCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate memory for wsmp data */
    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 if (dls.wsmpData == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc for wsmp data failed\n""); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));

 /* pre-parse the lins chunk */
    result = Parse_lins(&dls, linsPos, linsSize);
 if (result == EAS_SUCCESS)
 {

 /* limit check  */
 if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #regions [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #articulations [%u]\n"", dls.regionCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* limit check  */
 if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""DLS file contains invalid #instruments [%u]\n"", dls.instCount); */ }
 return EAS_ERROR_FILE_FORMAT;
 }

 /* Allocate memory for the converted DLS data */
 /* calculate size of instrument data */
        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);

 /* calculate size of region pool */
        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);

 /* calculate size of articulation pool, add one for default articulation */
        dls.artCount++;
        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);

 /* calculate size of wave length and offset arrays */
        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));

 /* calculate final memory size */
        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
 if (size <= 0) {
 return EAS_ERROR_FILE_FORMAT;
 }

 /* allocate the main EAS chunk */
        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
 if (dls.pDLS == NULL)
 {
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, ""EAS_HWMalloc failed for DLS memory allocation size %ld\n"", size); */ }
 return EAS_ERROR_MALLOC_FAILED;
 }
        EAS_HWMemSet(dls.pDLS, 0, size);
        dls.pDLS->refCount = 1;
        p = PtrOfs(dls.pDLS, sizeof(S_EAS));

 /* setup pointer to programs */
        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
        dls.pDLS->pDLSPrograms = p;
        p = PtrOfs(p, instSize);

 /* setup pointer to regions */
        dls.pDLS->pDLSRegions = p;
        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
        p = PtrOfs(p, rgnPoolSize);

 /* setup pointer to articulations */
        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
        dls.pDLS->pDLSArticulations = p;
        p = PtrOfs(p, artPoolSize);

 /* setup pointer to wave length table */
        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
        dls.pDLS->pDLSSampleLen = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave offsets table */
        dls.pDLS->pDLSSampleOffsets = p;
        p = PtrOfs(p, waveLenSize);

 /* setup pointer to wave pool */
        dls.pDLS->pDLSSamples = p;

 /* clear filter flag */
        dls.filterUsed = EAS_FALSE;

 /* parse the wave pool and load samples */
        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);

     }
 
     /* create the default articulation */
    if (dls.pDLS) {
        Convert_art(&dls, &defaultArt, 0);
        dls.artCount = 1;
    }
 
     /* parse the lins chunk and load instruments */
     dls.regionCount = dls.instCount = 0;
 if (result == EAS_SUCCESS)
        result = Parse_lins(&dls, linsPos, linsSize);

 /* clean up any temporary objects that were allocated */
 if (dls.wsmpData)
        EAS_HWFree(dls.hwInstData, dls.wsmpData);

 /* if successful, return a pointer to the EAS collection */
 if (result == EAS_SUCCESS)
 {
 *ppDLS = dls.pDLS;
#ifdef _DEBUG_DLS
 DumpDLS(dls.pDLS);
#endif
 }

 /* something went wrong, deallocate the EAS collection */
 else
 DLSCleanup(dls.hwInstData, dls.pDLS);

 return result;
}
","The `DLSParser` function processes a DLS (Downloadable Sounds) file by reading its contents from a specified file handle and offset, verifying the file format, and extracting relevant data chunks such as instrument, wave pool, and articulation information. It initializes a synthesizer data structure, checks for the presence of required chunks, and allocates memory for various data components. The function parses the chunks to populate the synthesizer data, ensuring that the counts of instruments, regions, and waves are within valid limits. If successful, it returns a pointer to the populated DLS structure; otherwise, it cleans up and returns an error code.","The code defines a function that reads and processes a DLS file to extract sound data for a synthesizer. It begins by initializing a data structure and checking the file format, ensuring that essential chunks are present. The function scans through the file to identify and parse various components, such as instruments and wave pools, while validating their counts against predefined limits. Memory is allocated for the extracted data, and if successful, a pointer to the populated data structure is returned. In case of errors, the function cleans up any allocated resources and returns an appropriate error code.","The vulnerability in the original code arises from a lack of proper checks for the presence of critical data chunks, which could lead to a NULL pointer dereference if a crafted media file is processed. Specifically, if the required chunks (like the lins, wvpl, and ptbl) are missing, the code would attempt to access uninitialized pointers, resulting in a denial of service. The fixed code addresses this issue by adding explicit checks to ensure that these chunks are present and valid before proceeding with memory allocation and data parsing. This prevents the function from dereferencing NULL pointers, thereby enhancing stability and security.","The vulnerability in the original code stems from inadequate validation of critical data chunks in a media file, which could lead to a NULL pointer dereference when processing malformed input. This oversight allows attackers to craft specific media files that, when processed, could cause the application to crash or the device to hang. The fixed code addresses this issue by implementing thorough checks to ensure that all necessary data chunks are present and valid before any further processing occurs. This proactive validation prevents the dereferencing of uninitialized pointers, thereby enhancing the robustness and security of the application.","The vulnerability was fixed by adding explicit checks for the presence and validity of essential data chunks before proceeding with memory allocation and parsing. In the updated code, conditions were introduced to verify that the sizes of the lins, wvpl, and ptbl chunks are greater than zero, ensuring that these critical components are present. For instance, checks like `if (linsSize == 0)` and `if (wvplSize == 0)` were implemented to prevent further processing if the required chunks are missing. This prevents the dereferencing of NULL pointers, thereby enhancing the stability and security of the application when handling crafted media files.","The vulnerability was fixed by implementing rigorous validation checks to ensure that all necessary data chunks are present and correctly sized before any further processing occurs. The updated code introduces conditions that verify the existence of critical components, such as instrument and wave pool data, preventing the function from proceeding if these elements are missing. This proactive approach ensures that the application does not attempt to access uninitialized pointers, thereby eliminating the risk of NULL pointer dereferences. As a result, the application becomes more robust against crafted input that could lead to crashes or system instability.","5,5","5,5","4,3","5,5","CWE-476, CWE-690, CWE-754, CWE-20, CWE-119, CWE-789, CWE-457, CWE-628, CWE-125, CWE-822",N,-1
28,28,28,187435,187435,,Remote,Not required,Complete,CVE-2016-3878,https://www.cvedetails.com/cve/CVE-2016-3878/,CWE-284,Medium,,,,2016-09-11,7.1,"decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-09-01 mishandles the case of decoding zero MBs, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29493002.",2017-08-12,DoS ,3,https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,"Fixed error concealment when no MBs are decoded in the current pic

Bug: 29493002
Change-Id: I3fae547ddb0616b4e6579580985232bd3d65881e
",0,decoder/ih264d_api.c,"{""filename"": ""decoder/ih264d_api.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf/decoder/ih264d_api.c"", ""patch"": ""@@ -2140,6 +2140,9 @@\n\n         else\n             prev_slice_err = 2;\n \n+        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n+            prev_slice_err = 1;\n+\n         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n                                    &temp_poc, prev_slice_err);\n \n""}","WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 /* ! */

 dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    WORD32 i4_err_status = 0;
    UWORD8 *pu1_buf = NULL;
    WORD32 buflen;
    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;

    UWORD32 bytes_consumed = 0;
    UWORD32 cur_slice_is_nonref = 0;
    UWORD32 u4_next_is_aud;
    UWORD32 u4_first_start_code_found = 0;
    WORD32 ret = 0,api_ret_value = IV_SUCCESS;
    WORD32 header_data_left = 0,frame_data_left = 0;
    UWORD8 *pu1_bitstrm_buf;
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    ithread_set_name((void*)""Parse_thread"");

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
 }

    ps_dec->pv_dec_out = ps_dec_op;
 if(ps_dec->init_done != 1)
 {
 return IV_FAIL;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
    DATA_SYNC();

 if(0 == ps_dec->u1_flushfrm)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }
    ps_dec->u1_pic_decode_done = 0;

    ps_dec_op->u4_num_bytes_consumed = 0;

    ps_dec->ps_out_buffer = NULL;

 if(ps_dec_ip->u4_size
 >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;

    ps_dec->u4_fmt_conv_cur_row = 0;

    ps_dec->u4_output_present = 0;
    ps_dec->s_disp_op.u4_error_code = 1;
    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
 if(0 == ps_dec->u4_share_disp_buf
 && ps_dec->i4_decode_header == 0)
 {
        UWORD32 i;
 if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

 if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
 return IV_FAIL;
 }

 /* ! */
    ps_dec->u4_ts = ps_dec_ip->u4_ts;

    ps_dec_op->u4_error_code = 0;
    ps_dec_op->e_pic_type = -1;
    ps_dec_op->u4_output_present = 0;
    ps_dec_op->u4_frame_decoded_flag = 0;

    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;
 /*
     * For field pictures, set the bottom and top picture decoded u4_flag correctly.
     */
 {
 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
 {
            ps_dec->u1_top_bottom_decoded = 0;
 }
 }
    ps_dec->u4_slice_start_code_found = 0;

 /* In case the deocder is not in flush mode(in shared mode),
     then decoder has to pick up a buffer to write current frame.
     Check if a frame is available in such cases */

 if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
 && ps_dec->u1_flushfrm == 0)
 {
        UWORD32 i;

        WORD32 disp_avail = 0, free_id;

 /* Check if at least one buffer is available with the codec */
 /* If not then return to application with error */
 for(i = 0; i < ps_dec->u1_pic_bufs; i++)
 {
 if(0 == ps_dec->u4_disp_buf_mapping[i]
 || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
 {
                disp_avail = 1;
 break;
 }

 }

 if(0 == disp_avail)
 {
 /* If something is queued for display wait for that buffer to be returned */

            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }

 while(1)
 {
 pic_buffer_t *ps_pic_buf;
            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);

 if(ps_pic_buf == NULL)
 {
                UWORD32 i, display_queued = 0;

 /* check if any buffer was given for display which is not returned yet */
 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
 {
 if(0 != ps_dec->u4_disp_buf_mapping[i])
 {
                        display_queued = 1;
 break;
 }
 }
 /* If some buffer is queued for display, then codec has to singal an error and wait
                 for that buffer to be returned.
                 If nothing is queued for display then codec has ownership of all display buffers
                 and it can reuse any of the existing buffers and continue decoding */

 if(1 == display_queued)
 {
 /* If something is queued for display wait for that buffer to be returned */
                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                    ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }
 }
 else
 {
 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
 {
                    ih264_buf_mgr_set_status(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                    free_id,
                                    BUF_MGR_IO);
 }
 else
 {
 /**
                     *  Found a free buffer for present call. Release it now.
                     *  Will be again obtained later.
                     */
                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                          free_id,
                                          BUF_MGR_IO);
 break;
 }
 }
 }

 }

 if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
 {

        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
            ps_dec->u4_fmt_conv_cur_row = 0;
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
            ps_dec->u4_output_present = 1;

 }
        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));

        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;

        ps_dec_op->u4_new_seq = 0;

        ps_dec_op->u4_output_present = ps_dec->u4_output_present;
        ps_dec_op->u4_progressive_frame_flag =
                        ps_dec->s_disp_op.u4_progressive_frame_flag;
        ps_dec_op->e_output_format =
                        ps_dec->s_disp_op.e_output_format;
        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;

 /*In the case of flush ,since no frame is decoded set pic type as invalid*/
        ps_dec_op->u4_is_ref_flag = -1;
        ps_dec_op->e_pic_type = IV_NA_FRAME;
        ps_dec_op->u4_frame_decoded_flag = 0;

 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
 return (IV_SUCCESS);
 }
 else
 return (IV_FAIL);

 }
 if(ps_dec->u1_res_changed == 1)
 {
 /*if resolution has changed and all buffers have been flushed, reset decoder*/
        ih264d_init_decoder(ps_dec);
 }

    ps_dec->u4_prev_nal_skipped = 0;

    ps_dec->u2_cur_mb_addr = 0;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->u2_cur_slice_num = 0;
    ps_dec->cur_dec_mb_num = 0;
    ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_slice_header_done = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->u4_dec_thread_created = 0;
    ps_dec->u4_bs_deblk_thread_created = 0;
    ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;

    DEBUG_THREADS_PRINTF("" Starting process call\n"");


    ps_dec->u4_pic_buf_got = 0;

 do
 {
        WORD32 buf_size;

        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
 + ps_dec_op->u4_num_bytes_consumed;

        u4_max_ofst = ps_dec_ip->u4_num_Bytes
 - ps_dec_op->u4_num_bytes_consumed;

 /* If dynamic bitstream buffer is not allocated and
         * header decode is done, then allocate dynamic bitstream buffer
         */
 if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
 (ps_dec->i4_header_decoded & 1))
 {
            WORD32 size;

 void *pv_buf;
 void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
            RETURN_IF((NULL == pv_buf), IV_FAIL);
            ps_dec->pu1_bits_buf_dynamic = pv_buf;
            ps_dec->u4_dynamic_bits_buf_size = size;
 }

 if(ps_dec->pu1_bits_buf_dynamic)
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
            buf_size = ps_dec->u4_dynamic_bits_buf_size;
 }
 else
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
            buf_size = ps_dec->u4_static_bits_buf_size;
 }

        u4_next_is_aud = 0;

        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
 &u4_length_of_start_code,
 &u4_next_is_aud);

 if(buflen == -1)
            buflen = 0;
 /* Ignore bytes beyond the allocated size of intermediate buffer */
        buflen = MIN(buflen, buf_size);

        bytes_consumed = buflen + u4_length_of_start_code;
        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;

 {
            UWORD8 u1_firstbyte, u1_nal_ref_idc;

 if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
 {
                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
 if(u1_nal_ref_idc == 0)
 {
 /*skip non reference frames*/
                    cur_slice_is_nonref = 1;
 continue;
 }
 else
 {
 if(1 == cur_slice_is_nonref)
 {
 /*We have encountered a referenced frame,return to app*/
                        ps_dec_op->u4_num_bytes_consumed -=
                                        bytes_consumed;
                        ps_dec_op->e_pic_type = IV_B_FRAME;
                        ps_dec_op->u4_error_code =
                                        IVD_DEC_FRM_SKIPPED;
                        ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
                        ps_dec_op->u4_frame_decoded_flag = 0;
                        ps_dec_op->u4_size =
 sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
                        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                            ih264d_signal_bs_deblk_thread(ps_dec);
 }

 return (IV_FAIL);
 }
 }

 }

 }


 if(buflen)
 {
            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                   buflen);
 /* Decoder may read extra 8 bytes near end of the frame */
 if((buflen + 8) < buf_size)
 {
                memset(pu1_bitstrm_buf + buflen, 0, 8);
 }
            u4_first_start_code_found = 1;

 }
 else
 {
 /*start code not found*/

 if(u4_first_start_code_found == 0)
 {
 /*no start codes found in current process call*/

                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;

 if(ps_dec->u4_pic_buf_got == 0)
 {

                    ih264d_fill_output_struct_from_context(ps_dec,
                                                           ps_dec_op);

                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                    ps_dec_op->u4_frame_decoded_flag = 0;

 return (IV_FAIL);
 }
 else
 {
                    ps_dec->u1_pic_decode_done = 1;
 continue;
 }
 }
 else
 {
 /* a start code has already been found earlier in the same process call*/
                frame_data_left = 0;
 continue;
 }

 }

        ps_dec->u4_return_to_app = 0;
        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                              pu1_bitstrm_buf, buflen);
 if(ret != OK)
 {
            UWORD32 error =  ih264d_map_error(ret);
            ps_dec_op->u4_error_code = error | ret;
            api_ret_value = IV_FAIL;

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {
                ps_dec->u4_slice_start_code_found = 0;
 break;
 }

 if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
 {
                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                api_ret_value = IV_FAIL;
 break;
 }

 if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
 {
                api_ret_value = IV_FAIL;
 break;
 }

 }

 if(ps_dec->u4_return_to_app)
 {
 /*We have encountered a referenced frame,return to app*/
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
            ps_dec_op->u4_frame_decoded_flag = 0;
            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
            ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }



        header_data_left = ((ps_dec->i4_decode_header == 1)
 && (ps_dec->i4_header_decoded != 3)
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
        frame_data_left = (((ps_dec->i4_decode_header == 0)
 && ((ps_dec->u1_pic_decode_done == 0)
 || (u4_next_is_aud == 1)))
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
 }
 while(( header_data_left == 1)||(frame_data_left == 1));

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ret != IVD_MEM_ALLOC_FAILED)
 && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        WORD32 num_mb_skipped;
        WORD32 prev_slice_err;
 pocstruct_t temp_poc;
        WORD32 ret1;

        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;

 if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
            prev_slice_err = 1;

         else
             prev_slice_err = 2;
 
        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
            prev_slice_err = 1;

         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
 if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
 {
 return IV_FAIL;
 }
 }

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {

 /* signal the decode thread */
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet */
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 /* dont consume bitstream for change in resolution case */
 if(ret == IVD_RES_CHANGED)
 {
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
 }
 return IV_FAIL;
 }


 if(ps_dec->u1_separate_parse)
 {
 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_num_cores == 2)
 {

 /*do deblocking of all mbs*/
 if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
 {
                UWORD32 u4_num_mbs,u4_max_addr;
 tfr_ctxt_t s_tfr_ctxt;
 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;

 /*BS is done for all mbs while parsing*/
                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;


                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                           ps_dec->u2_frm_wd_in_mbs, 0);


                u4_num_mbs = u4_max_addr
 - ps_dec->u4_cur_deblk_mb_num + 1;

                DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);

 if(u4_num_mbs != 0)
                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                   ps_tfr_cxt,1);

                ps_dec->u4_start_recon_deblk  = 0;

 }

 }

 /*signal the decode thread*/
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 }


    DATA_SYNC();


 if((ps_dec_op->u4_error_code & 0xff)
 != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
 {
        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 }

 if(ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }

 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }
 if(ps_dec->u4_prev_nal_skipped)
 {
 /*We have encountered a referenced frame,return to app*/
        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec_op->u4_frame_decoded_flag = 0;
        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
 {
 /*
         * For field pictures, set the bottom and top picture decoded u4_flag correctly.
         */

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
 {
 if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
 {
                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
 }
 else
 {
                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
 }
 }

 /* if new frame in not found (if we are still getting slices from previous frame)
         * ih264d_deblock_display is not called. Such frames will not be added to reference /display
         */
 if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
 {
 /* Calling Function to deblock Picture and Display */
            ret = ih264d_deblock_display(ps_dec);
 if(ret != 0)
 {
 return IV_FAIL;
 }
 }


 /*set to complete ,as we dont support partial frame decode*/
 if(ps_dec->i4_header_decoded == 3)
 {
            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
 }

 /*Update the i4_frametype at the end of picture*/
 if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
 {
            ps_dec->i4_frametype = IV_IDR_FRAME;
 }
 else if(ps_dec->i4_pic_type == B_SLICE)
 {
            ps_dec->i4_frametype = IV_B_FRAME;
 }
 else if(ps_dec->i4_pic_type == P_SLICE)
 {
            ps_dec->i4_frametype = IV_P_FRAME;
 }
 else if(ps_dec->i4_pic_type == I_SLICE)
 {
            ps_dec->i4_frametype = IV_I_FRAME;
 }
 else
 {
            H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
 }

        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;

        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
 - ps_dec->ps_cur_slice->u1_field_pic_flag;

 }

 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
        ih264d_signal_bs_deblk_thread(ps_dec);
 }


 {
 /* In case the decoder is configured to run in low delay mode,
         * then get display buffer and then format convert.
         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
         */

 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
 && ps_dec->u1_init_dec_flag)
 {

            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = 0;
                ps_dec->u4_output_present = 1;
 }
 }

        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);

 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_output_present &&
 (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
 {
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
 - ps_dec->u4_fmt_conv_cur_row;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
 }

        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 }

 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
 {
        ps_dec_op->u4_progressive_frame_flag = 1;
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
 && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                ps_dec_op->u4_progressive_frame_flag = 0;

 }
 }

 /*Data memory barrier instruction,so that yuv write by the library is complete*/
    DATA_SYNC();

    H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                         ps_dec_op->u4_num_bytes_consumed);
 return api_ret_value;
}
","WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 /* ! */

 dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    WORD32 i4_err_status = 0;
    UWORD8 *pu1_buf = NULL;
    WORD32 buflen;
    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;

    UWORD32 bytes_consumed = 0;
    UWORD32 cur_slice_is_nonref = 0;
    UWORD32 u4_next_is_aud;
    UWORD32 u4_first_start_code_found = 0;
    WORD32 ret = 0,api_ret_value = IV_SUCCESS;
    WORD32 header_data_left = 0,frame_data_left = 0;
    UWORD8 *pu1_bitstrm_buf;
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    ithread_set_name((void*)""Parse_thread"");

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
 }

    ps_dec->pv_dec_out = ps_dec_op;
 if(ps_dec->init_done != 1)
 {
 return IV_FAIL;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
    DATA_SYNC();

 if(0 == ps_dec->u1_flushfrm)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }
    ps_dec->u1_pic_decode_done = 0;

    ps_dec_op->u4_num_bytes_consumed = 0;

    ps_dec->ps_out_buffer = NULL;

 if(ps_dec_ip->u4_size
 >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;

    ps_dec->u4_fmt_conv_cur_row = 0;

    ps_dec->u4_output_present = 0;
    ps_dec->s_disp_op.u4_error_code = 1;
    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
 if(0 == ps_dec->u4_share_disp_buf
 && ps_dec->i4_decode_header == 0)
 {
        UWORD32 i;
 if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

 if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
 return IV_FAIL;
 }

 /* ! */
    ps_dec->u4_ts = ps_dec_ip->u4_ts;

    ps_dec_op->u4_error_code = 0;
    ps_dec_op->e_pic_type = -1;
    ps_dec_op->u4_output_present = 0;
    ps_dec_op->u4_frame_decoded_flag = 0;

    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;
 /*
     * For field pictures, set the bottom and top picture decoded u4_flag correctly.
     */
 {
 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
 {
            ps_dec->u1_top_bottom_decoded = 0;
 }
 }
    ps_dec->u4_slice_start_code_found = 0;

 /* In case the deocder is not in flush mode(in shared mode),
     then decoder has to pick up a buffer to write current frame.
     Check if a frame is available in such cases */

 if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
 && ps_dec->u1_flushfrm == 0)
 {
        UWORD32 i;

        WORD32 disp_avail = 0, free_id;

 /* Check if at least one buffer is available with the codec */
 /* If not then return to application with error */
 for(i = 0; i < ps_dec->u1_pic_bufs; i++)
 {
 if(0 == ps_dec->u4_disp_buf_mapping[i]
 || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
 {
                disp_avail = 1;
 break;
 }

 }

 if(0 == disp_avail)
 {
 /* If something is queued for display wait for that buffer to be returned */

            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }

 while(1)
 {
 pic_buffer_t *ps_pic_buf;
            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);

 if(ps_pic_buf == NULL)
 {
                UWORD32 i, display_queued = 0;

 /* check if any buffer was given for display which is not returned yet */
 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
 {
 if(0 != ps_dec->u4_disp_buf_mapping[i])
 {
                        display_queued = 1;
 break;
 }
 }
 /* If some buffer is queued for display, then codec has to singal an error and wait
                 for that buffer to be returned.
                 If nothing is queued for display then codec has ownership of all display buffers
                 and it can reuse any of the existing buffers and continue decoding */

 if(1 == display_queued)
 {
 /* If something is queued for display wait for that buffer to be returned */
                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                    ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }
 }
 else
 {
 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
 {
                    ih264_buf_mgr_set_status(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                    free_id,
                                    BUF_MGR_IO);
 }
 else
 {
 /**
                     *  Found a free buffer for present call. Release it now.
                     *  Will be again obtained later.
                     */
                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                          free_id,
                                          BUF_MGR_IO);
 break;
 }
 }
 }

 }

 if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
 {

        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
            ps_dec->u4_fmt_conv_cur_row = 0;
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
            ps_dec->u4_output_present = 1;

 }
        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));

        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;

        ps_dec_op->u4_new_seq = 0;

        ps_dec_op->u4_output_present = ps_dec->u4_output_present;
        ps_dec_op->u4_progressive_frame_flag =
                        ps_dec->s_disp_op.u4_progressive_frame_flag;
        ps_dec_op->e_output_format =
                        ps_dec->s_disp_op.e_output_format;
        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;

 /*In the case of flush ,since no frame is decoded set pic type as invalid*/
        ps_dec_op->u4_is_ref_flag = -1;
        ps_dec_op->e_pic_type = IV_NA_FRAME;
        ps_dec_op->u4_frame_decoded_flag = 0;

 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
 return (IV_SUCCESS);
 }
 else
 return (IV_FAIL);

 }
 if(ps_dec->u1_res_changed == 1)
 {
 /*if resolution has changed and all buffers have been flushed, reset decoder*/
        ih264d_init_decoder(ps_dec);
 }

    ps_dec->u4_prev_nal_skipped = 0;

    ps_dec->u2_cur_mb_addr = 0;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->u2_cur_slice_num = 0;
    ps_dec->cur_dec_mb_num = 0;
    ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_slice_header_done = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->u4_dec_thread_created = 0;
    ps_dec->u4_bs_deblk_thread_created = 0;
    ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;

    DEBUG_THREADS_PRINTF("" Starting process call\n"");


    ps_dec->u4_pic_buf_got = 0;

 do
 {
        WORD32 buf_size;

        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
 + ps_dec_op->u4_num_bytes_consumed;

        u4_max_ofst = ps_dec_ip->u4_num_Bytes
 - ps_dec_op->u4_num_bytes_consumed;

 /* If dynamic bitstream buffer is not allocated and
         * header decode is done, then allocate dynamic bitstream buffer
         */
 if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
 (ps_dec->i4_header_decoded & 1))
 {
            WORD32 size;

 void *pv_buf;
 void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
            RETURN_IF((NULL == pv_buf), IV_FAIL);
            ps_dec->pu1_bits_buf_dynamic = pv_buf;
            ps_dec->u4_dynamic_bits_buf_size = size;
 }

 if(ps_dec->pu1_bits_buf_dynamic)
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
            buf_size = ps_dec->u4_dynamic_bits_buf_size;
 }
 else
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
            buf_size = ps_dec->u4_static_bits_buf_size;
 }

        u4_next_is_aud = 0;

        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
 &u4_length_of_start_code,
 &u4_next_is_aud);

 if(buflen == -1)
            buflen = 0;
 /* Ignore bytes beyond the allocated size of intermediate buffer */
        buflen = MIN(buflen, buf_size);

        bytes_consumed = buflen + u4_length_of_start_code;
        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;

 {
            UWORD8 u1_firstbyte, u1_nal_ref_idc;

 if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
 {
                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
 if(u1_nal_ref_idc == 0)
 {
 /*skip non reference frames*/
                    cur_slice_is_nonref = 1;
 continue;
 }
 else
 {
 if(1 == cur_slice_is_nonref)
 {
 /*We have encountered a referenced frame,return to app*/
                        ps_dec_op->u4_num_bytes_consumed -=
                                        bytes_consumed;
                        ps_dec_op->e_pic_type = IV_B_FRAME;
                        ps_dec_op->u4_error_code =
                                        IVD_DEC_FRM_SKIPPED;
                        ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
                        ps_dec_op->u4_frame_decoded_flag = 0;
                        ps_dec_op->u4_size =
 sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
                        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                            ih264d_signal_bs_deblk_thread(ps_dec);
 }

 return (IV_FAIL);
 }
 }

 }

 }


 if(buflen)
 {
            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                   buflen);
 /* Decoder may read extra 8 bytes near end of the frame */
 if((buflen + 8) < buf_size)
 {
                memset(pu1_bitstrm_buf + buflen, 0, 8);
 }
            u4_first_start_code_found = 1;

 }
 else
 {
 /*start code not found*/

 if(u4_first_start_code_found == 0)
 {
 /*no start codes found in current process call*/

                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;

 if(ps_dec->u4_pic_buf_got == 0)
 {

                    ih264d_fill_output_struct_from_context(ps_dec,
                                                           ps_dec_op);

                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                    ps_dec_op->u4_frame_decoded_flag = 0;

 return (IV_FAIL);
 }
 else
 {
                    ps_dec->u1_pic_decode_done = 1;
 continue;
 }
 }
 else
 {
 /* a start code has already been found earlier in the same process call*/
                frame_data_left = 0;
 continue;
 }

 }

        ps_dec->u4_return_to_app = 0;
        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                              pu1_bitstrm_buf, buflen);
 if(ret != OK)
 {
            UWORD32 error =  ih264d_map_error(ret);
            ps_dec_op->u4_error_code = error | ret;
            api_ret_value = IV_FAIL;

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {
                ps_dec->u4_slice_start_code_found = 0;
 break;
 }

 if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
 {
                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                api_ret_value = IV_FAIL;
 break;
 }

 if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
 {
                api_ret_value = IV_FAIL;
 break;
 }

 }

 if(ps_dec->u4_return_to_app)
 {
 /*We have encountered a referenced frame,return to app*/
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
            ps_dec_op->u4_frame_decoded_flag = 0;
            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
            ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }



        header_data_left = ((ps_dec->i4_decode_header == 1)
 && (ps_dec->i4_header_decoded != 3)
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
        frame_data_left = (((ps_dec->i4_decode_header == 0)
 && ((ps_dec->u1_pic_decode_done == 0)
 || (u4_next_is_aud == 1)))
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
 }
 while(( header_data_left == 1)||(frame_data_left == 1));

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ret != IVD_MEM_ALLOC_FAILED)
 && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        WORD32 num_mb_skipped;
        WORD32 prev_slice_err;
 pocstruct_t temp_poc;
        WORD32 ret1;

        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;

 if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
            prev_slice_err = 1;

         else
             prev_slice_err = 2;
 
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
 if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
 {
 return IV_FAIL;
 }
 }

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {

 /* signal the decode thread */
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet */
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 /* dont consume bitstream for change in resolution case */
 if(ret == IVD_RES_CHANGED)
 {
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
 }
 return IV_FAIL;
 }


 if(ps_dec->u1_separate_parse)
 {
 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_num_cores == 2)
 {

 /*do deblocking of all mbs*/
 if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
 {
                UWORD32 u4_num_mbs,u4_max_addr;
 tfr_ctxt_t s_tfr_ctxt;
 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;

 /*BS is done for all mbs while parsing*/
                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;


                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                           ps_dec->u2_frm_wd_in_mbs, 0);


                u4_num_mbs = u4_max_addr
 - ps_dec->u4_cur_deblk_mb_num + 1;

                DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);

 if(u4_num_mbs != 0)
                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                   ps_tfr_cxt,1);

                ps_dec->u4_start_recon_deblk  = 0;

 }

 }

 /*signal the decode thread*/
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 }


    DATA_SYNC();


 if((ps_dec_op->u4_error_code & 0xff)
 != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
 {
        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 }

 if(ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }

 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }
 if(ps_dec->u4_prev_nal_skipped)
 {
 /*We have encountered a referenced frame,return to app*/
        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec_op->u4_frame_decoded_flag = 0;
        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
 {
 /*
         * For field pictures, set the bottom and top picture decoded u4_flag correctly.
         */

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
 {
 if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
 {
                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
 }
 else
 {
                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
 }
 }

 /* if new frame in not found (if we are still getting slices from previous frame)
         * ih264d_deblock_display is not called. Such frames will not be added to reference /display
         */
 if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
 {
 /* Calling Function to deblock Picture and Display */
            ret = ih264d_deblock_display(ps_dec);
 if(ret != 0)
 {
 return IV_FAIL;
 }
 }


 /*set to complete ,as we dont support partial frame decode*/
 if(ps_dec->i4_header_decoded == 3)
 {
            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
 }

 /*Update the i4_frametype at the end of picture*/
 if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
 {
            ps_dec->i4_frametype = IV_IDR_FRAME;
 }
 else if(ps_dec->i4_pic_type == B_SLICE)
 {
            ps_dec->i4_frametype = IV_B_FRAME;
 }
 else if(ps_dec->i4_pic_type == P_SLICE)
 {
            ps_dec->i4_frametype = IV_P_FRAME;
 }
 else if(ps_dec->i4_pic_type == I_SLICE)
 {
            ps_dec->i4_frametype = IV_I_FRAME;
 }
 else
 {
            H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
 }

        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;

        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
 - ps_dec->ps_cur_slice->u1_field_pic_flag;

 }

 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
        ih264d_signal_bs_deblk_thread(ps_dec);
 }


 {
 /* In case the decoder is configured to run in low delay mode,
         * then get display buffer and then format convert.
         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
         */

 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
 && ps_dec->u1_init_dec_flag)
 {

            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = 0;
                ps_dec->u4_output_present = 1;
 }
 }

        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);

 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_output_present &&
 (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
 {
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
 - ps_dec->u4_fmt_conv_cur_row;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
 }

        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 }

 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
 {
        ps_dec_op->u4_progressive_frame_flag = 1;
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
 && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                ps_dec_op->u4_progressive_frame_flag = 0;

 }
 }

 /*Data memory barrier instruction,so that yuv write by the library is complete*/
    DATA_SYNC();

    H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                         ps_dec_op->u4_num_bytes_consumed);
 return api_ret_value;
}
",C,"        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
            prev_slice_err = 1;

",,,"@@ -2140,6 +2140,9 @@

         else
             prev_slice_err = 2;
 
+        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
+            prev_slice_err = 1;
+
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
",Android,https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf/,https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf%5E/,1,"WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 /* ! */

 dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    WORD32 i4_err_status = 0;
    UWORD8 *pu1_buf = NULL;
    WORD32 buflen;
    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;

    UWORD32 bytes_consumed = 0;
    UWORD32 cur_slice_is_nonref = 0;
    UWORD32 u4_next_is_aud;
    UWORD32 u4_first_start_code_found = 0;
    WORD32 ret = 0,api_ret_value = IV_SUCCESS;
    WORD32 header_data_left = 0,frame_data_left = 0;
    UWORD8 *pu1_bitstrm_buf;
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    ithread_set_name((void*)""Parse_thread"");

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
 }

    ps_dec->pv_dec_out = ps_dec_op;
 if(ps_dec->init_done != 1)
 {
 return IV_FAIL;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
    DATA_SYNC();

 if(0 == ps_dec->u1_flushfrm)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }
    ps_dec->u1_pic_decode_done = 0;

    ps_dec_op->u4_num_bytes_consumed = 0;

    ps_dec->ps_out_buffer = NULL;

 if(ps_dec_ip->u4_size
 >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;

    ps_dec->u4_fmt_conv_cur_row = 0;

    ps_dec->u4_output_present = 0;
    ps_dec->s_disp_op.u4_error_code = 1;
    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
 if(0 == ps_dec->u4_share_disp_buf
 && ps_dec->i4_decode_header == 0)
 {
        UWORD32 i;
 if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

 if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
 return IV_FAIL;
 }

 /* ! */
    ps_dec->u4_ts = ps_dec_ip->u4_ts;

    ps_dec_op->u4_error_code = 0;
    ps_dec_op->e_pic_type = -1;
    ps_dec_op->u4_output_present = 0;
    ps_dec_op->u4_frame_decoded_flag = 0;

    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;
 /*
     * For field pictures, set the bottom and top picture decoded u4_flag correctly.
     */
 {
 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
 {
            ps_dec->u1_top_bottom_decoded = 0;
 }
 }
    ps_dec->u4_slice_start_code_found = 0;

 /* In case the deocder is not in flush mode(in shared mode),
     then decoder has to pick up a buffer to write current frame.
     Check if a frame is available in such cases */

 if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
 && ps_dec->u1_flushfrm == 0)
 {
        UWORD32 i;

        WORD32 disp_avail = 0, free_id;

 /* Check if at least one buffer is available with the codec */
 /* If not then return to application with error */
 for(i = 0; i < ps_dec->u1_pic_bufs; i++)
 {
 if(0 == ps_dec->u4_disp_buf_mapping[i]
 || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
 {
                disp_avail = 1;
 break;
 }

 }

 if(0 == disp_avail)
 {
 /* If something is queued for display wait for that buffer to be returned */

            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }

 while(1)
 {
 pic_buffer_t *ps_pic_buf;
            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);

 if(ps_pic_buf == NULL)
 {
                UWORD32 i, display_queued = 0;

 /* check if any buffer was given for display which is not returned yet */
 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
 {
 if(0 != ps_dec->u4_disp_buf_mapping[i])
 {
                        display_queued = 1;
 break;
 }
 }
 /* If some buffer is queued for display, then codec has to singal an error and wait
                 for that buffer to be returned.
                 If nothing is queued for display then codec has ownership of all display buffers
                 and it can reuse any of the existing buffers and continue decoding */

 if(1 == display_queued)
 {
 /* If something is queued for display wait for that buffer to be returned */
                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                    ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }
 }
 else
 {
 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
 {
                    ih264_buf_mgr_set_status(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                    free_id,
                                    BUF_MGR_IO);
 }
 else
 {
 /**
                     *  Found a free buffer for present call. Release it now.
                     *  Will be again obtained later.
                     */
                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                          free_id,
                                          BUF_MGR_IO);
 break;
 }
 }
 }

 }

 if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
 {

        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
            ps_dec->u4_fmt_conv_cur_row = 0;
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
            ps_dec->u4_output_present = 1;

 }
        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));

        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;

        ps_dec_op->u4_new_seq = 0;

        ps_dec_op->u4_output_present = ps_dec->u4_output_present;
        ps_dec_op->u4_progressive_frame_flag =
                        ps_dec->s_disp_op.u4_progressive_frame_flag;
        ps_dec_op->e_output_format =
                        ps_dec->s_disp_op.e_output_format;
        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;

 /*In the case of flush ,since no frame is decoded set pic type as invalid*/
        ps_dec_op->u4_is_ref_flag = -1;
        ps_dec_op->e_pic_type = IV_NA_FRAME;
        ps_dec_op->u4_frame_decoded_flag = 0;

 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
 return (IV_SUCCESS);
 }
 else
 return (IV_FAIL);

 }
 if(ps_dec->u1_res_changed == 1)
 {
 /*if resolution has changed and all buffers have been flushed, reset decoder*/
        ih264d_init_decoder(ps_dec);
 }

    ps_dec->u4_prev_nal_skipped = 0;

    ps_dec->u2_cur_mb_addr = 0;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->u2_cur_slice_num = 0;
    ps_dec->cur_dec_mb_num = 0;
    ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_slice_header_done = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->u4_dec_thread_created = 0;
    ps_dec->u4_bs_deblk_thread_created = 0;
    ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;

    DEBUG_THREADS_PRINTF("" Starting process call\n"");


    ps_dec->u4_pic_buf_got = 0;

 do
 {
        WORD32 buf_size;

        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
 + ps_dec_op->u4_num_bytes_consumed;

        u4_max_ofst = ps_dec_ip->u4_num_Bytes
 - ps_dec_op->u4_num_bytes_consumed;

 /* If dynamic bitstream buffer is not allocated and
         * header decode is done, then allocate dynamic bitstream buffer
         */
 if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
 (ps_dec->i4_header_decoded & 1))
 {
            WORD32 size;

 void *pv_buf;
 void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
            RETURN_IF((NULL == pv_buf), IV_FAIL);
            ps_dec->pu1_bits_buf_dynamic = pv_buf;
            ps_dec->u4_dynamic_bits_buf_size = size;
 }

 if(ps_dec->pu1_bits_buf_dynamic)
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
            buf_size = ps_dec->u4_dynamic_bits_buf_size;
 }
 else
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
            buf_size = ps_dec->u4_static_bits_buf_size;
 }

        u4_next_is_aud = 0;

        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
 &u4_length_of_start_code,
 &u4_next_is_aud);

 if(buflen == -1)
            buflen = 0;
 /* Ignore bytes beyond the allocated size of intermediate buffer */
        buflen = MIN(buflen, buf_size);

        bytes_consumed = buflen + u4_length_of_start_code;
        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;

 {
            UWORD8 u1_firstbyte, u1_nal_ref_idc;

 if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
 {
                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
 if(u1_nal_ref_idc == 0)
 {
 /*skip non reference frames*/
                    cur_slice_is_nonref = 1;
 continue;
 }
 else
 {
 if(1 == cur_slice_is_nonref)
 {
 /*We have encountered a referenced frame,return to app*/
                        ps_dec_op->u4_num_bytes_consumed -=
                                        bytes_consumed;
                        ps_dec_op->e_pic_type = IV_B_FRAME;
                        ps_dec_op->u4_error_code =
                                        IVD_DEC_FRM_SKIPPED;
                        ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
                        ps_dec_op->u4_frame_decoded_flag = 0;
                        ps_dec_op->u4_size =
 sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
                        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                            ih264d_signal_bs_deblk_thread(ps_dec);
 }

 return (IV_FAIL);
 }
 }

 }

 }


 if(buflen)
 {
            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                   buflen);
 /* Decoder may read extra 8 bytes near end of the frame */
 if((buflen + 8) < buf_size)
 {
                memset(pu1_bitstrm_buf + buflen, 0, 8);
 }
            u4_first_start_code_found = 1;

 }
 else
 {
 /*start code not found*/

 if(u4_first_start_code_found == 0)
 {
 /*no start codes found in current process call*/

                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;

 if(ps_dec->u4_pic_buf_got == 0)
 {

                    ih264d_fill_output_struct_from_context(ps_dec,
                                                           ps_dec_op);

                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                    ps_dec_op->u4_frame_decoded_flag = 0;

 return (IV_FAIL);
 }
 else
 {
                    ps_dec->u1_pic_decode_done = 1;
 continue;
 }
 }
 else
 {
 /* a start code has already been found earlier in the same process call*/
                frame_data_left = 0;
 continue;
 }

 }

        ps_dec->u4_return_to_app = 0;
        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                              pu1_bitstrm_buf, buflen);
 if(ret != OK)
 {
            UWORD32 error =  ih264d_map_error(ret);
            ps_dec_op->u4_error_code = error | ret;
            api_ret_value = IV_FAIL;

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {
                ps_dec->u4_slice_start_code_found = 0;
 break;
 }

 if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
 {
                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                api_ret_value = IV_FAIL;
 break;
 }

 if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
 {
                api_ret_value = IV_FAIL;
 break;
 }

 }

 if(ps_dec->u4_return_to_app)
 {
 /*We have encountered a referenced frame,return to app*/
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
            ps_dec_op->u4_frame_decoded_flag = 0;
            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
            ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }



        header_data_left = ((ps_dec->i4_decode_header == 1)
 && (ps_dec->i4_header_decoded != 3)
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
        frame_data_left = (((ps_dec->i4_decode_header == 0)
 && ((ps_dec->u1_pic_decode_done == 0)
 || (u4_next_is_aud == 1)))
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
 }
 while(( header_data_left == 1)||(frame_data_left == 1));

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ret != IVD_MEM_ALLOC_FAILED)
 && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
 // last slice - missing/corruption
        WORD32 num_mb_skipped;
        WORD32 prev_slice_err;
 pocstruct_t temp_poc;
        WORD32 ret1;

        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;

 if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
            prev_slice_err = 1;

         else
             prev_slice_err = 2;
 
//fix_flaw_line_below:
//        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
//fix_flaw_line_below:
//            prev_slice_err = 1;
//fix_flaw_line_below:
//
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
 if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
 {
 return IV_FAIL;
 }
 }

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {

 /* signal the decode thread */
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet */
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 /* dont consume bitstream for change in resolution case */
 if(ret == IVD_RES_CHANGED)
 {
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
 }
 return IV_FAIL;
 }


 if(ps_dec->u1_separate_parse)
 {
 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_num_cores == 2)
 {

 /*do deblocking of all mbs*/
 if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
 {
                UWORD32 u4_num_mbs,u4_max_addr;
 tfr_ctxt_t s_tfr_ctxt;
 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;

 /*BS is done for all mbs while parsing*/
                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;


                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                           ps_dec->u2_frm_wd_in_mbs, 0);


                u4_num_mbs = u4_max_addr
 - ps_dec->u4_cur_deblk_mb_num + 1;

                DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);

 if(u4_num_mbs != 0)
                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                   ps_tfr_cxt,1);

                ps_dec->u4_start_recon_deblk  = 0;

 }

 }

 /*signal the decode thread*/
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 }


    DATA_SYNC();


 if((ps_dec_op->u4_error_code & 0xff)
 != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
 {
        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 }

//Report if header (sps and pps) has not been decoded yet
 if(ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }

 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }
 if(ps_dec->u4_prev_nal_skipped)
 {
 /*We have encountered a referenced frame,return to app*/
        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec_op->u4_frame_decoded_flag = 0;
        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
 {
 /*
         * For field pictures, set the bottom and top picture decoded u4_flag correctly.
         */

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
 {
 if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
 {
                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
 }
 else
 {
                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
 }
 }

 /* if new frame in not found (if we are still getting slices from previous frame)
         * ih264d_deblock_display is not called. Such frames will not be added to reference /display
         */
 if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
 {
 /* Calling Function to deblock Picture and Display */
            ret = ih264d_deblock_display(ps_dec);
 if(ret != 0)
 {
 return IV_FAIL;
 }
 }


 /*set to complete ,as we dont support partial frame decode*/
 if(ps_dec->i4_header_decoded == 3)
 {
            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
 }

 /*Update the i4_frametype at the end of picture*/
 if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
 {
            ps_dec->i4_frametype = IV_IDR_FRAME;
 }
 else if(ps_dec->i4_pic_type == B_SLICE)
 {
            ps_dec->i4_frametype = IV_B_FRAME;
 }
 else if(ps_dec->i4_pic_type == P_SLICE)
 {
            ps_dec->i4_frametype = IV_P_FRAME;
 }
 else if(ps_dec->i4_pic_type == I_SLICE)
 {
            ps_dec->i4_frametype = IV_I_FRAME;
 }
 else
 {
            H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
 }

 //Update the content type
        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;

        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
 - ps_dec->ps_cur_slice->u1_field_pic_flag;

 }

 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
        ih264d_signal_bs_deblk_thread(ps_dec);
 }


 {
 /* In case the decoder is configured to run in low delay mode,
         * then get display buffer and then format convert.
         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
         */

 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
 && ps_dec->u1_init_dec_flag)
 {

            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = 0;
                ps_dec->u4_output_present = 1;
 }
 }

        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);

 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_output_present &&
 (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
 {
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
 - ps_dec->u4_fmt_conv_cur_row;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
 }

        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 }

 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
 {
        ps_dec_op->u4_progressive_frame_flag = 1;
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
 && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                ps_dec_op->u4_progressive_frame_flag = 0;

 }
 }

 /*Data memory barrier instruction,so that yuv write by the library is complete*/
    DATA_SYNC();

    H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                         ps_dec_op->u4_num_bytes_consumed);
 return api_ret_value;
}
",187435,"WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 /* ! */

 dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    WORD32 i4_err_status = 0;
    UWORD8 *pu1_buf = NULL;
    WORD32 buflen;
    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;

    UWORD32 bytes_consumed = 0;
    UWORD32 cur_slice_is_nonref = 0;
    UWORD32 u4_next_is_aud;
    UWORD32 u4_first_start_code_found = 0;
    WORD32 ret = 0,api_ret_value = IV_SUCCESS;
    WORD32 header_data_left = 0,frame_data_left = 0;
    UWORD8 *pu1_bitstrm_buf;
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    ithread_set_name((void*)""Parse_thread"");

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
 }

    ps_dec->pv_dec_out = ps_dec_op;
 if(ps_dec->init_done != 1)
 {
 return IV_FAIL;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
    DATA_SYNC();

 if(0 == ps_dec->u1_flushfrm)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }
    ps_dec->u1_pic_decode_done = 0;

    ps_dec_op->u4_num_bytes_consumed = 0;

    ps_dec->ps_out_buffer = NULL;

 if(ps_dec_ip->u4_size
 >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;

    ps_dec->u4_fmt_conv_cur_row = 0;

    ps_dec->u4_output_present = 0;
    ps_dec->s_disp_op.u4_error_code = 1;
    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
 if(0 == ps_dec->u4_share_disp_buf
 && ps_dec->i4_decode_header == 0)
 {
        UWORD32 i;
 if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

 if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
 return IV_FAIL;
 }

 /* ! */
    ps_dec->u4_ts = ps_dec_ip->u4_ts;

    ps_dec_op->u4_error_code = 0;
    ps_dec_op->e_pic_type = -1;
    ps_dec_op->u4_output_present = 0;
    ps_dec_op->u4_frame_decoded_flag = 0;

    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;
 /*
     * For field pictures, set the bottom and top picture decoded u4_flag correctly.
     */
 {
 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
 {
            ps_dec->u1_top_bottom_decoded = 0;
 }
 }
    ps_dec->u4_slice_start_code_found = 0;

 /* In case the deocder is not in flush mode(in shared mode),
     then decoder has to pick up a buffer to write current frame.
     Check if a frame is available in such cases */

 if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
 && ps_dec->u1_flushfrm == 0)
 {
        UWORD32 i;

        WORD32 disp_avail = 0, free_id;

 /* Check if at least one buffer is available with the codec */
 /* If not then return to application with error */
 for(i = 0; i < ps_dec->u1_pic_bufs; i++)
 {
 if(0 == ps_dec->u4_disp_buf_mapping[i]
 || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
 {
                disp_avail = 1;
 break;
 }

 }

 if(0 == disp_avail)
 {
 /* If something is queued for display wait for that buffer to be returned */

            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }

 while(1)
 {
 pic_buffer_t *ps_pic_buf;
            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);

 if(ps_pic_buf == NULL)
 {
                UWORD32 i, display_queued = 0;

 /* check if any buffer was given for display which is not returned yet */
 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
 {
 if(0 != ps_dec->u4_disp_buf_mapping[i])
 {
                        display_queued = 1;
 break;
 }
 }
 /* If some buffer is queued for display, then codec has to singal an error and wait
                 for that buffer to be returned.
                 If nothing is queued for display then codec has ownership of all display buffers
                 and it can reuse any of the existing buffers and continue decoding */

 if(1 == display_queued)
 {
 /* If something is queued for display wait for that buffer to be returned */
                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                    ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }
 }
 else
 {
 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
 {
                    ih264_buf_mgr_set_status(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                    free_id,
                                    BUF_MGR_IO);
 }
 else
 {
 /**
                     *  Found a free buffer for present call. Release it now.
                     *  Will be again obtained later.
                     */
                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                          free_id,
                                          BUF_MGR_IO);
 break;
 }
 }
 }

 }

 if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
 {

        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
            ps_dec->u4_fmt_conv_cur_row = 0;
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
            ps_dec->u4_output_present = 1;

 }
        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));

        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;

        ps_dec_op->u4_new_seq = 0;

        ps_dec_op->u4_output_present = ps_dec->u4_output_present;
        ps_dec_op->u4_progressive_frame_flag =
                        ps_dec->s_disp_op.u4_progressive_frame_flag;
        ps_dec_op->e_output_format =
                        ps_dec->s_disp_op.e_output_format;
        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;

 /*In the case of flush ,since no frame is decoded set pic type as invalid*/
        ps_dec_op->u4_is_ref_flag = -1;
        ps_dec_op->e_pic_type = IV_NA_FRAME;
        ps_dec_op->u4_frame_decoded_flag = 0;

 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
 return (IV_SUCCESS);
 }
 else
 return (IV_FAIL);

 }
 if(ps_dec->u1_res_changed == 1)
 {
 /*if resolution has changed and all buffers have been flushed, reset decoder*/
        ih264d_init_decoder(ps_dec);
 }

    ps_dec->u4_prev_nal_skipped = 0;

    ps_dec->u2_cur_mb_addr = 0;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->u2_cur_slice_num = 0;
    ps_dec->cur_dec_mb_num = 0;
    ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_slice_header_done = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->u4_dec_thread_created = 0;
    ps_dec->u4_bs_deblk_thread_created = 0;
    ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;

    DEBUG_THREADS_PRINTF("" Starting process call\n"");


    ps_dec->u4_pic_buf_got = 0;

 do
 {
        WORD32 buf_size;

        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
 + ps_dec_op->u4_num_bytes_consumed;

        u4_max_ofst = ps_dec_ip->u4_num_Bytes
 - ps_dec_op->u4_num_bytes_consumed;

 /* If dynamic bitstream buffer is not allocated and
         * header decode is done, then allocate dynamic bitstream buffer
         */
 if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
 (ps_dec->i4_header_decoded & 1))
 {
            WORD32 size;

 void *pv_buf;
 void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
            RETURN_IF((NULL == pv_buf), IV_FAIL);
            ps_dec->pu1_bits_buf_dynamic = pv_buf;
            ps_dec->u4_dynamic_bits_buf_size = size;
 }

 if(ps_dec->pu1_bits_buf_dynamic)
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
            buf_size = ps_dec->u4_dynamic_bits_buf_size;
 }
 else
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
            buf_size = ps_dec->u4_static_bits_buf_size;
 }

        u4_next_is_aud = 0;

        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
 &u4_length_of_start_code,
 &u4_next_is_aud);

 if(buflen == -1)
            buflen = 0;
 /* Ignore bytes beyond the allocated size of intermediate buffer */
        buflen = MIN(buflen, buf_size);

        bytes_consumed = buflen + u4_length_of_start_code;
        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;

 {
            UWORD8 u1_firstbyte, u1_nal_ref_idc;

 if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
 {
                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
 if(u1_nal_ref_idc == 0)
 {
 /*skip non reference frames*/
                    cur_slice_is_nonref = 1;
 continue;
 }
 else
 {
 if(1 == cur_slice_is_nonref)
 {
 /*We have encountered a referenced frame,return to app*/
                        ps_dec_op->u4_num_bytes_consumed -=
                                        bytes_consumed;
                        ps_dec_op->e_pic_type = IV_B_FRAME;
                        ps_dec_op->u4_error_code =
                                        IVD_DEC_FRM_SKIPPED;
                        ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
                        ps_dec_op->u4_frame_decoded_flag = 0;
                        ps_dec_op->u4_size =
 sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
                        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                            ih264d_signal_bs_deblk_thread(ps_dec);
 }

 return (IV_FAIL);
 }
 }

 }

 }


 if(buflen)
 {
            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                   buflen);
 /* Decoder may read extra 8 bytes near end of the frame */
 if((buflen + 8) < buf_size)
 {
                memset(pu1_bitstrm_buf + buflen, 0, 8);
 }
            u4_first_start_code_found = 1;

 }
 else
 {
 /*start code not found*/

 if(u4_first_start_code_found == 0)
 {
 /*no start codes found in current process call*/

                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;

 if(ps_dec->u4_pic_buf_got == 0)
 {

                    ih264d_fill_output_struct_from_context(ps_dec,
                                                           ps_dec_op);

                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                    ps_dec_op->u4_frame_decoded_flag = 0;

 return (IV_FAIL);
 }
 else
 {
                    ps_dec->u1_pic_decode_done = 1;
 continue;
 }
 }
 else
 {
 /* a start code has already been found earlier in the same process call*/
                frame_data_left = 0;
 continue;
 }

 }

        ps_dec->u4_return_to_app = 0;
        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                              pu1_bitstrm_buf, buflen);
 if(ret != OK)
 {
            UWORD32 error =  ih264d_map_error(ret);
            ps_dec_op->u4_error_code = error | ret;
            api_ret_value = IV_FAIL;

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {
                ps_dec->u4_slice_start_code_found = 0;
 break;
 }

 if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
 {
                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                api_ret_value = IV_FAIL;
 break;
 }

 if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
 {
                api_ret_value = IV_FAIL;
 break;
 }

 }

 if(ps_dec->u4_return_to_app)
 {
 /*We have encountered a referenced frame,return to app*/
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
            ps_dec_op->u4_frame_decoded_flag = 0;
            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
            ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }



        header_data_left = ((ps_dec->i4_decode_header == 1)
 && (ps_dec->i4_header_decoded != 3)
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
        frame_data_left = (((ps_dec->i4_decode_header == 0)
 && ((ps_dec->u1_pic_decode_done == 0)
 || (u4_next_is_aud == 1)))
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
 }
 while(( header_data_left == 1)||(frame_data_left == 1));

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ret != IVD_MEM_ALLOC_FAILED)
 && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        WORD32 num_mb_skipped;
        WORD32 prev_slice_err;
 pocstruct_t temp_poc;
        WORD32 ret1;

        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;

 if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
            prev_slice_err = 1;

         else
             prev_slice_err = 2;
 
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
 if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
 {
 return IV_FAIL;
 }
 }

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {

 /* signal the decode thread */
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet */
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 /* dont consume bitstream for change in resolution case */
 if(ret == IVD_RES_CHANGED)
 {
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
 }
 return IV_FAIL;
 }


 if(ps_dec->u1_separate_parse)
 {
 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_num_cores == 2)
 {

 /*do deblocking of all mbs*/
 if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
 {
                UWORD32 u4_num_mbs,u4_max_addr;
 tfr_ctxt_t s_tfr_ctxt;
 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;

 /*BS is done for all mbs while parsing*/
                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;


                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                           ps_dec->u2_frm_wd_in_mbs, 0);


                u4_num_mbs = u4_max_addr
 - ps_dec->u4_cur_deblk_mb_num + 1;

                DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);

 if(u4_num_mbs != 0)
                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                   ps_tfr_cxt,1);

                ps_dec->u4_start_recon_deblk  = 0;

 }

 }

 /*signal the decode thread*/
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 }


    DATA_SYNC();


 if((ps_dec_op->u4_error_code & 0xff)
 != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
 {
        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 }

 if(ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }

 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }
 if(ps_dec->u4_prev_nal_skipped)
 {
 /*We have encountered a referenced frame,return to app*/
        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec_op->u4_frame_decoded_flag = 0;
        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
 {
 /*
         * For field pictures, set the bottom and top picture decoded u4_flag correctly.
         */

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
 {
 if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
 {
                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
 }
 else
 {
                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
 }
 }

 /* if new frame in not found (if we are still getting slices from previous frame)
         * ih264d_deblock_display is not called. Such frames will not be added to reference /display
         */
 if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
 {
 /* Calling Function to deblock Picture and Display */
            ret = ih264d_deblock_display(ps_dec);
 if(ret != 0)
 {
 return IV_FAIL;
 }
 }


 /*set to complete ,as we dont support partial frame decode*/
 if(ps_dec->i4_header_decoded == 3)
 {
            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
 }

 /*Update the i4_frametype at the end of picture*/
 if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
 {
            ps_dec->i4_frametype = IV_IDR_FRAME;
 }
 else if(ps_dec->i4_pic_type == B_SLICE)
 {
            ps_dec->i4_frametype = IV_B_FRAME;
 }
 else if(ps_dec->i4_pic_type == P_SLICE)
 {
            ps_dec->i4_frametype = IV_P_FRAME;
 }
 else if(ps_dec->i4_pic_type == I_SLICE)
 {
            ps_dec->i4_frametype = IV_I_FRAME;
 }
 else
 {
            H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
 }

        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;

        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
 - ps_dec->ps_cur_slice->u1_field_pic_flag;

 }

 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
        ih264d_signal_bs_deblk_thread(ps_dec);
 }


 {
 /* In case the decoder is configured to run in low delay mode,
         * then get display buffer and then format convert.
         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
         */

 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
 && ps_dec->u1_init_dec_flag)
 {

            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = 0;
                ps_dec->u4_output_present = 1;
 }
 }

        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);

 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_output_present &&
 (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
 {
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
 - ps_dec->u4_fmt_conv_cur_row;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
 }

        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 }

 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
 {
        ps_dec_op->u4_progressive_frame_flag = 1;
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
 && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                ps_dec_op->u4_progressive_frame_flag = 0;

 }
 }

 /*Data memory barrier instruction,so that yuv write by the library is complete*/
    DATA_SYNC();

    H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                         ps_dec_op->u4_num_bytes_consumed);
 return api_ret_value;
}
","WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 /* ! */

 dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    WORD32 i4_err_status = 0;
    UWORD8 *pu1_buf = NULL;
    WORD32 buflen;
    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;

    UWORD32 bytes_consumed = 0;
    UWORD32 cur_slice_is_nonref = 0;
    UWORD32 u4_next_is_aud;
    UWORD32 u4_first_start_code_found = 0;
    WORD32 ret = 0,api_ret_value = IV_SUCCESS;
    WORD32 header_data_left = 0,frame_data_left = 0;
    UWORD8 *pu1_bitstrm_buf;
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    ithread_set_name((void*)""Parse_thread"");

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
 }

    ps_dec->pv_dec_out = ps_dec_op;
 if(ps_dec->init_done != 1)
 {
 return IV_FAIL;
 }

 /*Data memory barries instruction,so that bitstream write by the application is complete*/
    DATA_SYNC();

 if(0 == ps_dec->u1_flushfrm)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }
    ps_dec->u1_pic_decode_done = 0;

    ps_dec_op->u4_num_bytes_consumed = 0;

    ps_dec->ps_out_buffer = NULL;

 if(ps_dec_ip->u4_size
 >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;

    ps_dec->u4_fmt_conv_cur_row = 0;

    ps_dec->u4_output_present = 0;
    ps_dec->s_disp_op.u4_error_code = 1;
    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
 if(0 == ps_dec->u4_share_disp_buf
 && ps_dec->i4_decode_header == 0)
 {
        UWORD32 i;
 if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

 if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
 return IV_FAIL;
 }

 /* ! */
    ps_dec->u4_ts = ps_dec_ip->u4_ts;

    ps_dec_op->u4_error_code = 0;
    ps_dec_op->e_pic_type = -1;
    ps_dec_op->u4_output_present = 0;
    ps_dec_op->u4_frame_decoded_flag = 0;

    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;
 /*
     * For field pictures, set the bottom and top picture decoded u4_flag correctly.
     */
 {
 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
 {
            ps_dec->u1_top_bottom_decoded = 0;
 }
 }
    ps_dec->u4_slice_start_code_found = 0;

 /* In case the deocder is not in flush mode(in shared mode),
     then decoder has to pick up a buffer to write current frame.
     Check if a frame is available in such cases */

 if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
 && ps_dec->u1_flushfrm == 0)
 {
        UWORD32 i;

        WORD32 disp_avail = 0, free_id;

 /* Check if at least one buffer is available with the codec */
 /* If not then return to application with error */
 for(i = 0; i < ps_dec->u1_pic_bufs; i++)
 {
 if(0 == ps_dec->u4_disp_buf_mapping[i]
 || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
 {
                disp_avail = 1;
 break;
 }

 }

 if(0 == disp_avail)
 {
 /* If something is queued for display wait for that buffer to be returned */

            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }

 while(1)
 {
 pic_buffer_t *ps_pic_buf;
            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);

 if(ps_pic_buf == NULL)
 {
                UWORD32 i, display_queued = 0;

 /* check if any buffer was given for display which is not returned yet */
 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
 {
 if(0 != ps_dec->u4_disp_buf_mapping[i])
 {
                        display_queued = 1;
 break;
 }
 }
 /* If some buffer is queued for display, then codec has to singal an error and wait
                 for that buffer to be returned.
                 If nothing is queued for display then codec has ownership of all display buffers
                 and it can reuse any of the existing buffers and continue decoding */

 if(1 == display_queued)
 {
 /* If something is queued for display wait for that buffer to be returned */
                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                    ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
 return (IV_FAIL);
 }
 }
 else
 {
 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
 {
                    ih264_buf_mgr_set_status(
 (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                    free_id,
                                    BUF_MGR_IO);
 }
 else
 {
 /**
                     *  Found a free buffer for present call. Release it now.
                     *  Will be again obtained later.
                     */
                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                          free_id,
                                          BUF_MGR_IO);
 break;
 }
 }
 }

 }

 if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
 {

        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
            ps_dec->u4_fmt_conv_cur_row = 0;
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
            ps_dec->u4_output_present = 1;

 }
        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));

        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;

        ps_dec_op->u4_new_seq = 0;

        ps_dec_op->u4_output_present = ps_dec->u4_output_present;
        ps_dec_op->u4_progressive_frame_flag =
                        ps_dec->s_disp_op.u4_progressive_frame_flag;
        ps_dec_op->e_output_format =
                        ps_dec->s_disp_op.e_output_format;
        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;

 /*In the case of flush ,since no frame is decoded set pic type as invalid*/
        ps_dec_op->u4_is_ref_flag = -1;
        ps_dec_op->e_pic_type = IV_NA_FRAME;
        ps_dec_op->u4_frame_decoded_flag = 0;

 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
 return (IV_SUCCESS);
 }
 else
 return (IV_FAIL);

 }
 if(ps_dec->u1_res_changed == 1)
 {
 /*if resolution has changed and all buffers have been flushed, reset decoder*/
        ih264d_init_decoder(ps_dec);
 }

    ps_dec->u4_prev_nal_skipped = 0;

    ps_dec->u2_cur_mb_addr = 0;
    ps_dec->u2_total_mbs_coded = 0;
    ps_dec->u2_cur_slice_num = 0;
    ps_dec->cur_dec_mb_num = 0;
    ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_slice_header_done = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->u4_dec_thread_created = 0;
    ps_dec->u4_bs_deblk_thread_created = 0;
    ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;

    DEBUG_THREADS_PRINTF("" Starting process call\n"");


    ps_dec->u4_pic_buf_got = 0;

 do
 {
        WORD32 buf_size;

        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
 + ps_dec_op->u4_num_bytes_consumed;

        u4_max_ofst = ps_dec_ip->u4_num_Bytes
 - ps_dec_op->u4_num_bytes_consumed;

 /* If dynamic bitstream buffer is not allocated and
         * header decode is done, then allocate dynamic bitstream buffer
         */
 if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
 (ps_dec->i4_header_decoded & 1))
 {
            WORD32 size;

 void *pv_buf;
 void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
            RETURN_IF((NULL == pv_buf), IV_FAIL);
            ps_dec->pu1_bits_buf_dynamic = pv_buf;
            ps_dec->u4_dynamic_bits_buf_size = size;
 }

 if(ps_dec->pu1_bits_buf_dynamic)
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
            buf_size = ps_dec->u4_dynamic_bits_buf_size;
 }
 else
 {
            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
            buf_size = ps_dec->u4_static_bits_buf_size;
 }

        u4_next_is_aud = 0;

        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
 &u4_length_of_start_code,
 &u4_next_is_aud);

 if(buflen == -1)
            buflen = 0;
 /* Ignore bytes beyond the allocated size of intermediate buffer */
        buflen = MIN(buflen, buf_size);

        bytes_consumed = buflen + u4_length_of_start_code;
        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;

 {
            UWORD8 u1_firstbyte, u1_nal_ref_idc;

 if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
 {
                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
 if(u1_nal_ref_idc == 0)
 {
 /*skip non reference frames*/
                    cur_slice_is_nonref = 1;
 continue;
 }
 else
 {
 if(1 == cur_slice_is_nonref)
 {
 /*We have encountered a referenced frame,return to app*/
                        ps_dec_op->u4_num_bytes_consumed -=
                                        bytes_consumed;
                        ps_dec_op->e_pic_type = IV_B_FRAME;
                        ps_dec_op->u4_error_code =
                                        IVD_DEC_FRM_SKIPPED;
                        ps_dec_op->u4_error_code |= (1
 << IVD_UNSUPPORTEDPARAM);
                        ps_dec_op->u4_frame_decoded_flag = 0;
                        ps_dec_op->u4_size =
 sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
                        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                            ih264d_signal_bs_deblk_thread(ps_dec);
 }

 return (IV_FAIL);
 }
 }

 }

 }


 if(buflen)
 {
            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                   buflen);
 /* Decoder may read extra 8 bytes near end of the frame */
 if((buflen + 8) < buf_size)
 {
                memset(pu1_bitstrm_buf + buflen, 0, 8);
 }
            u4_first_start_code_found = 1;

 }
 else
 {
 /*start code not found*/

 if(u4_first_start_code_found == 0)
 {
 /*no start codes found in current process call*/

                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;

 if(ps_dec->u4_pic_buf_got == 0)
 {

                    ih264d_fill_output_struct_from_context(ps_dec,
                                                           ps_dec_op);

                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                    ps_dec_op->u4_frame_decoded_flag = 0;

 return (IV_FAIL);
 }
 else
 {
                    ps_dec->u1_pic_decode_done = 1;
 continue;
 }
 }
 else
 {
 /* a start code has already been found earlier in the same process call*/
                frame_data_left = 0;
 continue;
 }

 }

        ps_dec->u4_return_to_app = 0;
        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                              pu1_bitstrm_buf, buflen);
 if(ret != OK)
 {
            UWORD32 error =  ih264d_map_error(ret);
            ps_dec_op->u4_error_code = error | ret;
            api_ret_value = IV_FAIL;

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {
                ps_dec->u4_slice_start_code_found = 0;
 break;
 }

 if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
 {
                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                api_ret_value = IV_FAIL;
 break;
 }

 if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
 {
                api_ret_value = IV_FAIL;
 break;
 }

 }

 if(ps_dec->u4_return_to_app)
 {
 /*We have encountered a referenced frame,return to app*/
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
            ps_dec_op->u4_frame_decoded_flag = 0;
            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /*signal the decode thread*/
            ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
                ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }



        header_data_left = ((ps_dec->i4_decode_header == 1)
 && (ps_dec->i4_header_decoded != 3)
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
        frame_data_left = (((ps_dec->i4_decode_header == 0)
 && ((ps_dec->u1_pic_decode_done == 0)
 || (u4_next_is_aud == 1)))
 && (ps_dec_op->u4_num_bytes_consumed
 < ps_dec_ip->u4_num_Bytes));
 }
 while(( header_data_left == 1)||(frame_data_left == 1));

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ret != IVD_MEM_ALLOC_FAILED)
 && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        WORD32 num_mb_skipped;
        WORD32 prev_slice_err;
 pocstruct_t temp_poc;
        WORD32 ret1;

        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;

 if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
            prev_slice_err = 1;

         else
             prev_slice_err = 2;
 
        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
            prev_slice_err = 1;

         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
 if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
 {
 return IV_FAIL;
 }
 }

 if((ret == IVD_RES_CHANGED)
 || (ret == IVD_MEM_ALLOC_FAILED)
 || (ret == ERROR_UNAVAIL_PICBUF_T)
 || (ret == ERROR_UNAVAIL_MVBUF_T)
 || (ret == ERROR_INV_SPS_PPS_T))
 {

 /* signal the decode thread */
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet */
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 /* dont consume bitstream for change in resolution case */
 if(ret == IVD_RES_CHANGED)
 {
            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
 }
 return IV_FAIL;
 }


 if(ps_dec->u1_separate_parse)
 {
 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_num_cores == 2)
 {

 /*do deblocking of all mbs*/
 if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
 {
                UWORD32 u4_num_mbs,u4_max_addr;
 tfr_ctxt_t s_tfr_ctxt;
 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;

 /*BS is done for all mbs while parsing*/
                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;


                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                           ps_dec->u2_frm_wd_in_mbs, 0);


                u4_num_mbs = u4_max_addr
 - ps_dec->u4_cur_deblk_mb_num + 1;

                DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);

 if(u4_num_mbs != 0)
                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                   ps_tfr_cxt,1);

                ps_dec->u4_start_recon_deblk  = 0;

 }

 }

 /*signal the decode thread*/
        ih264d_signal_decode_thread(ps_dec);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 }


    DATA_SYNC();


 if((ps_dec_op->u4_error_code & 0xff)
 != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
 {
        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 }

 if(ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }

 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
 {
        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);

 }
 if(ps_dec->u4_prev_nal_skipped)
 {
 /*We have encountered a referenced frame,return to app*/
        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec_op->u4_frame_decoded_flag = 0;
        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
            ih264d_signal_bs_deblk_thread(ps_dec);
 }
 return (IV_FAIL);

 }

 if((ps_dec->u4_slice_start_code_found == 1)
 && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
 {
 /*
         * For field pictures, set the bottom and top picture decoded u4_flag correctly.
         */

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
 {
 if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
 {
                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
 }
 else
 {
                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
 }
 }

 /* if new frame in not found (if we are still getting slices from previous frame)
         * ih264d_deblock_display is not called. Such frames will not be added to reference /display
         */
 if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
 {
 /* Calling Function to deblock Picture and Display */
            ret = ih264d_deblock_display(ps_dec);
 if(ret != 0)
 {
 return IV_FAIL;
 }
 }


 /*set to complete ,as we dont support partial frame decode*/
 if(ps_dec->i4_header_decoded == 3)
 {
            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
 }

 /*Update the i4_frametype at the end of picture*/
 if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
 {
            ps_dec->i4_frametype = IV_IDR_FRAME;
 }
 else if(ps_dec->i4_pic_type == B_SLICE)
 {
            ps_dec->i4_frametype = IV_B_FRAME;
 }
 else if(ps_dec->i4_pic_type == P_SLICE)
 {
            ps_dec->i4_frametype = IV_P_FRAME;
 }
 else if(ps_dec->i4_pic_type == I_SLICE)
 {
            ps_dec->i4_frametype = IV_I_FRAME;
 }
 else
 {
            H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
 }

        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;

        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
 - ps_dec->ps_cur_slice->u1_field_pic_flag;

 }

 /* close deblock thread if it is not closed yet*/
 if(ps_dec->u4_num_cores == 3)
 {
        ih264d_signal_bs_deblk_thread(ps_dec);
 }


 {
 /* In case the decoder is configured to run in low delay mode,
         * then get display buffer and then format convert.
         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
         */

 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
 && ps_dec->u1_init_dec_flag)
 {

            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 if(0 == ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = 0;
                ps_dec->u4_output_present = 1;
 }
 }

        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);

 /* If Format conversion is not complete,
         complete it here */
 if(ps_dec->u4_output_present &&
 (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
 {
            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
 - ps_dec->u4_fmt_conv_cur_row;
            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                  ps_dec->u4_fmt_conv_cur_row,
                                  ps_dec->u4_fmt_conv_num_rows);
            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
 }

        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 }

 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
 {
        ps_dec_op->u4_progressive_frame_flag = 1;
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
 && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                ps_dec_op->u4_progressive_frame_flag = 0;

 }
 }

 /*Data memory barrier instruction,so that yuv write by the library is complete*/
    DATA_SYNC();

    H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                         ps_dec_op->u4_num_bytes_consumed);
 return api_ret_value;
}
","The `ih264d_video_decode` function is responsible for decoding H.264 video streams. It begins by initializing various structures and checking for errors in input parameters, such as null buffers or invalid byte counts. The function processes the input bitstream, searching for start codes and handling different frame types, including reference and non-reference frames. It manages memory for dynamic buffers and ensures that the decoder operates correctly under various conditions, such as resolution changes or buffer availability. Finally, it updates the output structure with decoded frame information and returns the appropriate status, indicating success or failure of the decoding process.","The provided code implements a video decoding function that processes H.264 streams by managing input parameters, checking for errors, and handling various frame types. It searches for start codes in the bitstream, allocates necessary buffers, and ensures that the decoder operates correctly under different conditions, such as resolution changes and buffer availability. The function also manages memory for dynamic buffers and updates the output structure with relevant frame information. Ultimately, it returns a status indicating whether the decoding process was successful or if any errors occurred during execution.","The vulnerability identified in the code relates to improper handling of scenarios where the decoder processes zero macroblocks, which can lead to denial of service, such as device hangs or reboots. This issue arises from the lack of checks for the number of macroblocks decoded, allowing attackers to exploit this oversight with specially crafted media files. In the fixed code, additional checks were introduced to ensure that the number of macroblocks is validated before proceeding with decoding operations. Specifically, the code now verifies that the total number of macroblocks coded is greater than zero, preventing the decoder from entering an invalid state and enhancing overall stability.","The vulnerability stems from inadequate handling of scenarios where the decoder attempts to process zero macroblocks, potentially leading to a denial of service, such as device hangs or unexpected reboots. This oversight allows attackers to exploit the decoder by providing specially crafted media files that trigger this condition. The fix implemented in the updated code introduces additional checks to validate the number of macroblocks before proceeding with decoding operations. By ensuring that the decoder does not attempt to process zero macroblocks, the code enhances stability and mitigates the risk of denial of service attacks.","The vulnerability was fixed by adding checks to ensure that the total number of macroblocks coded is greater than zero before proceeding with decoding operations. Specifically, the code now verifies the condition of `ps_dec->u2_total_mbs_coded` against the expected number of macroblocks derived from the frame dimensions. If this check fails, the decoder will not attempt to process the frame, thus preventing potential denial of service scenarios. This enhancement ensures that the decoder only operates under valid conditions, effectively mitigating the risk associated with processing zero macroblocks.","The vulnerability was addressed by implementing additional validation checks to ensure that the decoder does not attempt to process frames with zero macroblocks. The updated code includes conditions that verify the total number of macroblocks before any decoding operations are initiated. If the checks determine that the number of macroblocks is invalid, the decoder will halt further processing, thereby preventing potential denial of service scenarios. This proactive approach enhances the stability of the decoder and protects against exploitation through specially crafted media files that could otherwise lead to device hangs or reboots.","4,4","5, 5","4,4","4,4","CWE-789,CWE-369,CWE-20,CWE-400,CWE-754,CWE-119,CWE-131,CWE-248,CWE-835,CWE-476",N,-1
