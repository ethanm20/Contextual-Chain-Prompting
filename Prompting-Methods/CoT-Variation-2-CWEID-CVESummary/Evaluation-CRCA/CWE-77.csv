,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,182309,182309,,Remote,Not required,Partial,CVE-2018-14354,https://www.cvedetails.com/cve/CVE-2018-14354/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",2019-10-02,Exec Code ,3,https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,95e80bf9ff10f68cb6443f760b85df4117cb15eb,Quote path in imap_subscribe,1,imap/imap.c,"{""sha"": ""f1706885620c7afd61bdc5bd03593557980bd0ab"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=95e80bf9ff10f68cb6443f760b85df4117cb15eb"", ""patch"": ""@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n+  size_t len = 0;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n-    snprintf(mbox, sizeof(mbox), \""%smailboxes \\\""%s\\\""\"", subscribe ? \""\"" : \""un\"", path);\n+\tlen = snprintf(mbox, sizeof(mbox), \""%smailboxes \"", subscribe ? \""\"" : \""un\"");\n+\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n     FREE(&token.data);""}","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",C,"  size_t len = 0;
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
","    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
",,"@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
+  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
-    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
+	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
+	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);",neomutt,95e80bf9ff10f68cb6443f760b85df4117cb15eb,51c4efb8ccae3dab550fe8909fc76fb2462f0a89,1,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
//fix_flaw_line_below:
//  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
//flaw_line_below:
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
//fix_flaw_line_below:
//	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
//fix_flaw_line_below:
//	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",182309,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","The `imap_subscribe` function manages the subscription status of an IMAP mailbox, allowing users to either subscribe to or unsubscribe from a specified mailbox path. It first validates the mailbox path and retrieves the associated IMAP connection data. If the mailbox is valid, it constructs a command string based on the desired action (subscribe or unsubscribe) and executes it using the IMAP protocol. The function also handles error reporting and provides user feedback through messages indicating the action taken. If any step fails, it cleans up allocated resources and returns an error code, ensuring robust error handling throughout the process.","The code defines a function that manages the subscription status of a mailbox in an email client using the IMAP protocol. It begins by validating the mailbox path and retrieving the necessary connection data. If the mailbox is valid, it constructs a command to either subscribe to or unsubscribe from the mailbox, providing user feedback about the action being performed. The function executes the command and handles any errors that may arise during the process. In case of failure, it ensures proper cleanup of resources before returning an error code, maintaining robust error handling throughout its execution.","The vulnerability in the original code arises from the lack of proper input sanitization, allowing an attacker to inject arbitrary commands through backquote characters in the mailbox path. This is evident in the construction of the command string without validating or escaping the input, which could lead to command injection. The fixed code addresses this issue by introducing the `imap_quote_string` function, which sanitizes the mailbox name before it is included in the command string. This ensures that any potentially harmful characters are escaped, thereby preventing remote IMAP servers from executing arbitrary commands and mitigating the risk of command injection.","The vulnerability in the original code stems from insufficient input validation, which allows an attacker to inject arbitrary commands through backquote characters in the mailbox path. This lack of sanitization means that malicious input could be executed by the IMAP server, leading to potential command injection attacks. The fixed code addresses this issue by implementing a sanitization process that escapes potentially harmful characters in the mailbox name before it is used in command construction. This enhancement effectively prevents the execution of unauthorized commands, thereby mitigating the risk associated with the vulnerability.","The vulnerability was fixed by introducing the `imap_quote_string` function, which sanitizes the mailbox name before it is included in the command string. In the modified code, after constructing the initial part of the command string, the function is called to escape any potentially harmful characters in the user-provided mailbox path. This ensures that backquote characters and other special characters are properly handled, preventing them from being interpreted as command delimiters. As a result, the risk of command injection is significantly reduced, allowing for safer execution of subscription and unsubscription commands.","The vulnerability was fixed by implementing a sanitization process that escapes potentially harmful characters in the user-provided mailbox path before it is used in command construction. This enhancement ensures that any special characters, such as backquote characters, are properly handled and cannot be interpreted as command delimiters. By validating and sanitizing the input, the code prevents the execution of arbitrary commands that could be injected by an attacker. This change significantly mitigates the risk of command injection, allowing for safer handling of subscription and unsubscription actions within the email client.","5,4","5, 5","4,4","4, 4"
1,1,182848,182848,,Local,Not required,,CVE-2019-11884,https://www.cvedetails.com/cve/CVE-2019-11884/,CWE-77,Low,Partial,,,2019-05-10,2.1,"The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character.",2019-05-31,+Info ,1,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,a1616a5ac99ede5d605047a9012481ce7ff18b16,"Bluetooth: hidp: fix buffer overflow

Struct ca is copied from userspace. It is not checked whether the ""name""
field is NULL terminated, which allows local users to obtain potentially
sensitive information from kernel stack memory, via a HIDPCONNADD command.

This vulnerability is similar to CVE-2011-1079.

Signed-off-by: Young Xiao <YangX92@hotmail.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Cc: stable@vger.kernel.org",0,net/bluetooth/hidp/sock.c,"{""sha"": ""2151913892ce8705d093a96fa65c3888e8a6dbb1"", ""filename"": ""net/bluetooth/hidp/sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hidp/sock.c?ref=a1616a5ac99ede5d605047a9012481ce7ff18b16"", ""patch"": ""@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n+\t\tca.name[sizeof(ca.name)-1] = 0;\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))""}","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",C,"		ca.name[sizeof(ca.name)-1] = 0;
",,,"@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user
 			sockfd_put(csock);
 			return err;
 		}
+		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))",linux,a1616a5ac99ede5d605047a9012481ce7ff18b16,73623340546cceff421c95b53abd8140d1f2b2a2,1,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
//fix_flaw_line_below:
//		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",182848,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","The `do_hidp_sock_ioctl` function handles various IOCTL commands related to Bluetooth HID (Human Interface Device) connections. It processes commands such as adding a connection (`HIDPCONNADD`), deleting a connection (`HIDPCONNDEL`), retrieving a list of connections (`HIDPGETCONNLIST`), and fetching connection information (`HIDPGETCONNINFO`). The function checks for administrative privileges, copies data between user and kernel space, and manages socket references. It returns appropriate error codes for permission issues, data copying failures, or invalid parameters, ensuring robust interaction with HIDP socket operations while maintaining system security and stability.","The provided code implements a function that manages various operations related to Bluetooth HID connections through IOCTL commands. It allows for adding and deleting connections, as well as retrieving lists and details of existing connections. The function ensures that only users with the appropriate administrative privileges can perform certain actions. It handles data transfer between user space and kernel space, checking for errors during these operations. Additionally, it maintains socket references to ensure proper resource management and returns relevant error codes for issues such as permission denial, data transfer failures, or invalid input parameters.","The vulnerability in the original code stemmed from the lack of proper null termination for the name field in the connection addition request, which could allow a local user to read sensitive data from kernel stack memory when using the HIDPCONNADD command. This occurred because the name field could contain uninitialized data, leading to potential information leakage. The fix introduced a line that explicitly sets the last byte of the name field to zero, ensuring it is properly null-terminated. This change mitigates the risk of exposing sensitive information by preventing the inclusion of unintended data in the name field.","The vulnerability in the original code allowed local users to access sensitive information from kernel stack memory due to improper handling of a name field, which could lack proper null termination. This oversight meant that when the name was processed, it could inadvertently include uninitialized or sensitive data, leading to potential information leakage. The fix addressed this issue by ensuring that the last byte of the name field is explicitly set to zero, thereby guaranteeing that it is correctly null-terminated. This change effectively prevents the exposure of unintended data, enhancing the security of the function.","The vulnerability was fixed by adding a line of code that explicitly sets the last byte of the name field in the connection addition request structure to zero. This change ensures that the name field is properly null-terminated, preventing it from containing any uninitialized data that could leak sensitive information from kernel stack memory. Specifically, the line `ca.name[sizeof(ca.name)-1] = 0;` was introduced to guarantee that the name field ends with a null character, thereby mitigating the risk of information exposure when processing the HIDPCONNADD command.","The vulnerability was addressed by ensuring that the name field in the connection addition request is properly null-terminated. This was accomplished by explicitly setting the last byte of the name field to zero, which prevents it from containing any uninitialized or sensitive data that could be inadvertently exposed. By implementing this safeguard, the code now guarantees that the name field will not leak information from kernel stack memory when processed, thereby enhancing the security of the function and protecting against potential information disclosure vulnerabilities.","5,5","4,5","4,4","5,5"
2,2,187046,187046,,Local,Not required,,CVE-2019-5804,https://www.cvedetails.com/cve/CVE-2019-5804/,CWE-77,Low,,Partial,,2019-05-23,2.1,Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.,2019-06-28,,4,https://github.com/chromium/chromium/commit/08965161257ab9aeef9a3548c1cd1a44525dc562,08965161257ab9aeef9a3548c1cd1a44525dc562,"Ignore switches following ""--"" when parsing a command line.

BUG=933004
R=wfh@chromium.org

Change-Id: I911be4cbfc38a4d41dec85d85f7fe0f50ddca392
Reviewed-on: https://chromium-review.googlesource.com/c/1481210
Auto-Submit: Greg Thompson <grt@chromium.org>
Commit-Queue: Julian Pastarmov <pastarmovj@chromium.org>
Reviewed-by: Julian Pastarmov <pastarmovj@chromium.org>
Cr-Commit-Position: refs/heads/master@{#634604}",2,chrome/install_static/install_util.cc,"{""sha"": ""7c7b6c5343bb05ebea63212a0c00fdfbd675efc7"", ""filename"": ""chrome/install_static/install_util.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(\n \n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n+  static constexpr wchar_t kSwitchTerminator[] = L\""--\"";\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\""--\"" + switch_name + L\""=\"";\n-  for (size_t i = 1; i < as_array.size(); ++i) {\n-    const std::wstring& arg = as_array[i];\n+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);\n+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {\n+    const std::wstring& arg = *scan;\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }""}<_**next**_>{""sha"": ""27a55e3bd94ca5a377ca300fe5240874f4efdcf5"", ""filename"": ""chrome/install_static/install_util.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.h?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -275,9 +275,10 @@ std::vector<std::wstring> TokenizeString16(const std::wstring& str,\n std::vector<std::wstring> TokenizeCommandLineToArray(\n     const std::wstring& command_line);\n \n-// We assume that the command line |command_line| contains multiple switches\n-// with the format --<switch name>=<switch value>. This function returns the\n-// value of the |switch_name| passed in.\n+// Returns the value of a switch of the form \""--<switch name>=<switch value>\"" in\n+// |command_line|. An empty switch in |command_line| (\""--\"") denotes the end of\n+// switches and the beginning of args. Anything of the form --<switch\n+// name>=<switch value> following \""--\"" is ignored.\n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name);\n ""}<_**next**_>{""sha"": ""a05794655ddd653123941c14ce20076e5c07c79d"", ""filename"": ""chrome/install_static/install_util_unittest.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util_unittest.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -96,6 +96,10 @@ TEST(InstallStaticTest, GetSwitchValueFromCommandLineTest) {\n   // Bad command line without closing quotes. Should not crash.\n   value = GetSwitchValueFromCommandLine(L\""\\\""blah --type=\\t\\t\\t\"", L\""type\"");\n   EXPECT_TRUE(value.empty());\n+\n+  // Anything following \""--\"" should be considered args and therfore ignored.\n+  value = GetSwitchValueFromCommandLine(L\""blah -- --type=bleh\"", L\""type\"");\n+  EXPECT_TRUE(value.empty());\n }\n \n TEST(InstallStaticTest, SpacesAndQuotesInCommandLineArguments) {""}"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",C,"  static constexpr wchar_t kSwitchTerminator[] = L""--"";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
","  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
",,"@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(
 
 std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
+  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
-  for (size_t i = 1; i < as_array.size(); ++i) {
-    const std::wstring& arg = as_array[i];
+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
+    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }",Chrome,08965161257ab9aeef9a3548c1cd1a44525dc562,fba5eff0d4a6451e2d4a925c4f47973fbf10bb91,1," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
//fix_flaw_line_below:
//  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
//flaw_line_below:
  for (size_t i = 1; i < as_array.size(); ++i) {
//flaw_line_below:
    const std::wstring& arg = as_array[i];
//fix_flaw_line_below:
//  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
//fix_flaw_line_below:
//  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
//fix_flaw_line_below:
//    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",187046," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
","The provided code defines a function `GetSwitchValueFromCommandLine` that extracts the value associated with a specified command-line switch from a given command line string. It first checks that both the command line and switch name are not empty. The command line is tokenized into an array of arguments, and the function constructs a string representing the switch in the format `--switch_name=`. It then iterates through the tokenized arguments, comparing each to the constructed switch string. If a match is found, it returns the value following the equal sign; otherwise, it returns an empty string.","The code defines a function that retrieves the value associated with a specific command-line option from a provided command line string. It begins by ensuring that neither the command line nor the option name is empty. The command line is split into individual arguments, and a formatted string representing the desired option is created. The function then iterates through the arguments, checking for a match with the formatted option. If a match is found, it extracts and returns the value that follows the equal sign; if no match is found, it returns an empty string.","The vulnerability in the original code stemmed from improper command line processing, allowing an attacker to inject malicious command line arguments, potentially leading to domain spoofing. Specifically, the function iterated through all arguments without any restrictions, making it susceptible to crafted inputs. The fixed code addresses this issue by introducing a static constant that defines a switch terminator, which limits the scanning of arguments to only those before this terminator. This change ensures that only valid command line options are processed, effectively mitigating the risk of command injection and enhancing overall security.","The vulnerability in the original code was due to inadequate validation of command line arguments, which allowed an attacker to inject malicious inputs, potentially leading to domain spoofing. This lack of control over the arguments processed made the system susceptible to exploitation. The fixed code addresses this issue by introducing a mechanism to limit the scanning of arguments to only those preceding a defined terminator. By restricting the range of arguments considered, the revised implementation effectively mitigates the risk of command injection, enhancing the security of command line processing and preventing unauthorized manipulation of domain names.","The vulnerability was fixed by introducing a static constant that defines a switch terminator, which restricts the range of arguments processed. In the revised code, the `end` iterator is set to find the position of this terminator within the tokenized argument array. The loop then iterates only from the beginning of the argument list to this `end` position, ensuring that only valid command line options are considered. This change prevents the function from processing any arguments beyond the terminator, effectively mitigating the risk of command injection and enhancing the overall security of command line processing.","The vulnerability was fixed by implementing a mechanism to limit the processing of command line arguments to only those that are valid and relevant. This was achieved by introducing a defined terminator that marks the end of acceptable arguments. The code now scans only up to this terminator, preventing any arguments that follow from being processed. By restricting the range of arguments considered, the revised implementation effectively mitigates the risk of command injection, ensuring that only legitimate command line options are evaluated and enhancing the overall security of the command line handling process.","4,4","5,5","4,4","4,4"
