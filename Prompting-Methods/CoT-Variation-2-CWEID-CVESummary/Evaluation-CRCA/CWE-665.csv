,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,181138,181138,,Local,Not required,Complete,CVE-2017-12847,https://www.cvedetails.com/cve/CVE-2017-12847/,CWE-665,Medium,,Complete,,2017-08-23,6.3,"Nagios Core before 4.3.3 creates a nagios.lock PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for nagios.lock modification before a root script executes a *kill `cat /pathname/nagios.lock`* command.",2019-10-02,Exec Code ,16,https://github.com/NagiosEnterprises/nagioscore/commit/1b197346d490df2e2d3b1dcce5ac6134ad0c8752,1b197346d490df2e2d3b1dcce5ac6134ad0c8752,halfway revert hack/configure changes - switch order of daemon_init/drop_privileges,12,base/nagios.c,"{""sha"": ""440a443ffa9a6f2263341f060ed5e328f7b21af9"", ""filename"": ""Changelog"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/NagiosEnterprises/nagioscore/blob/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/Changelog"", ""raw_url"": ""https://github.com/NagiosEnterprises/nagioscore/raw/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/Changelog"", ""contents_url"": ""https://api.github.com/repos/NagiosEnterprises/nagioscore/contents/Changelog?ref=1b197346d490df2e2d3b1dcce5ac6134ad0c8752"", ""patch"": ""@@ -8,6 +8,8 @@ Nagios Core 4 Change Log\n * On-demand host check always use cached host state (John Frickson)\n * '\u00e1' causes Serivce Status Information to not be displayed (John Frickson)\n * New Macro(s) to generate URL for host / service object (John Frickson)\n+* Fix minor map issues (Troy Lea)\n+* Fix lockfile issues (Bryan Heden)\n \n \n 4.3.2 - 2017-05-09""}<_**next**_>{""sha"": ""dddba66b3b02e60c1e78ea01f24f50fbcecb82cf"", ""filename"": ""THANKS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/NagiosEnterprises/nagioscore/blob/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/THANKS"", ""raw_url"": ""https://github.com/NagiosEnterprises/nagioscore/raw/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/THANKS"", ""contents_url"": ""https://api.github.com/repos/NagiosEnterprises/nagioscore/contents/THANKS?ref=1b197346d490df2e2d3b1dcce5ac6134ad0c8752"", ""patch"": ""@@ -320,6 +320,7 @@ wrong, please let me know.\n * Tomer Okavi\n * Ton Voon\n * Torsten Huebler\n+* Troy Lea\n * Tyler Lund\n * Uwe Knop\n * Uwe Knop""}<_**next**_>{""sha"": ""6811aa6c5fae9659878ff35f88cf54ee5f5b5f3a"", ""filename"": ""base/nagios.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 15, ""changes"": 31, ""blob_url"": ""https://github.com/NagiosEnterprises/nagioscore/blob/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/base/nagios.c"", ""raw_url"": ""https://github.com/NagiosEnterprises/nagioscore/raw/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/base/nagios.c"", ""contents_url"": ""https://api.github.com/repos/NagiosEnterprises/nagioscore/contents/base/nagios.c?ref=1b197346d490df2e2d3b1dcce5ac6134ad0c8752"", ""patch"": ""@@ -592,6 +592,22 @@ int main(int argc, char **argv) {\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \""%llu\"", (unsigned long long)program_start);\n+\t\t\t\n+\t\t\t/* enter daemon mode (unless we're restarting...) */\n+\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n+\n+\t\t\t\tresult = daemon_init();\n+\n+\t\t\t\t/* we had an error daemonizing, so bail... */\n+\t\t\t\tif(result == ERROR) {\n+\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \""Bailing out due to failure to daemonize. (PID=%d)\"", (int)getpid());\n+\t\t\t\t\tcleanup();\n+\t\t\t\t\texit(EXIT_FAILURE);\n+\t\t\t\t\t}\n+\n+\t\t\t\t/* get new PID */\n+\t\t\t\tnagios_pid = (int)getpid();\n+\t\t\t\t}\n \n \t\t\t/* drop privileges */\n \t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n@@ -612,21 +628,6 @@ int main(int argc, char **argv) {\n \t\t\t\t/* error has already been logged */\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n-\t\t\t/* enter daemon mode (unless we're restarting...) */\n-\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n-\n-\t\t\t\tresult = daemon_init();\n-\n-\t\t\t\t/* we had an error daemonizing, so bail... */\n-\t\t\t\tif(result == ERROR) {\n-\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \""Bailing out due to failure to daemonize. (PID=%d)\"", (int)getpid());\n-\t\t\t\t\tcleanup();\n-\t\t\t\t\texit(EXIT_FAILURE);\n-\t\t\t\t\t}\n-\n-\t\t\t\t/* get new PID */\n-\t\t\t\tnagios_pid = (int)getpid();\n-\t\t\t\t}\n \n \t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n \t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \""Nagios %s starting... (PID=%d)\\n\"", PROGRAM_VERSION, (int)getpid());""}<_**next**_>{""sha"": ""c21ee0d1599b6f34eb9925496683000c0432b292"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/NagiosEnterprises/nagioscore/blob/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/configure.ac"", ""raw_url"": ""https://github.com/NagiosEnterprises/nagioscore/raw/1b197346d490df2e2d3b1dcce5ac6134ad0c8752/configure.ac"", ""contents_url"": ""https://api.github.com/repos/NagiosEnterprises/nagioscore/contents/configure.ac?ref=1b197346d490df2e2d3b1dcce5ac6134ad0c8752"", ""patch"": ""@@ -227,6 +227,7 @@ AC_ARG_WITH(checkresult-dir,\n if test x$CHECKRESULTDIR = xno; then\n \tCHECKRESULTDIR=\""$localstatedir/spool/checkresults\""\n fi \n+AC_SUBST(CHECKRESULTDIR)\n \n dnl Location of check result path\n TMPDIR=no\n@@ -270,7 +271,7 @@ AC_ARG_WITH(lockfile,\n \tlockfile=$withval,\n \tlockfile=$localstatedir/nagios.lock\n )\n-\n+AC_SUBST(lockfile)\n \n dnl Determine the library to be used by the iobroker\n \n@@ -819,13 +820,6 @@ perl subst sample-config/template-object/printer.cfg\n perl subst sample-config/template-object/switch.cfg\n \n \n-\n-eval localstatedir=$localstatedir\n-eval lockfile=$lockfile\n-eval CHECKRESULTDIR=$CHECKRESULTDIR\n-AC_SUBST(CHECKRESULTDIR)\n-AC_SUBST(lockfile)\n-\n dnl Review options\n echo \""\""\n echo \""\""""}","int main(int argc, char **argv) {
	int result;
	int error = FALSE;
	int display_license = FALSE;
	int display_help = FALSE;
	int c = 0;
	struct tm *tm, tm_s;
	time_t now;
	char datestring[256];
	nagios_macros *mac;
	const char *worker_socket = NULL;
	int i;
#ifdef HAVE_SIGACTION
	struct sigaction sig_action;
#endif

#ifdef HAVE_GETOPT_H
	int option_index = 0;
	static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'V'},
			{""license"", no_argument, 0, 'V'},
			{""verify-config"", no_argument, 0, 'v'},
			{""daemon"", no_argument, 0, 'd'},
			{""test-scheduling"", no_argument, 0, 's'},
			{""precache-objects"", no_argument, 0, 'p'},
			{""use-precached-objects"", no_argument, 0, 'u'},
			{""enable-timing-point"", no_argument, 0, 'T'},
			{""worker"", required_argument, 0, 'W'},
			{0, 0, 0, 0}
		};
#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
#endif

	memset(&loadctl, 0, sizeof(loadctl));
	mac = get_global_macros();

	/* make sure we have the correct number of command line arguments */
	if(argc < 2)
		error = TRUE;

	/* get all command line arguments */
	while(1) {
		c = getopt(argc, argv, ""+hVvdspuxTW"");

		if(c == -1 || c == EOF)
			break;

		switch(c) {

			case '?': /* usage */
			case 'h':
				display_help = TRUE;
				break;

			case 'V': /* version */
				display_license = TRUE;
				break;

			case 'v': /* verify */
				verify_config++;
				break;

			case 's': /* scheduling check */
				test_scheduling = TRUE;
				break;

			case 'd': /* daemon mode */
				daemon_mode = TRUE;
				break;

			case 'p': /* precache object config */
				precache_objects = TRUE;
				break;

			case 'u': /* use precached object config */
				use_precached_objects = TRUE;
				break;
			case 'T':
				enable_timing_point = TRUE;
				break;
			case 'W':
				worker_socket = optarg;
				break;

			case 'x':
				printf(""Warning: -x is deprecated and will be removed\n"");
				break;

			default:
				break;
			}

		}

#ifdef DEBUG_MEMORY
	mtrace();
#endif
	/* if we're a worker we can skip everything below */
	if(worker_socket) {
		exit(nagios_core_worker(worker_socket));
	}

	/* Initialize configuration variables */                             
	init_main_cfg_vars(1);
	init_shared_cfg_vars(1);

	if(daemon_mode == FALSE) {
		printf(""\nNagios Core %s\n"", PROGRAM_VERSION);
		printf(""Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\n"");
		printf(""Copyright (c) 1999-2009 Ethan Galstad\n"");
		printf(""Last Modified: %s\n"", PROGRAM_MODIFICATION_DATE);
		printf(""License: GPL\n\n"");
		printf(""Website: https://www.nagios.org\n"");
		}

	/* just display the license */
	if(display_license == TRUE) {

		printf(""This program is free software; you can redistribute it and/or modify\n"");
		printf(""it under the terms of the GNU General Public License version 2 as\n"");
		printf(""published by the Free Software Foundation.\n\n"");
		printf(""This program is distributed in the hope that it will be useful,\n"");
		printf(""but WITHOUT ANY WARRANTY; without even the implied warranty of\n"");
		printf(""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"");
		printf(""GNU General Public License for more details.\n\n"");
		printf(""You should have received a copy of the GNU General Public License\n"");
		printf(""along with this program; if not, write to the Free Software\n"");
		printf(""Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"");

		exit(OK);
		}

	/* make sure we got the main config file on the command line... */
	if(optind >= argc)
		error = TRUE;

	/* if there are no command line options (or if we encountered an error), print usage */
	if(error == TRUE || display_help == TRUE) {

		printf(""Usage: %s [options] <main_config_file>\n"", argv[0]);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""\n"");
		printf(""  -v, --verify-config          Verify all configuration data (-v -v for more info)\n"");
		printf(""  -s, --test-scheduling        Shows projected/recommended check scheduling and other\n"");
		printf(""                               diagnostic info based on the current configuration files.\n"");
		printf(""  -T, --enable-timing-point    Enable timed commentary on initialization\n"");
		printf(""  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\n"");
		printf(""  -p, --precache-objects       Precache object configuration\n"");
		printf(""  -u, --use-precached-objects  Use precached object config file\n"");
		printf(""  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\n"");
		printf(""  -W, --worker /path/to/socket Act as a worker for an already running daemon\n"");
		printf(""\n"");
		printf(""Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\n"");
		printf(""releases, online documentation, FAQs, information on subscribing to\n"");
		printf(""the mailing lists, and commercial support options for Nagios.\n"");
		printf(""\n"");

		exit(ERROR);
		}


	/*
	 * config file is last argument specified.
	 * Make sure it uses an absolute path
	 */
	config_file = nspath_absolute(argv[optind], NULL);
	if(config_file == NULL) {
		printf(""Error allocating memory.\n"");
		exit(ERROR);
		}

	config_file_dir = nspath_absolute_dirname(config_file, NULL);

	/* 
	 * Set the signal handler for the SIGXFSZ signal here because
	 * we may encounter this signal before the other signal handlers
	 * are set.
	 */
#ifdef HAVE_SIGACTION
	sig_action.sa_sigaction = NULL;
	sig_action.sa_handler = handle_sigxfsz;
	sigfillset(&sig_action.sa_mask);
	sig_action.sa_flags = SA_NODEFER|SA_RESTART;
	sigaction(SIGXFSZ, &sig_action, NULL);
#else
	signal(SIGXFSZ, handle_sigxfsz);
#endif

	/*
	 * let's go to town. We'll be noisy if we're verifying config
	 * or running scheduling tests.
	 */
	if(verify_config || test_scheduling || precache_objects) {
		reset_variables();
		/*
		 * if we don't beef up our resource limits as much as
		 * we can, it's quite possible we'll run headlong into
		 * EAGAIN due to too many processes when we try to
		 * drop privileges later.
		 */
		set_loadctl_defaults();

		if(verify_config)
			printf(""Reading configuration data...\n"");

		/* read our config file */
		result = read_main_config_file(config_file);
		if(result != OK) {
			printf(""   Error processing main config file!\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config)
			printf(""   Read main config file okay...\n"");

		/* drop privileges */
		if((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {
			printf(""   Failed to drop privileges.  Aborting."");
			exit(EXIT_FAILURE);
			}

		/*
		 * this must come after dropping privileges, so we make
		 * sure to test access permissions as the right user.
		 */
		if (!verify_config && test_configured_paths() == ERROR) {
			printf(""   One or more path problems detected. Aborting.\n"");
			exit(EXIT_FAILURE);
			}

		/* read object config files */
		result = read_all_object_data(config_file);
		if(result != OK) {
			printf(""   Error processing object config files!\n\n"");
			/* if the config filename looks fishy, warn the user */
			if(!strstr(config_file, ""nagios.cfg"")) {
				printf(""\n***> The name of the main configuration file looks suspicious...\n"");
				printf(""\n"");
				printf(""     Make sure you are specifying the name of the MAIN configuration file on\n"");
				printf(""     the command line and not the name of another configuration file.  The\n"");
				printf(""     main configuration file is typically '%s'\n"", DEFAULT_CONFIG_FILE);
				}

			printf(""\n***> One or more problems was encountered while processing the config files...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""   Read object config files okay...\n\n"");
			printf(""Running pre-flight check on configuration data...\n\n"");
			}

		/* run the pre-flight check to make sure things look okay... */
		result = pre_flight_check();

		if(result != OK) {
			printf(""\n***> One or more problems was encountered while running the pre-flight check...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""\nThings look okay - No serious problems were detected during the pre-flight check\n"");
			}

		/* scheduling tests need a bit more than config verifications */
		if(test_scheduling == TRUE) {

			/* we'll need the event queue here so we can time insertions */
			init_event_queue();
			timing_point(""Done initializing event queue\n"");

			/* read initial service and host state information */
			initialize_retention_data(config_file);
			read_initial_state_information();
			timing_point(""Retention data and initial state parsed\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Timing loop initialized\n"");

			/* display scheduling information */
			display_scheduling_info();
			}

		if(precache_objects) {
			result = fcache_objects(object_precache_file);
			timing_point(""Done precaching objects\n"");
			if(result == OK) {
				printf(""Object precache file created:\n%s\n"", object_precache_file);
				}
			else {
				printf(""Failed to precache objects to '%s': %s\n"", object_precache_file, strerror(errno));
				}
			}

		/* clean up after ourselves */
		cleanup();

		/* exit */
		timing_point(""Exiting\n"");

		/* make valgrind shut up about still reachable memory */
		neb_free_module_list();
		free(config_file_dir);
		free(config_file);

		exit(result);
		}


	/* else start to monitor things... */
	else {

		/*
		 * if we're called with a relative path we must make
		 * it absolute so we can launch our workers.
		 * If not, we needn't bother, as we're using execvp()
		 */
		if (strchr(argv[0], '/'))
			nagios_binary_path = nspath_absolute(argv[0], NULL);
		else
			nagios_binary_path = strdup(argv[0]);

		if (!nagios_binary_path) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Unable to allocate memory for nagios_binary_path\n"");
			exit(EXIT_FAILURE);
			}

		if (!(nagios_iobs = iobroker_create())) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to create IO broker set: %s\n"",
				  strerror(errno));
			exit(EXIT_FAILURE);
			}

		/* keep monitoring things until we get a shutdown command */
		do {
			/* reset internal book-keeping (in case we're restarting) */
			wproc_num_workers_spawned = wproc_num_workers_online = 0;
			caught_signal = sigshutdown = FALSE;
			sig_id = 0;

			/* reset program variables */
			reset_variables();
			timing_point(""Variables reset\n"");

			/* get PID */
			nagios_pid = (int)getpid();

			/* read in the configuration files (main and resource config files) */
			result = read_main_config_file(config_file);
			if (result != OK) {
				logit(NSLOG_CONFIG_ERROR, TRUE, ""Error: Failed to process config file '%s'. Aborting\n"", config_file);
				exit(EXIT_FAILURE);
				}
			timing_point(""Main config file read\n"");

			/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */
			/* get program (re)start time and save as macro */
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
			
			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {

				result = daemon_init();

				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}

				/* get new PID */
				nagios_pid = (int)getpid();
				}
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {

				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Failed to drop privileges.  Aborting."");

				cleanup();
				exit(ERROR);
				}

			if (test_path_access(nagios_binary_path, X_OK)) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: failed to access() %s: %s\n"", nagios_binary_path, strerror(errno));
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Spawning workers will be impossible. Aborting.\n"");
				exit(EXIT_FAILURE);
				}

			if (test_configured_paths() == ERROR) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());

			/* log the local time - may be different than clock time due to timezone offset */
			now = time(NULL);
			tm = localtime_r(&now, &tm_s);
			strftime(datestring, sizeof(datestring), ""%a %b %d %H:%M:%S %Z %Y"", tm);
			logit(NSLOG_PROCESS_INFO, TRUE, ""Local time is %s"", datestring);

			/* write log version/info */
			write_log_file_info(NULL);

			/* open debug log now that we're the right user */
			open_debug_log();

#ifdef USE_EVENT_BROKER
			/* initialize modules */
			neb_init_modules();
			neb_init_callback_list();
#endif
			timing_point(""NEB module API initialized\n"");

			/* handle signals (interrupts) before we do any socket I/O */
			setup_sighandler();

			/*
			 * Initialize query handler and event subscription service.
			 * This must be done before modules are initialized, so
			 * the modules can use our in-core stuff properly
			 */
			if (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to initialize query handler. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""Query handler initialized\n"");
			nerd_init();
			timing_point(""NERD initialized\n"");

			/* initialize check workers */
			if(init_workers(num_check_workers) < 0) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Failed to spawn workers. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""%u workers spawned\n"", wproc_num_workers_spawned);
			i = 0;
			while (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {
				iobroker_poll(nagios_iobs, 50);
				i++;
			}
			timing_point(""%u workers connected\n"", wproc_num_workers_online);

			/* now that workers have arrived we can set the defaults */
			set_loadctl_defaults();

#ifdef USE_EVENT_BROKER
			/* load modules */
			if (neb_load_all_modules() != OK) {
				logit(NSLOG_CONFIG_ERROR, ERROR, ""Error: Module loading failed. Aborting.\n"");
				/* if we're dumping core, we must remove all dl-files */
				if (daemon_dumps_core)
					neb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);
				exit(EXIT_FAILURE);
				}
			timing_point(""Modules loaded\n"");

			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			timing_point(""First callback made\n"");
#endif

			/* read in all object config data */
			if(result == OK)
				result = read_all_object_data(config_file);

			/* there was a problem reading the config files */
			if(result != OK)
				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)"", (int)getpid());

			else {

				/* run the pre-flight check to make sure everything looks okay*/
				if((result = pre_flight_check()) != OK)
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, ""Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\n"", (int)getpid());
				}

			/* an error occurred that prevented us from (re)starting */
			if(result != OK) {

				/* if we were restarting, we need to cleanup from the previous run */
				if(sigrestart == TRUE) {

					/* clean up the status data */
					cleanup_status_data(TRUE);
					}

#ifdef USE_EVENT_BROKER
				/* send program data to broker */
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);
#endif
				cleanup();
				exit(ERROR);
				}

			timing_point(""Object configuration parsed and understood\n"");

			/* write the objects.cache file */
			fcache_objects(object_cache_file);
			timing_point(""Objects cached\n"");

			init_event_queue();
			timing_point(""Event queue initialized\n"");


#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* initialize status data unless we're starting */
			if(sigrestart == FALSE) {
				initialize_status_data(config_file);
				timing_point(""Status data initialized\n"");
				}

			/* initialize scheduled downtime data */
			initialize_downtime_data();
			timing_point(""Downtime data initialized\n"");

			/* read initial service and host state information  */
			initialize_retention_data(config_file);
			timing_point(""Retention data initialized\n"");
			read_initial_state_information();
			timing_point(""Initial state information read\n"");

			/* initialize comment data */
			initialize_comment_data();
			timing_point(""Comment data initialized\n"");

			/* initialize performance data */
			initialize_performance_data(config_file);
			timing_point(""Performance data initialized\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Event timing loop initialized\n"");

			/* initialize check statistics */
			init_check_stats();
			timing_point(""check stats initialized\n"");

			/* check for updates */
			check_for_nagios_updates(FALSE, TRUE);
			timing_point(""Update check concluded\n"");

			/* update all status data (with retained information) */
			update_all_status_data();
			timing_point(""Status data updated\n"");

			/* log initial host and service state */
			log_host_states(INITIAL_STATES, NULL);
			log_service_states(INITIAL_STATES, NULL);
			timing_point(""Initial states logged\n"");

			/* reset the restart flag */
			sigrestart = FALSE;

			/* fire up command file worker */
			launch_command_file_worker();
			timing_point(""Command file worker launched\n"");

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* get event start time and save as macro */
			event_start = time(NULL);
			my_free(mac->x[MACRO_EVENTSTARTTIME]);
			asprintf(&mac->x[MACRO_EVENTSTARTTIME], ""%llu"", (unsigned long long)event_start);

			timing_point(""Entering event execution loop\n"");
			/***** start monitoring all services *****/
			/* (doesn't return until a restart or shutdown signal is encountered) */
			event_execution_loop();

			/*
			 * immediately deinitialize the query handler so it
			 * can remove modules that have stashed data with it
			 */
			qh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);

			/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */
			/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */
			/* did we catch a signal? */
			if(caught_signal == TRUE) {

				if(sig_id == SIGHUP)
					logit(NSLOG_PROCESS_INFO, TRUE, ""Caught SIGHUP, restarting...\n"");

				}

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			if(sigshutdown == TRUE)
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);
			else if(sigrestart == TRUE)
				broker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);
#endif

			/* save service and host state information */
			save_state_information(FALSE);
			cleanup_retention_data();

			/* clean up performance data */
			cleanup_performance_data();

			/* clean up the scheduled downtime data */
			cleanup_downtime_data();

			/* clean up the status data unless we're restarting */
			if(sigrestart == FALSE) {
				cleanup_status_data(TRUE);
				}

			free_worker_memory(WPROC_FORCE);
			/* shutdown stuff... */
			if(sigshutdown == TRUE) {
				iobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);
				nagios_iobs = NULL;

				/* log a shutdown message */
				logit(NSLOG_PROCESS_INFO, TRUE, ""Successfully shutdown... (PID=%d)\n"", (int)getpid());
				}

			/* clean up after ourselves */
			cleanup();

			/* close debug log */
			close_debug_log();

			}
		while(sigrestart == TRUE && sigshutdown == FALSE);

		if(daemon_mode == TRUE)
			unlink(lock_file);

		/* free misc memory */
		my_free(lock_file);
		my_free(config_file);
		my_free(config_file_dir);
		my_free(nagios_binary_path);
		}

	return OK;
	}
","int main(int argc, char **argv) {
	int result;
	int error = FALSE;
	int display_license = FALSE;
	int display_help = FALSE;
	int c = 0;
	struct tm *tm, tm_s;
	time_t now;
	char datestring[256];
	nagios_macros *mac;
	const char *worker_socket = NULL;
	int i;
#ifdef HAVE_SIGACTION
	struct sigaction sig_action;
#endif

#ifdef HAVE_GETOPT_H
	int option_index = 0;
	static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'V'},
			{""license"", no_argument, 0, 'V'},
			{""verify-config"", no_argument, 0, 'v'},
			{""daemon"", no_argument, 0, 'd'},
			{""test-scheduling"", no_argument, 0, 's'},
			{""precache-objects"", no_argument, 0, 'p'},
			{""use-precached-objects"", no_argument, 0, 'u'},
			{""enable-timing-point"", no_argument, 0, 'T'},
			{""worker"", required_argument, 0, 'W'},
			{0, 0, 0, 0}
		};
#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
#endif

	memset(&loadctl, 0, sizeof(loadctl));
	mac = get_global_macros();

	/* make sure we have the correct number of command line arguments */
	if(argc < 2)
		error = TRUE;

	/* get all command line arguments */
	while(1) {
		c = getopt(argc, argv, ""+hVvdspuxTW"");

		if(c == -1 || c == EOF)
			break;

		switch(c) {

			case '?': /* usage */
			case 'h':
				display_help = TRUE;
				break;

			case 'V': /* version */
				display_license = TRUE;
				break;

			case 'v': /* verify */
				verify_config++;
				break;

			case 's': /* scheduling check */
				test_scheduling = TRUE;
				break;

			case 'd': /* daemon mode */
				daemon_mode = TRUE;
				break;

			case 'p': /* precache object config */
				precache_objects = TRUE;
				break;

			case 'u': /* use precached object config */
				use_precached_objects = TRUE;
				break;
			case 'T':
				enable_timing_point = TRUE;
				break;
			case 'W':
				worker_socket = optarg;
				break;

			case 'x':
				printf(""Warning: -x is deprecated and will be removed\n"");
				break;

			default:
				break;
			}

		}

#ifdef DEBUG_MEMORY
	mtrace();
#endif
	/* if we're a worker we can skip everything below */
	if(worker_socket) {
		exit(nagios_core_worker(worker_socket));
	}

	/* Initialize configuration variables */                             
	init_main_cfg_vars(1);
	init_shared_cfg_vars(1);

	if(daemon_mode == FALSE) {
		printf(""\nNagios Core %s\n"", PROGRAM_VERSION);
		printf(""Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\n"");
		printf(""Copyright (c) 1999-2009 Ethan Galstad\n"");
		printf(""Last Modified: %s\n"", PROGRAM_MODIFICATION_DATE);
		printf(""License: GPL\n\n"");
		printf(""Website: https://www.nagios.org\n"");
		}

	/* just display the license */
	if(display_license == TRUE) {

		printf(""This program is free software; you can redistribute it and/or modify\n"");
		printf(""it under the terms of the GNU General Public License version 2 as\n"");
		printf(""published by the Free Software Foundation.\n\n"");
		printf(""This program is distributed in the hope that it will be useful,\n"");
		printf(""but WITHOUT ANY WARRANTY; without even the implied warranty of\n"");
		printf(""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"");
		printf(""GNU General Public License for more details.\n\n"");
		printf(""You should have received a copy of the GNU General Public License\n"");
		printf(""along with this program; if not, write to the Free Software\n"");
		printf(""Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"");

		exit(OK);
		}

	/* make sure we got the main config file on the command line... */
	if(optind >= argc)
		error = TRUE;

	/* if there are no command line options (or if we encountered an error), print usage */
	if(error == TRUE || display_help == TRUE) {

		printf(""Usage: %s [options] <main_config_file>\n"", argv[0]);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""\n"");
		printf(""  -v, --verify-config          Verify all configuration data (-v -v for more info)\n"");
		printf(""  -s, --test-scheduling        Shows projected/recommended check scheduling and other\n"");
		printf(""                               diagnostic info based on the current configuration files.\n"");
		printf(""  -T, --enable-timing-point    Enable timed commentary on initialization\n"");
		printf(""  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\n"");
		printf(""  -p, --precache-objects       Precache object configuration\n"");
		printf(""  -u, --use-precached-objects  Use precached object config file\n"");
		printf(""  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\n"");
		printf(""  -W, --worker /path/to/socket Act as a worker for an already running daemon\n"");
		printf(""\n"");
		printf(""Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\n"");
		printf(""releases, online documentation, FAQs, information on subscribing to\n"");
		printf(""the mailing lists, and commercial support options for Nagios.\n"");
		printf(""\n"");

		exit(ERROR);
		}


	/*
	 * config file is last argument specified.
	 * Make sure it uses an absolute path
	 */
	config_file = nspath_absolute(argv[optind], NULL);
	if(config_file == NULL) {
		printf(""Error allocating memory.\n"");
		exit(ERROR);
		}

	config_file_dir = nspath_absolute_dirname(config_file, NULL);

	/* 
	 * Set the signal handler for the SIGXFSZ signal here because
	 * we may encounter this signal before the other signal handlers
	 * are set.
	 */
#ifdef HAVE_SIGACTION
	sig_action.sa_sigaction = NULL;
	sig_action.sa_handler = handle_sigxfsz;
	sigfillset(&sig_action.sa_mask);
	sig_action.sa_flags = SA_NODEFER|SA_RESTART;
	sigaction(SIGXFSZ, &sig_action, NULL);
#else
	signal(SIGXFSZ, handle_sigxfsz);
#endif

	/*
	 * let's go to town. We'll be noisy if we're verifying config
	 * or running scheduling tests.
	 */
	if(verify_config || test_scheduling || precache_objects) {
		reset_variables();
		/*
		 * if we don't beef up our resource limits as much as
		 * we can, it's quite possible we'll run headlong into
		 * EAGAIN due to too many processes when we try to
		 * drop privileges later.
		 */
		set_loadctl_defaults();

		if(verify_config)
			printf(""Reading configuration data...\n"");

		/* read our config file */
		result = read_main_config_file(config_file);
		if(result != OK) {
			printf(""   Error processing main config file!\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config)
			printf(""   Read main config file okay...\n"");

		/* drop privileges */
		if((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {
			printf(""   Failed to drop privileges.  Aborting."");
			exit(EXIT_FAILURE);
			}

		/*
		 * this must come after dropping privileges, so we make
		 * sure to test access permissions as the right user.
		 */
		if (!verify_config && test_configured_paths() == ERROR) {
			printf(""   One or more path problems detected. Aborting.\n"");
			exit(EXIT_FAILURE);
			}

		/* read object config files */
		result = read_all_object_data(config_file);
		if(result != OK) {
			printf(""   Error processing object config files!\n\n"");
			/* if the config filename looks fishy, warn the user */
			if(!strstr(config_file, ""nagios.cfg"")) {
				printf(""\n***> The name of the main configuration file looks suspicious...\n"");
				printf(""\n"");
				printf(""     Make sure you are specifying the name of the MAIN configuration file on\n"");
				printf(""     the command line and not the name of another configuration file.  The\n"");
				printf(""     main configuration file is typically '%s'\n"", DEFAULT_CONFIG_FILE);
				}

			printf(""\n***> One or more problems was encountered while processing the config files...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""   Read object config files okay...\n\n"");
			printf(""Running pre-flight check on configuration data...\n\n"");
			}

		/* run the pre-flight check to make sure things look okay... */
		result = pre_flight_check();

		if(result != OK) {
			printf(""\n***> One or more problems was encountered while running the pre-flight check...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""\nThings look okay - No serious problems were detected during the pre-flight check\n"");
			}

		/* scheduling tests need a bit more than config verifications */
		if(test_scheduling == TRUE) {

			/* we'll need the event queue here so we can time insertions */
			init_event_queue();
			timing_point(""Done initializing event queue\n"");

			/* read initial service and host state information */
			initialize_retention_data(config_file);
			read_initial_state_information();
			timing_point(""Retention data and initial state parsed\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Timing loop initialized\n"");

			/* display scheduling information */
			display_scheduling_info();
			}

		if(precache_objects) {
			result = fcache_objects(object_precache_file);
			timing_point(""Done precaching objects\n"");
			if(result == OK) {
				printf(""Object precache file created:\n%s\n"", object_precache_file);
				}
			else {
				printf(""Failed to precache objects to '%s': %s\n"", object_precache_file, strerror(errno));
				}
			}

		/* clean up after ourselves */
		cleanup();

		/* exit */
		timing_point(""Exiting\n"");

		/* make valgrind shut up about still reachable memory */
		neb_free_module_list();
		free(config_file_dir);
		free(config_file);

		exit(result);
		}


	/* else start to monitor things... */
	else {

		/*
		 * if we're called with a relative path we must make
		 * it absolute so we can launch our workers.
		 * If not, we needn't bother, as we're using execvp()
		 */
		if (strchr(argv[0], '/'))
			nagios_binary_path = nspath_absolute(argv[0], NULL);
		else
			nagios_binary_path = strdup(argv[0]);

		if (!nagios_binary_path) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Unable to allocate memory for nagios_binary_path\n"");
			exit(EXIT_FAILURE);
			}

		if (!(nagios_iobs = iobroker_create())) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to create IO broker set: %s\n"",
				  strerror(errno));
			exit(EXIT_FAILURE);
			}

		/* keep monitoring things until we get a shutdown command */
		do {
			/* reset internal book-keeping (in case we're restarting) */
			wproc_num_workers_spawned = wproc_num_workers_online = 0;
			caught_signal = sigshutdown = FALSE;
			sig_id = 0;

			/* reset program variables */
			reset_variables();
			timing_point(""Variables reset\n"");

			/* get PID */
			nagios_pid = (int)getpid();

			/* read in the configuration files (main and resource config files) */
			result = read_main_config_file(config_file);
			if (result != OK) {
				logit(NSLOG_CONFIG_ERROR, TRUE, ""Error: Failed to process config file '%s'. Aborting\n"", config_file);
				exit(EXIT_FAILURE);
				}
			timing_point(""Main config file read\n"");

			/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */
			/* get program (re)start time and save as macro */
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {

				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Failed to drop privileges.  Aborting."");

				cleanup();
				exit(ERROR);
				}

			if (test_path_access(nagios_binary_path, X_OK)) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: failed to access() %s: %s\n"", nagios_binary_path, strerror(errno));
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Spawning workers will be impossible. Aborting.\n"");
				exit(EXIT_FAILURE);
				}

			if (test_configured_paths() == ERROR) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {
				result = daemon_init();
				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}
				/* get new PID */
				nagios_pid = (int)getpid();
				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());

			/* log the local time - may be different than clock time due to timezone offset */
			now = time(NULL);
			tm = localtime_r(&now, &tm_s);
			strftime(datestring, sizeof(datestring), ""%a %b %d %H:%M:%S %Z %Y"", tm);
			logit(NSLOG_PROCESS_INFO, TRUE, ""Local time is %s"", datestring);

			/* write log version/info */
			write_log_file_info(NULL);

			/* open debug log now that we're the right user */
			open_debug_log();

#ifdef USE_EVENT_BROKER
			/* initialize modules */
			neb_init_modules();
			neb_init_callback_list();
#endif
			timing_point(""NEB module API initialized\n"");

			/* handle signals (interrupts) before we do any socket I/O */
			setup_sighandler();

			/*
			 * Initialize query handler and event subscription service.
			 * This must be done before modules are initialized, so
			 * the modules can use our in-core stuff properly
			 */
			if (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to initialize query handler. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""Query handler initialized\n"");
			nerd_init();
			timing_point(""NERD initialized\n"");

			/* initialize check workers */
			if(init_workers(num_check_workers) < 0) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Failed to spawn workers. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""%u workers spawned\n"", wproc_num_workers_spawned);
			i = 0;
			while (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {
				iobroker_poll(nagios_iobs, 50);
				i++;
			}
			timing_point(""%u workers connected\n"", wproc_num_workers_online);

			/* now that workers have arrived we can set the defaults */
			set_loadctl_defaults();

#ifdef USE_EVENT_BROKER
			/* load modules */
			if (neb_load_all_modules() != OK) {
				logit(NSLOG_CONFIG_ERROR, ERROR, ""Error: Module loading failed. Aborting.\n"");
				/* if we're dumping core, we must remove all dl-files */
				if (daemon_dumps_core)
					neb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);
				exit(EXIT_FAILURE);
				}
			timing_point(""Modules loaded\n"");

			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			timing_point(""First callback made\n"");
#endif

			/* read in all object config data */
			if(result == OK)
				result = read_all_object_data(config_file);

			/* there was a problem reading the config files */
			if(result != OK)
				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)"", (int)getpid());

			else {

				/* run the pre-flight check to make sure everything looks okay*/
				if((result = pre_flight_check()) != OK)
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, ""Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\n"", (int)getpid());
				}

			/* an error occurred that prevented us from (re)starting */
			if(result != OK) {

				/* if we were restarting, we need to cleanup from the previous run */
				if(sigrestart == TRUE) {

					/* clean up the status data */
					cleanup_status_data(TRUE);
					}

#ifdef USE_EVENT_BROKER
				/* send program data to broker */
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);
#endif
				cleanup();
				exit(ERROR);
				}

			timing_point(""Object configuration parsed and understood\n"");

			/* write the objects.cache file */
			fcache_objects(object_cache_file);
			timing_point(""Objects cached\n"");

			init_event_queue();
			timing_point(""Event queue initialized\n"");


#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* initialize status data unless we're starting */
			if(sigrestart == FALSE) {
				initialize_status_data(config_file);
				timing_point(""Status data initialized\n"");
				}

			/* initialize scheduled downtime data */
			initialize_downtime_data();
			timing_point(""Downtime data initialized\n"");

			/* read initial service and host state information  */
			initialize_retention_data(config_file);
			timing_point(""Retention data initialized\n"");
			read_initial_state_information();
			timing_point(""Initial state information read\n"");

			/* initialize comment data */
			initialize_comment_data();
			timing_point(""Comment data initialized\n"");

			/* initialize performance data */
			initialize_performance_data(config_file);
			timing_point(""Performance data initialized\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Event timing loop initialized\n"");

			/* initialize check statistics */
			init_check_stats();
			timing_point(""check stats initialized\n"");

			/* check for updates */
			check_for_nagios_updates(FALSE, TRUE);
			timing_point(""Update check concluded\n"");

			/* update all status data (with retained information) */
			update_all_status_data();
			timing_point(""Status data updated\n"");

			/* log initial host and service state */
			log_host_states(INITIAL_STATES, NULL);
			log_service_states(INITIAL_STATES, NULL);
			timing_point(""Initial states logged\n"");

			/* reset the restart flag */
			sigrestart = FALSE;

			/* fire up command file worker */
			launch_command_file_worker();
			timing_point(""Command file worker launched\n"");

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* get event start time and save as macro */
			event_start = time(NULL);
			my_free(mac->x[MACRO_EVENTSTARTTIME]);
			asprintf(&mac->x[MACRO_EVENTSTARTTIME], ""%llu"", (unsigned long long)event_start);

			timing_point(""Entering event execution loop\n"");
			/***** start monitoring all services *****/
			/* (doesn't return until a restart or shutdown signal is encountered) */
			event_execution_loop();

			/*
			 * immediately deinitialize the query handler so it
			 * can remove modules that have stashed data with it
			 */
			qh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);

			/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */
			/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */
			/* did we catch a signal? */
			if(caught_signal == TRUE) {

				if(sig_id == SIGHUP)
					logit(NSLOG_PROCESS_INFO, TRUE, ""Caught SIGHUP, restarting...\n"");

				}

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			if(sigshutdown == TRUE)
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);
			else if(sigrestart == TRUE)
				broker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);
#endif

			/* save service and host state information */
			save_state_information(FALSE);
			cleanup_retention_data();

			/* clean up performance data */
			cleanup_performance_data();

			/* clean up the scheduled downtime data */
			cleanup_downtime_data();

			/* clean up the status data unless we're restarting */
			if(sigrestart == FALSE) {
				cleanup_status_data(TRUE);
				}

			free_worker_memory(WPROC_FORCE);
			/* shutdown stuff... */
			if(sigshutdown == TRUE) {
				iobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);
				nagios_iobs = NULL;

				/* log a shutdown message */
				logit(NSLOG_PROCESS_INFO, TRUE, ""Successfully shutdown... (PID=%d)\n"", (int)getpid());
				}

			/* clean up after ourselves */
			cleanup();

			/* close debug log */
			close_debug_log();

			}
		while(sigrestart == TRUE && sigshutdown == FALSE);

		if(daemon_mode == TRUE)
			unlink(lock_file);

		/* free misc memory */
		my_free(lock_file);
		my_free(config_file);
		my_free(config_file_dir);
		my_free(nagios_binary_path);
		}

	return OK;
	}
",C,"			
			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {

				result = daemon_init();

				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}

				/* get new PID */
				nagios_pid = (int)getpid();
				}
","			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {
				result = daemon_init();
				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}
				/* get new PID */
				nagios_pid = (int)getpid();
				}
",,"@@ -592,6 +592,22 @@ int main(int argc, char **argv) {
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
+			
+			/* enter daemon mode (unless we're restarting...) */
+			if(daemon_mode == TRUE && sigrestart == FALSE) {
+
+				result = daemon_init();
+
+				/* we had an error daemonizing, so bail... */
+				if(result == ERROR) {
+					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
+					cleanup();
+					exit(EXIT_FAILURE);
+					}
+
+				/* get new PID */
+				nagios_pid = (int)getpid();
+				}
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {
@@ -612,21 +628,6 @@ int main(int argc, char **argv) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
-			/* enter daemon mode (unless we're restarting...) */
-			if(daemon_mode == TRUE && sigrestart == FALSE) {
-
-				result = daemon_init();
-
-				/* we had an error daemonizing, so bail... */
-				if(result == ERROR) {
-					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
-					cleanup();
-					exit(EXIT_FAILURE);
-					}
-
-				/* get new PID */
-				nagios_pid = (int)getpid();
-				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());",nagioscore,1b197346d490df2e2d3b1dcce5ac6134ad0c8752,60638cfb6033b56f75258e8952d9b956e5edea22,1,"int main(int argc, char **argv) {
	int result;
	int error = FALSE;
	int display_license = FALSE;
	int display_help = FALSE;
	int c = 0;
	struct tm *tm, tm_s;
	time_t now;
	char datestring[256];
	nagios_macros *mac;
	const char *worker_socket = NULL;
	int i;
#ifdef HAVE_SIGACTION
	struct sigaction sig_action;
#endif

#ifdef HAVE_GETOPT_H
	int option_index = 0;
	static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'V'},
			{""license"", no_argument, 0, 'V'},
			{""verify-config"", no_argument, 0, 'v'},
			{""daemon"", no_argument, 0, 'd'},
			{""test-scheduling"", no_argument, 0, 's'},
			{""precache-objects"", no_argument, 0, 'p'},
			{""use-precached-objects"", no_argument, 0, 'u'},
			{""enable-timing-point"", no_argument, 0, 'T'},
			{""worker"", required_argument, 0, 'W'},
			{0, 0, 0, 0}
		};
#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
#endif

	memset(&loadctl, 0, sizeof(loadctl));
	mac = get_global_macros();

	/* make sure we have the correct number of command line arguments */
	if(argc < 2)
		error = TRUE;

	/* get all command line arguments */
	while(1) {
		c = getopt(argc, argv, ""+hVvdspuxTW"");

		if(c == -1 || c == EOF)
			break;

		switch(c) {

			case '?': /* usage */
			case 'h':
				display_help = TRUE;
				break;

			case 'V': /* version */
				display_license = TRUE;
				break;

			case 'v': /* verify */
				verify_config++;
				break;

			case 's': /* scheduling check */
				test_scheduling = TRUE;
				break;

			case 'd': /* daemon mode */
				daemon_mode = TRUE;
				break;

			case 'p': /* precache object config */
				precache_objects = TRUE;
				break;

			case 'u': /* use precached object config */
				use_precached_objects = TRUE;
				break;
			case 'T':
				enable_timing_point = TRUE;
				break;
			case 'W':
				worker_socket = optarg;
				break;

			case 'x':
				printf(""Warning: -x is deprecated and will be removed\n"");
				break;

			default:
				break;
			}

		}

#ifdef DEBUG_MEMORY
	mtrace();
#endif
	/* if we're a worker we can skip everything below */
	if(worker_socket) {
		exit(nagios_core_worker(worker_socket));
	}

	/* Initialize configuration variables */                             
	init_main_cfg_vars(1);
	init_shared_cfg_vars(1);

	if(daemon_mode == FALSE) {
		printf(""\nNagios Core %s\n"", PROGRAM_VERSION);
		printf(""Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\n"");
		printf(""Copyright (c) 1999-2009 Ethan Galstad\n"");
		printf(""Last Modified: %s\n"", PROGRAM_MODIFICATION_DATE);
		printf(""License: GPL\n\n"");
		printf(""Website: https://www.nagios.org\n"");
		}

	/* just display the license */
	if(display_license == TRUE) {

		printf(""This program is free software; you can redistribute it and/or modify\n"");
		printf(""it under the terms of the GNU General Public License version 2 as\n"");
		printf(""published by the Free Software Foundation.\n\n"");
		printf(""This program is distributed in the hope that it will be useful,\n"");
		printf(""but WITHOUT ANY WARRANTY; without even the implied warranty of\n"");
		printf(""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"");
		printf(""GNU General Public License for more details.\n\n"");
		printf(""You should have received a copy of the GNU General Public License\n"");
		printf(""along with this program; if not, write to the Free Software\n"");
		printf(""Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"");

		exit(OK);
		}

	/* make sure we got the main config file on the command line... */
	if(optind >= argc)
		error = TRUE;

	/* if there are no command line options (or if we encountered an error), print usage */
	if(error == TRUE || display_help == TRUE) {

		printf(""Usage: %s [options] <main_config_file>\n"", argv[0]);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""\n"");
		printf(""  -v, --verify-config          Verify all configuration data (-v -v for more info)\n"");
		printf(""  -s, --test-scheduling        Shows projected/recommended check scheduling and other\n"");
		printf(""                               diagnostic info based on the current configuration files.\n"");
		printf(""  -T, --enable-timing-point    Enable timed commentary on initialization\n"");
		printf(""  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\n"");
		printf(""  -p, --precache-objects       Precache object configuration\n"");
		printf(""  -u, --use-precached-objects  Use precached object config file\n"");
		printf(""  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\n"");
		printf(""  -W, --worker /path/to/socket Act as a worker for an already running daemon\n"");
		printf(""\n"");
		printf(""Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\n"");
		printf(""releases, online documentation, FAQs, information on subscribing to\n"");
		printf(""the mailing lists, and commercial support options for Nagios.\n"");
		printf(""\n"");

		exit(ERROR);
		}


	/*
	 * config file is last argument specified.
	 * Make sure it uses an absolute path
	 */
	config_file = nspath_absolute(argv[optind], NULL);
	if(config_file == NULL) {
		printf(""Error allocating memory.\n"");
		exit(ERROR);
		}

	config_file_dir = nspath_absolute_dirname(config_file, NULL);

	/* 
	 * Set the signal handler for the SIGXFSZ signal here because
	 * we may encounter this signal before the other signal handlers
	 * are set.
	 */
#ifdef HAVE_SIGACTION
	sig_action.sa_sigaction = NULL;
	sig_action.sa_handler = handle_sigxfsz;
	sigfillset(&sig_action.sa_mask);
	sig_action.sa_flags = SA_NODEFER|SA_RESTART;
	sigaction(SIGXFSZ, &sig_action, NULL);
#else
	signal(SIGXFSZ, handle_sigxfsz);
#endif

	/*
	 * let's go to town. We'll be noisy if we're verifying config
	 * or running scheduling tests.
	 */
	if(verify_config || test_scheduling || precache_objects) {
		reset_variables();
		/*
		 * if we don't beef up our resource limits as much as
		 * we can, it's quite possible we'll run headlong into
		 * EAGAIN due to too many processes when we try to
		 * drop privileges later.
		 */
		set_loadctl_defaults();

		if(verify_config)
			printf(""Reading configuration data...\n"");

		/* read our config file */
		result = read_main_config_file(config_file);
		if(result != OK) {
			printf(""   Error processing main config file!\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config)
			printf(""   Read main config file okay...\n"");

		/* drop privileges */
		if((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {
			printf(""   Failed to drop privileges.  Aborting."");
			exit(EXIT_FAILURE);
			}

		/*
		 * this must come after dropping privileges, so we make
		 * sure to test access permissions as the right user.
		 */
		if (!verify_config && test_configured_paths() == ERROR) {
			printf(""   One or more path problems detected. Aborting.\n"");
			exit(EXIT_FAILURE);
			}

		/* read object config files */
		result = read_all_object_data(config_file);
		if(result != OK) {
			printf(""   Error processing object config files!\n\n"");
			/* if the config filename looks fishy, warn the user */
			if(!strstr(config_file, ""nagios.cfg"")) {
				printf(""\n***> The name of the main configuration file looks suspicious...\n"");
				printf(""\n"");
				printf(""     Make sure you are specifying the name of the MAIN configuration file on\n"");
				printf(""     the command line and not the name of another configuration file.  The\n"");
				printf(""     main configuration file is typically '%s'\n"", DEFAULT_CONFIG_FILE);
				}

			printf(""\n***> One or more problems was encountered while processing the config files...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""   Read object config files okay...\n\n"");
			printf(""Running pre-flight check on configuration data...\n\n"");
			}

		/* run the pre-flight check to make sure things look okay... */
		result = pre_flight_check();

		if(result != OK) {
			printf(""\n***> One or more problems was encountered while running the pre-flight check...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""\nThings look okay - No serious problems were detected during the pre-flight check\n"");
			}

		/* scheduling tests need a bit more than config verifications */
		if(test_scheduling == TRUE) {

			/* we'll need the event queue here so we can time insertions */
			init_event_queue();
			timing_point(""Done initializing event queue\n"");

			/* read initial service and host state information */
			initialize_retention_data(config_file);
			read_initial_state_information();
			timing_point(""Retention data and initial state parsed\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Timing loop initialized\n"");

			/* display scheduling information */
			display_scheduling_info();
			}

		if(precache_objects) {
			result = fcache_objects(object_precache_file);
			timing_point(""Done precaching objects\n"");
			if(result == OK) {
				printf(""Object precache file created:\n%s\n"", object_precache_file);
				}
			else {
				printf(""Failed to precache objects to '%s': %s\n"", object_precache_file, strerror(errno));
				}
			}

		/* clean up after ourselves */
		cleanup();

		/* exit */
		timing_point(""Exiting\n"");

		/* make valgrind shut up about still reachable memory */
		neb_free_module_list();
		free(config_file_dir);
		free(config_file);

		exit(result);
		}


	/* else start to monitor things... */
	else {

		/*
		 * if we're called with a relative path we must make
		 * it absolute so we can launch our workers.
		 * If not, we needn't bother, as we're using execvp()
		 */
		if (strchr(argv[0], '/'))
			nagios_binary_path = nspath_absolute(argv[0], NULL);
		else
			nagios_binary_path = strdup(argv[0]);

		if (!nagios_binary_path) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Unable to allocate memory for nagios_binary_path\n"");
			exit(EXIT_FAILURE);
			}

		if (!(nagios_iobs = iobroker_create())) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to create IO broker set: %s\n"",
				  strerror(errno));
			exit(EXIT_FAILURE);
			}

		/* keep monitoring things until we get a shutdown command */
		do {
			/* reset internal book-keeping (in case we're restarting) */
			wproc_num_workers_spawned = wproc_num_workers_online = 0;
			caught_signal = sigshutdown = FALSE;
			sig_id = 0;

			/* reset program variables */
			reset_variables();
			timing_point(""Variables reset\n"");

			/* get PID */
			nagios_pid = (int)getpid();

			/* read in the configuration files (main and resource config files) */
			result = read_main_config_file(config_file);
			if (result != OK) {
				logit(NSLOG_CONFIG_ERROR, TRUE, ""Error: Failed to process config file '%s'. Aborting\n"", config_file);
				exit(EXIT_FAILURE);
				}
			timing_point(""Main config file read\n"");

			/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */
			/* get program (re)start time and save as macro */
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
//fix_flaw_line_below:
//			
//fix_flaw_line_below:
//			/* enter daemon mode (unless we're restarting...) */
//fix_flaw_line_below:
//			if(daemon_mode == TRUE && sigrestart == FALSE) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				result = daemon_init();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				/* we had an error daemonizing, so bail... */
//fix_flaw_line_below:
//				if(result == ERROR) {
//fix_flaw_line_below:
//					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
//fix_flaw_line_below:
//					cleanup();
//fix_flaw_line_below:
//					exit(EXIT_FAILURE);
//fix_flaw_line_below:
//					}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				/* get new PID */
//fix_flaw_line_below:
//				nagios_pid = (int)getpid();
//fix_flaw_line_below:
//				}
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {

				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Failed to drop privileges.  Aborting."");

				cleanup();
				exit(ERROR);
				}

			if (test_path_access(nagios_binary_path, X_OK)) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: failed to access() %s: %s\n"", nagios_binary_path, strerror(errno));
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Spawning workers will be impossible. Aborting.\n"");
				exit(EXIT_FAILURE);
				}

			if (test_configured_paths() == ERROR) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
//flaw_line_below:
			/* enter daemon mode (unless we're restarting...) */
//flaw_line_below:
			if(daemon_mode == TRUE && sigrestart == FALSE) {
//flaw_line_below:

//flaw_line_below:
				result = daemon_init();
//flaw_line_below:

//flaw_line_below:
				/* we had an error daemonizing, so bail... */
//flaw_line_below:
				if(result == ERROR) {
//flaw_line_below:
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
//flaw_line_below:
					cleanup();
//flaw_line_below:
					exit(EXIT_FAILURE);
//flaw_line_below:
					}
//flaw_line_below:

//flaw_line_below:
				/* get new PID */
//flaw_line_below:
				nagios_pid = (int)getpid();
//flaw_line_below:
				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());

			/* log the local time - may be different than clock time due to timezone offset */
			now = time(NULL);
			tm = localtime_r(&now, &tm_s);
			strftime(datestring, sizeof(datestring), ""%a %b %d %H:%M:%S %Z %Y"", tm);
			logit(NSLOG_PROCESS_INFO, TRUE, ""Local time is %s"", datestring);

			/* write log version/info */
			write_log_file_info(NULL);

			/* open debug log now that we're the right user */
			open_debug_log();

#ifdef USE_EVENT_BROKER
			/* initialize modules */
			neb_init_modules();
			neb_init_callback_list();
#endif
			timing_point(""NEB module API initialized\n"");

			/* handle signals (interrupts) before we do any socket I/O */
			setup_sighandler();

			/*
			 * Initialize query handler and event subscription service.
			 * This must be done before modules are initialized, so
			 * the modules can use our in-core stuff properly
			 */
			if (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to initialize query handler. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""Query handler initialized\n"");
			nerd_init();
			timing_point(""NERD initialized\n"");

			/* initialize check workers */
			if(init_workers(num_check_workers) < 0) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Failed to spawn workers. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""%u workers spawned\n"", wproc_num_workers_spawned);
			i = 0;
			while (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {
				iobroker_poll(nagios_iobs, 50);
				i++;
			}
			timing_point(""%u workers connected\n"", wproc_num_workers_online);

			/* now that workers have arrived we can set the defaults */
			set_loadctl_defaults();

#ifdef USE_EVENT_BROKER
			/* load modules */
			if (neb_load_all_modules() != OK) {
				logit(NSLOG_CONFIG_ERROR, ERROR, ""Error: Module loading failed. Aborting.\n"");
				/* if we're dumping core, we must remove all dl-files */
				if (daemon_dumps_core)
					neb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);
				exit(EXIT_FAILURE);
				}
			timing_point(""Modules loaded\n"");

			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			timing_point(""First callback made\n"");
#endif

			/* read in all object config data */
			if(result == OK)
				result = read_all_object_data(config_file);

			/* there was a problem reading the config files */
			if(result != OK)
				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)"", (int)getpid());

			else {

				/* run the pre-flight check to make sure everything looks okay*/
				if((result = pre_flight_check()) != OK)
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, ""Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\n"", (int)getpid());
				}

			/* an error occurred that prevented us from (re)starting */
			if(result != OK) {

				/* if we were restarting, we need to cleanup from the previous run */
				if(sigrestart == TRUE) {

					/* clean up the status data */
					cleanup_status_data(TRUE);
					}

#ifdef USE_EVENT_BROKER
				/* send program data to broker */
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);
#endif
				cleanup();
				exit(ERROR);
				}

			timing_point(""Object configuration parsed and understood\n"");

			/* write the objects.cache file */
			fcache_objects(object_cache_file);
			timing_point(""Objects cached\n"");

			init_event_queue();
			timing_point(""Event queue initialized\n"");


#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* initialize status data unless we're starting */
			if(sigrestart == FALSE) {
				initialize_status_data(config_file);
				timing_point(""Status data initialized\n"");
				}

			/* initialize scheduled downtime data */
			initialize_downtime_data();
			timing_point(""Downtime data initialized\n"");

			/* read initial service and host state information  */
			initialize_retention_data(config_file);
			timing_point(""Retention data initialized\n"");
			read_initial_state_information();
			timing_point(""Initial state information read\n"");

			/* initialize comment data */
			initialize_comment_data();
			timing_point(""Comment data initialized\n"");

			/* initialize performance data */
			initialize_performance_data(config_file);
			timing_point(""Performance data initialized\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Event timing loop initialized\n"");

			/* initialize check statistics */
			init_check_stats();
			timing_point(""check stats initialized\n"");

			/* check for updates */
			check_for_nagios_updates(FALSE, TRUE);
			timing_point(""Update check concluded\n"");

			/* update all status data (with retained information) */
			update_all_status_data();
			timing_point(""Status data updated\n"");

			/* log initial host and service state */
			log_host_states(INITIAL_STATES, NULL);
			log_service_states(INITIAL_STATES, NULL);
			timing_point(""Initial states logged\n"");

			/* reset the restart flag */
			sigrestart = FALSE;

			/* fire up command file worker */
			launch_command_file_worker();
			timing_point(""Command file worker launched\n"");

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* get event start time and save as macro */
			event_start = time(NULL);
			my_free(mac->x[MACRO_EVENTSTARTTIME]);
			asprintf(&mac->x[MACRO_EVENTSTARTTIME], ""%llu"", (unsigned long long)event_start);

			timing_point(""Entering event execution loop\n"");
			/***** start monitoring all services *****/
			/* (doesn't return until a restart or shutdown signal is encountered) */
			event_execution_loop();

			/*
			 * immediately deinitialize the query handler so it
			 * can remove modules that have stashed data with it
			 */
			qh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);

			/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */
			/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */
			/* did we catch a signal? */
			if(caught_signal == TRUE) {

				if(sig_id == SIGHUP)
					logit(NSLOG_PROCESS_INFO, TRUE, ""Caught SIGHUP, restarting...\n"");

				}

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			if(sigshutdown == TRUE)
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);
			else if(sigrestart == TRUE)
				broker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);
#endif

			/* save service and host state information */
			save_state_information(FALSE);
			cleanup_retention_data();

			/* clean up performance data */
			cleanup_performance_data();

			/* clean up the scheduled downtime data */
			cleanup_downtime_data();

			/* clean up the status data unless we're restarting */
			if(sigrestart == FALSE) {
				cleanup_status_data(TRUE);
				}

			free_worker_memory(WPROC_FORCE);
			/* shutdown stuff... */
			if(sigshutdown == TRUE) {
				iobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);
				nagios_iobs = NULL;

				/* log a shutdown message */
				logit(NSLOG_PROCESS_INFO, TRUE, ""Successfully shutdown... (PID=%d)\n"", (int)getpid());
				}

			/* clean up after ourselves */
			cleanup();

			/* close debug log */
			close_debug_log();

			}
		while(sigrestart == TRUE && sigshutdown == FALSE);

		if(daemon_mode == TRUE)
			unlink(lock_file);

		/* free misc memory */
		my_free(lock_file);
		my_free(config_file);
		my_free(config_file_dir);
		my_free(nagios_binary_path);
		}

	return OK;
	}
",181138,"int main(int argc, char **argv) {
	int result;
	int error = FALSE;
	int display_license = FALSE;
	int display_help = FALSE;
	int c = 0;
	struct tm *tm, tm_s;
	time_t now;
	char datestring[256];
	nagios_macros *mac;
	const char *worker_socket = NULL;
	int i;
#ifdef HAVE_SIGACTION
	struct sigaction sig_action;
#endif

#ifdef HAVE_GETOPT_H
	int option_index = 0;
	static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'V'},
			{""license"", no_argument, 0, 'V'},
			{""verify-config"", no_argument, 0, 'v'},
			{""daemon"", no_argument, 0, 'd'},
			{""test-scheduling"", no_argument, 0, 's'},
			{""precache-objects"", no_argument, 0, 'p'},
			{""use-precached-objects"", no_argument, 0, 'u'},
			{""enable-timing-point"", no_argument, 0, 'T'},
			{""worker"", required_argument, 0, 'W'},
			{0, 0, 0, 0}
		};
#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
#endif

	memset(&loadctl, 0, sizeof(loadctl));
	mac = get_global_macros();

	/* make sure we have the correct number of command line arguments */
	if(argc < 2)
		error = TRUE;

	/* get all command line arguments */
	while(1) {
		c = getopt(argc, argv, ""+hVvdspuxTW"");

		if(c == -1 || c == EOF)
			break;

		switch(c) {

			case '?': /* usage */
			case 'h':
				display_help = TRUE;
				break;

			case 'V': /* version */
				display_license = TRUE;
				break;

			case 'v': /* verify */
				verify_config++;
				break;

			case 's': /* scheduling check */
				test_scheduling = TRUE;
				break;

			case 'd': /* daemon mode */
				daemon_mode = TRUE;
				break;

			case 'p': /* precache object config */
				precache_objects = TRUE;
				break;

			case 'u': /* use precached object config */
				use_precached_objects = TRUE;
				break;
			case 'T':
				enable_timing_point = TRUE;
				break;
			case 'W':
				worker_socket = optarg;
				break;

			case 'x':
				printf(""Warning: -x is deprecated and will be removed\n"");
				break;

			default:
				break;
			}

		}

#ifdef DEBUG_MEMORY
	mtrace();
#endif
	/* if we're a worker we can skip everything below */
	if(worker_socket) {
		exit(nagios_core_worker(worker_socket));
	}

	/* Initialize configuration variables */                             
	init_main_cfg_vars(1);
	init_shared_cfg_vars(1);

	if(daemon_mode == FALSE) {
		printf(""\nNagios Core %s\n"", PROGRAM_VERSION);
		printf(""Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\n"");
		printf(""Copyright (c) 1999-2009 Ethan Galstad\n"");
		printf(""Last Modified: %s\n"", PROGRAM_MODIFICATION_DATE);
		printf(""License: GPL\n\n"");
		printf(""Website: https://www.nagios.org\n"");
		}

	/* just display the license */
	if(display_license == TRUE) {

		printf(""This program is free software; you can redistribute it and/or modify\n"");
		printf(""it under the terms of the GNU General Public License version 2 as\n"");
		printf(""published by the Free Software Foundation.\n\n"");
		printf(""This program is distributed in the hope that it will be useful,\n"");
		printf(""but WITHOUT ANY WARRANTY; without even the implied warranty of\n"");
		printf(""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"");
		printf(""GNU General Public License for more details.\n\n"");
		printf(""You should have received a copy of the GNU General Public License\n"");
		printf(""along with this program; if not, write to the Free Software\n"");
		printf(""Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"");

		exit(OK);
		}

	/* make sure we got the main config file on the command line... */
	if(optind >= argc)
		error = TRUE;

	/* if there are no command line options (or if we encountered an error), print usage */
	if(error == TRUE || display_help == TRUE) {

		printf(""Usage: %s [options] <main_config_file>\n"", argv[0]);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""\n"");
		printf(""  -v, --verify-config          Verify all configuration data (-v -v for more info)\n"");
		printf(""  -s, --test-scheduling        Shows projected/recommended check scheduling and other\n"");
		printf(""                               diagnostic info based on the current configuration files.\n"");
		printf(""  -T, --enable-timing-point    Enable timed commentary on initialization\n"");
		printf(""  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\n"");
		printf(""  -p, --precache-objects       Precache object configuration\n"");
		printf(""  -u, --use-precached-objects  Use precached object config file\n"");
		printf(""  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\n"");
		printf(""  -W, --worker /path/to/socket Act as a worker for an already running daemon\n"");
		printf(""\n"");
		printf(""Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\n"");
		printf(""releases, online documentation, FAQs, information on subscribing to\n"");
		printf(""the mailing lists, and commercial support options for Nagios.\n"");
		printf(""\n"");

		exit(ERROR);
		}


	/*
	 * config file is last argument specified.
	 * Make sure it uses an absolute path
	 */
	config_file = nspath_absolute(argv[optind], NULL);
	if(config_file == NULL) {
		printf(""Error allocating memory.\n"");
		exit(ERROR);
		}

	config_file_dir = nspath_absolute_dirname(config_file, NULL);

	/* 
	 * Set the signal handler for the SIGXFSZ signal here because
	 * we may encounter this signal before the other signal handlers
	 * are set.
	 */
#ifdef HAVE_SIGACTION
	sig_action.sa_sigaction = NULL;
	sig_action.sa_handler = handle_sigxfsz;
	sigfillset(&sig_action.sa_mask);
	sig_action.sa_flags = SA_NODEFER|SA_RESTART;
	sigaction(SIGXFSZ, &sig_action, NULL);
#else
	signal(SIGXFSZ, handle_sigxfsz);
#endif

	/*
	 * let's go to town. We'll be noisy if we're verifying config
	 * or running scheduling tests.
	 */
	if(verify_config || test_scheduling || precache_objects) {
		reset_variables();
		/*
		 * if we don't beef up our resource limits as much as
		 * we can, it's quite possible we'll run headlong into
		 * EAGAIN due to too many processes when we try to
		 * drop privileges later.
		 */
		set_loadctl_defaults();

		if(verify_config)
			printf(""Reading configuration data...\n"");

		/* read our config file */
		result = read_main_config_file(config_file);
		if(result != OK) {
			printf(""   Error processing main config file!\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config)
			printf(""   Read main config file okay...\n"");

		/* drop privileges */
		if((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {
			printf(""   Failed to drop privileges.  Aborting."");
			exit(EXIT_FAILURE);
			}

		/*
		 * this must come after dropping privileges, so we make
		 * sure to test access permissions as the right user.
		 */
		if (!verify_config && test_configured_paths() == ERROR) {
			printf(""   One or more path problems detected. Aborting.\n"");
			exit(EXIT_FAILURE);
			}

		/* read object config files */
		result = read_all_object_data(config_file);
		if(result != OK) {
			printf(""   Error processing object config files!\n\n"");
			/* if the config filename looks fishy, warn the user */
			if(!strstr(config_file, ""nagios.cfg"")) {
				printf(""\n***> The name of the main configuration file looks suspicious...\n"");
				printf(""\n"");
				printf(""     Make sure you are specifying the name of the MAIN configuration file on\n"");
				printf(""     the command line and not the name of another configuration file.  The\n"");
				printf(""     main configuration file is typically '%s'\n"", DEFAULT_CONFIG_FILE);
				}

			printf(""\n***> One or more problems was encountered while processing the config files...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""   Read object config files okay...\n\n"");
			printf(""Running pre-flight check on configuration data...\n\n"");
			}

		/* run the pre-flight check to make sure things look okay... */
		result = pre_flight_check();

		if(result != OK) {
			printf(""\n***> One or more problems was encountered while running the pre-flight check...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""\nThings look okay - No serious problems were detected during the pre-flight check\n"");
			}

		/* scheduling tests need a bit more than config verifications */
		if(test_scheduling == TRUE) {

			/* we'll need the event queue here so we can time insertions */
			init_event_queue();
			timing_point(""Done initializing event queue\n"");

			/* read initial service and host state information */
			initialize_retention_data(config_file);
			read_initial_state_information();
			timing_point(""Retention data and initial state parsed\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Timing loop initialized\n"");

			/* display scheduling information */
			display_scheduling_info();
			}

		if(precache_objects) {
			result = fcache_objects(object_precache_file);
			timing_point(""Done precaching objects\n"");
			if(result == OK) {
				printf(""Object precache file created:\n%s\n"", object_precache_file);
				}
			else {
				printf(""Failed to precache objects to '%s': %s\n"", object_precache_file, strerror(errno));
				}
			}

		/* clean up after ourselves */
		cleanup();

		/* exit */
		timing_point(""Exiting\n"");

		/* make valgrind shut up about still reachable memory */
		neb_free_module_list();
		free(config_file_dir);
		free(config_file);

		exit(result);
		}


	/* else start to monitor things... */
	else {

		/*
		 * if we're called with a relative path we must make
		 * it absolute so we can launch our workers.
		 * If not, we needn't bother, as we're using execvp()
		 */
		if (strchr(argv[0], '/'))
			nagios_binary_path = nspath_absolute(argv[0], NULL);
		else
			nagios_binary_path = strdup(argv[0]);

		if (!nagios_binary_path) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Unable to allocate memory for nagios_binary_path\n"");
			exit(EXIT_FAILURE);
			}

		if (!(nagios_iobs = iobroker_create())) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to create IO broker set: %s\n"",
				  strerror(errno));
			exit(EXIT_FAILURE);
			}

		/* keep monitoring things until we get a shutdown command */
		do {
			/* reset internal book-keeping (in case we're restarting) */
			wproc_num_workers_spawned = wproc_num_workers_online = 0;
			caught_signal = sigshutdown = FALSE;
			sig_id = 0;

			/* reset program variables */
			reset_variables();
			timing_point(""Variables reset\n"");

			/* get PID */
			nagios_pid = (int)getpid();

			/* read in the configuration files (main and resource config files) */
			result = read_main_config_file(config_file);
			if (result != OK) {
				logit(NSLOG_CONFIG_ERROR, TRUE, ""Error: Failed to process config file '%s'. Aborting\n"", config_file);
				exit(EXIT_FAILURE);
				}
			timing_point(""Main config file read\n"");

			/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */
			/* get program (re)start time and save as macro */
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {

				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Failed to drop privileges.  Aborting."");

				cleanup();
				exit(ERROR);
				}

			if (test_path_access(nagios_binary_path, X_OK)) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: failed to access() %s: %s\n"", nagios_binary_path, strerror(errno));
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Spawning workers will be impossible. Aborting.\n"");
				exit(EXIT_FAILURE);
				}

			if (test_configured_paths() == ERROR) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {
				result = daemon_init();
				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}
				/* get new PID */
				nagios_pid = (int)getpid();
				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());

			/* log the local time - may be different than clock time due to timezone offset */
			now = time(NULL);
			tm = localtime_r(&now, &tm_s);
			strftime(datestring, sizeof(datestring), ""%a %b %d %H:%M:%S %Z %Y"", tm);
			logit(NSLOG_PROCESS_INFO, TRUE, ""Local time is %s"", datestring);

			/* write log version/info */
			write_log_file_info(NULL);

			/* open debug log now that we're the right user */
			open_debug_log();

#ifdef USE_EVENT_BROKER
			/* initialize modules */
			neb_init_modules();
			neb_init_callback_list();
#endif
			timing_point(""NEB module API initialized\n"");

			/* handle signals (interrupts) before we do any socket I/O */
			setup_sighandler();

			/*
			 * Initialize query handler and event subscription service.
			 * This must be done before modules are initialized, so
			 * the modules can use our in-core stuff properly
			 */
			if (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to initialize query handler. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""Query handler initialized\n"");
			nerd_init();
			timing_point(""NERD initialized\n"");

			/* initialize check workers */
			if(init_workers(num_check_workers) < 0) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Failed to spawn workers. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""%u workers spawned\n"", wproc_num_workers_spawned);
			i = 0;
			while (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {
				iobroker_poll(nagios_iobs, 50);
				i++;
			}
			timing_point(""%u workers connected\n"", wproc_num_workers_online);

			/* now that workers have arrived we can set the defaults */
			set_loadctl_defaults();

#ifdef USE_EVENT_BROKER
			/* load modules */
			if (neb_load_all_modules() != OK) {
				logit(NSLOG_CONFIG_ERROR, ERROR, ""Error: Module loading failed. Aborting.\n"");
				/* if we're dumping core, we must remove all dl-files */
				if (daemon_dumps_core)
					neb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);
				exit(EXIT_FAILURE);
				}
			timing_point(""Modules loaded\n"");

			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			timing_point(""First callback made\n"");
#endif

			/* read in all object config data */
			if(result == OK)
				result = read_all_object_data(config_file);

			/* there was a problem reading the config files */
			if(result != OK)
				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)"", (int)getpid());

			else {

				/* run the pre-flight check to make sure everything looks okay*/
				if((result = pre_flight_check()) != OK)
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, ""Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\n"", (int)getpid());
				}

			/* an error occurred that prevented us from (re)starting */
			if(result != OK) {

				/* if we were restarting, we need to cleanup from the previous run */
				if(sigrestart == TRUE) {

					/* clean up the status data */
					cleanup_status_data(TRUE);
					}

#ifdef USE_EVENT_BROKER
				/* send program data to broker */
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);
#endif
				cleanup();
				exit(ERROR);
				}

			timing_point(""Object configuration parsed and understood\n"");

			/* write the objects.cache file */
			fcache_objects(object_cache_file);
			timing_point(""Objects cached\n"");

			init_event_queue();
			timing_point(""Event queue initialized\n"");


#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* initialize status data unless we're starting */
			if(sigrestart == FALSE) {
				initialize_status_data(config_file);
				timing_point(""Status data initialized\n"");
				}

			/* initialize scheduled downtime data */
			initialize_downtime_data();
			timing_point(""Downtime data initialized\n"");

			/* read initial service and host state information  */
			initialize_retention_data(config_file);
			timing_point(""Retention data initialized\n"");
			read_initial_state_information();
			timing_point(""Initial state information read\n"");

			/* initialize comment data */
			initialize_comment_data();
			timing_point(""Comment data initialized\n"");

			/* initialize performance data */
			initialize_performance_data(config_file);
			timing_point(""Performance data initialized\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Event timing loop initialized\n"");

			/* initialize check statistics */
			init_check_stats();
			timing_point(""check stats initialized\n"");

			/* check for updates */
			check_for_nagios_updates(FALSE, TRUE);
			timing_point(""Update check concluded\n"");

			/* update all status data (with retained information) */
			update_all_status_data();
			timing_point(""Status data updated\n"");

			/* log initial host and service state */
			log_host_states(INITIAL_STATES, NULL);
			log_service_states(INITIAL_STATES, NULL);
			timing_point(""Initial states logged\n"");

			/* reset the restart flag */
			sigrestart = FALSE;

			/* fire up command file worker */
			launch_command_file_worker();
			timing_point(""Command file worker launched\n"");

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* get event start time and save as macro */
			event_start = time(NULL);
			my_free(mac->x[MACRO_EVENTSTARTTIME]);
			asprintf(&mac->x[MACRO_EVENTSTARTTIME], ""%llu"", (unsigned long long)event_start);

			timing_point(""Entering event execution loop\n"");
			/***** start monitoring all services *****/
			/* (doesn't return until a restart or shutdown signal is encountered) */
			event_execution_loop();

			/*
			 * immediately deinitialize the query handler so it
			 * can remove modules that have stashed data with it
			 */
			qh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);

			/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */
			/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */
			/* did we catch a signal? */
			if(caught_signal == TRUE) {

				if(sig_id == SIGHUP)
					logit(NSLOG_PROCESS_INFO, TRUE, ""Caught SIGHUP, restarting...\n"");

				}

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			if(sigshutdown == TRUE)
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);
			else if(sigrestart == TRUE)
				broker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);
#endif

			/* save service and host state information */
			save_state_information(FALSE);
			cleanup_retention_data();

			/* clean up performance data */
			cleanup_performance_data();

			/* clean up the scheduled downtime data */
			cleanup_downtime_data();

			/* clean up the status data unless we're restarting */
			if(sigrestart == FALSE) {
				cleanup_status_data(TRUE);
				}

			free_worker_memory(WPROC_FORCE);
			/* shutdown stuff... */
			if(sigshutdown == TRUE) {
				iobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);
				nagios_iobs = NULL;

				/* log a shutdown message */
				logit(NSLOG_PROCESS_INFO, TRUE, ""Successfully shutdown... (PID=%d)\n"", (int)getpid());
				}

			/* clean up after ourselves */
			cleanup();

			/* close debug log */
			close_debug_log();

			}
		while(sigrestart == TRUE && sigshutdown == FALSE);

		if(daemon_mode == TRUE)
			unlink(lock_file);

		/* free misc memory */
		my_free(lock_file);
		my_free(config_file);
		my_free(config_file_dir);
		my_free(nagios_binary_path);
		}

	return OK;
	}
","int main(int argc, char **argv) {
	int result;
	int error = FALSE;
	int display_license = FALSE;
	int display_help = FALSE;
	int c = 0;
	struct tm *tm, tm_s;
	time_t now;
	char datestring[256];
	nagios_macros *mac;
	const char *worker_socket = NULL;
	int i;
#ifdef HAVE_SIGACTION
	struct sigaction sig_action;
#endif

#ifdef HAVE_GETOPT_H
	int option_index = 0;
	static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'V'},
			{""license"", no_argument, 0, 'V'},
			{""verify-config"", no_argument, 0, 'v'},
			{""daemon"", no_argument, 0, 'd'},
			{""test-scheduling"", no_argument, 0, 's'},
			{""precache-objects"", no_argument, 0, 'p'},
			{""use-precached-objects"", no_argument, 0, 'u'},
			{""enable-timing-point"", no_argument, 0, 'T'},
			{""worker"", required_argument, 0, 'W'},
			{0, 0, 0, 0}
		};
#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
#endif

	memset(&loadctl, 0, sizeof(loadctl));
	mac = get_global_macros();

	/* make sure we have the correct number of command line arguments */
	if(argc < 2)
		error = TRUE;

	/* get all command line arguments */
	while(1) {
		c = getopt(argc, argv, ""+hVvdspuxTW"");

		if(c == -1 || c == EOF)
			break;

		switch(c) {

			case '?': /* usage */
			case 'h':
				display_help = TRUE;
				break;

			case 'V': /* version */
				display_license = TRUE;
				break;

			case 'v': /* verify */
				verify_config++;
				break;

			case 's': /* scheduling check */
				test_scheduling = TRUE;
				break;

			case 'd': /* daemon mode */
				daemon_mode = TRUE;
				break;

			case 'p': /* precache object config */
				precache_objects = TRUE;
				break;

			case 'u': /* use precached object config */
				use_precached_objects = TRUE;
				break;
			case 'T':
				enable_timing_point = TRUE;
				break;
			case 'W':
				worker_socket = optarg;
				break;

			case 'x':
				printf(""Warning: -x is deprecated and will be removed\n"");
				break;

			default:
				break;
			}

		}

#ifdef DEBUG_MEMORY
	mtrace();
#endif
	/* if we're a worker we can skip everything below */
	if(worker_socket) {
		exit(nagios_core_worker(worker_socket));
	}

	/* Initialize configuration variables */                             
	init_main_cfg_vars(1);
	init_shared_cfg_vars(1);

	if(daemon_mode == FALSE) {
		printf(""\nNagios Core %s\n"", PROGRAM_VERSION);
		printf(""Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\n"");
		printf(""Copyright (c) 1999-2009 Ethan Galstad\n"");
		printf(""Last Modified: %s\n"", PROGRAM_MODIFICATION_DATE);
		printf(""License: GPL\n\n"");
		printf(""Website: https://www.nagios.org\n"");
		}

	/* just display the license */
	if(display_license == TRUE) {

		printf(""This program is free software; you can redistribute it and/or modify\n"");
		printf(""it under the terms of the GNU General Public License version 2 as\n"");
		printf(""published by the Free Software Foundation.\n\n"");
		printf(""This program is distributed in the hope that it will be useful,\n"");
		printf(""but WITHOUT ANY WARRANTY; without even the implied warranty of\n"");
		printf(""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"");
		printf(""GNU General Public License for more details.\n\n"");
		printf(""You should have received a copy of the GNU General Public License\n"");
		printf(""along with this program; if not, write to the Free Software\n"");
		printf(""Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"");

		exit(OK);
		}

	/* make sure we got the main config file on the command line... */
	if(optind >= argc)
		error = TRUE;

	/* if there are no command line options (or if we encountered an error), print usage */
	if(error == TRUE || display_help == TRUE) {

		printf(""Usage: %s [options] <main_config_file>\n"", argv[0]);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""\n"");
		printf(""  -v, --verify-config          Verify all configuration data (-v -v for more info)\n"");
		printf(""  -s, --test-scheduling        Shows projected/recommended check scheduling and other\n"");
		printf(""                               diagnostic info based on the current configuration files.\n"");
		printf(""  -T, --enable-timing-point    Enable timed commentary on initialization\n"");
		printf(""  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\n"");
		printf(""  -p, --precache-objects       Precache object configuration\n"");
		printf(""  -u, --use-precached-objects  Use precached object config file\n"");
		printf(""  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\n"");
		printf(""  -W, --worker /path/to/socket Act as a worker for an already running daemon\n"");
		printf(""\n"");
		printf(""Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\n"");
		printf(""releases, online documentation, FAQs, information on subscribing to\n"");
		printf(""the mailing lists, and commercial support options for Nagios.\n"");
		printf(""\n"");

		exit(ERROR);
		}


	/*
	 * config file is last argument specified.
	 * Make sure it uses an absolute path
	 */
	config_file = nspath_absolute(argv[optind], NULL);
	if(config_file == NULL) {
		printf(""Error allocating memory.\n"");
		exit(ERROR);
		}

	config_file_dir = nspath_absolute_dirname(config_file, NULL);

	/* 
	 * Set the signal handler for the SIGXFSZ signal here because
	 * we may encounter this signal before the other signal handlers
	 * are set.
	 */
#ifdef HAVE_SIGACTION
	sig_action.sa_sigaction = NULL;
	sig_action.sa_handler = handle_sigxfsz;
	sigfillset(&sig_action.sa_mask);
	sig_action.sa_flags = SA_NODEFER|SA_RESTART;
	sigaction(SIGXFSZ, &sig_action, NULL);
#else
	signal(SIGXFSZ, handle_sigxfsz);
#endif

	/*
	 * let's go to town. We'll be noisy if we're verifying config
	 * or running scheduling tests.
	 */
	if(verify_config || test_scheduling || precache_objects) {
		reset_variables();
		/*
		 * if we don't beef up our resource limits as much as
		 * we can, it's quite possible we'll run headlong into
		 * EAGAIN due to too many processes when we try to
		 * drop privileges later.
		 */
		set_loadctl_defaults();

		if(verify_config)
			printf(""Reading configuration data...\n"");

		/* read our config file */
		result = read_main_config_file(config_file);
		if(result != OK) {
			printf(""   Error processing main config file!\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config)
			printf(""   Read main config file okay...\n"");

		/* drop privileges */
		if((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {
			printf(""   Failed to drop privileges.  Aborting."");
			exit(EXIT_FAILURE);
			}

		/*
		 * this must come after dropping privileges, so we make
		 * sure to test access permissions as the right user.
		 */
		if (!verify_config && test_configured_paths() == ERROR) {
			printf(""   One or more path problems detected. Aborting.\n"");
			exit(EXIT_FAILURE);
			}

		/* read object config files */
		result = read_all_object_data(config_file);
		if(result != OK) {
			printf(""   Error processing object config files!\n\n"");
			/* if the config filename looks fishy, warn the user */
			if(!strstr(config_file, ""nagios.cfg"")) {
				printf(""\n***> The name of the main configuration file looks suspicious...\n"");
				printf(""\n"");
				printf(""     Make sure you are specifying the name of the MAIN configuration file on\n"");
				printf(""     the command line and not the name of another configuration file.  The\n"");
				printf(""     main configuration file is typically '%s'\n"", DEFAULT_CONFIG_FILE);
				}

			printf(""\n***> One or more problems was encountered while processing the config files...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""   Read object config files okay...\n\n"");
			printf(""Running pre-flight check on configuration data...\n\n"");
			}

		/* run the pre-flight check to make sure things look okay... */
		result = pre_flight_check();

		if(result != OK) {
			printf(""\n***> One or more problems was encountered while running the pre-flight check...\n"");
			printf(""\n"");
			printf(""     Check your configuration file(s) to ensure that they contain valid\n"");
			printf(""     directives and data definitions.  If you are upgrading from a previous\n"");
			printf(""     version of Nagios, you should be aware that some variables/definitions\n"");
			printf(""     may have been removed or modified in this version.  Make sure to read\n"");
			printf(""     the HTML documentation regarding the config files, as well as the\n"");
			printf(""     'Whats New' section to find out what has changed.\n\n"");
			exit(EXIT_FAILURE);
			}

		if(verify_config) {
			printf(""\nThings look okay - No serious problems were detected during the pre-flight check\n"");
			}

		/* scheduling tests need a bit more than config verifications */
		if(test_scheduling == TRUE) {

			/* we'll need the event queue here so we can time insertions */
			init_event_queue();
			timing_point(""Done initializing event queue\n"");

			/* read initial service and host state information */
			initialize_retention_data(config_file);
			read_initial_state_information();
			timing_point(""Retention data and initial state parsed\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Timing loop initialized\n"");

			/* display scheduling information */
			display_scheduling_info();
			}

		if(precache_objects) {
			result = fcache_objects(object_precache_file);
			timing_point(""Done precaching objects\n"");
			if(result == OK) {
				printf(""Object precache file created:\n%s\n"", object_precache_file);
				}
			else {
				printf(""Failed to precache objects to '%s': %s\n"", object_precache_file, strerror(errno));
				}
			}

		/* clean up after ourselves */
		cleanup();

		/* exit */
		timing_point(""Exiting\n"");

		/* make valgrind shut up about still reachable memory */
		neb_free_module_list();
		free(config_file_dir);
		free(config_file);

		exit(result);
		}


	/* else start to monitor things... */
	else {

		/*
		 * if we're called with a relative path we must make
		 * it absolute so we can launch our workers.
		 * If not, we needn't bother, as we're using execvp()
		 */
		if (strchr(argv[0], '/'))
			nagios_binary_path = nspath_absolute(argv[0], NULL);
		else
			nagios_binary_path = strdup(argv[0]);

		if (!nagios_binary_path) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Unable to allocate memory for nagios_binary_path\n"");
			exit(EXIT_FAILURE);
			}

		if (!(nagios_iobs = iobroker_create())) {
			logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to create IO broker set: %s\n"",
				  strerror(errno));
			exit(EXIT_FAILURE);
			}

		/* keep monitoring things until we get a shutdown command */
		do {
			/* reset internal book-keeping (in case we're restarting) */
			wproc_num_workers_spawned = wproc_num_workers_online = 0;
			caught_signal = sigshutdown = FALSE;
			sig_id = 0;

			/* reset program variables */
			reset_variables();
			timing_point(""Variables reset\n"");

			/* get PID */
			nagios_pid = (int)getpid();

			/* read in the configuration files (main and resource config files) */
			result = read_main_config_file(config_file);
			if (result != OK) {
				logit(NSLOG_CONFIG_ERROR, TRUE, ""Error: Failed to process config file '%s'. Aborting\n"", config_file);
				exit(EXIT_FAILURE);
				}
			timing_point(""Main config file read\n"");

			/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */
			/* get program (re)start time and save as macro */
 			program_start = time(NULL);
 			my_free(mac->x[MACRO_PROCESSSTARTTIME]);
 			asprintf(&mac->x[MACRO_PROCESSSTARTTIME], ""%llu"", (unsigned long long)program_start);
			
			/* enter daemon mode (unless we're restarting...) */
			if(daemon_mode == TRUE && sigrestart == FALSE) {

				result = daemon_init();

				/* we had an error daemonizing, so bail... */
				if(result == ERROR) {
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, ""Bailing out due to failure to daemonize. (PID=%d)"", (int)getpid());
					cleanup();
					exit(EXIT_FAILURE);
					}

				/* get new PID */
				nagios_pid = (int)getpid();
				}
 
 			/* drop privileges */
 			if(drop_privileges(nagios_user, nagios_group) == ERROR) {

				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Failed to drop privileges.  Aborting."");

				cleanup();
				exit(ERROR);
				}

			if (test_path_access(nagios_binary_path, X_OK)) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: failed to access() %s: %s\n"", nagios_binary_path, strerror(errno));
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Spawning workers will be impossible. Aborting.\n"");
				exit(EXIT_FAILURE);
				}

			if (test_configured_paths() == ERROR) {
 				/* error has already been logged */
 				exit(EXIT_FAILURE);
 				}
 
 			/* this must be logged after we read config data, as user may have changed location of main log file */
 			logit(NSLOG_PROCESS_INFO, TRUE, ""Nagios %s starting... (PID=%d)\n"", PROGRAM_VERSION, (int)getpid());

			/* log the local time - may be different than clock time due to timezone offset */
			now = time(NULL);
			tm = localtime_r(&now, &tm_s);
			strftime(datestring, sizeof(datestring), ""%a %b %d %H:%M:%S %Z %Y"", tm);
			logit(NSLOG_PROCESS_INFO, TRUE, ""Local time is %s"", datestring);

			/* write log version/info */
			write_log_file_info(NULL);

			/* open debug log now that we're the right user */
			open_debug_log();

#ifdef USE_EVENT_BROKER
			/* initialize modules */
			neb_init_modules();
			neb_init_callback_list();
#endif
			timing_point(""NEB module API initialized\n"");

			/* handle signals (interrupts) before we do any socket I/O */
			setup_sighandler();

			/*
			 * Initialize query handler and event subscription service.
			 * This must be done before modules are initialized, so
			 * the modules can use our in-core stuff properly
			 */
			if (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Error: Failed to initialize query handler. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""Query handler initialized\n"");
			nerd_init();
			timing_point(""NERD initialized\n"");

			/* initialize check workers */
			if(init_workers(num_check_workers) < 0) {
				logit(NSLOG_RUNTIME_ERROR, TRUE, ""Failed to spawn workers. Aborting\n"");
				exit(EXIT_FAILURE);
			}
			timing_point(""%u workers spawned\n"", wproc_num_workers_spawned);
			i = 0;
			while (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {
				iobroker_poll(nagios_iobs, 50);
				i++;
			}
			timing_point(""%u workers connected\n"", wproc_num_workers_online);

			/* now that workers have arrived we can set the defaults */
			set_loadctl_defaults();

#ifdef USE_EVENT_BROKER
			/* load modules */
			if (neb_load_all_modules() != OK) {
				logit(NSLOG_CONFIG_ERROR, ERROR, ""Error: Module loading failed. Aborting.\n"");
				/* if we're dumping core, we must remove all dl-files */
				if (daemon_dumps_core)
					neb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);
				exit(EXIT_FAILURE);
				}
			timing_point(""Modules loaded\n"");

			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			timing_point(""First callback made\n"");
#endif

			/* read in all object config data */
			if(result == OK)
				result = read_all_object_data(config_file);

			/* there was a problem reading the config files */
			if(result != OK)
				logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, ""Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)"", (int)getpid());

			else {

				/* run the pre-flight check to make sure everything looks okay*/
				if((result = pre_flight_check()) != OK)
					logit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, ""Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\n"", (int)getpid());
				}

			/* an error occurred that prevented us from (re)starting */
			if(result != OK) {

				/* if we were restarting, we need to cleanup from the previous run */
				if(sigrestart == TRUE) {

					/* clean up the status data */
					cleanup_status_data(TRUE);
					}

#ifdef USE_EVENT_BROKER
				/* send program data to broker */
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);
#endif
				cleanup();
				exit(ERROR);
				}

			timing_point(""Object configuration parsed and understood\n"");

			/* write the objects.cache file */
			fcache_objects(object_cache_file);
			timing_point(""Objects cached\n"");

			init_event_queue();
			timing_point(""Event queue initialized\n"");


#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* initialize status data unless we're starting */
			if(sigrestart == FALSE) {
				initialize_status_data(config_file);
				timing_point(""Status data initialized\n"");
				}

			/* initialize scheduled downtime data */
			initialize_downtime_data();
			timing_point(""Downtime data initialized\n"");

			/* read initial service and host state information  */
			initialize_retention_data(config_file);
			timing_point(""Retention data initialized\n"");
			read_initial_state_information();
			timing_point(""Initial state information read\n"");

			/* initialize comment data */
			initialize_comment_data();
			timing_point(""Comment data initialized\n"");

			/* initialize performance data */
			initialize_performance_data(config_file);
			timing_point(""Performance data initialized\n"");

			/* initialize the event timing loop */
			init_timing_loop();
			timing_point(""Event timing loop initialized\n"");

			/* initialize check statistics */
			init_check_stats();
			timing_point(""check stats initialized\n"");

			/* check for updates */
			check_for_nagios_updates(FALSE, TRUE);
			timing_point(""Update check concluded\n"");

			/* update all status data (with retained information) */
			update_all_status_data();
			timing_point(""Status data updated\n"");

			/* log initial host and service state */
			log_host_states(INITIAL_STATES, NULL);
			log_service_states(INITIAL_STATES, NULL);
			timing_point(""Initial states logged\n"");

			/* reset the restart flag */
			sigrestart = FALSE;

			/* fire up command file worker */
			launch_command_file_worker();
			timing_point(""Command file worker launched\n"");

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);
#endif

			/* get event start time and save as macro */
			event_start = time(NULL);
			my_free(mac->x[MACRO_EVENTSTARTTIME]);
			asprintf(&mac->x[MACRO_EVENTSTARTTIME], ""%llu"", (unsigned long long)event_start);

			timing_point(""Entering event execution loop\n"");
			/***** start monitoring all services *****/
			/* (doesn't return until a restart or shutdown signal is encountered) */
			event_execution_loop();

			/*
			 * immediately deinitialize the query handler so it
			 * can remove modules that have stashed data with it
			 */
			qh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);

			/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */
			/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */
			/* did we catch a signal? */
			if(caught_signal == TRUE) {

				if(sig_id == SIGHUP)
					logit(NSLOG_PROCESS_INFO, TRUE, ""Caught SIGHUP, restarting...\n"");

				}

#ifdef USE_EVENT_BROKER
			/* send program data to broker */
			broker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);
			if(sigshutdown == TRUE)
				broker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);
			else if(sigrestart == TRUE)
				broker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);
#endif

			/* save service and host state information */
			save_state_information(FALSE);
			cleanup_retention_data();

			/* clean up performance data */
			cleanup_performance_data();

			/* clean up the scheduled downtime data */
			cleanup_downtime_data();

			/* clean up the status data unless we're restarting */
			if(sigrestart == FALSE) {
				cleanup_status_data(TRUE);
				}

			free_worker_memory(WPROC_FORCE);
			/* shutdown stuff... */
			if(sigshutdown == TRUE) {
				iobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);
				nagios_iobs = NULL;

				/* log a shutdown message */
				logit(NSLOG_PROCESS_INFO, TRUE, ""Successfully shutdown... (PID=%d)\n"", (int)getpid());
				}

			/* clean up after ourselves */
			cleanup();

			/* close debug log */
			close_debug_log();

			}
		while(sigrestart == TRUE && sigshutdown == FALSE);

		if(daemon_mode == TRUE)
			unlink(lock_file);

		/* free misc memory */
		my_free(lock_file);
		my_free(config_file);
		my_free(config_file_dir);
		my_free(nagios_binary_path);
		}

	return OK;
	}
","The provided code is the main function of a Nagios monitoring system, which processes command-line arguments to configure its operation. It initializes various settings, handles options like displaying help or version information, and verifies configuration files. Depending on the arguments, it can run in daemon mode, verify configurations, or act as a worker for an existing Nagios instance. The code also manages signal handling, reads configuration files, initializes necessary components, and enters an event execution loop to monitor services. It includes error handling and cleanup procedures to ensure proper resource management and logging throughout its execution.","The code serves as the main entry point for a monitoring system, processing command-line arguments to configure its behavior. It allows users to display help or version information, verify configuration files, and run in daemon mode or as a worker for an existing instance. The program initializes necessary components, manages signal handling, and reads configuration data while performing error checks. It enters an event execution loop to monitor services, ensuring proper resource management and logging throughout its operation. Additionally, it includes cleanup procedures to handle shutdowns and restarts gracefully.","The vulnerability in the original code arises from the creation of a PID file after dropping privileges to a non-root account, which allows local users to modify the PID file and potentially kill arbitrary processes. This occurs because the program does not adequately secure the PID file, enabling unauthorized access. In the fixed code, the creation of the PID file is moved to a point before dropping privileges, ensuring that only the root user can create or modify it. This change effectively mitigates the risk of local users exploiting the PID file to terminate processes, thereby addressing the vulnerability.","The vulnerability in the original code stems from the creation of a PID file after the program has dropped privileges to a non-root account, allowing local users to modify this file. This could enable them to kill arbitrary processes by exploiting their access to the non-root account before a root script executes a command to terminate the process identified in the PID file. The fix involved moving the creation of the PID file to a point before dropping privileges, ensuring that only the root user can create or modify it, thereby preventing unauthorized access and mitigating the risk of process termination.","The vulnerability was fixed by relocating the creation of the PID file to occur before the call to drop privileges. In the updated code, the PID file is created while the program is still running with root privileges, ensuring that only the root user can create or modify it. This change prevents local users from altering the PID file after the program has switched to a non-root account. By ensuring that the PID file is securely managed before privilege reduction, the risk of unauthorized process termination through manipulation of the PID file is effectively mitigated.","The vulnerability was fixed by changing the sequence of operations related to the creation of the PID file. The updated code ensures that the PID file is created while the program still has root privileges, preventing local users from modifying it after the program has dropped to a non-root account. This adjustment secures the PID file from unauthorized access, effectively eliminating the risk of local users exploiting it to terminate arbitrary processes. By managing the PID file creation before privilege reduction, the code enhances overall security and protects against potential process manipulation.","5,5","5, 5","4,4","4,4"
1,1,182633,182633,,Remote,Not required,Partial,CVE-2019-1010319,https://www.cvedetails.com/cve/CVE-2019-1010319/,CWE-665,Medium,,,,2019-07-11,4.3,"WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseWave64HeaderConfig (wave64.c:211). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe.",2019-07-16,,1,https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,issue #68: clear WaveHeader at start to prevent uninitialized read,0,cli/wave64.c,"{""sha"": ""59548b13ce20ed1ea34ab1a814865060f2607961"", ""filename"": ""cli/wave64.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/dbry/WavPack/blob/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe/cli/wave64.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe/cli/wave64.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/wave64.c?ref=33a0025d1d63ccd05d9dbaa6923d52b1446a62fe"", ""patch"": ""@@ -56,6 +56,7 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa\n     int format_chunk = 0;\n     uint32_t bcount;\n \n+    CLEAR (WaveHeader);\n     infilesize = DoGetFileSize (infile);\n     memcpy (&filehdr, fourcc, 4);\n ""}","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
     int format_chunk = 0;
     uint32_t bcount;
 
    CLEAR (WaveHeader);
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 
    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            if (format_chunk++) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
     int format_chunk = 0;
     uint32_t bcount;
 
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 
    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            if (format_chunk++) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",C,"    CLEAR (WaveHeader);
",,,"@@ -56,6 +56,7 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
     int format_chunk = 0;
     uint32_t bcount;
 
+    CLEAR (WaveHeader);
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 ",WavPack,33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,f68a9555b548306c5b1ee45199ccdc4a16a6101b,1,"int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
     int format_chunk = 0;
     uint32_t bcount;
 
//fix_flaw_line_below:
//    CLEAR (WaveHeader);
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 
    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif

    // loop through all elements of the wave64 header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .wav file we can handle

        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            if (format_chunk++) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
",182633,"int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
    int format_chunk = 0;
    uint32_t bcount;

    infilesize = DoGetFileSize (infile);
    memcpy (&filehdr, fourcc, 4);

    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif

    // loop through all elements of the wave64 header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .wav file we can handle

        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            if (format_chunk++) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}","int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    int64_t total_samples = 0, infilesize;
    Wave64ChunkHeader chunk_header;
    Wave64FileHeader filehdr;
    WaveHeader WaveHeader;
     int format_chunk = 0;
     uint32_t bcount;
 
    CLEAR (WaveHeader);
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 
    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

#if 1   // this might be a little too picky...
    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);

    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
            error_line (""%s is not a valid .W64 file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
#endif


    while (1) {
        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
            bcount != sizeof (Wave64ChunkHeader)) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
        chunk_header.ckSize -= sizeof (chunk_header);


        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
            int supported = TRUE, format;

            if (format_chunk++) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;

            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                bcount != chunk_header.ckSize) {
                    error_line (""%s is not a valid .W64 file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);

            if (debug_logging_mode) {
                error_line (""format tag size = %d"", chunk_header.ckSize);
                error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);

                if (chunk_header.ckSize > 16)
                    error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                        WaveHeader.ValidBitsPerSample);

                if (chunk_header.ckSize > 20)
                    error_line (""ChannelMask = %x, SubFormat = %d"",
                        WaveHeader.ChannelMask, WaveHeader.SubFormat);
            }

            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                config->qmode |= QMODE_ADOBE_MODE;

            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                WaveHeader.SubFormat : WaveHeader.FormatTag;

            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;

            if (format != 1 && format != 3)
                supported = FALSE;

            if (format == 3 && config->bits_per_sample != 32)
                supported = FALSE;

            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                WaveHeader.BlockAlign % WaveHeader.NumChannels)
                    supported = FALSE;

            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .W64 format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (chunk_header.ckSize < 40) {
                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                    if (WaveHeader.NumChannels <= 2)
                        config->channel_mask = 0x5 - WaveHeader.NumChannels;
                    else if (WaveHeader.NumChannels <= 18)
                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                    else
                        config->channel_mask = 0x3ffff;
                }
            }
            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                error_line (""this W64 file already has channel order information!"");
                return WAVPACK_SOFT_ERROR;
            }
            else if (WaveHeader.ChannelMask)
                config->channel_mask = WaveHeader.ChannelMask;

            if (format == 3)
                config->float_norm_exp = 127;
            else if ((config->qmode & QMODE_ADOBE_MODE) &&
                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                    if (WaveHeader.BitsPerSample == 24)
                        config->float_norm_exp = 127 + 23;
                    else if (WaveHeader.BitsPerSample == 32)
                        config->float_norm_exp = 127 + 15;
            }

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: normalized 32-bit floating point"");
                else
                    error_line (""data format: %d-bit integers stored in %d byte(s)"",
                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
            }
        }
        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop

            if (!WaveHeader.NumChannels) {          // make sure we saw ""fmt"" chunk
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                    error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;

                if (!total_samples) {
                    error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
            config->num_channels = WaveHeader.NumChannels;
            config->sample_rate = WaveHeader.SampleRate;
            break;
        }
        else {          // just copy unknown chunks to output file
            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .W64 file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                    chunk_header.ckID [3], chunk_header.ckSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
        error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    return WAVPACK_NO_ERROR;
}
","The `ParseWave64HeaderConfig` function processes a Wave64 audio file header, validating its structure and extracting relevant configuration details. It begins by checking the file's validity and reading the Wave64 file header, ensuring it matches expected formats. The function then iterates through the header chunks, specifically looking for the format chunk to gather audio properties such as sample rate, number of channels, and bits per sample. It also handles unknown chunks by copying them to the output. Finally, it sets the WavPack configuration based on the parsed data and returns an error code if any issues arise during processing.","The code defines a function that reads and validates the header of a Wave64 audio file, ensuring it conforms to expected formats. It begins by checking the file's integrity and reading the initial header information. The function then processes various chunks within the header, extracting essential audio properties such as sample rate, number of channels, and bit depth. It also handles unknown chunks by copying them for later use. Finally, the function configures the audio processing settings based on the extracted information and returns an error code if any discrepancies or issues are detected during the process.","The vulnerability in the original code stemmed from the use of an uninitialized variable, specifically the `WaveHeader` structure, which could lead to unexpected behavior, crashes, or segmentation faults when processing maliciously crafted .wav files. This issue was addressed in the fixed code by explicitly initializing the `WaveHeader` variable using the `CLEAR` macro at the beginning of the function. This ensures that all fields within `WaveHeader` are set to a known state before being used, thereby preventing any unintended consequences from reading uninitialized memory and enhancing the overall robustness of the function.","The vulnerability in the original code was due to the use of an uninitialized variable, which could lead to unpredictable behavior, including crashes and segmentation faults when processing specially crafted audio files. This flaw allowed attackers to exploit the code by providing malicious input that could manipulate control flow. The vulnerability was addressed in the updated code by ensuring that the variable in question was explicitly initialized before use. This change guarantees that the variable contains a known value, thereby preventing any unintended consequences from accessing uninitialized memory and enhancing the stability and security of the function.","The vulnerability was fixed by adding the `CLEAR` macro to initialize the `WaveHeader` variable at the beginning of the function. This ensures that all fields within `WaveHeader` are set to a known state before any operations are performed on it. By doing so, the code prevents the use of uninitialized memory, which could lead to unexpected behavior, crashes, or segmentation faults when processing audio files. This initialization step effectively mitigates the risk associated with uninitialized variables, enhancing the overall reliability and security of the function when handling potentially malicious input.","The vulnerability was fixed by implementing an initialization step for the variable that was previously uninitialized. This change ensures that the variable is set to a known state before any operations are performed, thereby preventing the use of potentially garbage values that could lead to unpredictable behavior, crashes, or segmentation faults. By explicitly clearing or resetting the variable's contents, the code now safeguards against unintended consequences that arise from accessing uninitialized memory, significantly improving the stability and security of the function when processing input that could be maliciously crafted.","5, 5","5, 5","4,4","4, 4"
2,2,182634,182634,,Remote,Not required,Partial,CVE-2019-1010317,https://www.cvedetails.com/cve/CVE-2019-1010317/,CWE-665,Medium,,,,2019-07-11,4.3,"WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseCaffHeaderConfig (caff.c:486). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b.",2019-07-16,,3,https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b,f68a9555b548306c5b1ee45199ccdc4a16a6101b,"issue #66: make sure CAF files have a ""desc"" chunk",2,cli/caff.c,"{""sha"": ""a35da742454242ff5648b1c82fedb1770f821101"", ""filename"": ""cli/caff.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/dbry/WavPack/blob/f68a9555b548306c5b1ee45199ccdc4a16a6101b/cli/caff.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/f68a9555b548306c5b1ee45199ccdc4a16a6101b/cli/caff.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/cli/caff.c?ref=f68a9555b548306c5b1ee45199ccdc4a16a6101b"", ""patch"": ""@@ -152,7 +152,7 @@ static struct {\n \n int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n {\n-    uint32_t chan_chunk = 0, channel_layout = 0, bcount;\n+    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;\n     unsigned char *channel_identities = NULL;\n     unsigned char *channel_reorder = NULL;\n     int64_t total_samples = 0, infilesize;\n@@ -218,6 +218,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n             }\n \n             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n+            desc_chunk = 1;\n \n             if (debug_logging_mode) {\n                 char formatstr [5];\n@@ -458,7 +459,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n         else if (!strncmp (caf_chunk_header.mChunkType, \""data\"", 4)) {     // on the data chunk, get size and exit loop\n             uint32_t mEditCount;\n \n-            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n+            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                 bcount != sizeof (mEditCount)) {\n                     error_line (\""%s is not a valid .CAF file!\"", infilename);\n                     return WAVPACK_SOFT_ERROR;""}"," int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);


        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
            desc_chunk = 1;
 
             if (debug_logging_mode) {
                 char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }


                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);


                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }


                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);


                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
             uint32_t mEditCount;
 
            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
"," int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);


        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
 
             if (debug_logging_mode) {
                 char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }


                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);


                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }


                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);


                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
             uint32_t mEditCount;
 
            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
",C,"    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
            desc_chunk = 1;
            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
","    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
",,"@@ -152,7 +152,7 @@ static struct {
 
 int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
-    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
+    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
@@ -218,6 +218,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
+            desc_chunk = 1;
 
             if (debug_logging_mode) {
                 char formatstr [5];
@@ -458,7 +459,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
             uint32_t mEditCount;
 
-            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
+            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;",WavPack,f68a9555b548306c5b1ee45199ccdc4a16a6101b,4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc,1," int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
//flaw_line_below:
    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
//fix_flaw_line_below:
//    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }

    // loop through all elements of the RIFF wav header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .caf file we can handle

        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
//fix_flaw_line_below:
//            desc_chunk = 1;
 
             if (debug_logging_mode) {
                 char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }

                        // we allocate (and initialize to invalid values) a channel reorder array
                        // (even though we might not end up doing any reordering) and a string for
                        // any non-Microsoft channels we encounter

                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);

                        // convert the descriptions array to our native endian so it's easy to access

                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }

                        // first, we go though and find any MS channels present, and move those to the beginning

                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }

                        // next, we go though the channels again assigning any we haven't done

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }

                        // then, go through the reordering array and see if we really have to reorder

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);

                            // if debugging, display the reordering as a string (but only little ones)

                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
             uint32_t mEditCount;
 
//flaw_line_below:
            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
//fix_flaw_line_below:
//            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
",182634,"int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
    unsigned char *channel_identities = NULL;
    unsigned char *channel_reorder = NULL;
    int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }

    // loop through all elements of the RIFF wav header
    // (until the data chuck) and copy them to the output file

    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);

        // if it's the format chunk, we want to get some info out of there and
        // make sure it's a .caf file we can handle

        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);

            if (debug_logging_mode) {
                char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }

                        // we allocate (and initialize to invalid values) a channel reorder array
                        // (even though we might not end up doing any reordering) and a string for
                        // any non-Microsoft channels we encounter

                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);

                        // convert the descriptions array to our native endian so it's easy to access

                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }

                        // first, we go though and find any MS channels present, and move those to the beginning

                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }

                        // next, we go though the channels again assigning any we haven't done

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }

                        // then, go through the reordering array and see if we really have to reorder

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);

                            // if debugging, display the reordering as a string (but only little ones)

                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
            uint32_t mEditCount;

            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                bcount != sizeof (mEditCount)) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}"," int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }


    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);


        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
            desc_chunk = 1;
 
             if (debug_logging_mode) {
                 char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }


                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);


                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }


                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }


                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 // no reordering required, so don't
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              // if no non-MS channels, free the identities string
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        // otherwise NULL terminate it

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);


                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     // on the data chunk, get size and exit loop
             uint32_t mEditCount;
 
            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          // just copy unknown chunks to output file

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
","The `ParseCaffHeaderConfig` function processes a CAF (Core Audio Format) file header and its associated chunks to extract audio configuration details. It begins by validating the file format and reading the CAF file header, ensuring it is compatible with the expected version. The function then iterates through the chunks, extracting audio format information, channel layout, and data chunk size while checking for errors and unsupported formats. It populates a `WavpackConfig` structure with relevant audio properties, such as sample rate and channel configuration, and handles any necessary channel reordering. Finally, it sets the configuration in a `WavpackContext` and returns an error or success status.","The provided code processes a Core Audio Format (CAF) file to extract and validate its audio configuration. It begins by reading the file header and checking for compatibility with the expected version. The code then iterates through various chunks of the file, gathering essential audio format details, channel layout, and data chunk size while ensuring the format is supported. It populates a configuration structure with properties such as sample rate and channel information, manages any necessary channel reordering, and ultimately sets this configuration in a context for further processing, returning an appropriate success or error status.","The vulnerability in the original code stemmed from the use of an uninitialized variable, specifically the `desc_chunk` variable, which could lead to unexpected behavior, crashes, or segmentation faults when processing maliciously crafted CAF files. In the fixed code, the initialization of `desc_chunk` to zero ensures that it has a defined state before being used in conditional checks, particularly when verifying the presence of the ""desc"" chunk. This change mitigates the risk of undefined behavior by ensuring that the variable is properly set before any operations that depend on its value, thus enhancing the overall stability and security of the function.","The vulnerability in the original code was due to the use of an uninitialized variable, which could lead to unpredictable behavior, including crashes and segmentation faults when processing specially crafted audio files. This lack of initialization meant that the variable could contain arbitrary data, affecting control flow and potentially allowing an attacker to exploit the situation. In the revised code, the variable is explicitly initialized to a known state, ensuring that it has a defined value before being used in any logical checks. This fix enhances the robustness of the code by preventing unintended consequences from uninitialized data.","The vulnerability was fixed by initializing the `desc_chunk` variable to zero at the beginning of the function. This ensures that the variable has a defined state before it is used in conditional checks, particularly when verifying the presence of the ""desc"" chunk. In the revised code, the check for the ""data"" chunk now includes a condition that requires `desc_chunk` to be non-zero, preventing the function from proceeding with potentially uninitialized data. This change effectively mitigates the risk of unexpected control flow and crashes, enhancing the overall stability and security of the audio file processing function.","The vulnerability was addressed by ensuring that a critical variable is initialized to a known value at the start of the function. This initialization prevents the variable from containing arbitrary data, which could lead to unpredictable behavior during execution. Additionally, the code was modified to include checks that rely on this variable being properly set before proceeding with further processing. By enforcing this defined state, the fix eliminates the risk of unexpected control flow and potential crashes, thereby enhancing the overall reliability and security of the audio file handling process.","5,5","5,5","4, 4","5,5"
3,3,182828,182828,,Remote,Not required,Partial,CVE-2019-12730,https://www.cvedetails.com/cve/CVE-2019-12730/,CWE-665,Low,Partial,Partial,,2019-06-04,7.5,aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.,2019-07-16,,6,https://github.com/FFmpeg/FFmpeg/commit/ed188f6dcdf0935c939ed813cf8745d50742014b,ed188f6dcdf0935c939ed813cf8745d50742014b,"avformat/aadec: Check for scanf() failure

Fixes: use of uninitialized variables
Fixes: blank.aa

Found-by: Chamal De Silva <chamal.desilva@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavformat/aadec.c,"{""sha"": ""b9dd51ebfc3da00eac322f95a081872f35365e90"", ""filename"": ""libavformat/aadec.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/ed188f6dcdf0935c939ed813cf8745d50742014b/libavformat/aadec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/ed188f6dcdf0935c939ed813cf8745d50742014b/libavformat/aadec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/aadec.c?ref=ed188f6dcdf0935c939ed813cf8745d50742014b"", ""patch"": ""@@ -85,6 +85,7 @@ static int aa_read_header(AVFormatContext *s)\n     AADemuxContext *c = s->priv_data;\n     AVIOContext *pb = s->pb;\n     AVStream *st;\n+    int ret;\n \n     /* parse .aa header */\n     avio_skip(pb, 4); // file size\n@@ -118,8 +119,12 @@ static int aa_read_header(AVFormatContext *s)\n             header_seed = atoi(val);\n         } else if (!strcmp(key, \""HeaderKey\"")) { // this looks like \""1234567890 1234567890 1234567890 1234567890\""\n             av_log(s, AV_LOG_DEBUG, \""HeaderKey is <%s>\\n\"", val);\n-            sscanf(val, \""%\""SCNu32\""%\""SCNu32\""%\""SCNu32\""%\""SCNu32,\n+\n+            ret = sscanf(val, \""%\""SCNu32\""%\""SCNu32\""%\""SCNu32\""%\""SCNu32,\n                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);\n+            if (ret != 4)\n+                return AVERROR_INVALIDDATA;\n+\n             for (idx = 0; idx < 4; idx++) {\n                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n             }""}","static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
    int ret;
 
     /* parse .aa header */
     avio_skip(pb, 4); // file size
    avio_skip(pb, 4); // magic string
    toc_size = avio_rb32(pb); // TOC size
    avio_skip(pb, 4); // unidentified integer
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { // read TOC
        avio_skip(pb, 4); // TOC entry index
        TOC[i].offset = avio_rb32(pb); // block offset
        TOC[i].size = avio_rb32(pb); // block size
    }
    avio_skip(pb, 24); // header termination block (ignored)
    npairs = avio_rb32(pb); // read dictionary entries
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); // unidentified integer
        nkey = avio_rb32(pb); // key string length
        nval = avio_rb32(pb); // value string length
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);

            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
            if (ret != 4)
                return AVERROR_INVALIDDATA;

             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    /* verify fixed key */
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    /* verify codec */
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    /* decryption key derivation */
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; // purely for padding purposes
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    /* decoder setup */
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    /* determine, and jump to audio start offset */
    for (i = 1; i < toc_size; i++) { // skip the first entry!
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}
","static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
 
     /* parse .aa header */
     avio_skip(pb, 4); // file size
    avio_skip(pb, 4); // magic string
    toc_size = avio_rb32(pb); // TOC size
    avio_skip(pb, 4); // unidentified integer
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { // read TOC
        avio_skip(pb, 4); // TOC entry index
        TOC[i].offset = avio_rb32(pb); // block offset
        TOC[i].size = avio_rb32(pb); // block size
    }
    avio_skip(pb, 24); // header termination block (ignored)
    npairs = avio_rb32(pb); // read dictionary entries
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); // unidentified integer
        nkey = avio_rb32(pb); // key string length
        nval = avio_rb32(pb); // value string length
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    /* verify fixed key */
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    /* verify codec */
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    /* decryption key derivation */
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; // purely for padding purposes
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    /* decoder setup */
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    /* determine, and jump to audio start offset */
    for (i = 1; i < toc_size; i++) { // skip the first entry!
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}
",C,"    int ret;

            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
            if (ret != 4)
                return AVERROR_INVALIDDATA;

","            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
",,"@@ -85,6 +85,7 @@ static int aa_read_header(AVFormatContext *s)
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
+    int ret;
 
     /* parse .aa header */
     avio_skip(pb, 4); // file size
@@ -118,8 +119,12 @@ static int aa_read_header(AVFormatContext *s)
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
+
+            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
+            if (ret != 4)
+                return AVERROR_INVALIDDATA;
+
             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }",FFmpeg,ed188f6dcdf0935c939ed813cf8745d50742014b,9570322a2d8c122de3f1fa8079641950e01c5712,1,"static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
//fix_flaw_line_below:
//    int ret;
 
     /* parse .aa header */
     avio_skip(pb, 4); // file size
    avio_skip(pb, 4); // magic string
    toc_size = avio_rb32(pb); // TOC size
    avio_skip(pb, 4); // unidentified integer
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { // read TOC
        avio_skip(pb, 4); // TOC entry index
        TOC[i].offset = avio_rb32(pb); // block offset
        TOC[i].size = avio_rb32(pb); // block size
    }
    avio_skip(pb, 24); // header termination block (ignored)
    npairs = avio_rb32(pb); // read dictionary entries
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); // unidentified integer
        nkey = avio_rb32(pb); // key string length
        nval = avio_rb32(pb); // value string length
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
//flaw_line_below:
            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
//fix_flaw_line_below:
//            if (ret != 4)
//fix_flaw_line_below:
//                return AVERROR_INVALIDDATA;
//fix_flaw_line_below:
//
             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    /* verify fixed key */
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    /* verify codec */
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    /* decryption key derivation */
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; // purely for padding purposes
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    /* decoder setup */
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    /* determine, and jump to audio start offset */
    for (i = 1; i < toc_size; i++) { // skip the first entry!
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    // extract chapter positions. since all formats have constant bit rate, use it
    // as time base in bytes/s, for easy stream position <-> timestamp conversion
    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}
",182828,"static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
    AADemuxContext *c = s->priv_data;
    AVIOContext *pb = s->pb;
    AVStream *st;

    /* parse .aa header */
    avio_skip(pb, 4); // file size
    avio_skip(pb, 4); // magic string
    toc_size = avio_rb32(pb); // TOC size
    avio_skip(pb, 4); // unidentified integer
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { // read TOC
        avio_skip(pb, 4); // TOC entry index
        TOC[i].offset = avio_rb32(pb); // block offset
        TOC[i].size = avio_rb32(pb); // block size
    }
    avio_skip(pb, 24); // header termination block (ignored)
    npairs = avio_rb32(pb); // read dictionary entries
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); // unidentified integer
        nkey = avio_rb32(pb); // key string length
        nval = avio_rb32(pb); // value string length
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
            header_seed = atoi(val);
        } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
            av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                   &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
            for (idx = 0; idx < 4; idx++) {
                AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
            }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    /* verify fixed key */
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    /* verify codec */
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    /* decryption key derivation */
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; // purely for padding purposes
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    /* decoder setup */
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    /* determine, and jump to audio start offset */
    for (i = 1; i < toc_size; i++) { // skip the first entry!
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    // extract chapter positions. since all formats have constant bit rate, use it
    // as time base in bytes/s, for easy stream position <-> timestamp conversion
    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}","static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
    int ret;
 
     /* parse .aa header */
     avio_skip(pb, 4); // file size
    avio_skip(pb, 4); // magic string
    toc_size = avio_rb32(pb); // TOC size
    avio_skip(pb, 4); // unidentified integer
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { // read TOC
        avio_skip(pb, 4); // TOC entry index
        TOC[i].offset = avio_rb32(pb); // block offset
        TOC[i].size = avio_rb32(pb); // block size
    }
    avio_skip(pb, 24); // header termination block (ignored)
    npairs = avio_rb32(pb); // read dictionary entries
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); // unidentified integer
        nkey = avio_rb32(pb); // key string length
        nval = avio_rb32(pb); // value string length
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { // this looks like ""1234567890 1234567890 1234567890 1234567890""
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);

            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
            if (ret != 4)
                return AVERROR_INVALIDDATA;

             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!
             }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    /* verify fixed key */
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    /* verify codec */
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    /* decryption key derivation */
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; // purely for padding purposes
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    /* decoder setup */
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    /* determine, and jump to audio start offset */
    for (i = 1; i < toc_size; i++) { // skip the first entry!
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}
","The `aa_read_header` function is responsible for parsing the header of an audio file in the AA format within the FFmpeg framework. It begins by reading and validating the file's Table of Contents (TOC) and dictionary entries, extracting key metadata such as codec type and header keys. The function then derives a decryption key using the TEA algorithm and sets up the audio stream parameters based on the identified codec. It also determines the starting position of the audio content and extracts chapter positions, updating the stream's duration accordingly. Finally, it prepares the context for further audio processing.","The provided code is designed to read and parse the header of an audio file in a specific format. It begins by skipping over initial metadata and reading the Table of Contents to gather information about audio blocks. The code extracts key attributes such as codec type and encryption details, while also validating their integrity. It derives a decryption key for secure audio playback and sets up the audio stream parameters based on the identified codec. Additionally, it determines the starting position of the audio content and extracts chapter information, ultimately preparing the context for further audio processing.","The vulnerability in the original code arises from the lack of error handling after using the `sscanf` function to parse the header key, which could lead to the use of uninitialized variables if the parsing fails. Specifically, if the expected four values are not successfully read, the program would proceed with potentially invalid data, causing undefined behavior. In the fixed code, a check is introduced to verify the return value of `sscanf`. If it does not equal four, the function returns an error, ensuring that the program does not continue with uninitialized or incorrect values, thus enhancing its robustness and security.","The vulnerability in the original code stems from the failure to validate the result of a parsing operation, which could lead to the use of uninitialized variables if the operation does not succeed. This oversight can result in unpredictable behavior or security issues, as the program may operate on invalid data. In the revised code, a check is implemented to ensure that the parsing operation successfully retrieves the expected number of values. If the operation fails, the function now returns an error, preventing the use of any uninitialized or incorrect data and thereby enhancing the overall stability and security of the program.","The vulnerability was fixed by adding a validation check for the return value of the `sscanf` function, which parses the header key. In the revised code, the result of `sscanf` is stored in a variable, and a condition checks if this value equals four, indicating that all expected values were successfully read. If the check fails, the function returns an error code, specifically `AVERROR_INVALIDDATA`, preventing the use of any uninitialized variables that could lead to undefined behavior. This change ensures that the program only proceeds with valid and initialized data, enhancing its robustness.","The vulnerability was addressed by implementing a validation step after the parsing operation to ensure that the expected number of values was successfully retrieved. A check was introduced to verify the result of the parsing function, and if it did not match the expected count, the code now returns an error. This prevents the program from proceeding with potentially uninitialized or invalid data, thereby mitigating the risk of undefined behavior or security issues. This fix enhances the overall reliability and security of the code by ensuring that only valid data is used in subsequent operations.","5,4","5,5","5,5","4,4"
