,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,180133,180133,,Remote,Not required,Complete,CVE-2016-7117,https://www.cvedetails.com/cve/CVE-2016-7117/,CWE-19,Low,Complete,Complete,,2016-10-10,10.0,Use-after-free vulnerability in the __sys_recvmmsg function in net/socket.c in the Linux kernel before 4.5.2 allows remote attackers to execute arbitrary code via vectors involving a recvmmsg system call that is mishandled during error processing.,2018-01-04,Exec Code ,19,https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d,34b88a68f26a75e4fded796f1a49c40f82234b7d,"net: Fix use after free in the recvmmsg exit path

The syzkaller fuzzer hit the following use-after-free:

  Call Trace:
   [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
   [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
   [<     inline     >] SYSC_recvmmsg net/socket.c:2281
   [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
   [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
  arch/x86/entry/entry_64.S:185

And, as Dmitry rightly assessed, that is because we can drop the
reference and then touch it when the underlying recvmsg calls return
some packets and then hit an error, which will make recvmmsg to set
sock->sk->sk_err, oops, fix it.

Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: Alexander Potapenko <glider@google.com>
Cc: Eric Dumazet <edumazet@google.com>
Cc: Kostya Serebryany <kcc@google.com>
Cc: Sasha Levin <sasha.levin@oracle.com>
Fixes: a2e2725541fa (""net: Introduce recvmmsg socket syscall"")
http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",17,net/socket.c,"{""sha"": ""5f77a8e93830bd30cef60e68354bda683c9acc43"", ""filename"": ""net/socket.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 19, ""changes"": 38, ""blob_url"": ""https://github.com/torvalds/linux/blob/34b88a68f26a75e4fded796f1a49c40f82234b7d/net/socket.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/34b88a68f26a75e4fded796f1a49c40f82234b7d/net/socket.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/socket.c?ref=34b88a68f26a75e4fded796f1a49c40f82234b7d"", ""patch"": ""@@ -2244,31 +2244,31 @@ int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n \t\tcond_resched();\n \t}\n \n-out_put:\n-\tfput_light(sock->file, fput_needed);\n-\n \tif (err == 0)\n-\t\treturn datagrams;\n+\t\tgoto out_put;\n \n-\tif (datagrams != 0) {\n+\tif (datagrams == 0) {\n+\t\tdatagrams = err;\n+\t\tgoto out_put;\n+\t}\n+\n+\t/*\n+\t * We may return less entries than requested (vlen) if the\n+\t * sock is non block and there aren't enough datagrams...\n+\t */\n+\tif (err != -EAGAIN) {\n \t\t/*\n-\t\t * We may return less entries than requested (vlen) if the\n-\t\t * sock is non block and there aren't enough datagrams...\n+\t\t * ... or  if recvmsg returns an error after we\n+\t\t * received some datagrams, where we record the\n+\t\t * error to return on the next call or if the\n+\t\t * app asks about it using getsockopt(SO_ERROR).\n \t\t */\n-\t\tif (err != -EAGAIN) {\n-\t\t\t/*\n-\t\t\t * ... or  if recvmsg returns an error after we\n-\t\t\t * received some datagrams, where we record the\n-\t\t\t * error to return on the next call or if the\n-\t\t\t * app asks about it using getsockopt(SO_ERROR).\n-\t\t\t */\n-\t\t\tsock->sk->sk_err = -err;\n-\t\t}\n-\n-\t\treturn datagrams;\n+\t\tsock->sk->sk_err = -err;\n \t}\n+out_put:\n+\tfput_light(sock->file, fput_needed);\n \n-\treturn err;\n+\treturn datagrams;\n }\n \n SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,""}","int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
 		cond_resched();
 	}
 
 	if (err == 0)
		goto out_put;
 
	if (datagrams == 0) {
		datagrams = err;
		goto out_put;
	}

	/*
	 * We may return less entries than requested (vlen) if the
	 * sock is non block and there aren't enough datagrams...
	 */
	if (err != -EAGAIN) {
 		/*
		 * ... or  if recvmsg returns an error after we
		 * received some datagrams, where we record the
		 * error to return on the next call or if the
		 * app asks about it using getsockopt(SO_ERROR).
 		 */
		sock->sk->sk_err = -err;
 	}
out_put:
	fput_light(sock->file, fput_needed);
 
	return datagrams;
 }
","int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
 		cond_resched();
 	}
 
out_put:
	fput_light(sock->file, fput_needed);
 	if (err == 0)
		return datagrams;
 
	if (datagrams != 0) {
 		/*
		 * We may return less entries than requested (vlen) if the
		 * sock is non block and there aren't enough datagrams...
 		 */
		if (err != -EAGAIN) {
			/*
			 * ... or  if recvmsg returns an error after we
			 * received some datagrams, where we record the
			 * error to return on the next call or if the
			 * app asks about it using getsockopt(SO_ERROR).
			 */
			sock->sk->sk_err = -err;
		}
		return datagrams;
 	}
 
	return err;
 }
",C,"		goto out_put;
	if (datagrams == 0) {
		datagrams = err;
		goto out_put;
	}

	/*
	 * We may return less entries than requested (vlen) if the
	 * sock is non block and there aren't enough datagrams...
	 */
	if (err != -EAGAIN) {
		 * ... or  if recvmsg returns an error after we
		 * received some datagrams, where we record the
		 * error to return on the next call or if the
		 * app asks about it using getsockopt(SO_ERROR).
		sock->sk->sk_err = -err;
out_put:
	fput_light(sock->file, fput_needed);
	return datagrams;
","out_put:
	fput_light(sock->file, fput_needed);
		return datagrams;
	if (datagrams != 0) {
		 * We may return less entries than requested (vlen) if the
		 * sock is non block and there aren't enough datagrams...
		if (err != -EAGAIN) {
			/*
			 * ... or  if recvmsg returns an error after we
			 * received some datagrams, where we record the
			 * error to return on the next call or if the
			 * app asks about it using getsockopt(SO_ERROR).
			 */
			sock->sk->sk_err = -err;
		}
		return datagrams;
	return err;
",,"@@ -2244,31 +2244,31 @@ int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
 		cond_resched();
 	}
 
-out_put:
-	fput_light(sock->file, fput_needed);
-
 	if (err == 0)
-		return datagrams;
+		goto out_put;
 
-	if (datagrams != 0) {
+	if (datagrams == 0) {
+		datagrams = err;
+		goto out_put;
+	}
+
+	/*
+	 * We may return less entries than requested (vlen) if the
+	 * sock is non block and there aren't enough datagrams...
+	 */
+	if (err != -EAGAIN) {
 		/*
-		 * We may return less entries than requested (vlen) if the
-		 * sock is non block and there aren't enough datagrams...
+		 * ... or  if recvmsg returns an error after we
+		 * received some datagrams, where we record the
+		 * error to return on the next call or if the
+		 * app asks about it using getsockopt(SO_ERROR).
 		 */
-		if (err != -EAGAIN) {
-			/*
-			 * ... or  if recvmsg returns an error after we
-			 * received some datagrams, where we record the
-			 * error to return on the next call or if the
-			 * app asks about it using getsockopt(SO_ERROR).
-			 */
-			sock->sk->sk_err = -err;
-		}
-
-		return datagrams;
+		sock->sk->sk_err = -err;
 	}
+out_put:
+	fput_light(sock->file, fput_needed);
 
-	return err;
+	return datagrams;
 }
 
 SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,",linux,34b88a68f26a75e4fded796f1a49c40f82234b7d,b6e4038262bc933f2ef5427b6bcd2607d02ba4bb,1,"int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
 		cond_resched();
 	}
 
//flaw_line_below:
out_put:
//flaw_line_below:
	fput_light(sock->file, fput_needed);
//flaw_line_below:

 	if (err == 0)
//flaw_line_below:
		return datagrams;
//fix_flaw_line_below:
//		goto out_put;
 
//flaw_line_below:
	if (datagrams != 0) {
//fix_flaw_line_below:
//	if (datagrams == 0) {
//fix_flaw_line_below:
//		datagrams = err;
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * We may return less entries than requested (vlen) if the
//fix_flaw_line_below:
//	 * sock is non block and there aren't enough datagrams...
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (err != -EAGAIN) {
 		/*
//flaw_line_below:
		 * We may return less entries than requested (vlen) if the
//flaw_line_below:
		 * sock is non block and there aren't enough datagrams...
//fix_flaw_line_below:
//		 * ... or  if recvmsg returns an error after we
//fix_flaw_line_below:
//		 * received some datagrams, where we record the
//fix_flaw_line_below:
//		 * error to return on the next call or if the
//fix_flaw_line_below:
//		 * app asks about it using getsockopt(SO_ERROR).
 		 */
//flaw_line_below:
		if (err != -EAGAIN) {
//flaw_line_below:
			/*
//flaw_line_below:
			 * ... or  if recvmsg returns an error after we
//flaw_line_below:
			 * received some datagrams, where we record the
//flaw_line_below:
			 * error to return on the next call or if the
//flaw_line_below:
			 * app asks about it using getsockopt(SO_ERROR).
//flaw_line_below:
			 */
//flaw_line_below:
			sock->sk->sk_err = -err;
//flaw_line_below:
		}
//flaw_line_below:

//flaw_line_below:
		return datagrams;
//fix_flaw_line_below:
//		sock->sk->sk_err = -err;
 	}
//fix_flaw_line_below:
//out_put:
//fix_flaw_line_below:
//	fput_light(sock->file, fput_needed);
 
//flaw_line_below:
	return err;
//fix_flaw_line_below:
//	return datagrams;
 }
",180133,"int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
 		cond_resched();
 	}
 
out_put:
	fput_light(sock->file, fput_needed);
 	if (err == 0)
		return datagrams;
 
	if (datagrams != 0) {
 		/*
		 * We may return less entries than requested (vlen) if the
		 * sock is non block and there aren't enough datagrams...
 		 */
		if (err != -EAGAIN) {
			/*
			 * ... or  if recvmsg returns an error after we
			 * received some datagrams, where we record the
			 * error to return on the next call or if the
			 * app asks about it using getsockopt(SO_ERROR).
			 */
			sock->sk->sk_err = -err;
		}
		return datagrams;
 	}
 
	return err;
 }
","int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
 		cond_resched();
 	}
 
 	if (err == 0)
		goto out_put;
 
	if (datagrams == 0) {
		datagrams = err;
		goto out_put;
	}

	/*
	 * We may return less entries than requested (vlen) if the
	 * sock is non block and there aren't enough datagrams...
	 */
	if (err != -EAGAIN) {
 		/*
		 * ... or  if recvmsg returns an error after we
		 * received some datagrams, where we record the
		 * error to return on the next call or if the
		 * app asks about it using getsockopt(SO_ERROR).
 		 */
		sock->sk->sk_err = -err;
 	}
out_put:
	fput_light(sock->file, fput_needed);
 
	return datagrams;
 }
","The `__sys_recvmmsg` function is a system call that facilitates the reception of multiple messages from a socket, specified by the file descriptor `fd`. It takes parameters for a user-defined array of message headers, a maximum number of messages to receive (`vlen`), flags for message processing, and an optional timeout. The function checks for socket errors, processes incoming messages in a loop, and handles compatibility for different message header structures. It also manages timeout conditions and out-of-band data, returning the number of successfully received datagrams or an error code if applicable, while ensuring proper resource management.","The provided code implements a system call that allows a program to receive multiple messages from a specified socket. It manages the reception process by checking for errors, handling timeouts, and processing messages in a loop until a specified limit is reached or an error occurs. The code supports both standard and compatibility message formats, ensuring that messages are correctly received and their lengths recorded. Additionally, it accommodates conditions such as out-of-band data and non-blocking behavior, while ensuring proper resource cleanup and returning the number of successfully received messages or an error code as needed.","The vulnerability in the original code stemmed from improper handling of socket errors during the message reception process, leading to a use-after-free condition. Specifically, if an error occurred after successfully receiving some datagrams, the code did not adequately manage the socket's state, potentially allowing access to freed memory. In the fixed code, the error handling was improved by ensuring that the error state is recorded in `sock->sk->sk_err` only if the number of received datagrams is greater than zero, thus preventing the use of freed resources and enhancing overall memory safety during error processing.","The vulnerability in the original code was a use-after-free issue that arose from inadequate error handling during the reception of messages. When an error occurred after some messages had been successfully received, the code failed to properly manage the socket's state, which could lead to accessing freed memory and potentially allowing remote attackers to execute arbitrary code. The fix involved enhancing the error handling logic to ensure that the error state was only recorded when there were successfully received messages, thereby preventing the use of freed resources and improving memory safety during error conditions.","The vulnerability was fixed by modifying the error handling logic in the code. Specifically, the condition that records the error state in `sock->sk->sk_err` was adjusted to occur only if the number of successfully received datagrams was greater than zero. This change ensures that the error state is not set when no datagrams have been received, thus preventing the potential use of freed memory. Additionally, the code now correctly handles the return value of `datagrams` to reflect the actual number of messages processed, enhancing overall memory safety during error processing.","The vulnerability was addressed by refining the error handling mechanism to ensure that the error state is only recorded when there have been successful message receptions. This adjustment prevents the code from referencing freed memory when an error occurs after some messages have been processed. By implementing this check, the code now avoids setting the error state in scenarios where no messages were received, thereby enhancing memory safety. Overall, the fix ensures that the system maintains proper resource management and prevents potential exploitation through use-after-free conditions during error processing.","4,4","5,5","5,4","4,4"
1,1,180609,180609,,Local,Not required,,CVE-2016-2085,https://www.cvedetails.com/cve/CVE-2016-2085/,CWE-19,Low,,Partial,,2016-04-27,2.1,"The evm_verify_hmac function in security/integrity/evm/evm_main.c in the Linux kernel before 4.5 does not properly copy data, which makes it easier for local users to forge MAC values via a timing side-channel attack.",2016-12-02,,1,https://github.com/torvalds/linux/commit/613317bd212c585c20796c10afe5daaa95d4b0a1,613317bd212c585c20796c10afe5daaa95d4b0a1,"EVM: Use crypto_memneq() for digest comparisons

This patch fixes vulnerability CVE-2016-2085.  The problem exists
because the vm_verify_hmac() function includes a use of memcmp().
Unfortunately, this allows timing side channel attacks; specifically
a MAC forgery complexity drop from 2^128 to 2^12.  This patch changes
the memcmp() to the cryptographically safe crypto_memneq().

Reported-by: Xiaofei Rex Guo <xiaofei.rex.guo@intel.com>
Signed-off-by: Ryan Ware <ware@linux.intel.com>
Cc: stable@vger.kernel.org
Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/integrity/evm/evm_main.c,"{""sha"": ""e6ea9d4b1de91a8d58e3ccab0fd3cef222ea6fcd"", ""filename"": ""security/integrity/evm/evm_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/613317bd212c585c20796c10afe5daaa95d4b0a1/security/integrity/evm/evm_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/613317bd212c585c20796c10afe5daaa95d4b0a1/security/integrity/evm/evm_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/integrity/evm/evm_main.c?ref=613317bd212c585c20796c10afe5daaa95d4b0a1"", ""patch"": ""@@ -23,6 +23,7 @@\n #include <linux/integrity.h>\n #include <linux/evm.h>\n #include <crypto/hash.h>\n+#include <crypto/algapi.h>\n #include \""evm.h\""\n \n int evm_initialized;\n@@ -148,7 +149,7 @@ static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n \t\t\t\t   xattr_value_len, calc.digest);\n \t\tif (rc)\n \t\t\tbreak;\n-\t\trc = memcmp(xattr_data->digest, calc.digest,\n+\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n \t\t\t    sizeof(calc.digest));\n \t\tif (rc)\n \t\t\trc = -EINVAL;""}","static enum integrity_status evm_verify_hmac(struct dentry *dentry,
					     const char *xattr_name,
					     char *xattr_value,
					     size_t xattr_value_len,
					     struct integrity_iint_cache *iint)
{
	struct evm_ima_xattr_data *xattr_data = NULL;
	struct evm_ima_xattr_data calc;
	enum integrity_status evm_status = INTEGRITY_PASS;
	int rc, xattr_len;

	if (iint && iint->evm_status == INTEGRITY_PASS)
		return iint->evm_status;

	/* if status is not PASS, try to check again - against -ENOMEM */

	/* first need to know the sig type */
	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
				GFP_NOFS);
	if (rc <= 0) {
		evm_status = INTEGRITY_FAIL;
		if (rc == -ENODATA) {
			rc = evm_find_protected_xattrs(dentry);
			if (rc > 0)
				evm_status = INTEGRITY_NOLABEL;
			else if (rc == 0)
				evm_status = INTEGRITY_NOXATTRS; /* new file */
		} else if (rc == -EOPNOTSUPP) {
			evm_status = INTEGRITY_UNKNOWN;
		}
		goto out;
	}

	xattr_len = rc;

	/* check value type */
	switch (xattr_data->type) {
	case EVM_XATTR_HMAC:
		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
		rc = crypto_memneq(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
		break;
	case EVM_IMA_XATTR_DIGSIG:
		rc = evm_calc_hash(dentry, xattr_name, xattr_value,
				xattr_value_len, calc.digest);
		if (rc)
			break;
		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
					(const char *)xattr_data, xattr_len,
					calc.digest, sizeof(calc.digest));
		if (!rc) {
			/* Replace RSA with HMAC if not mounted readonly and
			 * not immutable
			 */
			if (!IS_RDONLY(d_backing_inode(dentry)) &&
			    !IS_IMMUTABLE(d_backing_inode(dentry)))
				evm_update_evmxattr(dentry, xattr_name,
						    xattr_value,
						    xattr_value_len);
		}
		break;
	default:
		rc = -EINVAL;
		break;
	}

	if (rc)
		evm_status = (rc == -ENODATA) ?
				INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
	if (iint)
		iint->evm_status = evm_status;
	kfree(xattr_data);
	return evm_status;
}
","static enum integrity_status evm_verify_hmac(struct dentry *dentry,
					     const char *xattr_name,
					     char *xattr_value,
					     size_t xattr_value_len,
					     struct integrity_iint_cache *iint)
{
	struct evm_ima_xattr_data *xattr_data = NULL;
	struct evm_ima_xattr_data calc;
	enum integrity_status evm_status = INTEGRITY_PASS;
	int rc, xattr_len;

	if (iint && iint->evm_status == INTEGRITY_PASS)
		return iint->evm_status;

	/* if status is not PASS, try to check again - against -ENOMEM */

	/* first need to know the sig type */
	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
				GFP_NOFS);
	if (rc <= 0) {
		evm_status = INTEGRITY_FAIL;
		if (rc == -ENODATA) {
			rc = evm_find_protected_xattrs(dentry);
			if (rc > 0)
				evm_status = INTEGRITY_NOLABEL;
			else if (rc == 0)
				evm_status = INTEGRITY_NOXATTRS; /* new file */
		} else if (rc == -EOPNOTSUPP) {
			evm_status = INTEGRITY_UNKNOWN;
		}
		goto out;
	}

	xattr_len = rc;

	/* check value type */
	switch (xattr_data->type) {
	case EVM_XATTR_HMAC:
		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
		rc = memcmp(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
		break;
	case EVM_IMA_XATTR_DIGSIG:
		rc = evm_calc_hash(dentry, xattr_name, xattr_value,
				xattr_value_len, calc.digest);
		if (rc)
			break;
		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
					(const char *)xattr_data, xattr_len,
					calc.digest, sizeof(calc.digest));
		if (!rc) {
			/* Replace RSA with HMAC if not mounted readonly and
			 * not immutable
			 */
			if (!IS_RDONLY(d_backing_inode(dentry)) &&
			    !IS_IMMUTABLE(d_backing_inode(dentry)))
				evm_update_evmxattr(dentry, xattr_name,
						    xattr_value,
						    xattr_value_len);
		}
		break;
	default:
		rc = -EINVAL;
		break;
	}

	if (rc)
		evm_status = (rc == -ENODATA) ?
				INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
	if (iint)
		iint->evm_status = evm_status;
	kfree(xattr_data);
	return evm_status;
}
",C,"		rc = crypto_memneq(xattr_data->digest, calc.digest,
","		rc = memcmp(xattr_data->digest, calc.digest,
",,"@@ -23,6 +23,7 @@
 #include <linux/integrity.h>
 #include <linux/evm.h>
 #include <crypto/hash.h>
+#include <crypto/algapi.h>
 #include ""evm.h""
 
 int evm_initialized;
@@ -148,7 +149,7 @@ static enum integrity_status evm_verify_hmac(struct dentry *dentry,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
-		rc = memcmp(xattr_data->digest, calc.digest,
+		rc = crypto_memneq(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;",linux,613317bd212c585c20796c10afe5daaa95d4b0a1,c05235d50f681bf685e7290cae05ab3b4fa493f3,1,"static enum integrity_status evm_verify_hmac(struct dentry *dentry,
					     const char *xattr_name,
					     char *xattr_value,
					     size_t xattr_value_len,
					     struct integrity_iint_cache *iint)
{
	struct evm_ima_xattr_data *xattr_data = NULL;
	struct evm_ima_xattr_data calc;
	enum integrity_status evm_status = INTEGRITY_PASS;
	int rc, xattr_len;

	if (iint && iint->evm_status == INTEGRITY_PASS)
		return iint->evm_status;

	/* if status is not PASS, try to check again - against -ENOMEM */

	/* first need to know the sig type */
	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
				GFP_NOFS);
	if (rc <= 0) {
		evm_status = INTEGRITY_FAIL;
		if (rc == -ENODATA) {
			rc = evm_find_protected_xattrs(dentry);
			if (rc > 0)
				evm_status = INTEGRITY_NOLABEL;
			else if (rc == 0)
				evm_status = INTEGRITY_NOXATTRS; /* new file */
		} else if (rc == -EOPNOTSUPP) {
			evm_status = INTEGRITY_UNKNOWN;
		}
		goto out;
	}

	xattr_len = rc;

	/* check value type */
	switch (xattr_data->type) {
	case EVM_XATTR_HMAC:
		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
//flaw_line_below:
		rc = memcmp(xattr_data->digest, calc.digest,
//fix_flaw_line_below:
//		rc = crypto_memneq(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
		break;
	case EVM_IMA_XATTR_DIGSIG:
		rc = evm_calc_hash(dentry, xattr_name, xattr_value,
				xattr_value_len, calc.digest);
		if (rc)
			break;
		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
					(const char *)xattr_data, xattr_len,
					calc.digest, sizeof(calc.digest));
		if (!rc) {
			/* Replace RSA with HMAC if not mounted readonly and
			 * not immutable
			 */
			if (!IS_RDONLY(d_backing_inode(dentry)) &&
			    !IS_IMMUTABLE(d_backing_inode(dentry)))
				evm_update_evmxattr(dentry, xattr_name,
						    xattr_value,
						    xattr_value_len);
		}
		break;
	default:
		rc = -EINVAL;
		break;
	}

	if (rc)
		evm_status = (rc == -ENODATA) ?
				INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
	if (iint)
		iint->evm_status = evm_status;
	kfree(xattr_data);
	return evm_status;
}
",180609,"static enum integrity_status evm_verify_hmac(struct dentry *dentry,
					     const char *xattr_name,
					     char *xattr_value,
					     size_t xattr_value_len,
					     struct integrity_iint_cache *iint)
{
	struct evm_ima_xattr_data *xattr_data = NULL;
	struct evm_ima_xattr_data calc;
	enum integrity_status evm_status = INTEGRITY_PASS;
	int rc, xattr_len;

	if (iint && iint->evm_status == INTEGRITY_PASS)
		return iint->evm_status;

	/* if status is not PASS, try to check again - against -ENOMEM */

	/* first need to know the sig type */
	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
				GFP_NOFS);
	if (rc <= 0) {
		evm_status = INTEGRITY_FAIL;
		if (rc == -ENODATA) {
			rc = evm_find_protected_xattrs(dentry);
			if (rc > 0)
				evm_status = INTEGRITY_NOLABEL;
			else if (rc == 0)
				evm_status = INTEGRITY_NOXATTRS; /* new file */
		} else if (rc == -EOPNOTSUPP) {
			evm_status = INTEGRITY_UNKNOWN;
		}
		goto out;
	}

	xattr_len = rc;

	/* check value type */
	switch (xattr_data->type) {
	case EVM_XATTR_HMAC:
		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
		rc = memcmp(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
		break;
	case EVM_IMA_XATTR_DIGSIG:
		rc = evm_calc_hash(dentry, xattr_name, xattr_value,
				xattr_value_len, calc.digest);
		if (rc)
			break;
		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
					(const char *)xattr_data, xattr_len,
					calc.digest, sizeof(calc.digest));
		if (!rc) {
			/* Replace RSA with HMAC if not mounted readonly and
			 * not immutable
			 */
			if (!IS_RDONLY(d_backing_inode(dentry)) &&
			    !IS_IMMUTABLE(d_backing_inode(dentry)))
				evm_update_evmxattr(dentry, xattr_name,
						    xattr_value,
						    xattr_value_len);
		}
		break;
	default:
		rc = -EINVAL;
		break;
	}

	if (rc)
		evm_status = (rc == -ENODATA) ?
				INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
	if (iint)
		iint->evm_status = evm_status;
	kfree(xattr_data);
	return evm_status;
}
","static enum integrity_status evm_verify_hmac(struct dentry *dentry,
					     const char *xattr_name,
					     char *xattr_value,
					     size_t xattr_value_len,
					     struct integrity_iint_cache *iint)
{
	struct evm_ima_xattr_data *xattr_data = NULL;
	struct evm_ima_xattr_data calc;
	enum integrity_status evm_status = INTEGRITY_PASS;
	int rc, xattr_len;

	if (iint && iint->evm_status == INTEGRITY_PASS)
		return iint->evm_status;

	/* if status is not PASS, try to check again - against -ENOMEM */

	/* first need to know the sig type */
	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
				GFP_NOFS);
	if (rc <= 0) {
		evm_status = INTEGRITY_FAIL;
		if (rc == -ENODATA) {
			rc = evm_find_protected_xattrs(dentry);
			if (rc > 0)
				evm_status = INTEGRITY_NOLABEL;
			else if (rc == 0)
				evm_status = INTEGRITY_NOXATTRS; /* new file */
		} else if (rc == -EOPNOTSUPP) {
			evm_status = INTEGRITY_UNKNOWN;
		}
		goto out;
	}

	xattr_len = rc;

	/* check value type */
	switch (xattr_data->type) {
	case EVM_XATTR_HMAC:
		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
		rc = crypto_memneq(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
		break;
	case EVM_IMA_XATTR_DIGSIG:
		rc = evm_calc_hash(dentry, xattr_name, xattr_value,
				xattr_value_len, calc.digest);
		if (rc)
			break;
		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
					(const char *)xattr_data, xattr_len,
					calc.digest, sizeof(calc.digest));
		if (!rc) {
			/* Replace RSA with HMAC if not mounted readonly and
			 * not immutable
			 */
			if (!IS_RDONLY(d_backing_inode(dentry)) &&
			    !IS_IMMUTABLE(d_backing_inode(dentry)))
				evm_update_evmxattr(dentry, xattr_name,
						    xattr_value,
						    xattr_value_len);
		}
		break;
	default:
		rc = -EINVAL;
		break;
	}

	if (rc)
		evm_status = (rc == -ENODATA) ?
				INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
	if (iint)
		iint->evm_status = evm_status;
	kfree(xattr_data);
	return evm_status;
}
","The `evm_verify_hmac` function verifies the integrity of a file's extended attributes (xattrs) using HMAC or digital signatures. It first checks the integrity status from a cache; if it's not marked as passing, it retrieves the EVM xattr data associated with the file. Depending on the type of signature (HMAC or digital signature), it calculates the expected digest and compares it with the stored value. If the verification fails, it updates the integrity status accordingly. The function also handles various error conditions, such as missing data or unsupported operations, and cleans up allocated resources before returning the integrity status.","The code implements a function that verifies the integrity of a file's extended attributes by checking their associated signatures. It first assesses the current integrity status and retrieves the relevant attribute data. Depending on the type of signature, it calculates the expected digest and compares it to the stored value to determine if the integrity check passes or fails. The function also handles various error scenarios, such as missing data or unsupported operations, and updates the integrity status accordingly. Finally, it ensures proper resource management by freeing allocated memory before returning the integrity result.","The vulnerability in the original code stemmed from improper comparison of cryptographic digests, which could allow local users to exploit timing side-channel attacks to forge MAC values. Specifically, the use of `memcmp` for digest comparison could reveal timing differences based on the data being compared, potentially leaking information about the validity of the MAC. In the fixed code, this was addressed by replacing `memcmp` with `crypto_memneq`, which performs a constant-time comparison of the digests. This change mitigates the risk of timing attacks by ensuring that the comparison time remains consistent, regardless of the input values.","The vulnerability in the original code was due to improper handling of cryptographic digest comparisons, which could allow local users to exploit timing side-channel attacks to forge Message Authentication Code (MAC) values. The method used for comparing the digests revealed timing variations based on the data being compared, potentially leaking information about the validity of the MAC. The fix involved implementing a constant-time comparison method, ensuring that the time taken to compare the digests remains consistent regardless of the input values. This change effectively mitigated the risk of timing attacks and enhanced the overall security of the integrity verification process.","The vulnerability was fixed by replacing the use of `memcmp` for comparing cryptographic digests with `crypto_memneq`. The original implementation could reveal timing differences based on the data being compared, making it susceptible to timing side-channel attacks. By using `crypto_memneq`, the comparison is performed in constant time, ensuring that the execution time does not vary with the input values. This change effectively prevents attackers from inferring information about the validity of the MAC based on timing discrepancies, thereby enhancing the security of the integrity verification process in the function.","The vulnerability was fixed by implementing a constant-time comparison method for verifying cryptographic digests, replacing the previous approach that was susceptible to timing side-channel attacks. This change ensures that the time taken to compare the digests remains consistent, regardless of the specific values being compared. By eliminating timing variations, the fix prevents attackers from gaining insights into the validity of the Message Authentication Code based on how long the comparison takes. This enhancement significantly improves the security of the integrity verification process, making it more resilient against potential exploitation.","5, 4","5,5","5,5","5,4"
2,2,181958,181958,,Remote,Not required,Partial,CVE-2016-7540,https://www.cvedetails.com/cve/CVE-2016-7540/,CWE-19,Medium,,,,2017-04-20,4.3,coders/rgf.c in ImageMagick before 6.9.4-10 allows remote attackers to cause a denial of service (assertion failure) by converting an image to rgf format.,2017-05-08,DoS ,3,https://github.com/ImageMagick/ImageMagick/commit/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7,a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7,"Fix abort when writing to rgf format

The rgf format (LEGO MINDSTORMS EV3 images) caused a software abort because
exception == NULL. When WriteRGFImage is called from WriteImage, it is only
passed two parameters, not three. So, removed the extra parameter and use
image->exception instead as in other coders.",5,coders/rgf.c,"{""sha"": ""e572f96d2441183b2e45850a6f8096f4ab2cc2b3"", ""filename"": ""coders/rgf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 8, ""changes"": 13, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7/coders/rgf.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7/coders/rgf.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/rgf.c?ref=a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7"", ""patch"": ""@@ -68,7 +68,7 @@\n   Forward declarations.\n */\n static MagickBooleanType\n-  WriteRGFImage(const ImageInfo *,Image *,ExceptionInfo *);\n+  WriteRGFImage(const ImageInfo *,Image *);\n \f\n /*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n@@ -305,7 +305,7 @@ ModuleExport void UnregisterRGFImage(void)\n %  The format of the WriteRGFImage method is:\n %\n %      MagickBooleanType WriteRGFImage(const ImageInfo *image_info,\n-%        Image *image,ExceptionInfo *exception)\n+%        Image *image)\n %\n %  A description of each parameter follows.\n %\n@@ -316,8 +316,7 @@ ModuleExport void UnregisterRGFImage(void)\n %    o exception: return any errors or warnings in this structure.\n %\n */\n-static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n-  ExceptionInfo *exception)\n+static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n {\n   MagickBooleanType\n     status;\n@@ -346,9 +345,7 @@ static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n   assert(image->signature == MagickSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n-  assert(exception != (ExceptionInfo *) NULL);\n-  assert(exception->signature == MagickSignature);\n-  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n+  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n   if (status == MagickFalse)\n     return(status);\n   (void) TransformImageColorspace(image,sRGBColorspace);\n@@ -367,7 +364,7 @@ static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n   y=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n-    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n+    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n     if (p == (const PixelPacket *) NULL)\n       break;\n     bit=0;""}","static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;

  int
    bit;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  unsigned char
    byte;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  if((image->columns > 255L) || (image->rows > 255L))
    ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
  /*
    Write header (just the image dimensions)
  */
  (void) WriteBlobByte(image,image->columns & 0xff);
  (void) WriteBlobByte(image,image->rows & 0xff);
  /*
    Convert MIFF to bit pixels.
  */
  (void) SetImageType(image,BilevelType);
  x=0;
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;
    byte=0;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      byte>>=1;
      if (GetPixelLuma(image,p) < (QuantumRange/2.0))
        byte|=0x80;
      bit++;
      if (bit == 8)
        {
          /*
            Write a bitmap byte to the image file.
          */
       	  (void) WriteBlobByte(image,byte);
          bit=0;
          byte=0;
        }
      p++;
    }
    if (bit != 0)
      (void) WriteBlobByte(image,byte);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}
","static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
 {
   MagickBooleanType
     status;

  int
    bit;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  unsigned char
    byte;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  if((image->columns > 255L) || (image->rows > 255L))
    ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
  /*
    Write header (just the image dimensions)
  */
  (void) WriteBlobByte(image,image->columns & 0xff);
  (void) WriteBlobByte(image,image->rows & 0xff);
  /*
    Convert MIFF to bit pixels.
  */
  (void) SetImageType(image,BilevelType);
  x=0;
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;
    byte=0;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      byte>>=1;
      if (GetPixelLuma(image,p) < (QuantumRange/2.0))
        byte|=0x80;
      bit++;
      if (bit == 8)
        {
          /*
            Write a bitmap byte to the image file.
          */
       	  (void) WriteBlobByte(image,byte);
          bit=0;
          byte=0;
        }
      p++;
    }
    if (bit != 0)
      (void) WriteBlobByte(image,byte);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}
",C,"static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
","  ExceptionInfo *exception)
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
",,"@@ -68,7 +68,7 @@
   Forward declarations.
 */
 static MagickBooleanType
-  WriteRGFImage(const ImageInfo *,Image *,ExceptionInfo *);
+  WriteRGFImage(const ImageInfo *,Image *);
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -305,7 +305,7 @@ ModuleExport void UnregisterRGFImage(void)
 %  The format of the WriteRGFImage method is:
 %
 %      MagickBooleanType WriteRGFImage(const ImageInfo *image_info,
-%        Image *image,ExceptionInfo *exception)
+%        Image *image)
 %
 %  A description of each parameter follows.
 %
@@ -316,8 +316,7 @@ ModuleExport void UnregisterRGFImage(void)
 %    o exception: return any errors or warnings in this structure.
 %
 */
-static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
-  ExceptionInfo *exception)
+static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;
@@ -346,9 +345,7 @@ static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
-  assert(exception != (ExceptionInfo *) NULL);
-  assert(exception->signature == MagickSignature);
-  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
+  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
@@ -367,7 +364,7 @@ static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
-    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
+    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;",ImageMagick,a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7,8627a99c524c27b203cb14555046326b9d53d0d9,1,"static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
//flaw_line_below:
  ExceptionInfo *exception)
//fix_flaw_line_below:
//static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;

  int
    bit;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  unsigned char
    byte;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
//flaw_line_below:
  assert(exception != (ExceptionInfo *) NULL);
//flaw_line_below:
  assert(exception->signature == MagickSignature);
//flaw_line_below:
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
//fix_flaw_line_below:
//  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  if((image->columns > 255L) || (image->rows > 255L))
    ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
  /*
    Write header (just the image dimensions)
  */
  (void) WriteBlobByte(image,image->columns & 0xff);
  (void) WriteBlobByte(image,image->rows & 0xff);
  /*
    Convert MIFF to bit pixels.
  */
  (void) SetImageType(image,BilevelType);
  x=0;
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
//flaw_line_below:
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
//fix_flaw_line_below:
//    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;
    byte=0;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      byte>>=1;
      if (GetPixelLuma(image,p) < (QuantumRange/2.0))
        byte|=0x80;
      bit++;
      if (bit == 8)
        {
          /*
            Write a bitmap byte to the image file.
          */
       	  (void) WriteBlobByte(image,byte);
          bit=0;
          byte=0;
        }
      p++;
    }
    if (bit != 0)
      (void) WriteBlobByte(image,byte);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}
",181958,"static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
 {
   MagickBooleanType
     status;

  int
    bit;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  unsigned char
    byte;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  if((image->columns > 255L) || (image->rows > 255L))
    ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
  /*
    Write header (just the image dimensions)
  */
  (void) WriteBlobByte(image,image->columns & 0xff);
  (void) WriteBlobByte(image,image->rows & 0xff);
  /*
    Convert MIFF to bit pixels.
  */
  (void) SetImageType(image,BilevelType);
  x=0;
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;
    byte=0;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      byte>>=1;
      if (GetPixelLuma(image,p) < (QuantumRange/2.0))
        byte|=0x80;
      bit++;
      if (bit == 8)
        {
          /*
            Write a bitmap byte to the image file.
          */
       	  (void) WriteBlobByte(image,byte);
          bit=0;
          byte=0;
        }
      p++;
    }
    if (bit != 0)
      (void) WriteBlobByte(image,byte);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}
","static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;

  int
    bit;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  unsigned char
    byte;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  if((image->columns > 255L) || (image->rows > 255L))
    ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
  /*
    Write header (just the image dimensions)
  */
  (void) WriteBlobByte(image,image->columns & 0xff);
  (void) WriteBlobByte(image,image->rows & 0xff);
  /*
    Convert MIFF to bit pixels.
  */
  (void) SetImageType(image,BilevelType);
  x=0;
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;
    byte=0;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      byte>>=1;
      if (GetPixelLuma(image,p) < (QuantumRange/2.0))
        byte|=0x80;
      bit++;
      if (bit == 8)
        {
          /*
            Write a bitmap byte to the image file.
          */
       	  (void) WriteBlobByte(image,byte);
          bit=0;
          byte=0;
        }
      p++;
    }
    if (bit != 0)
      (void) WriteBlobByte(image,byte);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}
","The `WriteRGFImage` function is designed to write an image in a specific binary format, ensuring that the image dimensions do not exceed 255x255 pixels. It begins by validating input parameters and opening a binary output file. The function transforms the image colorspace to sRGB and sets the image type to Bilevel. It then writes the image dimensions as a header, followed by processing each pixel to convert the image data into a bit-packed format, where pixel luminance is evaluated to determine the corresponding bits. Finally, it updates the progress and closes the output file, returning a success status.","The code defines a function that writes an image in a specific binary format, ensuring the dimensions are limited to a maximum of 255x255 pixels. It begins by validating input parameters and opening a binary output file for writing. The image is transformed to a standard colorspace and set to a specific type. The function then writes the image dimensions as a header and processes each pixel to convert the image data into a compact bit representation based on luminance. Finally, it updates the progress of the writing process and closes the output file, indicating success or failure.","The vulnerability in the original code arises from insufficient validation of image dimensions, which could allow an attacker to provide an image with dimensions exceeding the allowed limits, leading to an assertion failure and potential denial of service. Specifically, the check for dimensions was not robust enough, allowing for unexpected behavior. In the fixed code, a validation check was added to ensure that both the width and height of the image do not exceed 255 pixels. This is done through a conditional statement that throws an exception if the dimensions are too large, thereby preventing the assertion failure and enhancing the code's robustness against malformed input.","The vulnerability in the original code stems from inadequate validation of image dimensions, allowing attackers to submit images with sizes that exceed the permissible limits, which could lead to assertion failures and denial of service. This lack of proper checks meant that the program could enter an unexpected state when processing oversized images. In the revised code, a specific validation step was introduced to ensure that both the width and height of the image are within acceptable bounds before proceeding with any processing. This fix effectively prevents the program from attempting to handle invalid input, thereby mitigating the risk of assertion failures.","The vulnerability was fixed by adding a validation check for the image dimensions before any processing occurs. In the revised code, a conditional statement checks if the image's columns or rows exceed 255 pixels. If either dimension is too large, the code throws an exception using `ThrowWriterException`, preventing further execution. This ensures that the program does not attempt to process images that could lead to assertion failures. By enforcing this constraint, the code effectively mitigates the risk of denial of service caused by oversized images, enhancing overall stability and security.","The vulnerability was addressed by implementing a validation step that checks the dimensions of the image before any processing takes place. The revised code includes a condition that verifies whether the width and height of the image exceed the maximum allowed limits. If the dimensions are found to be too large, the code triggers an exception, effectively halting further execution. This proactive measure prevents the program from attempting to process invalid input, thereby eliminating the risk of assertion failures and enhancing the overall stability and security of the application against potential denial of service attacks.","5,4","5,5","4,4","4, 5"
3,3,182092,182092,,Local,Not required,Complete,CVE-2006-5331,https://www.cvedetails.com/cve/CVE-2006-5331/,CWE-19,Low,,,,2017-10-29,4.9,"The altivec_unavailable_exception function in arch/powerpc/kernel/traps.c in the Linux kernel before 2.6.19 on 64-bit systems mishandles the case where CONFIG_ALTIVEC is defined and the CPU actually supports Altivec, but the Altivec support was not detected by the kernel, which allows local users to cause a denial of service (panic) by triggering execution of an Altivec instruction.",2017-11-17,DoS ,1,https://github.com/torvalds/linux/commit/6c4841c2b6c32a134f9f36e5e08857138cc12b10,6c4841c2b6c32a134f9f36e5e08857138cc12b10,"[POWERPC] Never panic when taking altivec exceptions from userspace

At the moment we rely on a cpu feature bit or a firmware property to
detect altivec. If we dont have either of these and the cpu does in fact
support altivec we can cause a panic from userspace.

It seems safer to always send a signal if we manage to get an 0xf20
exception from userspace.

Signed-off-by: Anton Blanchard <anton@samba.org>
Signed-off-by: Paul Mackerras <paulus@samba.org>",2,arch/powerpc/kernel/traps.c,"{""sha"": ""5ed4c2ceb5caa8632c11f229193afe0596893650"", ""filename"": ""arch/powerpc/kernel/traps.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/6c4841c2b6c32a134f9f36e5e08857138cc12b10/arch/powerpc/kernel/traps.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6c4841c2b6c32a134f9f36e5e08857138cc12b10/arch/powerpc/kernel/traps.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/traps.c?ref=6c4841c2b6c32a134f9f36e5e08857138cc12b10"", ""patch"": ""@@ -900,14 +900,13 @@ void kernel_fp_unavailable_exception(struct pt_regs *regs)\n \n void altivec_unavailable_exception(struct pt_regs *regs)\n {\n-#if !defined(CONFIG_ALTIVEC)\n \tif (user_mode(regs)) {\n \t\t/* A user program has executed an altivec instruction,\n \t\t   but this kernel doesn't support altivec. */\n \t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n \t\treturn;\n \t}\n-#endif\n+\n \tprintk(KERN_EMERG \""Unrecoverable VMX/Altivec Unavailable Exception \""\n \t\t\t\""%lx at %lx\\n\"", regs->trap, regs->nip);\n \tdie(\""Unrecoverable VMX/Altivec Unavailable Exception\"", regs, SIGABRT);""}"," void altivec_unavailable_exception(struct pt_regs *regs)
 {
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}

 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}
"," void altivec_unavailable_exception(struct pt_regs *regs)
 {
#if !defined(CONFIG_ALTIVEC)
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}
#endif
 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}
",C,"
","#if !defined(CONFIG_ALTIVEC)
#endif
",,"@@ -900,14 +900,13 @@ void kernel_fp_unavailable_exception(struct pt_regs *regs)
 
 void altivec_unavailable_exception(struct pt_regs *regs)
 {
-#if !defined(CONFIG_ALTIVEC)
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}
-#endif
+
 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);",linux,6c4841c2b6c32a134f9f36e5e08857138cc12b10,60b2a46cd60c54bd6551ddfa01f0aab08ca58a5d,1," void altivec_unavailable_exception(struct pt_regs *regs)
 {
//flaw_line_below:
#if !defined(CONFIG_ALTIVEC)
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}
//flaw_line_below:
#endif
//fix_flaw_line_below:
//
 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}
",182092," void altivec_unavailable_exception(struct pt_regs *regs)
 {
#if !defined(CONFIG_ALTIVEC)
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}
#endif
 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}
"," void altivec_unavailable_exception(struct pt_regs *regs)
 {
 	if (user_mode(regs)) {
 		/* A user program has executed an altivec instruction,
 		   but this kernel doesn't support altivec. */
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}

 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}
","The provided code defines a function `altivec_unavailable_exception` that handles exceptions related to the Altivec instruction set when it is not supported by the kernel. If the exception occurs in user mode, it triggers an illegal instruction signal (SIGILL) indicating that a user program attempted to execute an unsupported Altivec instruction. If the exception occurs in kernel mode, it logs an emergency message detailing the exception and the instruction pointer where it occurred. Finally, it calls the `die` function to terminate the process with an abort signal (SIGABRT), indicating a critical failure due to the unavailable Altivec functionality.","The code defines a function that handles exceptions related to an unsupported instruction set in the kernel. When a program attempts to execute an instruction from this set while running in user mode, the function generates an illegal instruction signal to indicate the error. If the exception occurs in kernel mode, it logs a critical error message that includes details about the exception and the location of the fault. Subsequently, the function terminates the process with an abort signal, signifying a severe failure due to the unavailability of the specified instruction set functionality.","The vulnerability in the original code arises from the mishandling of scenarios where the Altivec instruction set is defined but not properly detected by the kernel, leading to a denial of service when a user program executes an unsupported instruction. Specifically, the function fails to account for cases where the CPU supports Altivec, but the kernel does not recognize it, resulting in an unhandled exception. The fixed code addresses this by ensuring that the function only triggers the illegal instruction signal when the user mode is confirmed, thus preventing the kernel from panicking and allowing for a more graceful handling of the situation.","The vulnerability in the original code stems from improper handling of situations where the Altivec instruction set is defined in the kernel configuration, yet the kernel fails to detect its support on the CPU. This oversight allows local users to execute Altivec instructions, leading to a system panic and denial of service. The fixed code resolves this issue by ensuring that the function only responds to illegal instructions when the execution context is confirmed as user mode, thereby preventing the kernel from entering a panic state and allowing for a more controlled response to unsupported instructions.","The vulnerability was fixed by modifying the handling of exceptions in the function to ensure that it only triggers an illegal instruction signal when the execution context is confirmed as user mode. In the updated code, the check for user mode is retained, and if a user program executes an unsupported Altivec instruction, it calls the `_exception` function with the appropriate parameters. This change prevents the kernel from panicking in cases where the CPU supports Altivec but the kernel does not detect it, allowing for a more graceful handling of the situation without leading to a denial of service.","The vulnerability was fixed by implementing a more robust check to ensure that the function only responds to unsupported instructions when the execution context is confirmed as user mode. This adjustment prevents the system from entering a panic state when a user program attempts to execute an instruction that the kernel does not support. By clearly distinguishing between user and kernel modes, the updated code allows for the generation of an appropriate signal for illegal instructions, thereby enabling a controlled response to the situation and mitigating the risk of denial of service due to unhandled exceptions.","4, 4","5,5","4,4","4,4"
4,4,184619,184619,,Remote,Not required,Partial,CVE-2011-3927,https://www.cvedetails.com/cve/CVE-2011-3927/,CWE-19,Low,Partial,Partial,,2012-01-23,7.5,"Skia, as used in Google Chrome before 16.0.912.77, does not perform all required initialization of values, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",2017-09-18,DoS ,11,https://github.com/chromium/chromium/commit/58ffd25567098d8ce9443b7c977382929d163b3d,58ffd25567098d8ce9443b7c977382929d163b3d,"[skia] not all convex paths are convex, so recompute convexity for the problematic ones
https://bugs.webkit.org/show_bug.cgi?id=75960

Reviewed by Stephen White.

No new tests.
See related chrome issue
http://code.google.com/p/chromium/issues/detail?id=108605

* platform/graphics/skia/GraphicsContextSkia.cpp:
(WebCore::setPathFromConvexPoints):


git-svn-id: svn://svn.chromium.org/blink/trunk@104609 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/WebCore/platform/graphics/skia/GraphicsContextSkia.cpp,"{""sha"": ""8710fc85b1d579e074c14b06e77c1c52fb6b1bf9"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/58ffd25567098d8ce9443b7c977382929d163b3d/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/58ffd25567098d8ce9443b7c977382929d163b3d/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=58ffd25567098d8ce9443b7c977382929d163b3d"", ""patch"": ""@@ -1,3 +1,17 @@\n+2012-01-10  Mike Reed  <reed@google.com>\n+\n+        [skia] not all convex paths are convex, so recompute convexity for the problematic ones\n+        https://bugs.webkit.org/show_bug.cgi?id=75960\n+\n+        Reviewed by Stephen White.\n+\n+        No new tests.\n+        See related chrome issue\n+        http://code.google.com/p/chromium/issues/detail?id=108605\n+\n+        * platform/graphics/skia/GraphicsContextSkia.cpp:\n+        (WebCore::setPathFromConvexPoints):\n+\n 2012-01-10  Gavin Barraclough  <barraclough@apple.com>\n \n         Do not allow Array length to be set if it is non-configurable""}<_**next**_>{""sha"": ""db343615fb8840fc386b646fb2d057a4d3ae6936"", ""filename"": ""third_party/WebKit/Source/WebCore/platform/graphics/skia/GraphicsContextSkia.cpp"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/58ffd25567098d8ce9443b7c977382929d163b3d/third_party/WebKit/Source/WebCore/platform/graphics/skia/GraphicsContextSkia.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/58ffd25567098d8ce9443b7c977382929d163b3d/third_party/WebKit/Source/WebCore/platform/graphics/skia/GraphicsContextSkia.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/platform/graphics/skia/GraphicsContextSkia.cpp?ref=58ffd25567098d8ce9443b7c977382929d163b3d"", ""patch"": ""@@ -440,7 +440,17 @@ static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatP\n         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),\n                      WebCoreFloatToSkScalar(points[i].y()));\n     }\n-    path->setIsConvex(true);\n+\n+    /*  The code used to just blindly call this\n+            path->setIsConvex(true);\n+        But webkit can sometimes send us non-convex 4-point values, so we mark the path's\n+        convexity as unknown, so it will get computed by skia at draw time.\n+        See crbug.com 108605\n+    */\n+    SkPath::Convexity convexity = SkPath::kConvex_Convexity;\n+    if (numPoints == 4)\n+        convexity = SkPath::kUnknown_Convexity;\n+    path->setConvexity(convexity);\n }\n \n void GraphicsContext::drawConvexPolygon(size_t numPoints,""}","static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)
{
    path->incReserve(numPoints);
    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),
                 WebCoreFloatToSkScalar(points[0].y()));
    for (size_t i = 1; i < numPoints; ++i) {
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }

    /*  The code used to just blindly call this
            path->setIsConvex(true);
        But webkit can sometimes send us non-convex 4-point values, so we mark the path's
        convexity as unknown, so it will get computed by skia at draw time.
        See crbug.com 108605
    */
    SkPath::Convexity convexity = SkPath::kConvex_Convexity;
    if (numPoints == 4)
        convexity = SkPath::kUnknown_Convexity;
    path->setConvexity(convexity);
 }
","static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)
{
    path->incReserve(numPoints);
    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),
                 WebCoreFloatToSkScalar(points[0].y()));
    for (size_t i = 1; i < numPoints; ++i) {
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }
    path->setIsConvex(true);
 }
",C,"
    /*  The code used to just blindly call this
            path->setIsConvex(true);
        But webkit can sometimes send us non-convex 4-point values, so we mark the path's
        convexity as unknown, so it will get computed by skia at draw time.
        See crbug.com 108605
    */
    SkPath::Convexity convexity = SkPath::kConvex_Convexity;
    if (numPoints == 4)
        convexity = SkPath::kUnknown_Convexity;
    path->setConvexity(convexity);
","    path->setIsConvex(true);
",,"@@ -440,7 +440,17 @@ static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatP
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }
-    path->setIsConvex(true);
+
+    /*  The code used to just blindly call this
+            path->setIsConvex(true);
+        But webkit can sometimes send us non-convex 4-point values, so we mark the path's
+        convexity as unknown, so it will get computed by skia at draw time.
+        See crbug.com 108605
+    */
+    SkPath::Convexity convexity = SkPath::kConvex_Convexity;
+    if (numPoints == 4)
+        convexity = SkPath::kUnknown_Convexity;
+    path->setConvexity(convexity);
 }
 
 void GraphicsContext::drawConvexPolygon(size_t numPoints,",Chrome,58ffd25567098d8ce9443b7c977382929d163b3d,d18b03cf294a6f08e872e98b78f196ba20d37163,1,"static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)
{
    path->incReserve(numPoints);
    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),
                 WebCoreFloatToSkScalar(points[0].y()));
    for (size_t i = 1; i < numPoints; ++i) {
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }
//flaw_line_below:
    path->setIsConvex(true);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /*  The code used to just blindly call this
//fix_flaw_line_below:
//            path->setIsConvex(true);
//fix_flaw_line_below:
//        But webkit can sometimes send us non-convex 4-point values, so we mark the path's
//fix_flaw_line_below:
//        convexity as unknown, so it will get computed by skia at draw time.
//fix_flaw_line_below:
//        See crbug.com 108605
//fix_flaw_line_below:
//    */
//fix_flaw_line_below:
//    SkPath::Convexity convexity = SkPath::kConvex_Convexity;
//fix_flaw_line_below:
//    if (numPoints == 4)
//fix_flaw_line_below:
//        convexity = SkPath::kUnknown_Convexity;
//fix_flaw_line_below:
//    path->setConvexity(convexity);
 }
",184619,"static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)
{
    path->incReserve(numPoints);
    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),
                 WebCoreFloatToSkScalar(points[0].y()));
    for (size_t i = 1; i < numPoints; ++i) {
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }
    path->setIsConvex(true);
 }
","static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)
{
    path->incReserve(numPoints);
    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),
                 WebCoreFloatToSkScalar(points[0].y()));
    for (size_t i = 1; i < numPoints; ++i) {
         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),
                      WebCoreFloatToSkScalar(points[i].y()));
     }

    /*  The code used to just blindly call this
            path->setIsConvex(true);
        But webkit can sometimes send us non-convex 4-point values, so we mark the path's
        convexity as unknown, so it will get computed by skia at draw time.
        See crbug.com 108605
    */
    SkPath::Convexity convexity = SkPath::kConvex_Convexity;
    if (numPoints == 4)
        convexity = SkPath::kUnknown_Convexity;
    path->setConvexity(convexity);
 }
","The provided code defines a function `setPathFromConvexPoints` that constructs a geometric path using a series of convex points. It takes a pointer to an `SkPath` object, the number of points, and an array of `FloatPoint` structures as input. The function first reserves space in the path for the specified number of points, then initializes the path by moving to the coordinates of the first point. Subsequently, it iterates through the remaining points, adding straight line segments to the path for each point. Finally, it marks the path as convex, indicating that the shape formed by the points does not curve inward.","The code defines a function that creates a geometric path based on a set of convex points. It begins by reserving space in the path for the specified number of points, then sets the starting point of the path to the first point's coordinates. Following this, it iterates through the remaining points, adding straight line segments to the path for each subsequent point. Finally, the function marks the path as convex, indicating that the shape formed by the points is a simple polygon that does not curve inward, ensuring a clear and defined outline.","The vulnerability in the original code arises from the assumption that any set of four points is convex, leading to potential misuse when non-convex points are provided, which could cause unexpected behavior or denial of service. This is addressed in the fixed code by introducing a check for the number of points; if there are exactly four points, the convexity is set to unknown instead of assuming it is convex. This change ensures that the path's convexity is accurately determined at draw time by the Skia library, preventing potential issues from incorrect assumptions about the input data.","The vulnerability in the original code stems from the incorrect assumption that any set of four points is guaranteed to form a convex shape, which could lead to unexpected behavior or denial of service when non-convex points are processed. This oversight could allow attackers to exploit the system by providing such points, resulting in potential instability. The fixed code addresses this issue by introducing a conditional check for the number of points; if there are four points, it marks the shape's convexity as unknown. This adjustment ensures that the system accurately determines the shape's properties at runtime, enhancing stability and security.","The vulnerability was fixed by modifying how the convexity of the path is determined based on the number of points provided. In the original code, the convexity was blindly set to true, which could lead to issues with non-convex shapes. In the updated code, a conditional check was introduced: if the number of points is exactly four, the convexity is set to unknown instead of assuming it is convex. This change allows the Skia library to compute the correct convexity at draw time, thereby preventing potential denial of service and ensuring more robust handling of various input shapes.","The vulnerability was addressed by implementing a conditional check that evaluates the number of points provided to the function. Instead of automatically assuming that a set of four points is convex, the updated code marks the convexity as unknown when there are exactly four points. This adjustment allows the system to defer the determination of convexity to a later stage, ensuring that the correct properties of the shape are assessed at draw time. This change enhances the robustness of the code by preventing incorrect assumptions that could lead to instability or denial of service.","4,4","5, 5","4,4","4, 5"
5,5,186514,186514,,Remote,Not required,,CVE-2016-5225,https://www.cvedetails.com/cve/CVE-2016-5225/,CWE-19,Medium,,Partial,,2017-01-19,4.3,"Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled form actions, which allowed a remote attacker to bypass Content Security Policy via a crafted HTML page.",2018-01-04,Bypass ,5,https://github.com/chromium/chromium/commit/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0,4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0,"Enforce form-action CSP even when form.target is present.

BUG=630332

Review-Url: https://codereview.chromium.org/2464123004
Cr-Commit-Position: refs/heads/master@{#429922}",3,third_party/WebKit/Source/core/html/HTMLFormElement.cpp,"{""sha"": ""7b22df1678c243254c0861227ada90d0d291a7c6"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank-expected.txt"", ""status"": ""added"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank-expected.txt?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -0,0 +1,13 @@\n+CONSOLE MESSAGE: line 15: submit event fired.\n+CONSOLE ERROR: line 19: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n+\n+CONSOLE MESSAGE: line 24: securitypolicyviolation event fired.\n+CONSOLE MESSAGE: line 25: securitypolicyviolation_event.documentURI=http://127.0.0.1:8000/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html\n+CONSOLE MESSAGE: line 26: securitypolicyviolation_event.blockedURI=http://127.0.0.1:8000/navigation/resources/form-target.pl\n+CONSOLE MESSAGE: line 27: securitypolicyviolation_event.violatedDirective=form-action\n+  \n+Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.\n+\n+============== Back Forward List ==============\n+curr->  http://127.0.0.1:8000/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html\n+===============================================""}<_**next**_>{""sha"": ""09103f5b1998e37db283dc7e0ddd65e98cab7ef4"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html"", ""status"": ""added"", ""additions"": 43, ""deletions"": 0, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-blank.html?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -0,0 +1,43 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<meta http-equiv=\""Content-Security-Policy\"" content=\""form-action 'none'\"">\n+<script>\n+    if (window.testRunner) {\n+        testRunner.dumpAsText();\n+        testRunner.waitUntilDone();\n+        testRunner.clearBackForwardList();\n+        testRunner.dumpBackForwardList();\n+    }\n+\n+    window.addEventListener('load', function() {\n+        document.getElementById('theform').addEventListener('submit', function(e) {\n+            console.log('submit event fired.');\n+        });\n+\n+        setTimeout(function() {\n+            document.getElementById('submit').click();\n+        }, 0);\n+    });\n+\n+    document.addEventListener('securitypolicyviolation', function(e) {\n+        console.log('securitypolicyviolation event fired.');\n+        console.log('securitypolicyviolation_event.documentURI=' + e.documentURI);\n+        console.log('securitypolicyviolation_event.blockedURI=' + e.blockedURI);\n+        console.log('securitypolicyviolation_event.violatedDirective=' + e.violatedDirective);\n+        setTimeout(function() {\n+            testRunner.notifyDone();\n+        }, 0);\n+    });\n+</script>\n+</head>\n+<body>\n+    <form action='/navigation/resources/form-target.pl' id='theform'\n+          method='post' target=\""_blank\"">\n+        <input type='text' name='fieldname' value='fieldvalue'>\n+        <input type='submit' id='submit' value='submit'>\n+    </form>\n+\n+    <p>Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.</p>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""957bce5a723faa41fc0fdc7e63df512af9713125"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window-expected.txt"", ""status"": ""added"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window-expected.txt?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -0,0 +1,9 @@\n+CONSOLE MESSAGE: line 19: submit event fired.\n+CONSOLE ERROR: line 23: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n+\n+CONSOLE MESSAGE: line 28: securitypolicyviolation event fired.\n+CONSOLE MESSAGE: line 29: securitypolicyviolation_event.documentURI=http://127.0.0.1:8000/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window.html\n+CONSOLE MESSAGE: line 30: securitypolicyviolation_event.blockedURI=http://127.0.0.1:8000/navigation/resources/form-target.pl\n+CONSOLE MESSAGE: line 31: securitypolicyviolation_event.violatedDirective=form-action\n+  \n+Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.""}<_**next**_>{""sha"": ""1b2dfe864fc8a1e7c62859fbeb70e6abed963f9e"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-blocked-when-target-cross-site-window.html?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<meta http-equiv=\""Content-Security-Policy\"" content=\""form-action 'none'\"">\n+<script>\n+    if (window.testRunner) {\n+        testRunner.dumpAsText();\n+        testRunner.waitUntilDone();\n+        testRunner.setCanOpenWindows();\n+    }\n+\n+    // Open a new window with the name matching form.target attribute below.\n+    window.open(\n+        'http://localhost:8080/security/resources/empty.html',\n+        'namedCrossSiteWindow')\n+\n+    window.addEventListener('load', function() {\n+        document.getElementById('theform').addEventListener('submit', function(e) {\n+            console.log('submit event fired.');\n+        });\n+\n+        setTimeout(function() {\n+            document.getElementById('submit').click();\n+        }, 0);\n+    });\n+\n+    document.addEventListener('securitypolicyviolation', function(e) {\n+        console.log('securitypolicyviolation event fired.');\n+        console.log('securitypolicyviolation_event.documentURI=' + e.documentURI);\n+        console.log('securitypolicyviolation_event.blockedURI=' + e.blockedURI);\n+        console.log('securitypolicyviolation_event.violatedDirective=' + e.violatedDirective);\n+        setTimeout(function() {\n+            testRunner.notifyDone();\n+        }, 0);\n+    });\n+</script>\n+</head>\n+<body>\n+    <form action='/navigation/resources/form-target.pl' id='theform'\n+          method='post' target=\""namedCrossSiteWindow\"">\n+        <input type='text' name='fieldname' value='fieldvalue'>\n+        <input type='submit' id='submit' value='submit'>\n+    </form>\n+\n+    <p>Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.</p>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""9e95b5d927f352e51d6925bc3620a776f35d3787"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked-expected.txt"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked-expected.txt?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -1,5 +1,10 @@\n-CONSOLE ERROR: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n+CONSOLE MESSAGE: line 15: submit event fired.\n+CONSOLE ERROR: line 19: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n \n+CONSOLE MESSAGE: line 24: securitypolicyviolation event fired.\n+CONSOLE MESSAGE: line 25: securitypolicyviolation_event.documentURI=http://127.0.0.1:8000/security/contentSecurityPolicy/1.1/form-action-src-blocked.html\n+CONSOLE MESSAGE: line 26: securitypolicyviolation_event.blockedURI=http://127.0.0.1:8000/navigation/resources/form-target.pl\n+CONSOLE MESSAGE: line 27: securitypolicyviolation_event.violatedDirective=form-action\n   \n Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.\n ""}<_**next**_>{""sha"": ""b5bc0a3f413e1e946148975be530dccdfaf946d0"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked.html"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-blocked.html?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -9,14 +9,26 @@\n         testRunner.clearBackForwardList();\n         testRunner.dumpBackForwardList();\n     }\n+\n     window.addEventListener('load', function() {\n+        document.getElementById('theform').addEventListener('submit', function(e) {\n+            console.log('submit event fired.');\n+        });\n+\n         setTimeout(function() {\n             document.getElementById('submit').click();\n         }, 0);\n     });\n-    setTimeout(function () {\n-        testRunner.notifyDone();\n-    }, 1000);\n+\n+    document.addEventListener('securitypolicyviolation', function(e) {\n+        console.log('securitypolicyviolation event fired.');\n+        console.log('securitypolicyviolation_event.documentURI=' + e.documentURI);\n+        console.log('securitypolicyviolation_event.blockedURI=' + e.blockedURI);\n+        console.log('securitypolicyviolation_event.violatedDirective=' + e.violatedDirective);\n+        setTimeout(function() {\n+            testRunner.notifyDone();\n+        }, 0);\n+    });\n </script>\n </head>\n <body>""}<_**next**_>{""sha"": ""5f482cf28e871163391b21a85761662b42fb5c6a"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-get-blocked-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-get-blocked-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-get-blocked-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/1.1/form-action-src-get-blocked-expected.txt?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -1,4 +1,4 @@\n-CONSOLE ERROR: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl?fieldname=fieldvalue' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n+CONSOLE ERROR: line 16: Refused to send form data to 'http://127.0.0.1:8000/navigation/resources/form-target.pl' because it violates the following Content Security Policy directive: \""form-action 'none'\"".\n \n   \n Tests that blocking form actions works correctly. If this test passes, you will see a console error, and will not see a page indicating a form was POSTed.""}<_**next**_>{""sha"": ""746f318784c9fbb967c94848593369c6cba6ce64"", ""filename"": ""third_party/WebKit/Source/core/html/HTMLFormElement.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/Source/core/html/HTMLFormElement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0/third_party/WebKit/Source/core/html/HTMLFormElement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/HTMLFormElement.cpp?ref=4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0"", ""patch"": ""@@ -416,10 +416,12 @@ void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {\n     return;\n   }\n \n+  if (!document().contentSecurityPolicy()->allowFormAction(\n+          submission->action())) {\n+    return;\n+  }\n+\n   if (protocolIsJavaScript(submission->action())) {\n-    if (!document().contentSecurityPolicy()->allowFormAction(\n-            submission->action()))\n-      return;\n     document().frame()->script().executeScriptIfJavaScriptURL(\n         submission->action(), this);\n     return;""}","void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
  DCHECK(submission->method() == FormSubmission::PostMethod ||
         submission->method() == FormSubmission::GetMethod);
  DCHECK(submission->data());
  DCHECK(submission->form());
  if (submission->action().isEmpty())
    return;
  if (document().isSandboxed(SandboxForms)) {
    document().addConsoleMessage(ConsoleMessage::create(
        SecurityMessageSource, ErrorMessageLevel,
        ""Blocked form submission to '"" + submission->action().elidedString() +
            ""' because the form's frame is sandboxed and the 'allow-forms' ""
            ""permission is not set.""));
     return;
   }
 
  if (!document().contentSecurityPolicy()->allowFormAction(
          submission->action())) {
    return;
  }

   if (protocolIsJavaScript(submission->action())) {
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;
  }

  Frame* targetFrame = document().frame()->findFrameForNavigation(
      submission->target(), *document().frame());
  if (!targetFrame) {
    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
        !UserGestureIndicator::utilizeUserGesture())
      return;
    targetFrame = document().frame();
  } else {
    submission->clearTarget();
  }
  if (!targetFrame->host())
    return;

  UseCounter::count(document(), UseCounter::FormsSubmitted);
  if (MixedContentChecker::isMixedFormAction(document().frame(),
                                             submission->action()))
    UseCounter::count(document().frame(),
                      UseCounter::MixedContentFormsSubmitted);

  if (targetFrame->isLocalFrame()) {
    toLocalFrame(targetFrame)
        ->navigationScheduler()
        .scheduleFormSubmission(&document(), submission);
  } else {
    FrameLoadRequest frameLoadRequest =
        submission->createFrameLoadRequest(&document());
    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
  }
}
","void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
  DCHECK(submission->method() == FormSubmission::PostMethod ||
         submission->method() == FormSubmission::GetMethod);
  DCHECK(submission->data());
  DCHECK(submission->form());
  if (submission->action().isEmpty())
    return;
  if (document().isSandboxed(SandboxForms)) {
    document().addConsoleMessage(ConsoleMessage::create(
        SecurityMessageSource, ErrorMessageLevel,
        ""Blocked form submission to '"" + submission->action().elidedString() +
            ""' because the form's frame is sandboxed and the 'allow-forms' ""
            ""permission is not set.""));
     return;
   }
 
   if (protocolIsJavaScript(submission->action())) {
    if (!document().contentSecurityPolicy()->allowFormAction(
            submission->action()))
      return;
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;
  }

  Frame* targetFrame = document().frame()->findFrameForNavigation(
      submission->target(), *document().frame());
  if (!targetFrame) {
    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
        !UserGestureIndicator::utilizeUserGesture())
      return;
    targetFrame = document().frame();
  } else {
    submission->clearTarget();
  }
  if (!targetFrame->host())
    return;

  UseCounter::count(document(), UseCounter::FormsSubmitted);
  if (MixedContentChecker::isMixedFormAction(document().frame(),
                                             submission->action()))
    UseCounter::count(document().frame(),
                      UseCounter::MixedContentFormsSubmitted);

  if (targetFrame->isLocalFrame()) {
    toLocalFrame(targetFrame)
        ->navigationScheduler()
        .scheduleFormSubmission(&document(), submission);
  } else {
    FrameLoadRequest frameLoadRequest =
        submission->createFrameLoadRequest(&document());
    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
  }
}
",C,"  if (!document().contentSecurityPolicy()->allowFormAction(
          submission->action())) {
    return;
  }

","    if (!document().contentSecurityPolicy()->allowFormAction(
            submission->action()))
      return;
",,"@@ -416,10 +416,12 @@ void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
     return;
   }
 
+  if (!document().contentSecurityPolicy()->allowFormAction(
+          submission->action())) {
+    return;
+  }
+
   if (protocolIsJavaScript(submission->action())) {
-    if (!document().contentSecurityPolicy()->allowFormAction(
-            submission->action()))
-      return;
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;",Chrome,4ac4aff49c4c539bce6d8a0d8800c01324bb6bc0,2ad79b35d6c1a054c1f38681deff659cd2f3b00d,1,"void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
  DCHECK(submission->method() == FormSubmission::PostMethod ||
         submission->method() == FormSubmission::GetMethod);
  DCHECK(submission->data());
  DCHECK(submission->form());
  if (submission->action().isEmpty())
    return;
  if (document().isSandboxed(SandboxForms)) {
    // FIXME: This message should be moved off the console once a solution to
    // https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
    document().addConsoleMessage(ConsoleMessage::create(
        SecurityMessageSource, ErrorMessageLevel,
        ""Blocked form submission to '"" + submission->action().elidedString() +
            ""' because the form's frame is sandboxed and the 'allow-forms' ""
            ""permission is not set.""));
     return;
   }
 
//fix_flaw_line_below:
//  if (!document().contentSecurityPolicy()->allowFormAction(
//fix_flaw_line_below:
//          submission->action())) {
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   if (protocolIsJavaScript(submission->action())) {
//flaw_line_below:
    if (!document().contentSecurityPolicy()->allowFormAction(
//flaw_line_below:
            submission->action()))
//flaw_line_below:
      return;
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;
  }

  Frame* targetFrame = document().frame()->findFrameForNavigation(
      submission->target(), *document().frame());
  if (!targetFrame) {
    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
        !UserGestureIndicator::utilizeUserGesture())
      return;
    targetFrame = document().frame();
  } else {
    submission->clearTarget();
  }
  if (!targetFrame->host())
    return;

  UseCounter::count(document(), UseCounter::FormsSubmitted);
  if (MixedContentChecker::isMixedFormAction(document().frame(),
                                             submission->action()))
    UseCounter::count(document().frame(),
                      UseCounter::MixedContentFormsSubmitted);

  // TODO(lukasza): Investigate if the code below can uniformly handle remote
  // and local frames (i.e. by calling virtual Frame::navigate from a timer).
  // See also https://goo.gl/95d2KA.
  if (targetFrame->isLocalFrame()) {
    toLocalFrame(targetFrame)
        ->navigationScheduler()
        .scheduleFormSubmission(&document(), submission);
  } else {
    FrameLoadRequest frameLoadRequest =
        submission->createFrameLoadRequest(&document());
    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
  }
}
",186514,"void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
  DCHECK(submission->method() == FormSubmission::PostMethod ||
         submission->method() == FormSubmission::GetMethod);
  DCHECK(submission->data());
  DCHECK(submission->form());
  if (submission->action().isEmpty())
    return;
  if (document().isSandboxed(SandboxForms)) {
    document().addConsoleMessage(ConsoleMessage::create(
        SecurityMessageSource, ErrorMessageLevel,
        ""Blocked form submission to '"" + submission->action().elidedString() +
            ""' because the form's frame is sandboxed and the 'allow-forms' ""
            ""permission is not set.""));
     return;
   }
 
   if (protocolIsJavaScript(submission->action())) {
    if (!document().contentSecurityPolicy()->allowFormAction(
            submission->action()))
      return;
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;
  }

  Frame* targetFrame = document().frame()->findFrameForNavigation(
      submission->target(), *document().frame());
  if (!targetFrame) {
    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
        !UserGestureIndicator::utilizeUserGesture())
      return;
    targetFrame = document().frame();
  } else {
    submission->clearTarget();
  }
  if (!targetFrame->host())
    return;

  UseCounter::count(document(), UseCounter::FormsSubmitted);
  if (MixedContentChecker::isMixedFormAction(document().frame(),
                                             submission->action()))
    UseCounter::count(document().frame(),
                      UseCounter::MixedContentFormsSubmitted);

  if (targetFrame->isLocalFrame()) {
    toLocalFrame(targetFrame)
        ->navigationScheduler()
        .scheduleFormSubmission(&document(), submission);
  } else {
    FrameLoadRequest frameLoadRequest =
        submission->createFrameLoadRequest(&document());
    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
  }
}
","void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
  DCHECK(submission->method() == FormSubmission::PostMethod ||
         submission->method() == FormSubmission::GetMethod);
  DCHECK(submission->data());
  DCHECK(submission->form());
  if (submission->action().isEmpty())
    return;
  if (document().isSandboxed(SandboxForms)) {
    document().addConsoleMessage(ConsoleMessage::create(
        SecurityMessageSource, ErrorMessageLevel,
        ""Blocked form submission to '"" + submission->action().elidedString() +
            ""' because the form's frame is sandboxed and the 'allow-forms' ""
            ""permission is not set.""));
     return;
   }
 
  if (!document().contentSecurityPolicy()->allowFormAction(
          submission->action())) {
    return;
  }

   if (protocolIsJavaScript(submission->action())) {
     document().frame()->script().executeScriptIfJavaScriptURL(
         submission->action(), this);
     return;
  }

  Frame* targetFrame = document().frame()->findFrameForNavigation(
      submission->target(), *document().frame());
  if (!targetFrame) {
    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
        !UserGestureIndicator::utilizeUserGesture())
      return;
    targetFrame = document().frame();
  } else {
    submission->clearTarget();
  }
  if (!targetFrame->host())
    return;

  UseCounter::count(document(), UseCounter::FormsSubmitted);
  if (MixedContentChecker::isMixedFormAction(document().frame(),
                                             submission->action()))
    UseCounter::count(document().frame(),
                      UseCounter::MixedContentFormsSubmitted);

  if (targetFrame->isLocalFrame()) {
    toLocalFrame(targetFrame)
        ->navigationScheduler()
        .scheduleFormSubmission(&document(), submission);
  } else {
    FrameLoadRequest frameLoadRequest =
        submission->createFrameLoadRequest(&document());
    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
  }
}
","The `scheduleFormSubmission` function in the `HTMLFormElement` class manages the submission of a form, ensuring it adheres to security and navigation constraints. It first verifies that the submission method is either POST or GET and that the submission contains valid data and a form. If the form's action is empty or if the document is sandboxed without the 'allow-forms' permission, it blocks the submission. The function also checks for JavaScript protocol actions and enforces content security policies. Finally, it determines the appropriate target frame for navigation, counting form submissions and handling mixed content scenarios before scheduling the submission accordingly.","The provided code manages the submission of a web form while enforcing security and navigation rules. It checks that the submission method is valid and that the necessary data is present. If the submission action is empty or if the document is restricted by security settings, it prevents the submission. The code also verifies if the action adheres to content security policies and handles JavaScript-based submissions appropriately. It identifies the target frame for navigation, counts the submission for analytics, and ensures that mixed content issues are addressed before scheduling the form submission to the correct destination.","The vulnerability in the original code stemmed from inadequate checks on the form submission action, allowing attackers to exploit the system by bypassing the Content Security Policy, potentially leading to unauthorized actions. Specifically, the lack of a check for the action's compliance with the content security policy left the system open to manipulation. The fixed code addresses this by adding a verification step that explicitly checks if the action is allowed by the content security policy using `document().contentSecurityPolicy()->allowFormAction(submission->action())`. This ensures that only compliant actions are processed, thereby mitigating the risk of exploitation.","The vulnerability in the original code allowed attackers to exploit form submissions by bypassing the Content Security Policy, which could lead to unauthorized actions being executed through crafted HTML pages. This occurred due to insufficient validation of the form submission action, enabling malicious inputs to be processed without proper checks. The fixed code addresses this issue by implementing a verification step that ensures the action adheres to the established content security policy before proceeding with the submission. This additional validation effectively mitigates the risk of exploitation by ensuring only compliant actions are executed.","The vulnerability was fixed by adding a crucial validation step that checks whether the form submission action is permitted by the content security policy. In the updated code, the line `if (!document().contentSecurityPolicy()->allowFormAction(submission->action()))` ensures that any action being submitted is explicitly allowed by the policy. This check prevents unauthorized actions from being processed, effectively blocking potential exploitation through crafted HTML pages. By enforcing this validation before any further processing of the submission, the code enhances security and mitigates the risk of bypassing the content security policy.","The vulnerability was fixed by introducing a validation step that checks whether the form submission action complies with the established content security policy. This additional check ensures that any action intended for submission is explicitly permitted, thereby preventing unauthorized or malicious actions from being executed. By enforcing this validation before processing the submission, the code effectively blocks potential exploitation through crafted inputs, enhancing the overall security of the form handling mechanism. This change significantly reduces the risk of bypassing security measures and ensures that only compliant actions are allowed to proceed.","4,4","5,5","4,4","4,5"
6,6,187987,187987,,Local,Not required,Complete,CVE-2016-0808,https://www.cvedetails.com/cve/CVE-2016-0808/,CWE-19,Low,,,,2016-02-06,4.9,"Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.",2016-03-14,DoS Overflow ,3,https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b,ed4c8d79153baab7f26562afb8930652dfbf853b,"Avoid integer overflows in parsing fonts

A malformed TTF can cause size calculations to overflow. This patch
checks the maximum reasonable value so that the total size fits in 32
bits. It also adds some explicit casting to avoid possible technical
undefined behavior when parsing sized unsigned values.

Bug: 25645298
Change-Id: Id4716132041a6f4f1fbb73ec4e445391cf7d9616
(cherry picked from commit 183c9ec2800baa2ce099ee260c6cbc6121cf1274)
",1,libs/minikin/CmapCoverage.cpp,"{""filename"": ""libs/minikin/CmapCoverage.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b/libs/minikin/CmapCoverage.cpp"", ""patch"": ""@@ -29,11 +29,12 @@\n\n \n // These could perhaps be optimized to use __builtin_bswap16 and friends.\n static uint32_t readU16(const uint8_t* data, size_t offset) {\n-    return data[offset] << 8 | data[offset + 1];\n+    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);\n }\n \n static uint32_t readU32(const uint8_t* data, size_t offset) {\n-    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n+    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |\n+        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);\n }\n \n static void addRange(vector<uint32_t> &coverage, uint32_t start, uint32_t end) {\n@@ -101,11 +102,13 @@\n\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n+    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow\n+    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n-    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n+    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n""}","static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow
    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
","static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
",C,"    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow
    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.
    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
","    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
",,"@@ -29,11 +29,12 @@

 
 // These could perhaps be optimized to use __builtin_bswap16 and friends.
 static uint32_t readU16(const uint8_t* data, size_t offset) {
-    return data[offset] << 8 | data[offset + 1];
+    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);
 }
 
 static uint32_t readU32(const uint8_t* data, size_t offset) {
-    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
+    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |
+        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);
 }
 
 static void addRange(vector<uint32_t> &coverage, uint32_t start, uint32_t end) {
@@ -101,11 +102,13 @@

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
+    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow
+    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
-    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
+    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
",Android,https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b/,https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b%5E/,1,"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
//fix_flaw_line_below:
//    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow
//fix_flaw_line_below:
//    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
//flaw_line_below:
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
//fix_flaw_line_below:
//    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
",187987,"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
","static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow
    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
","The function `getCoverageFormat12` processes a binary data array to extract character coverage information, specifically for a format that includes groups of character ranges. It first checks if the data size is sufficient to read the number of groups and their corresponding offsets. If valid, it reads the number of groups and iterates through each group to retrieve the start and end character codes. These codes are then used to populate a vector with ranges, ensuring that the end character is inclusive in the input but exclusive in the output. The function returns a boolean indicating success or failure.","The code defines a function that extracts character coverage information from a binary data array formatted in a specific way. It begins by verifying that the data size is adequate to read the necessary group information. If the data is valid, it retrieves the number of groups and iterates through each one to obtain the start and end character codes. These codes are then used to populate a collection with character ranges, ensuring that the end character is included in the input but excluded in the output. The function ultimately returns a status indicating whether the operation was successful.","The vulnerability in the original code stemmed from a potential integer overflow when calculating the total size of groups based on the number of groups read from the data. Specifically, if the number of groups exceeded a certain threshold, the calculation of `kFirstGroupOffset + nGroups * kGroupSize` could overflow, leading to memory access violations and potential denial of service. The fixed code addresses this by introducing a maximum limit for the number of groups, `kMaxNGroups`, which ensures that the number of groups is checked against this limit before performing the size calculation, thus preventing the overflow and enhancing overall stability.","The vulnerability in the original code was due to an integer overflow that could occur when calculating the total size of character groups based on user-provided data. This overflow could lead to incorrect memory access, potentially allowing attackers to exploit the situation and cause a denial of service, such as continuous system reboots, by loading specially crafted font files. The fixed code mitigates this risk by introducing a maximum limit for the number of groups, ensuring that any calculations involving the number of groups are safely bounded, thus preventing overflow and enhancing the stability and security of the function.","The vulnerability was fixed by introducing a maximum limit for the number of groups, defined as `kMaxNGroups`, which is calculated to prevent overflow during size calculations. In the updated code, a check is added to ensure that the number of groups, `nGroups`, does not exceed this maximum limit before performing the calculation of `kFirstGroupOffset + nGroups * kGroupSize`. This additional validation ensures that the size calculation remains within safe bounds, effectively preventing the integer overflow that could lead to memory access violations and potential denial of service, thereby enhancing the overall security of the function.","The vulnerability was addressed by implementing a safeguard that limits the maximum number of groups that can be processed, thereby preventing potential integer overflow during calculations. The updated code includes a check to ensure that the number of groups does not exceed this predefined limit before performing any size-related calculations. This additional validation step ensures that all arithmetic operations remain within safe bounds, effectively mitigating the risk of memory access violations. As a result, the fix enhances the stability and security of the function, preventing exploitation that could lead to denial of service.","5,5","5,5","4,4","3, 2"
