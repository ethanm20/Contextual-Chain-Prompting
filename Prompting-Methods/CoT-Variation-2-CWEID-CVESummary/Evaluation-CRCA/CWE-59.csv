,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,177857,177857,,Remote,Not required,Partial,CVE-2019-13636,https://www.cvedetails.com/cve/CVE-2019-13636/,CWE-59,Medium,,Partial,,2019-07-17,5.8,"In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c.",2019-07-24,,6,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,dce4683cbbe107a95f1f0d45fabc304acfb5d71a,,1,,,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  size_t buffered = 0, n;
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
",C,"	  int flags = O_RDONLY | binary_transput;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
","	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
",61d7788b83b302207a67b82786f4fd79e3538f30,"@@ -238,8 +238,13 @@ plan_a (char const *filename)
     {
       if (S_ISREG (instat.st_mode))
         {
-	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
+	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
+	  int ifd;
+
+	  if (! follow_symlinks)
+	    flags |= O_NOFOLLOW;
+	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
@@ -340,6 +345,7 @@ plan_a (char const *filename)
 static void
 plan_b (char const *filename)
 {
+  int flags = O_RDONLY | binary_transput;
   int ifd;
   FILE *ifp;
   int c;
@@ -353,7 +359,9 @@ plan_b (char const *filename)
 
   if (instat.st_size == 0)
     filename = NULL_DEVICE;
-  if ((ifd = safe_open (filename, O_RDONLY | binary_transput, 0)) < 0
+  if (! follow_symlinks)
+    flags |= O_NOFOLLOW;
+  if ((ifd = safe_open (filename, flags, 0)) < 0
       || ! (ifp = fdopen (ifd, binary_transput ? ""rb"" : ""r"")))
     pfatal (""Can't open file %s"", quotearg (filename));
   if (TMPINNAME_needs_removal)",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=dce4683cbbe107a95f1f0d45fabc304acfb5d71a,https://git.savannah.gnu.org/cgit/patch.git/tree/src/inp.c?id=61d7788b83b302207a67b82786f4fd79e3538f30,1,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
//flaw_line_below:
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
//fix_flaw_line_below:
//	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
//fix_flaw_line_below:
//	  int ifd;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	  if (! follow_symlinks)
//fix_flaw_line_below:
//	    flags |= O_NOFOLLOW;
//fix_flaw_line_below:
//	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
",177857,"plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  size_t buffered = 0, n;
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","plan_a (char const *filename)
{
  char const *s;
  char const *lim;
  char const **ptr;
  char *buffer;
  lin iline;
  size_t size = instat.st_size;

  /* Fail if the file size doesn't fit in a size_t,
     or if storage isn't available.  */
  if (! (size == instat.st_size
	 && (buffer = malloc (size ? size : (size_t) 1))))
    return false;

  /* Read the input file, but don't bother reading it if it's empty.
     When creating files, the files do not actually exist.  */
  if (size)
     {
       if (S_ISREG (instat.st_mode))
         {
	  int flags = O_RDONLY | binary_transput;
 	  size_t buffered = 0, n;
	  int ifd;

	  if (! follow_symlinks)
	    flags |= O_NOFOLLOW;
	  ifd = safe_open (filename, flags, 0);
 	  if (ifd < 0)
 	    pfatal (""can't open file %s"", quotearg (filename));
 
		  /* Some non-POSIX hosts exaggerate st_size in text mode;
		     or the file may have shrunk!  */
		  size = buffered;
		  break;
		}
	      if (n == (size_t) -1)
		{
		  /* Perhaps size is too large for this host.  */
		  close (ifd);
		  free (buffer);
		  return false;
		}
	      buffered += n;
	    }

	  if (close (ifd) != 0)
	    read_fatal ();
	}
","The provided code defines a function `plan_a` that attempts to read a file specified by `filename`. It first checks if the file size can fit in a `size_t` and allocates a buffer accordingly. If the file is not empty and is a regular file, it opens the file in read-only mode. The function reads the file's contents into the buffer while handling potential errors, such as file opening failures or size discrepancies. If any issues arise during these operations, it cleans up by freeing allocated memory and returning false, indicating failure.","The code defines a function that attempts to read a specified file by first checking if its size can be accommodated in memory and allocating a buffer for it. If the file is not empty and is a regular file, the function opens it in read-only mode. It then reads the file's contents into the allocated buffer while monitoring for errors, such as issues with opening the file or discrepancies in size. In case of any failures during these operations, the function ensures proper cleanup by freeing allocated memory and indicates failure through a return value.","The vulnerability in the original code arises from the lack of proper handling of symbolic links when opening files, which can lead to unintended file access or manipulation. Specifically, the absence of a flag to prevent following symbolic links allows the program to potentially open a target file that the user did not intend, exposing it to security risks. In the fixed code, the introduction of a conditional check for the `follow_symlinks` variable allows the program to set the `O_NOFOLLOW` flag when opening the file. This change ensures that symbolic links are not followed, thereby mitigating the risk of unintended file access.","The vulnerability in the original code stems from improper handling of symbolic links, which can lead to unintended file access or manipulation. Specifically, the code allowed the program to follow symbolic links when opening files, potentially exposing sensitive files or directories to unauthorized access. The fixed code addresses this issue by introducing a mechanism to prevent following symbolic links when opening files, ensuring that only the intended target files are accessed. This enhancement significantly reduces the risk of security breaches by ensuring that symbolic links do not redirect the program to unintended locations.","The vulnerability was fixed by introducing a conditional check for the `follow_symlinks` variable, which determines whether to follow symbolic links when opening files. In the modified code, if `follow_symlinks` is false, the `O_NOFOLLOW` flag is added to the file opening flags. This change ensures that when the `safe_open` function is called with the specified flags, it will not follow symbolic links, thereby preventing unintended access to files that could lead to security risks. This enhancement effectively mitigates the vulnerability by ensuring that only the intended files are opened.","The vulnerability was fixed by implementing a mechanism to control the handling of symbolic links when opening files. A conditional check was introduced to determine whether symbolic links should be followed. If the condition is set to prevent following links, an additional flag is applied during the file opening process. This adjustment ensures that the program does not inadvertently access files through symbolic links, thereby protecting against unauthorized file access and potential security breaches. The fix effectively restricts file operations to the intended targets, enhancing the overall security of the code.","5,5","5,5","4,4","5,4"
1,1,179457,179457,,Local,Not required,Complete,CVE-2014-5045,https://www.cvedetails.com/cve/CVE-2014-5045/,CWE-59,High,Complete,Complete,,2014-08-01,6.2,"The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program.",2017-01-06,DoS ,2,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,295dc39d941dc2ae53d5c170365af4c9d5c16212,"fs: umount on symlink leaks mnt count

Currently umount on symlink blocks following umount:

/vz is separate mount

# ls /vz/ -al | grep test
drwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir
lrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir
# umount -l /vz/testlink
umount: /vz/testlink: not mounted (expected)

# lsof /vz
# umount /vz
umount: /vz: device is busy. (unexpected)

In this case mountpoint_last() gets an extra refcount on path->mnt

Signed-off-by: Vasily Averin <vvs@openvz.org>
Acked-by: Ian Kent <raven@themaw.net>
Acked-by: Jeff Layton <jlayton@primarydata.com>
Cc: stable@vger.kernel.org
Signed-off-by: Christoph Hellwig <hch@lst.de>",1,fs/namei.c,"{""sha"": ""9eb787e5c167fb601845590f0181d249bf515fb0"", ""filename"": ""fs/namei.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/295dc39d941dc2ae53d5c170365af4c9d5c16212/fs/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namei.c?ref=295dc39d941dc2ae53d5c170365af4c9d5c16212"", ""patch"": ""@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n-\tpath->mnt = mntget(nd->path.mnt);\n+\tpath->mnt = nd->path.mnt;\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n+\tmntget(path->mnt);\n \tfollow_mount(path);\n \terror = 0;\n out:""}","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
",C,"	path->mnt = nd->path.mnt;
	mntget(path->mnt);
","	path->mnt = mntget(nd->path.mnt);
",,"@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)
 		goto out;
 	}
 	path->dentry = dentry;
-	path->mnt = mntget(nd->path.mnt);
+	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
+	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:",linux,295dc39d941dc2ae53d5c170365af4c9d5c16212,6fcc5420bfb91049a318bb4d88fe471248b5b391,1,"mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
//flaw_line_below:
	path->mnt = mntget(nd->path.mnt);
//fix_flaw_line_below:
//	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
//fix_flaw_line_below:
//	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
",179457,"mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","mountpoint_last(struct nameidata *nd, struct path *path)
{
	int error = 0;
	struct dentry *dentry;
	struct dentry *dir = nd->path.dentry;

	/* If we're in rcuwalk, drop out of it to handle last component */
	if (nd->flags & LOOKUP_RCU) {
		if (unlazy_walk(nd, NULL)) {
			error = -ECHILD;
			goto out;
		}
	}

	nd->flags &= ~LOOKUP_PARENT;

	if (unlikely(nd->last_type != LAST_NORM)) {
		error = handle_dots(nd, nd->last_type);
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
		if (IS_ERR(dentry)) {
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
	if (!dentry->d_inode || d_is_negative(dentry)) {
		error = -ENOENT;
		dput(dentry);
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:
	terminate_walk(nd);
	return error;
}
","The `mountpoint_last` function is designed to resolve the last component of a file path in a Linux filesystem context, handling various scenarios such as symbolic links and mounted directories. It first checks if the current operation is in a read-copy-update (RCU) walk and, if so, attempts to transition out of it. The function then manages directory entry (dentry) lookups, including handling special cases for dot entries and ensuring proper locking mechanisms are in place. If the dentry is found to be valid, it updates the provided path structure and determines whether to follow a symbolic link or mount point, ultimately returning an error code or success indicator.","The provided code is responsible for resolving the last component of a file path within a filesystem, ensuring proper handling of various scenarios such as symbolic links and mounted directories. It begins by checking if the operation is in a specific state and attempts to transition out if necessary. The code manages directory entry lookups while implementing locking mechanisms to prevent race conditions. If a valid entry is found, it updates the path structure accordingly and decides whether to follow a symbolic link or mount point, ultimately returning an appropriate error code or success status based on the outcome of these operations.","The vulnerability in the original code arises from improper management of reference counts when handling directory entries, particularly during operations involving symbolic links and the umount system call. This oversight can lead to memory consumption issues or use-after-free vulnerabilities, allowing local users to exploit the system. In the fixed code, the reference count is correctly maintained by ensuring that the dentry is properly allocated and checked before being used. Additionally, the code now includes appropriate locking mechanisms and error handling, which help prevent the misuse of freed memory and ensure that the system remains stable during these operations.","The vulnerability in the original code stems from inadequate management of reference counts when handling directory entries, particularly in scenarios involving symbolic links and the umount system call. This mismanagement can lead to memory consumption issues or use-after-free vulnerabilities, potentially allowing local users to disrupt system stability. The fixed code addresses this vulnerability by ensuring that reference counts are correctly maintained throughout the process, implementing proper error handling, and utilizing locking mechanisms to prevent access to freed memory. These changes enhance the robustness of the code, mitigating the risk of denial of service and other unintended consequences.","The vulnerability was fixed by ensuring proper management of reference counts and enhancing error handling in the code. Specifically, the allocation of the directory entry is now followed by checks to confirm its validity, using functions like `dget` and `dput` to manage the reference count correctly. The code also includes a mutex lock around critical sections to prevent race conditions, ensuring that the reference count remains accurate during operations. Additionally, the use of `mntget` ensures that the mount reference is correctly incremented, thereby preventing memory consumption issues and use-after-free vulnerabilities associated with symbolic links and the umount system call.","The vulnerability was addressed by implementing stricter management of reference counts and enhancing error handling throughout the code. The revised implementation ensures that directory entries are properly allocated and validated before use, preventing issues related to memory consumption and use-after-free scenarios. Additionally, critical sections of the code are now protected by locking mechanisms to avoid race conditions, which helps maintain the integrity of reference counts during operations. Overall, these changes improve the robustness of the code, ensuring that the system remains stable and secure when handling symbolic links and unmounting operations.","4,4","5,5","4,4","4,5"
2,2,179776,179776,,Local,Not required,Complete,CVE-2015-5287,https://www.cvedetails.com/cve/CVE-2015-5287/,CWE-59,Medium,Complete,Complete,,2015-12-07,6.9,"The abrt-hook-ccpp help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users with certain permissions to gain privileges via a symlink attack on a file with a predictable name, as demonstrated by /var/tmp/abrt/abrt-hax-coredump or /var/spool/abrt/abrt-hax-coredump.",2016-12-07,+Priv ,2,https://github.com/abrt/abrt/commit/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,"ccpp: save abrt core files only to new files

Prior this commit abrt-hook-ccpp saved a core file generated by a
process running a program whose name starts with ""abrt"" in
DUMP_LOCATION/$(basename program)-coredump. If the file was a symlink,
the hook followed and wrote core file to the symlink's target.

Addresses CVE-2015-5287

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""58d9c28d20a2534cb92eea1dbb19069064393751"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/abrt/abrt/blob/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=3c1b60cfa62d39e5fff5a53a5bc53dae189e740e"", ""patch"": ""@@ -718,7 +718,8 @@ int main(int argc, char** argv)\n         if (snprintf(path, sizeof(path), \""%s/%s-coredump\"", g_settings_dump_location, last_slash) >= sizeof(path))\n             error_msg_and_die(\""Error saving '%s': truncated long file path\"", path);\n \n-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n+        unlink(path);\n+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n         if (core_size < 0 || fsync(abrt_core_fd) != 0)\n         {""}","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
",C,"        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
","        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
",,"@@ -718,7 +718,8 @@ int main(int argc, char** argv)
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
+        unlink(path);
+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {",abrt,3c1b60cfa62d39e5fff5a53a5bc53dae189e740e,dec3089ff88fe7ada77058dca6ed3ad88c18ee16,1,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
//flaw_line_below:
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
//fix_flaw_line_below:
//        unlink(path);
//fix_flaw_line_below:
//        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;

        // Disabled for now: /proc/PID/smaps tends to be BIG,
        // and not much more informative than /proc/PID/maps:
        // dd_copy_file(dd, FILENAME_SMAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
",179776,"int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","int main(int argc, char** argv)
{
    /* Kernel starts us with all fd's closed.
     * But it's dangerous:
     * fprintf(stderr) can dump messages into random fds, etc.
     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.
     */
    int fd = xopen(""/dev/null"", O_RDWR);
    while (fd < 2)
        fd = xdup(fd);
    if (fd > 2)
        close(fd);

    int err = 1;
    logmode = LOGMODE_JOURNAL;

    /* Parse abrt.conf */
    load_abrt_conf();
    /* ... and plugins/CCpp.conf */
    bool setting_MakeCompatCore;
    bool setting_SaveBinaryImage;
    bool setting_SaveFullCore;
    bool setting_CreateCoreBacktrace;
    bool setting_SaveContainerizedPackageData;
    bool setting_StandaloneHook;
    {
        map_string_t *settings = new_map_string();
        load_abrt_plugin_conf_file(""CCpp.conf"", settings);
        const char *value;
        value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
        setting_MakeCompatCore = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
        setting_SaveBinaryImage = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""SaveFullCore"");
        setting_SaveFullCore = value ? string_to_bool(value) : true;
        value = get_map_string_item_or_NULL(settings, ""CreateCoreBacktrace"");
        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;

        value = get_map_string_item_or_NULL(settings, ""SaveContainerizedPackageData"");
        setting_SaveContainerizedPackageData = value && string_to_bool(value);

        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */
        if (!g_settings_explorechroots)
        {
            if (setting_SaveContainerizedPackageData)
                log_warning(""Ignoring SaveContainerizedPackageData because ExploreChroots is disabled"");
            setting_SaveContainerizedPackageData = false;
        }

        value = get_map_string_item_or_NULL(settings, ""StandaloneHook"");
        setting_StandaloneHook = value && string_to_bool(value);
        value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
        if (value)
            g_verbose = xatoi_positive(value);
        free_map_string(settings);
    }

    if (argc == 2 && strcmp(argv[1], ""--config-test""))
        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);

    if (argc < 8)
    {
        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/
        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/
        error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]"", argv[0]);
    }

    /* Not needed on 2.6.30.
     * At least 2.6.18 has a bug where
     * argv[1] = ""SIGNO CORE_SIZE_LIMIT PID ...""
     * argv[2] = ""CORE_SIZE_LIMIT PID ...""
     * and so on. Fixing it:
     */
    if (strchr(argv[1], ' '))
    {
        int i;
        for (i = 1; argv[i]; i++)
        {
            strchrnul(argv[i], ' ')[0] = '\0';
        }
    }

    errno = 0;
    const char* signal_str = argv[1];
    int signal_no = xatoi_positive(signal_str);
    off_t ulimit_c = strtoull(argv[2], NULL, 10);
    if (ulimit_c < 0) /* unlimited? */
    {
        /* set to max possible >0 value */
        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
    }
    const char *pid_str = argv[3];
    pid_t local_pid = xatoi_positive(argv[3]);
    uid_t uid = xatoi_positive(argv[4]);
    if (errno || local_pid <= 0)
    {
        perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
    }

    {
        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
        /* If we have a saved pattern and it's not a ""|PROG ARGS"" thing... */
        if (s && s[0] != '|')
            core_basename = s;
        else
            free(s);
    }
    const char *global_pid_str = argv[8];
    pid_t pid = xatoi_positive(argv[8]);

    pid_t tid = -1;
    const char *tid_str = argv[9];
    if (tid_str)
    {
        tid = xatoi_positive(tid_str);
    }

    char path[PATH_MAX];

    char *executable = get_executable(pid);
    if (executable && strstr(executable, ""/abrt-hook-ccpp""))
    {
        error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                        (long)pid, executable);
    }

    user_pwd = get_cwd(pid); /* may be NULL on error */
    log_notice(""user_pwd:'%s'"", user_pwd);

    sprintf(path, ""/proc/%lu/status"", (long)pid);
    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);

    uid_t fsuid = uid;
    uid_t tmp_fsuid = get_fsuid(proc_pid_status);
    if (tmp_fsuid < 0)
        perror_msg_and_die(""Can't parse 'Uid: line' in /proc/%lu/status"", (long)pid);

    const int fsgid = get_fsgid(proc_pid_status);
    if (fsgid < 0)
        error_msg_and_die(""Can't parse 'Gid: line' in /proc/%lu/status"", (long)pid);

    int suid_policy = dump_suid_policy();
    if (tmp_fsuid != uid)
    {
        /* use root for suided apps unless it's explicitly set to UNSAFE */
        fsuid = 0;
        if (suid_policy == DUMP_SUID_UNSAFE)
            fsuid = tmp_fsuid;
        else
        {
            g_user_core_flags = O_EXCL;
            g_need_nonrelative = 1;
        }
    }

    /* Open a fd to compat coredump, if requested and is possible */
    int user_core_fd = -1;
    if (setting_MakeCompatCore && ulimit_c != 0)
        /* note: checks ""user_pwd == NULL"" inside; updates core_basename */
        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);

    if (executable == NULL)
    {
        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */
        error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *signame = NULL;
    if (!signal_is_fatal(signal_no, &signame))
        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about

    const int abrtd_running = daemon_is_ok();
    if (!setting_StandaloneHook && !abrtd_running)
    {
        /* not an error, exit with exit code 0 */
        log(""abrtd is not running. If it crashed, ""
            ""/proc/sys/kernel/core_pattern contains a stale value, ""
            ""consider resetting it to 'core'""
        );
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    if (setting_StandaloneHook)
        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, ""abrt"");

    if (g_settings_nMaxCrashReportsSize > 0)
    {
        /* If free space is less than 1/4 of MaxCrashReportsSize... */
        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
            return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes
     * if they happen too often. Else, write new marker value.
     */
    snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
    if (check_recent_crash_file(path, executable))
    {
        /* It is a repeating crash */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    const char *last_slash = strrchr(executable, '/');
    if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
    {
        if (g_settings_debug_level == 0)
        {
            log_warning(""Ignoring crash of %s (SIG%s)."",
                        executable, signame ? signame : signal_str);
            goto cleanup_and_exit;
        }

        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,
         * since that can make new copy of abrtd to process it,
         * and maybe crash again...
         * Unlike dirs, mere files are ignored by abrtd.
         */
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
            unlink(path);
            /* copyfd_eof logs the error including errno string,
             * but it does not log file name */
            error_msg_and_die(""Error saving '%s'"", path);
        }
        log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
        err = 0;
        goto cleanup_and_exit;
    }

    unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
            g_settings_dump_location, iso_date_string(NULL), (long)pid);
    if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
    {
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

    /* If you don't want to have fs owner as root then:
     *
     * - use fsuid instead of uid for fs owner, so we don't expose any
     *   sensitive information of suided app in /var/(tmp|spool)/abrt
     *
     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish
     *   creating the new dump directory, to prevent the real owner to write to
     *   the directory until the hook is done (avoid race conditions and defend
     *   hard and symbolic link attacs)
     */
    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);
    if (dd)
    {
        char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
        int source_base_ofs = sprintf(source_filename, ""/proc/%lu/root"", (long)pid);
        source_base_ofs -= strlen(""root"");

        /* What's wrong on using /proc/[pid]/root every time ?*/
        /* It creates os_info_in_root_dir for all crashes. */
        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;

        /* Reading data from an arbitrary root directory is not secure. */
        if (g_settings_explorechroots)
        {
            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can
             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */
            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);
        }
        else
        {
            dd_create_basic_files(dd, fsuid, NULL);
        }

        char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
        char *dest_base = strrchr(dest_filename, '/') + 1;


        strcpy(source_filename + source_base_ofs, ""maps"");
        dd_copy_file(dd, FILENAME_MAPS, source_filename);

        strcpy(source_filename + source_base_ofs, ""limits"");
        dd_copy_file(dd, FILENAME_LIMITS, source_filename);

        strcpy(source_filename + source_base_ofs, ""cgroup"");
        dd_copy_file(dd, FILENAME_CGROUP, source_filename);

        strcpy(source_filename + source_base_ofs, ""mountinfo"");
        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);

        strcpy(dest_base, FILENAME_OPEN_FDS);
        strcpy(source_filename + source_base_ofs, ""fd"");
        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);

        strcpy(dest_base, FILENAME_NAMESPACES);
        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);

        free(dest_filename);

        char *tmp = NULL;
        get_env_variable(pid, ""container"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER, tmp);
            free(tmp);
            tmp = NULL;
        }

        get_env_variable(pid, ""container_uuid"", &tmp);
        if (tmp != NULL)
        {
            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);
            free(tmp);
        }

        /* There's no need to compare mount namespaces and search for '/' in
         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works
         * fine. If those inodes do not equal each other, we have to verify
         * that '/proc/[pid]/root' is not a symlink to a chroot.
         */
        const int containerized = (rootdir != NULL && strcmp(rootdir, ""/"") == 0);
        if (containerized)
        {
            log_debug(""Process %d is considered to be containerized"", pid);
            pid_t container_pid;
            if (get_pid_of_container(pid, &container_pid) == 0)
            {
                char *container_cmdline = get_cmdline(container_pid);
                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);
                free(container_cmdline);
            }
        }

        dd_save_text(dd, FILENAME_ANALYZER, ""abrt-ccpp"");
        dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
        dd_save_text(dd, FILENAME_EXECUTABLE, executable);
        dd_save_text(dd, FILENAME_PID, pid_str);
        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);
        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
        if (user_pwd)
            dd_save_text(dd, FILENAME_PWD, user_pwd);
        if (tid_str)
            dd_save_text(dd, FILENAME_TID, tid_str);

        if (rootdir)
        {
            if (strcmp(rootdir, ""/"") != 0)
                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
        }
        free(rootdir);

        char *reason = xasprintf(""%s killed by SIG%s"",
                                 last_slash, signame ? signame : signal_str);
        dd_save_text(dd, FILENAME_REASON, reason);
        free(reason);

        char *cmdline = get_cmdline(pid);
        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
        free(cmdline);

        char *environ = get_environ(pid);
        dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
        free(environ);

        char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
        if (fips_enabled)
        {
            if (strcmp(fips_enabled, ""0"") != 0)
                dd_save_text(dd, ""fips_enabled"", fips_enabled);
            free(fips_enabled);
        }

        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);

        /* In case of errors, treat the process as if it has locked memory */
        long unsigned lck_bytes = ULONG_MAX;
        const char *vmlck = strstr(proc_pid_status, ""VmLck:"");
        if (vmlck == NULL)
            error_msg(""/proc/%s/status does not contain 'VmLck:' line"", pid_str);
        else if (1 != sscanf(vmlck + 6, ""%lu kB\n"", &lck_bytes))
            error_msg(""Failed to parse 'VmLck:' line in /proc/%s/status"", pid_str);

        if (lck_bytes)
        {
            log_notice(""Process %s of user %lu has locked memory"",
                        pid_str, (long unsigned)uid);

            dd_mark_as_notreportable(dd, ""The process had locked memory ""
                    ""which usually indicates efforts to protect sensitive ""
                    ""data (passwords) from being written to disk.\n""
                    ""In order to avoid sensitive information leakages, ""
                    ""ABRT will not allow you to report this problem to ""
                    ""bug tracking tools"");
        }

        if (setting_SaveBinaryImage)
        {
            if (save_crashing_binary(pid, dd))
            {
                error_msg(""Error saving '%s'"", path);

                goto cleanup_and_exit;
            }
        }

        off_t core_size = 0;
        if (setting_SaveFullCore)
        {
            strcpy(path + path_len, ""/""FILENAME_COREDUMP);
            int abrt_core_fd = create_or_die(path, user_core_fd);

            /* We write both coredumps at once.
             * We can't write user coredump first, since it might be truncated
             * and thus can't be copied and used as abrt coredump;
             * and if we write abrt coredump first and then copy it as user one,
             * then we have a race when process exits but coredump does not exist yet:
             * $ echo -e '#include<signal.h>\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -
             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*
             * 21631 Segmentation fault (core dumped) ./test
             * ls: cannot access core*: No such file or directory <=== BAD
             */
            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
            close_user_core(user_core_fd, core_size);
            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
            {
                unlink(path);

                /* copyfd_sparse logs the error including errno string,
                 * but it does not log file name */
                error_msg(""Error writing '%s'"", path);

                goto cleanup_and_exit;
            }
        }
        else
        {
            /* User core is created even if WriteFullCore is off. */
            create_user_core(user_core_fd, pid, ulimit_c);
        }

        /* User core is either written or closed */
        user_core_fd = -1;

        /*
         * ! No other errors should cause removal of the user core !
         */

/* Because of #1211835 and #1126850 */
#if 0
        /* Save JVM crash log if it exists. (JVM's coredump per se
         * is nearly useless for JVM developers)
         */
        {
            char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
            int src_fd = open(java_log, O_RDONLY);
            free(java_log);

            /* If we couldn't open the error log in /tmp directory we can try to
             * read the log from the current directory. It may produce AVC, it
             * may produce some error log but all these are expected.
             */
            if (src_fd < 0)
            {
                java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                src_fd = open(java_log, O_RDONLY);
                free(java_log);
            }

            if (src_fd >= 0)
            {
                strcpy(path + path_len, ""/hs_err.log"");
                int dst_fd = create_or_die(path, user_core_fd);
                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                if (close(dst_fd) != 0 || sz < 0)
                {
                    error_msg(""Error saving '%s'"", path);

                    goto cleanup_and_exit;
                }
                close(src_fd);
            }
        }
#endif

        /* Perform crash-time unwind of the guilty thread. */
        if (tid > 0 && setting_CreateCoreBacktrace)
            create_core_backtrace(tid, executable, signal_no, dd);

        /* We close dumpdir before we start catering for crash storm case.
         * Otherwise, delete_dump_dir's from other concurrent
         * CCpp's won't be able to delete our dump (their delete_dump_dir
         * will wait for us), and we won't be able to delete their dumps.
         * Classic deadlock.
         */
        dd_close(dd);
        dd = NULL;

        path[path_len] = '\0'; /* path now contains only directory name */

        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)
        {   /* Do we really need to run rpm from core_pattern hook? */
            sprintf(source_filename, ""/proc/%lu/root"", (long)pid);

            const char *cmd_args[6];
            cmd_args[0] = BIN_DIR""/abrt-action-save-package-data"";
            cmd_args[1] = ""-d"";
            cmd_args[2] = path;
            cmd_args[3] = ""-r"";
            cmd_args[4] = source_filename;
            cmd_args[5] = NULL;

            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);
            int stat;
            safe_waitpid(pid, &stat, 0);
        }

        char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
        if (rename(path, newpath) == 0)
            strcpy(path, newpath);
        free(newpath);

        if (core_size > 0)
            log_notice(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"",
                       (long)pid, executable, path, (long long)core_size);

        if (abrtd_running)
            notify_new_path(path);

        /* rhbz#539551: ""abrt going crazy when crashing process is respawned"" */
        if (g_settings_nMaxCrashReportsSize > 0)
        {
            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming
             * kicks in first, and we don't ""fight"" with it:
             */
            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
            maxsize |= 63;
            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
        }

        err = 0;
    }
    else
    {
        /* We didn't create abrt dump, but may need to create compat coredump */
        return create_user_core(user_core_fd, pid, ulimit_c);
    }

cleanup_and_exit:
    if (dd)
        dd_delete(dd);

    if (user_core_fd >= 0)
        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);

    if (proc_cwd != NULL)
        closedir(proc_cwd);

    return err;
}
","The provided code is a C program that serves as a core dump handler for processes that crash, specifically targeting C/C++ applications. It begins by ensuring that standard file descriptors (stdin, stdout, stderr) are open, redirecting them to `/dev/null` if necessary. The program then loads configuration settings from specified files, including options for saving core dumps and binary images. It processes command-line arguments to gather information about the crashed process, such as its PID and signal number. The code checks various conditions, such as whether the process is containerized, and manages the creation of core dump files while ensuring that sensitive information is handled securely. Finally, it logs relevant information and cleans up resources before exiting.","The code is a core dump handler designed to manage and save information from crashed processes, particularly for C/C++ applications. It ensures that essential file descriptors are open and loads configuration settings related to core dump behavior. The program processes command-line arguments to gather details about the crashed process, such as its identifier and the signal that caused the crash. It checks various conditions, including whether the process is running in a container, and manages the creation of core dump files while ensuring sensitive data is protected. Finally, it logs relevant information and performs cleanup before exiting.","The vulnerability in the original code arises from the potential for a symlink attack, where an attacker could create a symbolic link to a file with a predictable name, allowing unauthorized access to sensitive data or system resources. This was particularly concerning for files created in directories like `/var/tmp/abrt/` or `/var/spool/abrt/`, where the program would write core dumps. The fixed code addresses this issue by ensuring that the directory for core dumps is created with secure permissions and by using a unique naming convention for the core dump files, thus mitigating the risk of symlink attacks and ensuring that sensitive information is not exposed.","The vulnerability stems from the program's use of predictable file names for core dumps, which could be exploited through a symlink attack, allowing unauthorized users to redirect sensitive data to locations they control. This could lead to privilege escalation or data exposure. The fix involved implementing secure directory creation practices and ensuring that core dump files are generated with unique, less predictable names. By enhancing the security of the file handling process, the updated code mitigates the risk of symlink attacks, thereby protecting sensitive information and maintaining system integrity.","The vulnerability was fixed by ensuring that core dump files are created in a secure manner, specifically by using the `dd_create` function to establish a directory with appropriate permissions, preventing unauthorized access. Additionally, the code generates unique file names for core dumps using a combination of timestamps and process identifiers, which reduces predictability. The use of `snprintf` to format paths and the check for path length help avoid buffer overflows and ensure that file names do not collide. These changes collectively enhance the security of the core dump handling process, mitigating the risk of symlink attacks.","The vulnerability was addressed by implementing secure practices for creating directories and files associated with core dumps. The updated code ensures that core dump directories are created with strict permissions to prevent unauthorized access. Additionally, it generates unique and less predictable file names for core dumps, reducing the risk of symlink attacks. By incorporating checks for path lengths and ensuring that file creation processes are robust, the code effectively mitigates the potential for exploitation, thereby enhancing the overall security of the core dump handling mechanism.","4, 4","5, 5","5,4","5,5"
3,3,179781,179781,,Local,Not required,Partial,CVE-2015-5273,https://www.cvedetails.com/cve/CVE-2015-5273/,CWE-59,Low,,Partial,,2015-12-07,3.6,The abrt-action-install-debuginfo-to-abrt-cache help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users to write to arbitrary files via a symlink attack on unpacked.cpio in a pre-created directory with a predictable name in /var/tmp.,2016-12-07,,37,https://github.com/abrt/abrt/commit/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,"a-a-i-d-to-abrt-cache: make own random temporary directory

The set-user-ID wrapper must use own new temporary directory in order to
avoid security issues with unpacking specially crafted debuginfo
packages that might be used to create files or symlinks anywhere on the
file system as the abrt user.

Withot the forking code the temporary directory would remain on the
filesystem in the case where all debuginfo data are already available.
This is caused by the fact that the underlying libreport functionality
accepts path to a desired temporary directory and creates it only if
necessary. Otherwise, the directory is not touched at all.

This commit addresses CVE-2015-5273

Signed-off-by: Jakub Filak <jfilak@redhat.com>",4,src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c,"{""sha"": ""005cc9da147fc0adcfc85b82f6805bb399d28284"", ""filename"": ""src/plugins/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/Makefile.am?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -371,6 +371,7 @@ abrt_action_install_debuginfo_to_abrt_cache_CPPFLAGS = \\\n     -D_GNU_SOURCE \\\n     -DBIN_DIR=\\\""$(bindir)\\\"" \\\n     -DSBIN_DIR=\\\""$(sbindir)\\\"" \\\n+    -DLARGE_DATA_TMP_DIR=\\\""$(LARGE_DATA_TMP_DIR)\\\"" \\\n     $(LIBREPORT_CFLAGS) \\\n     -Wall -Wwrite-strings \\\n     -fPIE""}<_**next**_>{""sha"": ""52d00de6291968a4bd5c72f18ca27ddd7a1a7f77"", ""filename"": ""src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 4, ""changes"": 41, ""blob_url"": ""https://github.com/abrt/abrt/blob/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/plugins/abrt-action-install-debuginfo-to-abrt-cache.c?ref=50ee8130fb4cd4ef1af7682a2c85dd99cb99424e"", ""patch"": ""@@ -108,8 +108,14 @@ int main(int argc, char **argv)\n         build_ids_self_fd = xasprintf(\""/proc/self/fd/%d\"", build_ids_fd);\n     }\n \n-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n-    const char *args[11];\n+    char tmp_directory[] = LARGE_DATA_TMP_DIR\""/abrt-tmp-debuginfo.XXXXXX\"";\n+    if (mkdtemp(tmp_directory) == NULL)\n+        perror_msg_and_die(\""Failed to create working directory\"");\n+\n+    log_info(\""Created working directory: %s\"", tmp_directory);\n+\n+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */\n+    const char *args[13];\n     {\n         const char *verbs[] = { \""\"", \""-v\"", \""-vv\"", \""-vvv\"" };\n         unsigned i = 0;\n@@ -130,6 +136,8 @@ int main(int argc, char **argv)\n             args[i++] = \""--repo\"";\n             args[i++] = repo;\n         }\n+        args[i++] = \""--tmpdir\"";\n+        args[i++] = tmp_directory;\n         args[i++] = \""--\"";\n         args[i] = NULL;\n     }\n@@ -204,6 +212,31 @@ int main(int argc, char **argv)\n         umask(0022);\n     }\n \n-    execvp(EXECUTABLE, (char **)args);\n-    error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    pid_t pid = fork();\n+    if (pid < 0)\n+        perror_msg_and_die(\""fork\"");\n+\n+    if (pid == 0)\n+    {\n+        execvp(EXECUTABLE, (char **)args);\n+        error_msg_and_die(\""Can't execute %s\"", EXECUTABLE);\n+    }\n+\n+    int status;\n+    if (safe_waitpid(pid, &status, 0) < 0)\n+        perror_msg_and_die(\""waitpid\"");\n+\n+    if (rmdir(tmp_directory) >= 0)\n+        log_info(\""Removed working directory: %s\"", tmp_directory);\n+    else if (errno != ENOENT)\n+        perror_msg(\""Failed to remove working directory\"");\n+\n+    /* Normal execution should exit here. */\n+    if (WIFEXITED(status))\n+        return WEXITSTATUS(status);\n+\n+    if (WIFSIGNALED(status))\n+        error_msg_and_die(\""Child terminated with signal %d\"", WTERMSIG(status));\n+\n+    error_msg_and_die(\""Child exit failed\"");\n }""}","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
 }
","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
 }
",C,"    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
","    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
",,"@@ -108,8 +108,14 @@ int main(int argc, char **argv)
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
-    const char *args[11];
+    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
+    if (mkdtemp(tmp_directory) == NULL)
+        perror_msg_and_die(""Failed to create working directory"");
+
+    log_info(""Created working directory: %s"", tmp_directory);
+
+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
+    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
@@ -130,6 +136,8 @@ int main(int argc, char **argv)
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
+        args[i++] = ""--tmpdir"";
+        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }
@@ -204,6 +212,31 @@ int main(int argc, char **argv)
         umask(0022);
     }
 
-    execvp(EXECUTABLE, (char **)args);
-    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    pid_t pid = fork();
+    if (pid < 0)
+        perror_msg_and_die(""fork"");
+
+    if (pid == 0)
+    {
+        execvp(EXECUTABLE, (char **)args);
+        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
+    }
+
+    int status;
+    if (safe_waitpid(pid, &status, 0) < 0)
+        perror_msg_and_die(""waitpid"");
+
+    if (rmdir(tmp_directory) >= 0)
+        log_info(""Removed working directory: %s"", tmp_directory);
+    else if (errno != ENOENT)
+        perror_msg(""Failed to remove working directory"");
+
+    /* Normal execution should exit here. */
+    if (WIFEXITED(status))
+        return WEXITSTATUS(status);
+
+    if (WIFSIGNALED(status))
+        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
+
+    error_msg_and_die(""Child exit failed"");
 }",abrt,50ee8130fb4cd4ef1af7682a2c85dd99cb99424e,bfd3a454cd0a10e8384f8ce421e752867259c874,1,"int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
//flaw_line_below:
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
//flaw_line_below:
    const char *args[11];
//fix_flaw_line_below:
//    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
//fix_flaw_line_below:
//    if (mkdtemp(tmp_directory) == NULL)
//fix_flaw_line_below:
//        perror_msg_and_die(""Failed to create working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    log_info(""Created working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
//fix_flaw_line_below:
//    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
//fix_flaw_line_below:
//        args[i++] = ""--tmpdir"";
//fix_flaw_line_below:
//        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1
// We forgot to sanitize PYTHONPATH. And who knows what else we forgot
// (especially considering *future* new variables of this kind).
// We switched to clearing entire environment instead:

        // However since we communicate through environment variables
        // we have to keep a whitelist of variables to keep.
        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        // Now we can clear the environment
        clearenv();

        // And once again set whitelisted variables
        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        // Adding configure --bindir and --sbindir to the PATH so that
        // abrt-action-install-debuginfo doesn't fail when spawning
        // abrt-action-trim-files
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
//flaw_line_below:
    execvp(EXECUTABLE, (char **)args);
//flaw_line_below:
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    pid_t pid = fork();
//fix_flaw_line_below:
//    if (pid < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""fork"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (pid == 0)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        execvp(EXECUTABLE, (char **)args);
//fix_flaw_line_below:
//        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    int status;
//fix_flaw_line_below:
//    if (safe_waitpid(pid, &status, 0) < 0)
//fix_flaw_line_below:
//        perror_msg_and_die(""waitpid"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (rmdir(tmp_directory) >= 0)
//fix_flaw_line_below:
//        log_info(""Removed working directory: %s"", tmp_directory);
//fix_flaw_line_below:
//    else if (errno != ENOENT)
//fix_flaw_line_below:
//        perror_msg(""Failed to remove working directory"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* Normal execution should exit here. */
//fix_flaw_line_below:
//    if (WIFEXITED(status))
//fix_flaw_line_below:
//        return WEXITSTATUS(status);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (WIFSIGNALED(status))
//fix_flaw_line_below:
//        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    error_msg_and_die(""Child exit failed"");
 }
",179781,"int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */
    const char *args[11];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    execvp(EXECUTABLE, (char **)args);
    error_msg_and_die(""Can't execute %s"", EXECUTABLE);
 }
","int main(int argc, char **argv)
{
    /* I18n */
    setlocale(LC_ALL, """");
#if ENABLE_NLS
    bindtextdomain(PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);
#endif

    abrt_init(argv);

    /* Can't keep these strings/structs static: _() doesn't support that */
    const char *program_usage_string = _(
        ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n""
        ""\t[-r REPO]\n""
        ""\n""
        ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n""
        ""ABRT system cache.""
    );

    enum {
        OPT_v = 1 << 0,
        OPT_y = 1 << 1,
        OPT_i = 1 << 2,
        OPT_e = 1 << 3,
        OPT_r = 1 << 4,
        OPT_s = 1 << 5,
    };

    const char *build_ids = ""build_ids"";
    const char *exact = NULL;
    const char *repo = NULL;
    const char *size_mb = NULL;

    struct options program_options[] = {
        OPT__VERBOSE(&g_verbose),
        OPT_BOOL  ('y', ""yes"",         NULL,                   _(""Noninteractive, assume 'Yes' to all questions"")),
        OPT_STRING('i', ""ids"",   &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")),
        OPT_STRING('e', ""exact"",     &exact, ""EXACT"",          _(""Download only specified files"")),
        OPT_STRING('r', ""repo"",       &repo, ""REPO"",           _(""Pattern to use when searching for repos, default: *debug*"")),
        OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"",        _(""Ignored option"")),
        OPT_END()
    };
    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);

    const gid_t egid = getegid();
    const gid_t rgid = getgid();
    const uid_t euid = geteuid();
    const gid_t ruid = getuid();

    /* We need to open the build ids file under the caller's UID/GID to avoid
     * information disclosures when reading files with changed UID.
     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses
     * STDIN to communicate with the caller. So, the following code opens a
     * dummy file descriptor to the build ids file and passes the new fd's proc
     * path to the wrapped program in the ids argument.
     * The new fd remains opened, the OS will close it for us. */
    char *build_ids_self_fd = NULL;
    if (strcmp(""-"", build_ids) != 0)
    {
        if (setregid(egid, rgid) < 0)
            perror_msg_and_die(""setregid(egid, rgid)"");

        if (setreuid(euid, ruid) < 0)
            perror_msg_and_die(""setreuid(euid, ruid)"");

        const int build_ids_fd = open(build_ids, O_RDONLY);

        if (setregid(rgid, egid) < 0)
            perror_msg_and_die(""setregid(rgid, egid)"");

        if (setreuid(ruid, euid) < 0 )
            perror_msg_and_die(""setreuid(ruid, euid)"");

        if (build_ids_fd < 0)
            perror_msg_and_die(""Failed to open file '%s'"", build_ids);

        /* We are not going to free this memory. There is no place to do so. */
         build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd);
     }
 
    char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
    if (mkdtemp(tmp_directory) == NULL)
        perror_msg_and_die(""Failed to create working directory"");

    log_info(""Created working directory: %s"", tmp_directory);

    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */
    const char *args[13];
     {
         const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" };
         unsigned i = 0;
        args[i++] = EXECUTABLE;
        args[i++] = ""--ids"";
        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-"";
        if (g_verbose > 0)
            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];
        if ((opts & OPT_y))
            args[i++] = ""-y"";
        if ((opts & OPT_e))
        {
            args[i++] = ""--exact"";
            args[i++] = exact;
        }
        if ((opts & OPT_r))
        {
             args[i++] = ""--repo"";
             args[i++] = repo;
         }
        args[i++] = ""--tmpdir"";
        args[i++] = tmp_directory;
         args[i++] = ""--"";
         args[i] = NULL;
     }

    /* Switch real user/group to effective ones.
     * Otherwise yum library gets confused - gets EPERM (why??).
     */
    /* do setregid only if we have to, to not upset selinux needlessly */
    if (egid != rgid)
        IGNORE_RESULT(setregid(egid, egid));
    if (euid != ruid)
    {
        IGNORE_RESULT(setreuid(euid, euid));
        /* We are suid'ed! */
        /* Prevent malicious user from messing up with suid'ed process: */
#if 1

        static const char *whitelist[] = {
            ""REPORT_CLIENT_SLAVE"", //  Check if the app is being run as a slave
            ""LANG"",
        };
        const size_t wlsize = sizeof(whitelist)/sizeof(char*);
        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };
        char *p = NULL;
        for (size_t i = 0; i < wlsize; i++)
            if ((p = getenv(whitelist[i])) != NULL)
                setlist[i] = xstrdup(p);

        clearenv();

        for (size_t i = 0; i < wlsize; i++)
            if (setlist[i] != NULL)
            {
                xsetenv(whitelist[i], setlist[i]);
                free(setlist[i]);
            }
#else
        /* Clear dangerous stuff from env */
        static const char forbid[] =
            ""LD_LIBRARY_PATH"" ""\0""
            ""LD_PRELOAD"" ""\0""
            ""LD_TRACE_LOADED_OBJECTS"" ""\0""
            ""LD_BIND_NOW"" ""\0""
            ""LD_AOUT_LIBRARY_PATH"" ""\0""
            ""LD_AOUT_PRELOAD"" ""\0""
            ""LD_NOWARN"" ""\0""
            ""LD_KEEPDIR"" ""\0""
        ;
        const char *p = forbid;
        do {
            unsetenv(p);
            p += strlen(p) + 1;
        } while (*p);
#endif
        /* Set safe PATH */
        char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR;
        if (euid != 0)
            strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR);
        putenv(path_env);

        /* Use safe umask */
         umask(0022);
     }
 
    pid_t pid = fork();
    if (pid < 0)
        perror_msg_and_die(""fork"");

    if (pid == 0)
    {
        execvp(EXECUTABLE, (char **)args);
        error_msg_and_die(""Can't execute %s"", EXECUTABLE);
    }

    int status;
    if (safe_waitpid(pid, &status, 0) < 0)
        perror_msg_and_die(""waitpid"");

    if (rmdir(tmp_directory) >= 0)
        log_info(""Removed working directory: %s"", tmp_directory);
    else if (errno != ENOENT)
        perror_msg(""Failed to remove working directory"");

    /* Normal execution should exit here. */
    if (WIFEXITED(status))
        return WEXITSTATUS(status);

    if (WIFSIGNALED(status))
        error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));

    error_msg_and_die(""Child exit failed"");
 }
","The provided code is a C program that initializes localization settings and processes command-line arguments to install debuginfo packages based on specified build IDs. It sets up various options, including verbosity, non-interactive mode, and repository patterns, while ensuring secure handling of user permissions by switching user and group IDs. The program reads a file containing build IDs, potentially opening it under the caller's UID/GID to prevent information disclosure. Finally, it constructs an argument list and executes another program (EXECUTABLE) with the specified options, handling errors appropriately if execution fails.","The code is a C program designed to facilitate the installation of debuginfo packages based on a list of build IDs provided by the user. It initializes localization settings and processes command-line options for various functionalities, including non-interactive execution and specific repository searches. The program securely handles user permissions to prevent unauthorized access to sensitive information while reading the build IDs file. After constructing a command with the specified options, it executes another program to perform the installation, ensuring proper error handling throughout the process.","The vulnerability in the original code arises from the use of a predictable temporary directory for unpacking files, which allows local users to perform a symlink attack, potentially leading to unauthorized file writes. This is classified under CWE-59, where the program fails to securely manage temporary files. The fixed code addresses this issue by creating a unique temporary directory using a secure method, specifically with the `mkdtemp` function, which generates a directory with a randomized name. This change mitigates the risk of symlink attacks by ensuring that the directory's name is not predictable, thus enhancing the security of the file handling process.","The vulnerability in the original code stems from the use of a predictable temporary directory for unpacking files, which exposes the program to symlink attacks, allowing local users to overwrite arbitrary files. This issue is classified under CWE-59, highlighting the insecure handling of temporary files. The fixed code resolves this vulnerability by implementing a secure method to create a unique temporary directory, ensuring that its name is randomized and not easily guessable. This change effectively prevents unauthorized access and manipulation of files, thereby enhancing the overall security of the program's file management process.","The vulnerability was fixed by replacing the predictable temporary directory creation with a secure method using the `mkdtemp` function. In the updated code, a template for the temporary directory is defined, which includes a randomized suffix, ensuring that the directory name is unique and not easily guessable. This change prevents local users from exploiting the predictable directory name for symlink attacks. Additionally, the program logs the creation of the new working directory, enhancing transparency and security in file handling. Overall, this approach significantly mitigates the risk of unauthorized file access and manipulation.","The vulnerability was fixed by implementing a secure method for creating temporary directories that ensures their names are unique and unpredictable. Instead of using a static or predictable name, the updated code generates a directory with a randomized suffix, significantly reducing the risk of symlink attacks. This approach prevents local users from being able to manipulate the directory structure to overwrite arbitrary files. Additionally, the program logs the creation of the new directory, which enhances security by providing visibility into the file handling process and ensuring that temporary files are managed safely.","5,4","5,5","4,5","5,4"
4,4,179897,179897,,Local,Not required,,CVE-2015-1331,https://www.cvedetails.com/cve/CVE-2015-1331/,CWE-59,Low,,Complete,,2015-08-12,4.9,lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.,2019-05-31,,10,https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6,72cf81f6a3404e35028567db2c99a90406e9c6e6,"CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc

This prevents an unprivileged user to use LXC to create arbitrary file
on the filesystem.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
Acked-by: Stéphane Graber <stgraber@ubuntu.com>",36,src/lxc/lxclock.c,"{""sha"": ""e9e95f7a01d924f824c9a127cd624802c6ed5265"", ""filename"": ""src/lxc/lxclock.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 37, ""changes"": 47, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/lxc/lxclock.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/lxc/lxclock.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)\n \tchar *rundir;\n \n \t/* lockfile will be:\n-\t * \""/run\"" + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n+\t * \""/run\"" + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n \t * or\n-\t * $XDG_RUNTIME_DIR + \""/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n+\t * $XDG_RUNTIME_DIR + \""/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n-\t/* length of \""/lock/lxc/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n-\tlen = strlen(\""/lock/lxc/\"") + strlen(n) + strlen(p) + 3;\n+\t/* length of \""/lxc/lock/\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0' */\n+\tlen = strlen(\""/lxc/lock/\"") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)\n \t\treturn NULL;\n \t}\n \n-\tret = snprintf(dest, len, \""%s/lock/lxc/%s\"", rundir, p);\n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s\"", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n-\t\t/* fall back to \""/tmp/\"" + $(id -u) + \""/lxc\"" + $lxcpath + \""/\"" + \"".\"" + $lxcname + '\\0'\n-\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n-\t\t * * lxcpath always starts with '/'\n-\t\t */\n-\t\tint l2 = 22 + strlen(n) + strlen(p);\n-\t\tif (l2 > len) {\n-\t\t\tchar *d;\n-\t\t\td = realloc(dest, l2);\n-\t\t\tif (!d) {\n-\t\t\t\tfree(dest);\n-\t\t\t\tfree(rundir);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tlen = l2;\n-\t\t\tdest = d;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s\"", geteuid(), p);\n-\t\tif (ret < 0 || ret >= len) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = mkdir_p(dest, 0755);\n-\t\tif (ret < 0) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = snprintf(dest, len, \""/tmp/%d/lxc%s/.%s\"", geteuid(), p, n);\n-\t} else\n-\t\tret = snprintf(dest, len, \""%s/lock/lxc/%s/.%s\"", rundir, p, n);\n+\t\tfree(dest);\n+\t\tfree(rundir);\n+\t\treturn NULL;\n+\t}\n \n+\tret = snprintf(dest, len, \""%s/lxc/lock/%s/.%s\"", rundir, p, n);\n \tfree(rundir);\n-\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;""}<_**next**_>{""sha"": ""233ca127c6dec567e775abbbb0ef9ce0ed417e43"", ""filename"": ""src/tests/locktests.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/lxc/lxc/blob/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""raw_url"": ""https://github.com/lxc/lxc/raw/72cf81f6a3404e35028567db2c99a90406e9c6e6/src/tests/locktests.c"", ""contents_url"": ""https://api.github.com/repos/lxc/lxc/contents/src/tests/locktests.c?ref=72cf81f6a3404e35028567db2c99a90406e9c6e6"", ""patch"": ""@@ -122,7 +122,7 @@ int main(int argc, char *argv[])\n \t\texit(1);\n \t}\n \tstruct stat sb;\n-\tchar *pathname = RUNTIME_PATH \""/lock/lxc/var/lib/lxc/\"";\n+\tchar *pathname = RUNTIME_PATH \""/lxc/lock/var/lib/lxc/\"";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \""%d: filename %s not created\\n\"", __LINE__,""}","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
",C,"	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
		free(dest);
		free(rundir);
		return NULL;
	}
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
","	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
",,"@@ -103,13 +103,13 @@ static char *lxclock_name(const char *p, const char *n)
 	char *rundir;
 
 	/* lockfile will be:
-	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
+	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
-	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
+	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
-	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
-	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
+	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
+	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
@@ -120,48 +120,21 @@ static char *lxclock_name(const char *p, const char *n)
 		return NULL;
 	}
 
-	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
-		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
-		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
-		 * * lxcpath always starts with '/'
-		 */
-		int l2 = 22 + strlen(n) + strlen(p);
-		if (l2 > len) {
-			char *d;
-			d = realloc(dest, l2);
-			if (!d) {
-				free(dest);
-				free(rundir);
-				return NULL;
-			}
-			len = l2;
-			dest = d;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
-		if (ret < 0 || ret >= len) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = mkdir_p(dest, 0755);
-		if (ret < 0) {
-			free(dest);
-			free(rundir);
-			return NULL;
-		}
-		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
-	} else
-		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
+		free(dest);
+		free(rundir);
+		return NULL;
+	}
 
+	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
-
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;",lxc,72cf81f6a3404e35028567db2c99a90406e9c6e6,f52c0d2677e365289e921cfd38033c0c987cefd5,1,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
//flaw_line_below:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
//fix_flaw_line_below:
//	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
//flaw_line_below:
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
//fix_flaw_line_below:
//	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
//flaw_line_below:
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//flaw_line_below:
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
//fix_flaw_line_below:
//	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
//fix_flaw_line_below:
//	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
//flaw_line_below:
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
//flaw_line_below:
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
//flaw_line_below:
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
//flaw_line_below:
		 * * lxcpath always starts with '/'
//flaw_line_below:
		 */
//flaw_line_below:
		int l2 = 22 + strlen(n) + strlen(p);
//flaw_line_below:
		if (l2 > len) {
//flaw_line_below:
			char *d;
//flaw_line_below:
			d = realloc(dest, l2);
//flaw_line_below:
			if (!d) {
//flaw_line_below:
				free(dest);
//flaw_line_below:
				free(rundir);
//flaw_line_below:
				return NULL;
//flaw_line_below:
			}
//flaw_line_below:
			len = l2;
//flaw_line_below:
			dest = d;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
//flaw_line_below:
		if (ret < 0 || ret >= len) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = mkdir_p(dest, 0755);
//flaw_line_below:
		if (ret < 0) {
//flaw_line_below:
			free(dest);
//flaw_line_below:
			free(rundir);
//flaw_line_below:
			return NULL;
//flaw_line_below:
		}
//flaw_line_below:
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
//flaw_line_below:
	} else
//flaw_line_below:
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
//fix_flaw_line_below:
//		free(dest);
//fix_flaw_line_below:
//		free(rundir);
//fix_flaw_line_below:
//		return NULL;
//fix_flaw_line_below:
//	}
 
//fix_flaw_line_below:
//	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
//flaw_line_below:

 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
",179897,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lock/lxc/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lock/lxc/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lock/lxc/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		/* fall back to ""/tmp/"" + $(id -u) + ""/lxc"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0'
		 * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)
		 * * lxcpath always starts with '/'
		 */
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	/* lockfile will be:
	 * ""/run"" + ""/lxc/lock/$lxcpath/$lxcname + '\0' if root
 	 * or
	 * $XDG_RUNTIME_DIR + ""/lxc/lock/$lxcpath/$lxcname + '\0' if non-root
 	 */
 
	/* length of ""/lxc/lock/"" + $lxcpath + ""/"" + ""."" + $lxcname + '\0' */
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","The `lxclock_name` function generates a lock file path for LXC (Linux Containers) based on the provided container path (`p`) and name (`n`). It first determines the runtime directory using `get_rundir()`, then constructs a path in the format of either `/run/lock/lxc/$lxcpath/$lxcname` for root or `/tmp/$USER/lxc/$lxcpath/$lxcname` for non-root users. The function allocates memory for the path, creates the necessary directories, and handles errors gracefully by freeing allocated memory if any step fails. Finally, it returns the constructed lock file path or `NULL` if an error occurs.","The code defines a function that constructs a path for a lock file used in container management. It determines the appropriate runtime directory based on user privileges and builds a file path that includes the container's path and name. The function allocates memory for this path and attempts to create the necessary directories. If the initial directory creation fails, it falls back to a temporary directory structure for non-root users. Throughout the process, it handles memory management and error checking, ensuring that resources are freed if any operation encounters an issue, ultimately returning the constructed path or indicating failure.","The vulnerability in the original code arises from the potential for a symbolic link attack, where an attacker could create a symlink in the `/run/lock/lxc/` directory, allowing them to redirect the lock file creation to an arbitrary location. This occurs because the code does not validate the path properly before creating directories or files. In the fixed code, the path construction is modified to use a more secure directory structure, specifically changing the path to `/lxc/lock/` and ensuring that the directory creation is handled more securely. This reduces the risk of symlink attacks by limiting the locations where files can be created and ensuring that the paths are less predictable.","The vulnerability in the original code allows local users to exploit symbolic links to redirect the creation of lock files to arbitrary locations, potentially leading to unauthorized file manipulation or overwriting. This occurs because the code does not adequately validate the target directory before creating files, making it susceptible to attacks that leverage symlinks. In the revised code, the path structure is altered to enhance security by using a more controlled directory hierarchy, which mitigates the risk of symlink attacks. Additionally, the implementation ensures that directory creation is handled more securely, reducing the likelihood of unauthorized access to sensitive file locations.","The vulnerability was fixed by changing the path construction in the code to use a more secure directory structure, specifically modifying the path to `/lxc/lock/` instead of `/run/lock/lxc/`. This adjustment reduces the risk of symlink attacks by limiting the locations where files can be created. Additionally, the code now ensures that the directory is created with proper permissions using the `mkdir_p` function, which helps prevent unauthorized access. The checks for the return values of `snprintf` and `malloc` are also retained to ensure that any errors in memory allocation or path formatting are handled appropriately, further enhancing security.","The vulnerability was addressed by altering the directory structure used for lock file creation, moving from a more exposed location to a more secure one. This change minimizes the risk of symbolic link attacks by restricting where files can be created, thereby preventing unauthorized redirection. Additionally, the implementation includes enhanced checks for memory allocation and path formatting errors, ensuring that any issues are properly handled. By enforcing stricter directory permissions during creation, the revised code further protects against unauthorized access, significantly improving the overall security of the file handling process.","5, 4","5,4","4,4","4,4"
5,5,181450,181450,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/pull/444/commits/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,"Walk the entire DefaultRoot path, checking for symlinks of any component,
when AllowChrootSymlinks is disabled.",13,modules/mod_auth.c,"{""sha"": ""6e535bbb7a66d5babfc08807099ecd7a6d80a5da"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 58, ""deletions"": 15, ""changes"": 73, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache2(path);\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n+\n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n /* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n   config_rec *c = NULL;\n@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache2(path);\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}<_**next**_>{""sha"": ""8872231db18a970369799ece823cc1d8325aafde"", ""filename"": ""tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 9, ""changes"": 23, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/TestSuite/Utils.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/TestSuite/Utils.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -1198,6 +1198,7 @@ sub test_setup {\n   $uid = 500 unless defined($uid);\n   my $gid = shift;\n   $gid = 500 unless defined($gid);\n+  my $home_dir = shift;\n \n   my $config_file = \""$tmpdir/$name.conf\"";\n   my $pid_file = File::Spec->rel2abs(\""$tmpdir/$name.pid\"");\n@@ -1206,17 +1207,21 @@ sub test_setup {\n   my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/$name.passwd\"");\n   my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/$name.group\"");\n \n-  my $home_dir = File::Spec->rel2abs($tmpdir);\n+  # If the caller provides the home directory, it is ASSUMED that they will\n+  # have created it.\n+  unless (defined($home_dir)) {\n+    $home_dir = File::Spec->rel2abs($tmpdir);\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $home_dir)) {\n-      croak(\""Can't set perms on $home_dir to 0755: $!\"");\n-    }\n+    # Make sure that, if we're running as root, that the home directory has\n+    # permissions/privs set for the account we create\n+    if ($< == 0) {\n+      unless (chmod(0755, $home_dir)) {\n+        croak(\""Can't set perms on $home_dir to 0755: $!\"");\n+      }\n \n-    unless (chown($uid, $gid, $home_dir)) {\n-      croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      unless (chown($uid, $gid, $home_dir)) {\n+        croak(\""Can't set owner of $home_dir to $uid/$gid: $!\"");\n+      }\n     }\n   }\n ""}<_**next**_>{""sha"": ""88486c3a774b144b863f3ba8bd209c64abb8d0ea"", ""filename"": ""tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 55, ""changes"": 76, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm?ref=349addc3be4fcdad9bd4ec01ad1ccd916c898ed8"", ""patch"": ""@@ -621,65 +621,39 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   my $self = shift;\n   my $tmpdir = $self->{tmpdir};\n \n-  my $config_file = \""$tmpdir/config.conf\"";\n-  my $pid_file = File::Spec->rel2abs(\""$tmpdir/config.pid\"");\n-  my $scoreboard_file = File::Spec->rel2abs(\""$tmpdir/config.scoreboard\"");\n-\n-  my $log_file = test_get_logfile();\n-\n-  my $auth_user_file = File::Spec->rel2abs(\""$tmpdir/config.passwd\"");\n-  my $auth_group_file = File::Spec->rel2abs(\""$tmpdir/config.group\"");\n-\n   my $user = 'proftpd';\n-  my $passwd = 'test';\n-  my $group = 'ftpd';\n   my $home_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks/$user\"");\n   my $uid = 500;\n   my $gid = 500;\n \n-  my $intermed_dir = File::Spec->rel2abs(\""$tmpdir/home.d/symlinks\"");\n-  mkpath($intermed_dir);\n-\n-  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real/$user\"");\n-  mkpath($symlink_dst);\n+  my $symlink_dst = File::Spec->rel2abs(\""$tmpdir/real\"");\n \n   my $cwd = getcwd();\n \n-  unless (chdir($intermed_dir)) {\n-    die(\""Can't chdir to $intermed_dir: $!\"");\n+  unless (chdir($tmpdir)) {\n+    die(\""Can't chdir to $tmpdir: $!\"");\n   }\n \n-  unless (symlink(\""../../real/$user\"", \""./$user\"")) {\n-    die(\""Can't symlink '../../real/$user' to './$user': $!\"");\n+  unless (symlink(\""./real\"", \""./home.d\"")) {\n+    die(\""Can't symlink './real' to './home.d': $!\"");\n   }\n \n   unless (chdir($cwd)) {\n     die(\""Can't chdir to $cwd: $!\"");\n   }\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $symlink_dst)) {\n-      die(\""Can't set perms on $symlink_dst to 0755: $!\"");\n-    }\n+  mkpath(File::Spec->rel2abs(\""$tmpdir/real/symlinks/$user\""));\n \n-    unless (chown($uid, $gid, $symlink_dst)) {\n-      die(\""Can't set owner of $symlink_dst to $uid/$gid: $!\"");\n-    }\n-  }\n-\n-  auth_user_write($auth_user_file, $user, $passwd, $uid, $gid, $home_dir,\n-    '/bin/bash');\n-  auth_group_write($auth_group_file, $group, $gid, $user);\n+  my $setup = test_setup($tmpdir, 'config', $user, undef, undef, $uid, $gid,\n+    $home_dir);\n \n   my $config = {\n-    PidFile => $pid_file,\n-    ScoreboardFile => $scoreboard_file,\n-    SystemLog => $log_file,\n+    PidFile => $setup->{pid_file},\n+    ScoreboardFile => $setup->{scoreboard_file},\n+    SystemLog => $setup->{log_file},\n \n-    AuthUserFile => $auth_user_file,\n-    AuthGroupFile => $auth_group_file,\n+    AuthUserFile => $setup->{auth_user_file},\n+    AuthGroupFile => $setup->{auth_group_file},\n \n     AllowChrootSymlinks => 'off',\n     DefaultRoot => '~',\n@@ -691,7 +665,8 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     },\n   };\n \n-  my ($port, $config_user, $config_group) = config_write($config_file, $config);\n+  my ($port, $config_user, $config_group) = config_write($setup->{config_file},\n+    $config);\n \n   # Open pipes, for use between the parent and child processes.  Specifically,\n   # the child will indicate when it's done with its test by writing a message\n@@ -709,7 +684,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   if ($pid) {\n     eval {\n       my $client = ProFTPD::TestSuite::FTP->new('127.0.0.1', $port);\n-      eval { $client->login($user, $passwd) };\n+      eval { $client->login($user, $setup->{passwd}) };\n       unless ($@) {\n         die(\""Login succeeded unexpectedly\"");\n       }\n@@ -721,13 +696,12 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n \n       $expected = 530;\n       $self->assert($expected == $resp_code,\n-        test_msg(\""Expected response code $expected, got $resp_code\""));\n+        \""Expected response code $expected, got $resp_code\"");\n \n       $expected = \""Login incorrect.\"";\n       $self->assert($expected eq $resp_msg,\n-        test_msg(\""Expected response message '$expected', got '$resp_msg'\""));\n+        \""Expected response message '$expected', got '$resp_msg'\"");\n     };\n-\n     if ($@) {\n       $ex = $@;\n     }\n@@ -736,7 +710,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     $wfh->flush();\n \n   } else {\n-    eval { server_wait($config_file, $rfh) };\n+    eval { server_wait($setup->{config_file}, $rfh) };\n     if ($@) {\n       warn($@);\n       exit 1;\n@@ -746,18 +720,10 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   }\n \n   # Stop server\n-  server_stop($pid_file);\n-\n+  server_stop($setup->{pid_file});\n   $self->assert_child_ok($pid);\n \n-  if ($ex) {\n-    test_append_logfile($log_file, $ex);\n-    unlink($log_file);\n-\n-    die($ex);\n-  }\n-\n-  unlink($log_file);\n+  test_cleanup($setup->{log_file}, $ex);\n }\n \n 1;""}"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache2(path);
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
+
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
 /* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache2(path);
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,349addc3be4fcdad9bd4ec01ad1ccd916c898ed8,31ce8400c18c3ac46cbe3f17f3e7f0cc4e712dfc,1," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache2(path);
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",181450," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  const char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c != NULL) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir != NULL) {
    const char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = pstrdup(p, dir);
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      pr_fs_clear_cache2(dir);

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
","The `get_default_root` function retrieves the default root directory for a server, considering configuration parameters and access control. It searches for the ""DefaultRoot"" setting in the server's configuration, evaluating any associated group permissions. If a valid directory is found, it checks for expandable user variables and ensures the directory is not a symlink if `allow_symlinks` is false. The function also resolves the directory path, handling potential errors and logging warnings if issues arise. Finally, it assigns the resolved directory to the output parameter `root` and returns a status code indicating success or failure.","The function determines the default root directory for a server by examining configuration settings and evaluating access permissions. It searches for a specific configuration parameter and, if found, checks if the directory is valid based on group permissions. If the directory is valid, it processes any user-specific variables and ensures that the directory is not a symbolic link if such links are not permitted. The function resolves the directory path, handles potential errors, and logs warnings as necessary. Ultimately, it assigns the resolved directory to an output parameter and returns a status code indicating success or failure.","The vulnerability in the original code arises from inadequate checks on symbolic links, allowing attackers to bypass the `AllowChrootSymlinks` configuration by replacing any path component except the last one with a symbolic link. This oversight could lead to unauthorized access to restricted directories. The fixed code addresses this issue by introducing a dedicated function, `is_symlink_path`, which thoroughly checks the entire path for symbolic links, rather than just the last component. This enhancement ensures that all components of the path are validated against the configuration, effectively mitigating the risk of unauthorized access through symbolic links.","The vulnerability stems from insufficient validation of symbolic links within a user's home directory, allowing attackers to exploit the configuration option that restricts such links. Specifically, the original code only checked the last component of the path, enabling attackers to substitute earlier components with symbolic links to bypass security controls. The fix implemented a comprehensive check across the entire path, ensuring that all components are validated against the configuration. This enhancement effectively prevents unauthorized access by ensuring that any symbolic links present in the path are properly accounted for, thereby closing the security loophole.","The vulnerability was fixed by introducing a dedicated function, `is_symlink_path`, which checks the entire path for symbolic links rather than just the last component. In the updated code, this function is called to validate the path before proceeding with further operations. If a symbolic link is detected, an error is logged, and the function returns an error code, effectively enforcing the `AllowChrootSymlinks` configuration. This comprehensive validation ensures that any symbolic links present in the path are properly handled, thereby preventing attackers from bypassing security controls by manipulating earlier path components.","The vulnerability was addressed by implementing a thorough check for symbolic links throughout the entire directory path instead of only examining the last component. This enhancement ensures that all parts of the path are validated against the configuration that restricts symbolic links. If any symbolic link is detected, the code logs an appropriate error message and prevents further processing, thereby enforcing the security policy effectively. This comprehensive validation mechanism closes the loophole that allowed attackers to bypass restrictions by manipulating earlier components of the path, thereby strengthening the overall security of the system.","4,5","5,5","4,4","4,4"
6,6,182086,182086,,Local,Not required,Partial,CVE-2014-4978,https://www.cvedetails.com/cve/CVE-2014-4978/,CWE-59,Low,,Partial,,2017-12-29,3.6,The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.,2018-01-10,,18,https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,Fixes insecure use of temporary file (CVE-2014-4978).,3,librawstudio/rs-filter.c,"{""sha"": ""352b23c51a00b32c4993732b1534ff5a988ee763"", ""filename"": ""librawstudio/rs-filter.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 3, ""changes"": 21, ""blob_url"": ""https://github.com/rawstudio/rawstudio/blob/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""raw_url"": ""https://github.com/rawstudio/rawstudio/raw/9c2cd3c93c05d009a91d84eedbb85873b0cb505d/librawstudio/rs-filter.c"", ""contents_url"": ""https://api.github.com/repos/rawstudio/rawstudio/contents/librawstudio/rs-filter.c?ref=9c2cd3c93c05d009a91d84eedbb85873b0cb505d"", ""patch"": ""@@ -772,17 +772,32 @@ void\n rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n+\tgchar *dot_filename;\n+\tgchar *png_filename;\n+\tgchar *command_line;\n \tGString *str = g_string_new(\""digraph G {\\n\"");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \""}\\n\"");\n-\tg_file_set_contents(\""/tmp/rs-filter-graph\"", str->str, str->len, NULL);\n \n-\tif (0 != system(\""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\""))\n+\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n+\tdot_filename = g_strdup_printf(\""/tmp/rs-filter-graph.%u\"", g_random_int());\n+\tpng_filename = g_strdup_printf(\""%s.%u.png\"", dot_filename, g_random_int());\n+\n+\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n+\n+\tcommand_line = g_strdup_printf(\""dot -Tpng >%s <%s\"", png_filename, dot_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling dot failed\"");\n-\tif (0 != system(\""gnome-open /tmp/rs-filter-graph.png\""))\n+\tg_free(command_line);\n+\n+\tcommand_line = g_strdup_printf(\""gnome-open %s\"", png_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\""Calling gnome-open failed.\"");\n+\tg_free(command_line);\n \n+\tg_free(dot_filename);\n+\tg_free(png_filename);\n \tg_string_free(str, TRUE);\n }""}"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",C,"	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
	g_free(command_line);
	g_free(dot_filename);
	g_free(png_filename);
","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
",,"@@ -772,17 +772,32 @@ void
 rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
+	gchar *dot_filename;
+	gchar *png_filename;
+	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
-	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
-	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
+	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
+	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
+	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
+
+	g_file_set_contents(dot_filename, str->str, str->len, NULL);
+
+	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
-	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
+	g_free(command_line);
+
+	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
+	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
+	g_free(command_line);
 
+	g_free(dot_filename);
+	g_free(png_filename);
 	g_string_free(str, TRUE);
 }",rawstudio,9c2cd3c93c05d009a91d84eedbb85873b0cb505d,70f2da78b575ea1105eae865c7e49465b838bdfd,1," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
//fix_flaw_line_below:
//	gchar *dot_filename;
//fix_flaw_line_below:
//	gchar *png_filename;
//fix_flaw_line_below:
//	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
//flaw_line_below:
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
//flaw_line_below:
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
//fix_flaw_line_below:
//	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
//fix_flaw_line_below:
//	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
//fix_flaw_line_below:
//	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	g_file_set_contents(dot_filename, str->str, str->len, NULL);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
//flaw_line_below:
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
//fix_flaw_line_below:
//	g_free(command_line);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
//fix_flaw_line_below:
//	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
//fix_flaw_line_below:
//	g_free(command_line);
 
//fix_flaw_line_below:
//	g_free(dot_filename);
//fix_flaw_line_below:
//	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
",182086," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }
","The `rs_filter_graph` function generates a visual representation of a filter graph for a given `RSFilter` object. It begins by validating the filter input and initializing a new string to construct a Graphviz DOT format representation. The function then calls a helper function to populate this string with the filter's details. After finalizing the DOT string, it writes the content to a temporary file. Subsequently, it uses the `dot` command to convert the DOT file into a PNG image and attempts to open the resulting image using `gnome-open`. Finally, it frees the allocated string memory.","The code defines a function that creates a visual representation of a filter graph based on a specified filter object. It starts by ensuring the validity of the filter input and initializes a string to build a representation in a specific format. A helper function is then called to populate this string with the filter's details. After completing the string, the content is saved to a temporary file. The code subsequently invokes a command-line tool to convert the file into an image format and attempts to open the generated image for viewing. Finally, it releases any allocated memory.","The vulnerability in the original code arises from the use of predictable temporary file names, which allows an attacker to create symbolic links to these files, potentially leading to arbitrary file truncation (CWE-59). Specifically, the code generates a fixed filename for the temporary DOT file, making it susceptible to symlink attacks. In the fixed code, this issue is addressed by incorporating randomness into the filename generation using `g_random_int()`, creating unique filenames for both the DOT and PNG files. This change mitigates the risk of an attacker exploiting predictable file paths, thereby enhancing the security of the function.","The vulnerability in the original code stems from the use of predictable temporary file names, which exposes the application to symlink attacks, allowing an attacker to create links to these files and potentially truncate arbitrary files. This issue arises because the fixed filenames can be easily guessed, enabling malicious users to exploit the system. In the revised code, the vulnerability is mitigated by generating unique filenames that incorporate randomness, making it significantly harder for an attacker to predict the file paths. This enhancement effectively reduces the risk of unauthorized file manipulation and improves overall security.","The vulnerability was fixed by modifying the filename generation process to incorporate randomness, thereby preventing predictable file paths. In the revised code, the `g_random_int()` function is used to create unique filenames for both the DOT and PNG files, specifically through `g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int())` for the DOT file and `g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int())` for the PNG file. This change ensures that the filenames are not easily guessable, significantly reducing the risk of symlink attacks and enhancing the security of the function.","The vulnerability was addressed by altering the method of generating temporary file names to include randomness, which prevents attackers from predicting the file paths. By incorporating unique identifiers into the filenames, the revised code ensures that each execution creates distinct and non-guessable file names. This change effectively mitigates the risk of symlink attacks, as it becomes significantly more difficult for malicious users to create links to the temporary files. Overall, this enhancement improves the security of the function by safeguarding against unauthorized file manipulation.","5,5","5,5","4,4","5, 5"
7,7,182606,182606,,Local,Not required,Complete,CVE-2017-7500,https://www.cvedetails.com/cve/CVE-2017-7500/,CWE-59,Low,Complete,Complete,,2018-08-13,7.2,"It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",2019-10-09,+Priv ,12,https://github.com/rpm-software-management/rpm/commit/c815822c8bdb138066ff58c624ae83e3a12ebfa9,c815822c8bdb138066ff58c624ae83e3a12ebfa9,"Make verification match the new restricted directory symlink behavior

Only follow directory symlinks owned by target directory owner or root
during verification to match the behavior of fsmVerify() in the new
CVE-2017-7500 world order.

The code is klunkier than it should and the logic should use common code
with fsmVerify() instead of duplicating it here, but that needs more
changes than is comfortable to backport so starting with this.

Also worth noting that the previous ""follow the link"" logic from
commit 3ccd774255b8215733e0bdfdf5a683da9dd10923 was not quite right,
it'd fail with RPMVERIFY_LSTATFAIL on a broken symlink when it should've
ran verification on the symlink itself. This behavior is fixed here too.

Finally, once again fakechroot gets in the way and forces the related
verify testcase to be changed to be able to create a valid link. Reuse
the replacement testcase for the purpose and add another case for
verifying an invalid link.",3,lib/verify.c,"{""sha"": ""62eec08617fb02a6d8e4fa89e9236e844a277cc7"", ""filename"": ""lib/verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/lib/verify.c"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/lib/verify.c?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n     }\n \n     /* If we expected a directory but got a symlink to one, follow the link */\n-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n-\tvfy |= RPMVERIFY_LSTATFAIL;\n-\tgoto exit;\n+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n+\tstruct stat dsb;\n+\t/* ...if it actually points to a directory  */\n+\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n+\t    uid_t fuid;\n+\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n+\t    if (sb.st_uid == 0 ||\n+\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n+\t\t\t sb.st_uid == fuid)) {\n+\t\tsb = dsb; /* struct assignment */\n+\t    }\n+\t}\n     }\n \n     /* Links have no mode, other types have no linkto */""}<_**next**_>{""sha"": ""c5530de69ca263e2e0e6934bb8de61c05155c85e"", ""filename"": ""tests/rpmverify.at"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 9, ""changes"": 56, ""blob_url"": ""https://github.com/rpm-software-management/rpm/blob/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""raw_url"": ""https://github.com/rpm-software-management/rpm/raw/c815822c8bdb138066ff58c624ae83e3a12ebfa9/tests/rpmverify.at"", ""contents_url"": ""https://api.github.com/repos/rpm-software-management/rpm/contents/tests/rpmverify.at?ref=c815822c8bdb138066ff58c624ae83e3a12ebfa9"", ""patch"": ""@@ -69,18 +69,56 @@ AT_KEYWORDS([verify])\n AT_CHECK([\n RPMDB_CLEAR\n RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n \n-runroot rpm -U --nodeps --noscripts --ignorearch --ignoreos \\\n-\t/data/RPMS/hello-1.0-1.i386.rpm\n-mv \""${RPMTEST}\""/usr/share/doc/hello-1.0 \""${RPMTEST}\""/usr/share/doc/hello-1.0.orig\n-ln -s hello-1.0.orig \""${RPMTEST}\""/usr/share/doc/hello-1.0\n-runroot rpm -Vva --nodeps --nouser --nogroup\n-rm -rf \""${RPMTEST}\""/usr/share/doc/\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+        --define \""user $(id -u -n)\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv replacetest\n ],\n [0],\n-[.........    /usr/local/bin/hello\n-.........    /usr/share/doc/hello-1.0\n-.........  d /usr/share/doc/hello-1.0/FAQ\n+[.........    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n+],\n+[])\n+AT_CLEANUP\n+\n+AT_SETUP([directory replaced with an invalid directory symlink])\n+AT_KEYWORDS([verify])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\""${RPMTEST}\""/opt/foo\n+rm -rf \""${RPMTEST}\""/opt/*\n+rm -rf \""${TOPDIR}\""\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \""ver 1.0\"" \\\n+        --define \""filetype datadir\"" \\\n+        --define \""filedata README1\"" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \""${RPMTEST}\""/opt/foo \""${RPMTEST}\""/opt/was\n+ln -s was \""${RPMTEST}\""/opt/foo\n+runroot rpm -Vv --nouser --nogroup replacetest\n+],\n+[1],\n+[....L....    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n ],\n [])\n AT_CLEANUP""}","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
",C,"    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
","    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
",,"@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
-	vfy |= RPMVERIFY_LSTATFAIL;
-	goto exit;
+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
+	struct stat dsb;
+	/* ...if it actually points to a directory  */
+	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
+	    uid_t fuid;
+	    /* ...and is by a legit user, to match fsmVerify() behavior */
+	    if (sb.st_uid == 0 ||
+			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
+			 sb.st_uid == fuid)) {
+		sb = dsb; /* struct assignment */
+	    }
+	}
     }
 
     /* Links have no mode, other types have no linkto */",rpm,c815822c8bdb138066ff58c624ae83e3a12ebfa9,f2d3be2a8741234faaa96f5fd05fdfdc75779a79,1,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
//flaw_line_below:
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
//flaw_line_below:
	vfy |= RPMVERIFY_LSTATFAIL;
//flaw_line_below:
	goto exit;
//fix_flaw_line_below:
//    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
//fix_flaw_line_below:
//	struct stat dsb;
//fix_flaw_line_below:
//	/* ...if it actually points to a directory  */
//fix_flaw_line_below:
//	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
//fix_flaw_line_below:
//	    uid_t fuid;
//fix_flaw_line_below:
//	    /* ...and is by a legit user, to match fsmVerify() behavior */
//fix_flaw_line_below:
//	    if (sb.st_uid == 0 ||
//fix_flaw_line_below:
//			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
//fix_flaw_line_below:
//			 sb.st_uid == fuid)) {
//fix_flaw_line_below:
//		sb = dsb; /* struct assignment */
//fix_flaw_line_below:
//	    }
//fix_flaw_line_below:
//	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
",182606,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
{
    rpm_mode_t fmode = rpmfilesFMode(fi, ix);
    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);
    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);
    const char * fn = rpmfilesFN(fi, ix);
    struct stat sb;
    rpmVerifyAttrs vfy = RPMVERIFY_NONE;

    /*
     * Check to see if the file was installed - if not pretend all is OK.
     */
    switch (rpmfilesFState(fi, ix)) {
    case RPMFILE_STATE_NETSHARED:
    case RPMFILE_STATE_NOTINSTALLED:
	goto exit;
	break;
    case RPMFILE_STATE_REPLACED:
	/* For replaced files we can only verify if it exists at all */
	flags = RPMVERIFY_LSTATFAIL;
	break;
    case RPMFILE_STATE_WRONGCOLOR:
	/*
	 * Files with wrong color are supposed to share some attributes
	 * with the actually installed file - verify what we can.
	 */
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_RDEV);
	break;
    case RPMFILE_STATE_NORMAL:
    /* File from a non-installed package, try to verify nevertheless */
    case RPMFILE_STATE_MISSING:
	break;
    }

    if (fn == NULL || lstat(fn, &sb) != 0) {
	vfy |= RPMVERIFY_LSTATFAIL;
	goto exit;
     }
 
     /* If we expected a directory but got a symlink to one, follow the link */
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	/* ...if it actually points to a directory  */
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	    /* ...and is by a legit user, to match fsmVerify() behavior */
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb; /* struct assignment */
	    }
	}
     }
 
     /* Links have no mode, other types have no linkto */
    if (S_ISLNK(sb.st_mode))
	flags &= ~(RPMVERIFY_MODE);
    else
	flags &= ~(RPMVERIFY_LINKTO);

    /* Not all attributes of non-regular files can be verified */
    if (!S_ISREG(sb.st_mode))
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_CAPS);

    /* Content checks of %ghost files are meaningless. */
    if (fileAttrs & RPMFILE_GHOST)
	flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |
		   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);

    /* Don't verify any features in omitMask. */
    flags &= ~(omitMask | RPMVERIFY_FAILURES);


    if (flags & RPMVERIFY_FILEDIGEST) {
	const unsigned char *digest; 
	int algo;
	size_t diglen;

	/* XXX If --nomd5, then prelinked library sizes are not corrected. */
	if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {
	    unsigned char fdigest[diglen];
	    rpm_loff_t fsize;

	    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {
		vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);
	    } else {
		sb.st_size = fsize;
		if (memcmp(fdigest, digest, diglen))
		    vfy |= RPMVERIFY_FILEDIGEST;
	    }
	} else {
	    vfy |= RPMVERIFY_FILEDIGEST;
	} 
    } 

    if (flags & RPMVERIFY_LINKTO) {
	char linkto[1024+1];
	int size = 0;

	if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)
	    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);
	else {
	    const char * flink = rpmfilesFLink(fi, ix);
	    linkto[size] = '\0';
	    if (flink == NULL || !rstreq(linkto, flink))
		vfy |= RPMVERIFY_LINKTO;
	}
    } 

    if (flags & RPMVERIFY_FILESIZE) {
	if (sb.st_size != rpmfilesFSize(fi, ix))
	    vfy |= RPMVERIFY_FILESIZE;
    } 

    if (flags & RPMVERIFY_MODE) {
	rpm_mode_t metamode = fmode;
	rpm_mode_t filemode;

	/*
	 * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)
	 * need the (rpm_mode_t) cast here. 
	 */
	filemode = (rpm_mode_t)sb.st_mode;

	/*
	 * Comparing the type of %ghost files is meaningless, but perms are OK.
	 */
	if (fileAttrs & RPMFILE_GHOST) {
	    metamode &= ~0xf000;
	    filemode &= ~0xf000;
	}

	if (metamode != filemode)
	    vfy |= RPMVERIFY_MODE;

#if WITH_ACL
	/*
	 * For now, any non-default acl's on a file is a difference as rpm
	 * cannot have set them.
	 */
	acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);
	if (facl) {
	    if (acl_equiv_mode(facl, NULL) == 1) {
		vfy |= RPMVERIFY_MODE;
	    }
	    acl_free(facl);
	}
#endif 
    }

    if (flags & RPMVERIFY_RDEV) {
	if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)
	 || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))
	{
	    vfy |= RPMVERIFY_RDEV;
	} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {
	    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);
	    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);
	    if (st_rdev != frdev)
		vfy |= RPMVERIFY_RDEV;
	} 
    }

#if WITH_CAP
    if (flags & RPMVERIFY_CAPS) {
	/*
 	 * Empty capability set (""="") is not exactly the same as no
 	 * capabilities at all but suffices for now... 
 	 */
	cap_t cap, fcap;
	cap = cap_from_text(rpmfilesFCaps(fi, ix));
	if (!cap) {
	    cap = cap_from_text(""="");
	}
	fcap = cap_get_file(fn);
	if (!fcap) {
	    fcap = cap_from_text(""="");
	}
	
	if (cap_compare(cap, fcap) != 0)
	    vfy |= RPMVERIFY_CAPS;

	cap_free(fcap);
	cap_free(cap);
    }
#endif

    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {
	vfy |= RPMVERIFY_MTIME;
    }

    if (flags & RPMVERIFY_USER) {
	const char * name = rpmugUname(sb.st_uid);
	const char * fuser = rpmfilesFUser(fi, ix);
	uid_t uid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fuser)
	   namematch =  rstreq(name, fuser);
	if (fuser && rpmugUid(fuser, &uid) == 0)
	    idmatch = (uid == sb.st_uid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate username or UID for user %s\n""), fuser);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_USER;
    }

    if (flags & RPMVERIFY_GROUP) {
	const char * name = rpmugGname(sb.st_gid);
	const char * fgroup = rpmfilesFGroup(fi, ix);
	gid_t gid;
	int namematch = 0;
	int idmatch = 0;

	if (name && fgroup)
	    namematch = rstreq(name, fgroup);
	if (fgroup && rpmugGid(fgroup, &gid) == 0)
	    idmatch = (gid == sb.st_gid);

	if (namematch != idmatch) {
	    rpmlog(RPMLOG_WARNING,
		    _(""Duplicate groupname or GID for group %s\n""), fgroup);
	}

	if (!(namematch || idmatch))
	    vfy |= RPMVERIFY_GROUP;
    }

exit:
    return vfy;
}
","The `rpmfilesVerify` function is designed to verify various attributes of files associated with RPM packages. It checks the installation state of the file, and if it is installed, it retrieves its mode, attributes, and flags. The function performs a series of checks, including file existence, type, size, permissions, and ownership, while considering specific conditions for ghost files and omitted attributes. It utilizes system calls like `lstat` and `readlink` to gather file information and compares it against expected values from the RPM database. The function ultimately returns a set of verification flags indicating any discrepancies found during the checks.","The provided code verifies the attributes of files associated with RPM packages by checking their installation status and various properties such as existence, type, size, permissions, and ownership. It handles different scenarios, including files that are not installed, replaced, or marked as ghost files, adjusting the verification checks accordingly. The code uses system calls to gather file information and compares it against expected values from the package database. Ultimately, it returns a set of flags indicating any discrepancies found during the verification process, ensuring the integrity and correctness of the installed files.","The vulnerability in the original code stemmed from inadequate handling of symbolic links pointing to directories, which could allow an attacker to manipulate the installation path, potentially leading to unauthorized changes in ownership and permissions of arbitrary directories. This could enable an attacker with write access to redirect installations to unintended locations, risking privilege escalation. The fixed code addresses this by adding a check to ensure that if a symbolic link is encountered, it verifies that the link points to a legitimate directory and that the user associated with the link matches the expected user, thereby preventing unauthorized access and ensuring proper ownership during installation.","The vulnerability in the original code allowed an attacker to exploit symbolic links pointing to directories, which could lead to unauthorized changes in ownership and permissions of arbitrary directories during RPM installations. This could enable an attacker with write access to redirect installations to unintended locations, potentially gaining elevated privileges. The fixed code addresses this issue by implementing checks to ensure that if a symbolic link is encountered, it verifies that the link points to a legitimate directory and that the user associated with the link has the appropriate permissions, thereby preventing unauthorized access and ensuring correct ownership during the installation process.","The vulnerability was fixed by adding a check for symbolic links that point to directories. In the updated code, when a symbolic link is encountered, it first uses a system call to retrieve the status of the target directory. It then verifies that the link points to an actual directory and checks the user ID of the symbolic link against the expected user ID. This is done using the comparison of `sb.st_uid` with the user ID obtained from the RPM database. If the checks pass, the directory's status is updated, ensuring that only legitimate directories are used during the installation process.","The vulnerability was fixed by implementing additional checks for symbolic links that point to directories during the installation process. The updated code verifies that if a symbolic link is encountered, it confirms that the link points to a valid directory and checks the ownership of that directory against the expected user. This ensures that only legitimate directories are used for installation, preventing unauthorized changes to arbitrary directories. By enforcing these checks, the code mitigates the risk of privilege escalation and ensures that installations occur in the intended locations with the correct permissions.","4, 5","5, 5","5,4","5,5"
8,8,183242,183242,,Local,Not required,,CVE-2017-7418,https://www.cvedetails.com/cve/CVE-2017-7418/,CWE-59,Low,,Partial,,2017-04-04,2.1,"ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",2019-08-08,Bypass ,5,https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,"Backporting recursive handling of DefaultRoot path, when AllowChrootSymlinks
is off, to 1.3.5 branch.",13,modules/mod_auth.c,"{""sha"": ""410215979a91ad5056eab1d8a301a06312e65be8"", ""filename"": ""modules/mod_auth.c"", ""status"": ""modified"", ""additions"": 65, ""deletions"": 18, ""changes"": 83, ""blob_url"": ""https://github.com/proftpd/proftpd/blob/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""raw_url"": ""https://github.com/proftpd/proftpd/raw/ecff21e0d0e84f35c299ef91d7fda088e516d4ed/modules/mod_auth.c"", ""contents_url"": ""https://api.github.com/repos/proftpd/proftpd/contents/modules/mod_auth.c?ref=ecff21e0d0e84f35c299ef91d7fda088e516d4ed"", ""patch"": ""@@ -2,7 +2,7 @@\n  * ProFTPD - FTP server daemon\n  * Copyright (c) 1997, 1998 Public Flood Software\n  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n- * Copyright (c) 2001-2016 The ProFTPD Project team\n+ * Copyright (c) 2001-2017 The ProFTPD Project team\n  *\n  * This program is free software; you can redistribute it and/or modify\n  * it under the terms of the GNU General Public License as published by\n@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n-/* Determine if the user (non-anon) needs a default root dir other than /.\n- */\n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache();\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n \n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+\n+    /* Make sure our pointer actually changed position. */\n+    if (new_pathlen == pathlen) {\n+      return 0;\n+    }\n+\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \""AllowChrootSymlink: path '%s' not a symlink, checking '%s'\"", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+/* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache();\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \""error: unable to check %s: %s\"", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \""error: DefaultRoot %s is a symlink \""\n+              \""(denied by AllowChrootSymlinks config)\"", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \""\n-            \""config)\"", path);\n           errno = EPERM;\n           return -1;\n         }""}"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",C,"        res = is_symlink_path(p, path, pathlen);
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
","        struct stat st;
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
",,"@@ -2,7 +2,7 @@
  * ProFTPD - FTP server daemon
  * Copyright (c) 1997, 1998 Public Flood Software
  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
- * Copyright (c) 2001-2016 The ProFTPD Project team
+ * Copyright (c) 2001-2017 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -688,9 +688,66 @@ static char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
-/* Determine if the user (non-anon) needs a default root dir other than /.
- */
+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
+  int res, xerrno = 0;
+  struct stat st;
+  char *ptr;
+
+  if (pathlen == 0) {
+    return 0;
+  }
+
+  pr_fs_clear_cache();
+  res = pr_fsio_lstat(path, &st);
+  if (res < 0) {
+    xerrno = errno;
+
+    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
+      strerror(xerrno));
+
+    errno = xerrno;
+    return -1;
+  }
 
+  if (S_ISLNK(st.st_mode)) {
+    errno = EPERM;
+    return -1;
+  }
+
+  /* To handle the case where a component further up the path might be a
+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,
+   * calling ourselves recursively.
+   */
+
+  ptr = strrchr(path, '/');
+  if (ptr != NULL) {
+    char *new_path;
+    size_t new_pathlen;
+
+    pr_signals_handle();
+
+    new_pathlen = ptr - path;
+
+    /* Make sure our pointer actually changed position. */
+    if (new_pathlen == pathlen) {
+      return 0;
+    }
+
+    new_path = pstrndup(p, path, new_pathlen);
+
+    pr_log_debug(DEBUG10,
+      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
+      new_path);
+    res = is_symlink_path(p, new_path, new_pathlen);
+    if (res < 0) {
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+/* Determine if the user (non-anon) needs a default root dir other than /. */
 static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
@@ -733,7 +790,6 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
-        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
@@ -764,22 +820,13 @@ static int get_default_root(pool *p, int allow_symlinks, char **root) {
           path[pathlen-1] = '\0';
         }
 
-        pr_fs_clear_cache();
-        res = pr_fsio_lstat(path, &st);
+        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
-          xerrno = errno;
-
-          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
-            strerror(xerrno));
-
-          errno = xerrno;
-          return -1;
-        }
+          if (errno == EPERM) {
+            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
+              ""(denied by AllowChrootSymlinks config)"", path);
+          }
 
-        if (S_ISLNK(st.st_mode)) {
-          pr_log_pri(PR_LOG_WARNING,
-            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
-            ""config)"", path);
           errno = EPERM;
           return -1;
         }",proftpd,ecff21e0d0e84f35c299ef91d7fda088e516d4ed,5a2ca0f12723c6fa9bdaa4faa1c2979335e50b07,1," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
//flaw_line_below:
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
//flaw_line_below:
        pr_fs_clear_cache();
//flaw_line_below:
        res = pr_fsio_lstat(path, &st);
//fix_flaw_line_below:
//        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
//flaw_line_below:
          xerrno = errno;
//flaw_line_below:

//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
//flaw_line_below:
            strerror(xerrno));
//flaw_line_below:

//flaw_line_below:
          errno = xerrno;
//flaw_line_below:
          return -1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//          if (errno == EPERM) {
//fix_flaw_line_below:
//            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
//fix_flaw_line_below:
//              ""(denied by AllowChrootSymlinks config)"", path);
//fix_flaw_line_below:
//          }
 
//flaw_line_below:
        if (S_ISLNK(st.st_mode)) {
//flaw_line_below:
          pr_log_pri(PR_LOG_WARNING,
//flaw_line_below:
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
//flaw_line_below:
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
",183242," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
 
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
"," static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  int res;

  c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
  while (c) {
    pr_signals_handle();

    /* Check the groups acl */
    if (c->argc < 2) {
      dir = c->argv[0];
      break;
    }

    res = pr_expr_eval_group_and(((char **) c->argv)+1);
    if (res) {
      dir = c->argv[0];
      break;
    }

    c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
  }

  if (dir) {
    char *new_dir;

    /* Check for any expandable variables. */
    new_dir = path_subst_uservar(p, &dir);
    if (new_dir != NULL) {
      dir = new_dir;
    }

    if (strncmp(dir, ""/"", 2) == 0) {
      dir = NULL;

    } else {
      char *realdir;
      int xerrno = 0;
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
         * do this for us, but dir_realpath() ALSO automatically follows
         * symlinks, which is what we do NOT want to do here.
         */

        path = dir;
        if (*path != '/') {
          if (*path == '~') {
            if (pr_fs_interpolate(dir, target_path,
                sizeof(target_path)-1) < 0) {
              return -1;
            }

            path = target_path;
          }
        }

        /* Note: lstat(2) is sensitive to the presence of a trailing slash on
         * the path, particularly in the case of a symlink to a directory.
         * Thus to get the correct test, we need to remove any trailing slash
         * that might be present.  Subtle.
         */
        pathlen = strlen(path);
        if (pathlen > 1 &&
            path[pathlen-1] == '/') {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }
      }

      /* We need to be the final user here so that if the user has their home
       * directory with a mode the user proftpd is running (i.e. the User
       * directive) as can not traverse down, we can still have the default
       * root.
       */

      PRIVS_USER
      realdir = dir_realpath(p, dir);
      xerrno = errno;
      PRIVS_RELINQUISH

      if (realdir) {
        dir = realdir;

      } else {
        /* Try to provide a more informative message. */
        char interp_dir[PR_TUNABLE_PATH_MAX + 1];

        memset(interp_dir, '\0', sizeof(interp_dir));
        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 

        pr_log_pri(PR_LOG_NOTICE,
          ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
          dir, interp_dir, strerror(xerrno));

        errno = xerrno;
      }
    }
  }

  *root = dir;
  return 0;
}
","The `get_default_root` function retrieves the default root directory for a server configuration, allowing for optional symbolic link handling. It searches for the ""DefaultRoot"" parameter in the server's configuration, evaluating access control conditions for each entry. If a valid directory is found, it processes any user variables and checks if the directory is a symbolic link (if disallowed). The function resolves the directory path, ensuring it is accessible, and logs any errors encountered during this process. Finally, it assigns the resolved directory to the provided pointer and returns a status code indicating success or failure.","The function retrieves the default root directory for a server configuration, checking for specific parameters and evaluating access control conditions. It processes the directory to handle user-defined variables and verifies whether symbolic links are permitted. If symbolic links are not allowed, it checks the directory's status to ensure it is not a link and resolves the path to confirm accessibility. Any errors encountered during this process are logged for clarity. Ultimately, the resolved directory is assigned to an output pointer, and the function returns a status code indicating success or failure.","The vulnerability in the original code stemmed from inadequate checks on symbolic links, allowing attackers to bypass the `AllowChrootSymlinks` configuration by replacing any path component except the last one with a symbolic link. This oversight could lead to unauthorized access to restricted directories. The fixed code addresses this by implementing a dedicated function, `is_symlink_path`, which thoroughly checks the entire path for symbolic links, ensuring that all components are validated against the configuration. This enhancement prevents attackers from exploiting symbolic links in the home directory, thereby reinforcing security.","The vulnerability in the original code allowed attackers to bypass security controls regarding symbolic links by only checking the last component of a directory path. This oversight meant that an attacker could replace any preceding path component with a symbolic link, potentially gaining unauthorized access to restricted areas of the filesystem. The fixed code addresses this issue by implementing a comprehensive check for symbolic links throughout the entire path, rather than just the last component. This enhancement ensures that all parts of the directory structure are validated against the security configuration, effectively mitigating the risk of exploitation.","The vulnerability was fixed by introducing a dedicated function, `is_symlink_path`, which checks the entire directory path for symbolic links instead of only the last component. In the updated code, this function is called to validate the path before proceeding with further operations. If a symbolic link is detected, an error is logged, and the function returns an appropriate status code. This comprehensive check ensures that all components of the path are scrutinized against the `AllowChrootSymlinks` configuration, effectively preventing attackers from exploiting symbolic links to gain unauthorized access to restricted directories.","The vulnerability was fixed by implementing a thorough check for symbolic links throughout the entire directory path, rather than just the last component. This enhancement ensures that every part of the path is validated against the security configuration, effectively preventing attackers from exploiting symbolic links to bypass access controls. The updated code introduces a dedicated function that performs this comprehensive check, logging any errors if a symbolic link is detected. This approach significantly strengthens the security posture by ensuring that all components of the directory structure are properly scrutinized before granting access.","5,5","5,5","5,4","4,4"
9,9,183310,183310,,Local,Not required,Complete,CVE-2015-3315,https://www.cvedetails.com/cve/CVE-2015-3315/,CWE-59,Low,Complete,Complete,,2017-06-26,7.2,"Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",2018-02-18,,1,https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7,d6e2f6f128cef4c21cb80941ae674c9842681aa7,"ccpp: open file for dump_fd_info with O_EXCL

To avoid possible races.

Related: #1211835

Signed-off-by: Jakub Filak <jfilak@redhat.com>",1,src/hooks/abrt-hook-ccpp.c,"{""sha"": ""ece1ecebc00cabdb05bb06a6d80a6289d58968b7"", ""filename"": ""src/hooks/abrt-hook-ccpp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/abrt/abrt/blob/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""raw_url"": ""https://github.com/abrt/abrt/raw/d6e2f6f128cef4c21cb80941ae674c9842681aa7/src/hooks/abrt-hook-ccpp.c"", ""contents_url"": ""https://api.github.com/repos/abrt/abrt/contents/src/hooks/abrt-hook-ccpp.c?ref=d6e2f6f128cef4c21cb80941ae674c9842681aa7"", ""patch"": ""@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu\n \n static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n-    FILE *fp = fopen(dest_filename, \""w\"");\n+    FILE *fp = fopen(dest_filename, \""wx\"");\n     if (!fp)\n         return false;\n ""}"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
",C,"    FILE *fp = fopen(dest_filename, ""wx"");
","    FILE *fp = fopen(dest_filename, ""w"");
",,"@@ -399,7 +399,7 @@ static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
 
 static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
-    FILE *fp = fopen(dest_filename, ""w"");
+    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 ",abrt,d6e2f6f128cef4c21cb80941ae674c9842681aa7,4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,1," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
//flaw_line_below:
    FILE *fp = fopen(dest_filename, ""w"");
//fix_flaw_line_below:
//    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
",183310," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
"," static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 
    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

    fclose(fp);
    return true;
}
","The `dump_fd_info` function is designed to gather and write information about file descriptors from a source directory to a specified destination file. It opens the destination file for writing and iterates through potential file descriptors (0 to 99999), constructing paths to both the `fd` and `fdinfo` directories. For each valid file descriptor, it retrieves the symbolic link target and writes it to the destination file, followed by the contents of the corresponding `fdinfo` file. After processing, it attempts to change the ownership of the destination file to the specified user ID and group ID, handling errors appropriately before closing the file and returning a success status.","The provided code defines a function that collects and writes information about file descriptors to a specified output file. It opens the output file for writing and iterates through a range of possible file descriptors, constructing paths to retrieve both the symbolic link targets and associated information. For each valid descriptor, it writes the link target and the contents of the corresponding information file to the output file. After processing all descriptors, the function attempts to change the ownership of the output file to specified user and group identifiers, handling any errors before closing the file and returning a success status.","The vulnerability in the original code arises from the use of the `fopen` function with the ""w"" mode, which allows for a symlink attack, enabling local users to manipulate arbitrary files by creating symbolic links to sensitive locations. This could lead to unauthorized file access or modification. The fix implemented in the changed code involves using the ""wx"" mode with `fopen`, which ensures that the file is created exclusively and fails if the file already exists, thereby mitigating the risk of symlink attacks and ensuring that only legitimate files are created and accessed.","The vulnerability in the original code stems from the potential for a symlink attack, where an attacker could create a symbolic link to a sensitive file, allowing unauthorized access or modification when the code attempts to write to a file. This issue is classified under the relevant CWE ID due to the risk of manipulating file paths. The fix in the updated code addresses this vulnerability by changing the file opening mode to one that ensures the file is created exclusively, preventing the code from overwriting existing files and thereby mitigating the risk of symlink attacks and unauthorized file manipulation.","The vulnerability was fixed by changing the file opening mode in the `fopen` function from ""w"" to ""wx"". The ""wx"" mode ensures that the file is created exclusively, meaning that if the destination file already exists, the operation will fail instead of overwriting it. This change prevents potential symlink attacks, as it eliminates the risk of an attacker creating a symbolic link to a sensitive file that could be inadvertently modified. By enforcing this exclusive creation, the code enhances security and protects against unauthorized file access or manipulation.","The vulnerability was fixed by modifying the file opening method to ensure exclusive creation of the output file. This change prevents the code from overwriting an existing file, which could be exploited through a symlink attack. By enforcing that the file must not already exist for the operation to succeed, the fix mitigates the risk of unauthorized access or modification of sensitive files. This enhancement strengthens the security of the code by ensuring that only legitimate files are created and accessed, thereby protecting against potential manipulation by malicious users.","4,4","5,5","5,5","5,5"
