,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,182200,182200,,Remote,Not required,,CVE-2018-17082,https://www.cvedetails.com/cve/CVE-2018-17082/,CWE-79,Medium,,Partial,,2018-09-16,4.3,"The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.",2019-08-19,XSS ,1,https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e,23b057742e3cf199612fa8050ae86cae675e214e,"Fix for bug #76582

The brigade seems to end up in a messed up state if something fails
in shutdown, so we clean it up.",0,sapi/apache2handler/sapi_apache2.c,"{""sha"": ""0ebca9bca863909aef3fd3417bb3baad1605df34"", ""filename"": ""sapi/apache2handler/sapi_apache2.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""raw_url"": ""https://github.com/php/php-src/raw/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/apache2handler/sapi_apache2.c?ref=23b057742e3cf199612fa8050ae86cae675e214e"", ""patch"": ""@@ -678,6 +678,7 @@ zend_first_try {\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n ""}","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",C,"		apr_brigade_cleanup(brigade);
",,,"@@ -678,6 +678,7 @@ zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
+		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 ",php-src,23b057742e3cf199612fa8050ae86cae675e214e,1ba3314335b8bb7c86c24443588d5ef9c55d4a44,1,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
//fix_flaw_line_below:
//		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",182200,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","The provided code defines a function `php_handler` that processes incoming HTTP requests for PHP scripts in an Apache server environment. It initializes a context for the PHP request, applies configuration settings, and checks various conditions such as the request handler type and file type. If the request is valid, it sets up CGI variables and executes the PHP script or highlights the source code if requested. The function also manages memory usage tracking and handles cleanup after the request is processed. Finally, it returns an appropriate HTTP status code based on the outcome of the request processing.","The code defines a function that handles HTTP requests for PHP scripts within a web server environment. It initializes a context for processing, applies configuration settings, and checks the validity of the request based on various criteria, such as the type of handler and file. If the request is deemed valid, it sets up necessary environment variables and either executes the PHP script or displays the source code. The function also tracks memory usage and ensures proper cleanup after processing, ultimately returning an appropriate HTTP status code based on the request's outcome.","The vulnerability, identified as CWE-79, arises from improper handling of the bucket brigade in the request processing function, which allows for cross-site scripting (XSS) attacks via chunked transfer encoding. Specifically, the code fails to adequately sanitize or validate the content being processed, potentially allowing malicious input to be executed in the context of the web application. The fix involves ensuring that the bucket brigade is properly managed and cleaned up after processing, as seen in the addition of cleanup calls and checks for the request's validity, which mitigate the risk of executing untrusted content and enhance overall security.","The vulnerability, classified as CWE-79, allows for cross-site scripting (XSS) attacks due to improper handling of input in chunked transfer encoding requests. This occurs when the server processes potentially malicious content without adequate validation or sanitization, enabling attackers to inject harmful scripts that could be executed in the context of a user's session. The fix addresses this issue by implementing stricter management of the input data, ensuring that the content is properly validated and cleaned up after processing. This enhances security by preventing the execution of untrusted input and mitigating the risk of XSS attacks.","The vulnerability was fixed by enhancing the management of the bucket brigade and ensuring proper cleanup after processing requests. The code now includes calls to `apr_brigade_cleanup` to clear the brigade, preventing any residual data from being executed. Additionally, the checks for the request's validity were strengthened, particularly in the conditions that handle the request type and file type. The use of `php_apache_request_dtor` ensures that the server context is properly disposed of after each request, thereby mitigating the risk of executing untrusted content and addressing the XSS vulnerability effectively.","The vulnerability was fixed by implementing stricter management of input data and ensuring thorough cleanup after processing requests. The code now includes mechanisms to validate and sanitize the content being processed, which prevents the execution of potentially malicious scripts. Additionally, the cleanup routines were enhanced to ensure that any residual data from previous requests is properly cleared, reducing the risk of cross-site scripting attacks. Overall, these changes improve the security of the request handling process by ensuring that only safe and validated content is executed.","4, 4","2, 4","4,4","4,4"
1,1,184492,184492,,Remote,Not required,,CVE-2012-2872,https://www.cvedetails.com/cve/CVE-2012-2872/,CWE-79,Medium,,Partial,,2012-08-31,4.3,Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.,2018-10-30,XSS ,3,https://github.com/chromium/chromium/commit/68b6502084af7e2021f7321633f5fbb5f997a58b,68b6502084af7e2021f7321633f5fbb5f997a58b,"Properly EscapeForHTML potentially malicious input from X.509 certificates.

BUG=142956

TEST=Create an X.509 certificate with a CN field that contains JavaScript.
When you get the SSL error screen, check that the HTML + JavaScript is
escape instead of being treated as HTML and/or script.

Review URL: https://chromiumcodereview.appspot.com/10827364

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@152210 0039d316-1c4b-4281-b951-d872f2087c98",2,chrome/browser/ssl/ssl_error_info.cc,"{""sha"": ""d33960e55ff85b6899415bd0be1f0f9e14daca04"", ""filename"": ""chrome/browser/ssl/ssl_error_info.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ssl/ssl_error_info.cc?ref=68b6502084af7e2021f7321633f5fbb5f997a58b"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""grit/chromium_strings.h\""\n #include \""grit/generated_resources.h\""\n #include \""net/base/cert_status_flags.h\""\n+#include \""net/base/escape.h\""\n #include \""net/base/net_errors.h\""\n #include \""net/base/ssl_info.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n-                                     UTF8ToUTF16(dns_names[i]),\n+                                     net::EscapeForHTML(\n+                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n-              UTF8ToUTF16(cert->subject().common_name),\n+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }""}","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",C,"                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
","                                     UTF8ToUTF16(dns_names[i]),
              UTF8ToUTF16(cert->subject().common_name),
",,"@@ -12,6 +12,7 @@
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
 #include ""net/base/cert_status_flags.h""
+#include ""net/base/escape.h""
 #include ""net/base/net_errors.h""
 #include ""net/base/ssl_info.h""
 #include ""ui/base/l10n/l10n_util.h""
@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
-                                     UTF8ToUTF16(dns_names[i]),
+                                     net::EscapeForHTML(
+                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
-              UTF8ToUTF16(cert->subject().common_name),
+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }",Chrome,68b6502084af7e2021f7321633f5fbb5f997a58b,4150ecc30d10d0f211033346f10611e3c6083160,1,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      // If the certificate contains multiple DNS names, we choose the most
      // representative one -- either the DNS name that's also in the subject
      // field, or the first one.  If this heuristic turns out to be
      // inadequate, we can consider choosing the DNS name that is the
      // ""closest match"" to the host name in the request URL, or listing all
      // the DNS names with an HTML <ul>.
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
//flaw_line_below:
                                     UTF8ToUTF16(dns_names[i]),
//fix_flaw_line_below:
//                                     net::EscapeForHTML(
//fix_flaw_line_below:
//                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
//flaw_line_below:
              UTF8ToUTF16(cert->subject().common_name),
//fix_flaw_line_below:
//              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        // Then it must be not yet valid.  We don't check that it is not yet
        // valid as there is still a very unlikely chance that the cert might
        // have become valid since the error occurred.
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",184492,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","The `SSLErrorInfo::CreateError` function generates detailed error information related to SSL certificate issues based on the specified `ErrorType`. It constructs a title, detailed message, short description, and additional information for various certificate errors, such as invalid common names, expired certificates, or weak keys. The function utilizes localization utilities to retrieve user-friendly strings and formats them with relevant data, including the request URL and certificate details. Finally, it returns an `SSLErrorInfo` object encapsulating this information, which can be used to inform users about the nature of the SSL error encountered.","The provided code defines a function that generates detailed error information for various SSL certificate issues. Depending on the type of error encountered, it constructs a title, detailed explanation, short description, and additional context to help users understand the problem. The function retrieves localized strings to ensure user-friendly messages and formats them with relevant data, such as the request URL and certificate specifics. Ultimately, it returns an object containing all this information, which can be utilized to inform users about the specific SSL error and guide them in addressing the issue.","The vulnerability in the original code stemmed from the lack of proper sanitization of user input, specifically when displaying certificate details, which could allow for cross-site scripting (XSS) attacks. Attackers could inject malicious scripts through the certificate's common name or DNS names, leading to potential exploitation. The fixed code addresses this issue by incorporating a sanitization function, `net::EscapeForHTML`, to escape potentially harmful characters in the common name and DNS names before they are included in the output details. This ensures that any user input is rendered harmless, effectively mitigating the XSS risk.","The vulnerability in the original code was due to insufficient sanitization of user input, which could allow attackers to inject malicious scripts into the SSL interstitial page, leading to cross-site scripting (XSS) attacks. This risk arose from displaying potentially unsafe data, such as certificate details, without proper encoding. The fixed code mitigated this vulnerability by implementing a sanitization process that escapes harmful characters in user-provided data before rendering it in the output. This ensures that any injected scripts are neutralized, thereby protecting users from XSS attacks and enhancing the overall security of the application.","The vulnerability was fixed by incorporating the `net::EscapeForHTML` function to sanitize user input before it is displayed in the output. Specifically, this function was applied to the common name and DNS names retrieved from the certificate, ensuring that any potentially harmful characters are escaped. For instance, in the details string for the common name invalid error, the sanitized DNS name is now included using `net::EscapeForHTML(UTF8ToUTF16(dns_names[i]))`, and similarly for the certificate's subject common name. This change effectively neutralizes any malicious scripts, thereby preventing cross-site scripting (XSS) attacks.","The vulnerability was fixed by implementing a sanitization process that encodes potentially harmful characters in user input before it is displayed in the output. This involved applying a specific function to escape any unsafe content derived from the certificate details, such as the common name and DNS names. By ensuring that any user-provided data is properly sanitized, the code prevents the execution of malicious scripts that could lead to cross-site scripting (XSS) attacks. This enhancement significantly improves the security of the application by neutralizing threats associated with untrusted input.","5,5","5,5","4, 4","4,4"
2,2,185960,185960,,Remote,Not required,,CVE-2016-5147,https://www.cvedetails.com/cve/CVE-2016-5147/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles deferred page loads, which allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2017-08-12,XSS ,3,https://github.com/chromium/chromium/commit/5472db1c7eca35822219d03be5c817d9a9258c11,5472db1c7eca35822219d03be5c817d9a9258c11,"Always call UpdateCompositedScrollOffset, not just for the root layer

Bug: 927560
Change-Id: I1d5522aae4f11dd3f5b8947bb089bac1bf19bdb4
Reviewed-on: https://chromium-review.googlesource.com/c/1452701
Reviewed-by: Chris Harrelson <chrishtr@chromium.org>
Commit-Queue: Mason Freed <masonfreed@chromium.org>
Cr-Commit-Position: refs/heads/master@{#628942}",1,third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc,"{""sha"": ""7f1f0a4890e03135c6d704b67d0de508ffda6c7d"", ""filename"": ""third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc?ref=5472db1c7eca35822219d03be5c817d9a9258c11"", ""patch"": ""@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n-        Layer()->IsRootLayer() && scrolling_coordinator &&\n+        (Layer()->IsRootLayer() ||\n+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&\n+        scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {""}","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",C,"        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
","        Layer()->IsRootLayer() && scrolling_coordinator &&
",,"@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
-        Layer()->IsRootLayer() && scrolling_coordinator &&
+        (Layer()->IsRootLayer() ||
+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
+        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {",Chrome,5472db1c7eca35822219d03be5c817d9a9258c11,756828f7b127d39fb9863dc0c5db67640a88724f,1,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
//flaw_line_below:
        Layer()->IsRootLayer() && scrolling_coordinator &&
//fix_flaw_line_below:
//        (Layer()->IsRootLayer() ||
//fix_flaw_line_below:
//         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
//fix_flaw_line_below:
//        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        // In non-BGPT mode, we need to do a full sub-tree update here, because
        // we need to update the position property to compute
        // offset_to_transform_parent. For more context, see the comment from
        // chrishtr@ here:
        // https://chromium-review.googlesource.com/c/chromium/src/+/1403639/6/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    // If we have fixed elements and we scroll the root layer we might
    // change compositing since the fixed elements might now overlap a
    // composited layer.
    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185960,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","The `UpdateCompositingLayersAfterScroll` function is responsible for managing the update of compositing layers in a scrollable area after a scroll event occurs. It first checks if the compositor is in compositing mode and whether composited scrolling is being used. If so, it attempts to update the scroll offset through the scrolling coordinator for root layers. If the scroll is not handled, it marks the layer for a graphics update unless certain runtime features are enabled. Additionally, if the layer is a root layer and the associated frame has viewport-constrained objects, it requests an update for compositing inputs, ensuring that the visual representation remains accurate after scrolling.","The function manages the updates of compositing layers in a scrollable area following a scroll event. It first verifies if the compositor is active and whether composited scrolling is in use. If so, it attempts to adjust the scroll offset for the main layer. If the adjustment is not successful, it marks the layer for a graphics update unless specific features are enabled. Additionally, if the layer is the main one and the associated frame contains constrained objects, it requests an update for compositing inputs, ensuring that the visual output accurately reflects any changes resulting from the scroll.","The vulnerability in the original code stemmed from improper handling of scroll events, which could allow attackers to inject arbitrary scripts through crafted web pages, leading to Universal XSS. Specifically, the lack of checks on whether the layer was a root layer or if certain runtime features were enabled allowed for unsafe updates to the scroll offset. The fixed code introduced a condition that ensures the scroll offset is only updated if the layer is a root layer or if specific features are enabled, thereby mitigating the risk of script injection by enforcing stricter validation before processing scroll events.","The vulnerability in the original code allowed for Universal XSS due to inadequate validation during the handling of scroll events, which could be exploited by attackers to inject malicious scripts through specially crafted web pages. This occurred because the code did not sufficiently check the conditions under which scroll offsets were updated, potentially leading to unsafe interactions. The fixed code addressed this issue by introducing stricter conditions that ensure updates to scroll offsets only occur under specific circumstances, thereby preventing unauthorized script execution and enhancing the overall security against such injection attacks.","The vulnerability was fixed by modifying the condition that determines whether the scroll offset should be updated. In the updated code, the check now ensures that the scroll offset is only handled if the layer is a root layer or if specific runtime features are enabled. This is achieved through the expression that combines the checks for the root layer and the enabled features before calling the scrolling coordinator to update the composited scroll offset. By enforcing these stricter conditions, the code mitigates the risk of arbitrary script injection, thereby enhancing security against Universal XSS attacks.","The vulnerability was fixed by implementing stricter validation checks before allowing updates to the scroll offset. The updated code ensures that such updates only occur under specific conditions, which include verifying the type of layer involved and whether certain runtime features are active. This additional layer of checks prevents unauthorized modifications that could lead to script injection, thereby addressing the potential for Universal XSS attacks. By limiting the circumstances under which scroll offsets can be processed, the code enhances security and reduces the risk of exploitation through crafted web pages.","4,4","5,5","4,4","4,3"
3,3,186016,186016,,Remote,Not required,,CVE-2016-5191,https://www.cvedetails.com/cve/CVE-2016-5191/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:",2018-01-04,XSS ,12,https://github.com/chromium/chromium/commit/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,"Prevent interpretating userinfo as url scheme when editing bookmarks

Chrome's Edit Bookmark dialog formats urls for display such that a
url of http://javascript:scripttext@host.com is later converted to a
javascript url scheme, allowing persistence of a script injection
attack within the user's bookmarks.

This fix prevents such misinterpretations by always showing the
scheme when a userinfo component is present within the url.

BUG=639126

Review-Url: https://codereview.chromium.org/2368593002
Cr-Commit-Position: refs/heads/master@{#422467}",4,chrome/browser/ui/bookmarks/bookmark_utils.cc,"{""sha"": ""ffebacaa0f6864fd57e0d0cda9b2dbb08552a13c"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 5, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {\n \n base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n-  // and trailing slash, and unescape most characters.  However, it's\n+  // and trailing slash, and unescape most characters. However, it's\n   // important not to drop any username/password, or unescape anything that\n   // changes the URL's meaning.\n-  return url_formatter::FormatUrl(\n-      url, url_formatter::kFormatUrlOmitAll &\n-               ~url_formatter::kFormatUrlOmitUsernamePassword,\n-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n+  url_formatter::FormatUrlTypes format_types =\n+      url_formatter::kFormatUrlOmitAll &\n+      ~url_formatter::kFormatUrlOmitUsernamePassword;\n+\n+  // If username is present, we must not omit the scheme because FixupURL() will\n+  // subsequently interpret the username as a scheme. crbug.com/639126\n+  if (url.has_username())\n+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n+\n+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n+                                  nullptr, nullptr, nullptr);\n }\n \n bool IsAppsShortcutEnabled(Profile* profile) {""}<_**next**_>{""sha"": ""1a5bf29d3599fce20c987c7c997a9c80aa331c7a"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.h?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -53,9 +53,8 @@ void GetURLAndTitleToBookmark(content::WebContents* web_contents,\n // all tabs. This is a preference modifier, not a visual modifier.\n void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context);\n \n-// Returns a formatted version of |url| appropriate to display to a user with\n-// the given |prefs|, which may be NULL.  When re-parsing this URL, clients\n-// should call url_formatter::FixupURL().\n+// Returns a formatted version of |url| appropriate to display to a user.\n+// When re-parsing this URL, clients should call url_formatter::FixupURL().\n base::string16 FormatBookmarkURLForDisplay(const GURL& url);\n \n // Returns whether the Apps shortcut is enabled. If true, then the visibility""}<_**next**_>{""sha"": ""4098467fc081af1263246bbe49d32fbea47d7ae9"", ""filename"": ""chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -259,6 +259,45 @@ void TearDown() override {\n   [controller_ cancel:nil];\n }\n \n+using BookmarkEditorControllerEditKeepsSchemeTest = CocoaProfileTest;\n+TEST_F(BookmarkEditorControllerEditKeepsSchemeTest, EditKeepsScheme) {\n+  // Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+  // when userinfo is present in the URL\n+  ASSERT_TRUE(profile());\n+\n+  BookmarkModel* model = BookmarkModelFactory::GetForBrowserContext(profile());\n+  const BookmarkNode* kParent = model->bookmark_bar_node();\n+  const base::string16 kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+  const BookmarkNode* kNode = model->AddURL(kParent, 0, base::string16(), kUrl);\n+\n+  BookmarkEditorController* controller = [[BookmarkEditorController alloc]\n+      initWithParentWindow:test_window()\n+                   profile:profile()\n+                    parent:kParent\n+                      node:kNode\n+                       url:GURL()\n+                     title:base::string16()\n+             configuration:BookmarkEditor::SHOW_TREE];\n+\n+  [controller runAsModalSheet];\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_NSEQ(base::SysUTF8ToNSString(kUrl.spec()),\n+              [[controller displayURL] stringByAppendingString:@\""/\""]);\n+\n+  [controller setDisplayName:base::SysUTF16ToNSString(kTitle)];\n+\n+  EXPECT_TRUE([controller okButtonEnabled]);\n+  [controller ok:nil];\n+\n+  ASSERT_EQ(1, kParent->child_count());\n+  const BookmarkNode* kChild = kParent->GetChild(0);\n+  EXPECT_EQ(kTitle, kChild->GetTitle());\n+  EXPECT_EQ(kUrl, kChild->url());\n+}\n+\n class BookmarkEditorControllerTreeTest : public CocoaProfileTest {\n \n  public:""}<_**next**_>{""sha"": ""2abe3d77823e2f144ab3c2c62b5117ac182d68d0"", ""filename"": ""chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -73,6 +73,13 @@ class BookmarkEditorViewTest : public testing::Test {\n       editor_->url_tf_->SetText(text);\n   }\n \n+  base::string16 GetURLText() const {\n+    if (editor_->details_.type != BookmarkEditor::EditDetails::NEW_FOLDER)\n+      return editor_->url_tf_->text();\n+\n+    return base::string16();\n+  }\n+\n   void ApplyEdits() {\n     editor_->ApplyEdits();\n   }\n@@ -332,6 +339,34 @@ TEST_F(BookmarkEditorViewTest, ChangeTitleNoTree) {\n   EXPECT_EQ(ASCIIToUTF16(\""new_a\""), new_node->GetTitle());\n }\n \n+// Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+// when userinfo is present in the URL\n+TEST_F(BookmarkEditorViewTest, EditKeepsScheme) {\n+  const BookmarkNode* kBBNode = model_->bookmark_bar_node();\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+\n+  CreateEditor(profile_.get(), kBBNode,\n+               BookmarkEditor::EditDetails::AddNodeInFolder(kBBNode, 1, kUrl,\n+                                                            base::string16()),\n+               BookmarkEditorView::SHOW_TREE);\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_EQ(ASCIIToUTF16(kUrl.spec()), GetURLText() + ASCIIToUTF16(\""/\""));\n+\n+  const base::string16& kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+  SetTitleText(kTitle);\n+\n+  ApplyEdits(editor_tree_model()->GetRoot()->GetChild(0));\n+\n+  ASSERT_EQ(4, kBBNode->child_count());\n+\n+  const BookmarkNode* kNewNode = kBBNode->GetChild(1);\n+\n+  EXPECT_EQ(kTitle, kNewNode->GetTitle());\n+  EXPECT_EQ(kUrl, kNewNode->url());\n+}\n+\n // Creates a new folder.\n TEST_F(BookmarkEditorViewTest, NewFolder) {\n   const BookmarkNode* bb_node = model_->bookmark_bar_node();""}"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
",C,"  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
","  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
",,"@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {
 
 base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
-  // and trailing slash, and unescape most characters.  However, it's
+  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
-  return url_formatter::FormatUrl(
-      url, url_formatter::kFormatUrlOmitAll &
-               ~url_formatter::kFormatUrlOmitUsernamePassword,
-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
+  url_formatter::FormatUrlTypes format_types =
+      url_formatter::kFormatUrlOmitAll &
+      ~url_formatter::kFormatUrlOmitUsernamePassword;
+
+  // If username is present, we must not omit the scheme because FixupURL() will
+  // subsequently interpret the username as a scheme. crbug.com/639126
+  if (url.has_username())
+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
+
+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
+                                  nullptr, nullptr, nullptr);
 }
 
 bool IsAppsShortcutEnabled(Profile* profile) {",Chrome,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,60cf29f2af9a364c215f71c9ac8fdd92c16b82b4,1," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
//flaw_line_below:
  // and trailing slash, and unescape most characters.  However, it's
//fix_flaw_line_below:
//  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
//flaw_line_below:
  return url_formatter::FormatUrl(
//flaw_line_below:
      url, url_formatter::kFormatUrlOmitAll &
//flaw_line_below:
               ~url_formatter::kFormatUrlOmitUsernamePassword,
//flaw_line_below:
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
//fix_flaw_line_below:
//  url_formatter::FormatUrlTypes format_types =
//fix_flaw_line_below:
//      url_formatter::kFormatUrlOmitAll &
//fix_flaw_line_below:
//      ~url_formatter::kFormatUrlOmitUsernamePassword;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // If username is present, we must not omit the scheme because FixupURL() will
//fix_flaw_line_below:
//  // subsequently interpret the username as a scheme. crbug.com/639126
//fix_flaw_line_below:
//  if (url.has_username())
//fix_flaw_line_below:
//    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
//fix_flaw_line_below:
//                                  nullptr, nullptr, nullptr);
 }
",186016," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
","The provided code defines a function, `FormatBookmarkURLForDisplay`, which takes a `GURL` object representing a URL as input and formats it for display purposes. It utilizes the `url_formatter::FormatUrl` function to format the URL while omitting certain components, specifically the username and password, as indicated by the bitwise operations on formatting flags. The function also specifies that spaces should be unescaped during the formatting process. The result is a `string16` object that contains the formatted URL, suitable for presentation in a user interface, while maintaining privacy by excluding sensitive information.","The code defines a function that formats a given URL for display purposes, ensuring that sensitive information such as usernames and passwords are omitted from the output. It processes the URL to create a user-friendly version, while also handling spaces by unescaping them. The resulting formatted string is designed to be suitable for presentation in a user interface, allowing users to view the URL without exposing any private details. This functionality enhances the security and usability of URLs when displayed, making them more accessible and visually appealing to users.","The vulnerability in the original code stemmed from insufficient validation of user-supplied URLs, allowing attackers to inject arbitrary scripts or HTML through crafted URLs, leading to a cross-site scripting issue. Specifically, the lack of proper handling for URLs containing usernames could result in the username being misinterpreted as a scheme, enabling exploitation. The fixed code addresses this by checking if the URL contains a username and ensuring that the scheme is not omitted in such cases. This adjustment prevents the misinterpretation of the URL components, thereby mitigating the risk of user-injected scripts and enhancing overall security.","The vulnerability in the original code was due to inadequate validation of user-supplied URLs, which allowed attackers to inject malicious scripts or HTML, leading to a cross-site scripting issue. This occurred because the code did not properly handle cases where a username was present in the URL, potentially misinterpreting it as a scheme. The fixed code addresses this by implementing a check for the presence of a username and ensuring that the scheme is retained in such cases. This change prevents the misinterpretation of URL components, thereby mitigating the risk of script injection and enhancing security.","The vulnerability was fixed by modifying the handling of URL formatting to ensure that the scheme is not omitted when a username is present. In the updated code, a conditional check was added to determine if the URL contains a username. If it does, the formatting types are adjusted to retain the scheme by removing the flag that omits the HTTP scheme. This change prevents the misinterpretation of the username as a scheme, thereby eliminating the potential for script injection through crafted URLs. The overall result is a more secure handling of user-supplied URLs in the application.","The vulnerability was fixed by implementing a check to ensure that the scheme of a URL is preserved when a username is present. The updated code introduces a conditional statement that modifies the formatting options based on the presence of a username, preventing it from being misinterpreted as a scheme. This adjustment ensures that the URL is processed correctly, thereby mitigating the risk of script injection through crafted URLs. By enhancing the validation of user-supplied data, the fix effectively addresses the security issue and improves the overall robustness of URL handling in the application.","4,4","4, 4","4, 4","4,4"
4,4,186246,186246,,Remote,Not required,,CVE-2016-1652,https://www.cvedetails.com/cve/CVE-2016-1652/,CWE-79,Medium,,Partial,,2016-04-18,4.3,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,5,https://github.com/chromium/chromium/commit/7c5aa07be11cd63d953fbe66370c5869a52170bf,7c5aa07be11cd63d953fbe66370c5869a52170bf,"Use install_static::GetAppGuid instead of the hardcoded string in BrandcodeConfigFetcher.

Bug: 769756
Change-Id: Ifdcb0a5145ffad1d563562e2b2ea2390ff074cdc
Reviewed-on: https://chromium-review.googlesource.com/1213178
Reviewed-by: Dominic Battré <battre@chromium.org>
Commit-Queue: Vasilii Sukhanov <vasilii@chromium.org>
Cr-Commit-Position: refs/heads/master@{#590275}",6,chrome/browser/profile_resetter/brandcode_config_fetcher.cc,"{""sha"": ""c15c60c3ac2815695cc024d1e7891827c18383c5"", ""filename"": ""chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 10, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profile_resetter/brandcode_config_fetcher.cc?ref=7c5aa07be11cd63d953fbe66370c5869a52170bf"", ""patch"": ""@@ -9,7 +9,9 @@\n \n #include \""base/callback_helpers.h\""\n #include \""base/macros.h\""\n+#include \""base/strings/stringprintf.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""build/build_config.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/profile_resetter/brandcoded_default_settings.h\""\n #include \""libxml/parser.h\""\n@@ -20,30 +22,34 @@\n #include \""services/network/public/cpp/simple_url_loader.h\""\n #include \""services/network/public/mojom/url_loader_factory.mojom.h\""\n \n+#if defined(OS_WIN)\n+#include \""chrome/install_static/install_util.h\""\n+#endif  // defined(OS_WIN)\n+\n namespace {\n \n-const int kDownloadTimeoutSec = 10;\n-const char kPostXml[] =\n+constexpr char kDefaultAppID[] = \""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"";\n+constexpr int kDownloadTimeoutSec = 10;\n+constexpr char kPostXml[] =\n     \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\""?>\""\n     \""<request\""\n     \""    version=\\\""chromeprofilereset-1.1\\\""\""\n     \""    protocol=\\\""3.0\\\""\""\n     \""    installsource=\\\""profilereset\\\"">\""\n-    \""  <app appid=\\\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\\\"">\""\n-    \""    <data name=\\\""install\\\"" index=\\\""__BRANDCODE_PLACEHOLDER__\\\""/>\""\n+    \""  <app appid=\\\""%s\\\"">\""\n+    \""    <data name=\\\""install\\\"" index=\\\""%s\\\""/>\""\n     \""  </app>\""\n     \""</request>\"";\n \n // Returns the query to the server which can be used to retrieve the config.\n // |brand| is a brand code, it mustn't be empty.\n std::string GetUploadData(const std::string& brand) {\n+  std::string app_id(kDefaultAppID);\n+#if defined(OS_WIN)\n+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());\n+#endif  // defined(OS_WIN)\n   DCHECK(!brand.empty());\n-  std::string data(kPostXml);\n-  const std::string placeholder(\""__BRANDCODE_PLACEHOLDER__\"");\n-  size_t placeholder_pos = data.find(placeholder);\n-  DCHECK(placeholder_pos != std::string::npos);\n-  data.replace(placeholder_pos, placeholder.size(), brand);\n-  return data;\n+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());\n }\n \n // Extracts json master prefs from xml.""}"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
"," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
",C,"  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
","  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
",,"@@ -9,7 +9,9 @@
 
 #include ""base/callback_helpers.h""
 #include ""base/macros.h""
+#include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
+#include ""build/build_config.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/profile_resetter/brandcoded_default_settings.h""
 #include ""libxml/parser.h""
@@ -20,30 +22,34 @@
 #include ""services/network/public/cpp/simple_url_loader.h""
 #include ""services/network/public/mojom/url_loader_factory.mojom.h""
 
+#if defined(OS_WIN)
+#include ""chrome/install_static/install_util.h""
+#endif  // defined(OS_WIN)
+
 namespace {
 
-const int kDownloadTimeoutSec = 10;
-const char kPostXml[] =
+constexpr char kDefaultAppID[] = ""{8A69D345-D564-463C-AFF1-A69D9E530F96}"";
+constexpr int kDownloadTimeoutSec = 10;
+constexpr char kPostXml[] =
     ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
     ""<request""
     ""    version=\""chromeprofilereset-1.1\""""
     ""    protocol=\""3.0\""""
     ""    installsource=\""profilereset\"">""
-    ""  <app appid=\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"">""
-    ""    <data name=\""install\"" index=\""__BRANDCODE_PLACEHOLDER__\""/>""
+    ""  <app appid=\""%s\"">""
+    ""    <data name=\""install\"" index=\""%s\""/>""
     ""  </app>""
     ""</request>"";
 
 // Returns the query to the server which can be used to retrieve the config.
 // |brand| is a brand code, it mustn't be empty.
 std::string GetUploadData(const std::string& brand) {
+  std::string app_id(kDefaultAppID);
+#if defined(OS_WIN)
+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
+#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
-  std::string data(kPostXml);
-  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
-  size_t placeholder_pos = data.find(placeholder);
-  DCHECK(placeholder_pos != std::string::npos);
-  data.replace(placeholder_pos, placeholder.size(), brand);
-  return data;
+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
 
 // Extracts json master prefs from xml.",Chrome,7c5aa07be11cd63d953fbe66370c5869a52170bf,32582f5489e1e45821e4583886ba5c19845bb2ac,1," std::string GetUploadData(const std::string& brand) {
//fix_flaw_line_below:
//  std::string app_id(kDefaultAppID);
//fix_flaw_line_below:
//#if defined(OS_WIN)
//fix_flaw_line_below:
//  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
//fix_flaw_line_below:
//#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
//flaw_line_below:
  std::string data(kPostXml);
//flaw_line_below:
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
//flaw_line_below:
  size_t placeholder_pos = data.find(placeholder);
//flaw_line_below:
  DCHECK(placeholder_pos != std::string::npos);
//flaw_line_below:
  data.replace(placeholder_pos, placeholder.size(), brand);
//flaw_line_below:
  return data;
//fix_flaw_line_below:
//  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
",186246," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
","The `GetUploadData` function generates a string containing XML data for uploading, where it replaces a specific placeholder with a provided brand code. It first checks that the input `brand` is not empty using a debug assertion. The function initializes a string `data` with a predefined XML template (`kPostXml`) and searches for the placeholder `__BRANDCODE_PLACEHOLDER__`. Upon finding the placeholder, it replaces it with the actual `brand` value. Finally, the modified XML string is returned, ready for use in an upload operation.","The code defines a function that generates a formatted XML string for uploading, incorporating a specific brand code. It begins by ensuring that the input brand is not empty, which is crucial for data integrity. The function then initializes a string with a predefined XML template and searches for a designated placeholder within this template. Once the placeholder is located, it is replaced with the provided brand code. The final output is the modified XML string, which is prepared for subsequent upload operations, ensuring that the brand information is correctly embedded within the XML structure.","The vulnerability in the original code stemmed from directly embedding user-supplied input (the brand code) into an XML template without proper sanitization, leading to a cross-site scripting (XSS) risk. Attackers could exploit this by injecting malicious scripts through the brand parameter. In the fixed code, the vulnerability was addressed by using a safer method to format the XML string, specifically through `base::StringPrintf`, which ensures that the app ID and brand code are properly handled and escaped. This change mitigates the risk of XSS by preventing the execution of injected scripts in the generated output.","The vulnerability in the original code arose from directly incorporating user input into an XML template without adequate sanitization, creating a risk for cross-site scripting (XSS) attacks. Malicious users could exploit this by injecting harmful scripts through the input, potentially compromising the application. The fixed code addressed this issue by employing a safer method for formatting the output, which ensures that any user-supplied data is properly handled and escaped. This change effectively mitigates the risk of executing injected scripts, thereby enhancing the security of the application against XSS vulnerabilities.","The vulnerability was fixed by replacing the direct string manipulation approach with a safer formatting method. In the original code, user input was directly inserted into the XML template, which could lead to XSS attacks. The updated code utilizes `base::StringPrintf` to format the output string, ensuring that both the application ID and the user-supplied brand code are properly handled. This method automatically escapes any potentially harmful characters in the input, thus preventing the execution of injected scripts and significantly reducing the risk of cross-site scripting vulnerabilities in the generated XML data.","The vulnerability was fixed by changing the method of incorporating user input into the output string. Instead of directly embedding the user-supplied data into the XML template, which posed a risk for cross-site scripting attacks, the updated approach uses a safer formatting technique that ensures proper handling of the input. This method automatically escapes any potentially harmful characters, preventing the execution of malicious scripts. By implementing this change, the code significantly enhances security, effectively mitigating the risk of XSS vulnerabilities in the generated output.","5,4","4,4","4,4","4,4"
5,5,186366,186366,,Remote,Not required,,CVE-2017-5069,https://www.cvedetails.com/cve/CVE-2017-5069/,CWE-79,Medium,,Partial,,2017-10-27,4.3,"Incorrect MIME type of XSS-Protection reports in Blink in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac, and 58.0.3029.83 for Android, allowed a remote attacker to circumvent Cross-Origin Resource Sharing checks via a crafted HTML page.",2019-10-02,XSS ,1,https://github.com/chromium/chromium/commit/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,"Prevent regular mode session startup pref type turning to default.

When user loses past session tabs of regular mode after
invoking a new window from the incognito mode.

This was happening because the SessionStartUpPref type was being set
to default, from last, for regular user mode. This was happening in
the RestoreIfNecessary method where the restoration was taking place
for users whose SessionStartUpPref type was set to last.

The fix was to make the protocol of changing the pref type to
default more explicit to incognito users and not regular users
of pref type last.

Bug: 481373
Change-Id: I96efb4cf196949312181c83c6dcd45986ddded13
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1774441
Reviewed-by: Tommy Martino <tmartino@chromium.org>
Reviewed-by: Ramin Halavati <rhalavati@chromium.org>
Commit-Queue: Rohit Agarwal <roagarwal@chromium.org>
Cr-Commit-Position: refs/heads/master@{#691726}",2,chrome/browser/ui/startup/startup_browser_creator.cc,"{""sha"": ""f118e6d27ecca45fecfc48580608159a47d2de24"", ""filename"": ""chrome/browser/ui/startup/startup_browser_creator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/startup/startup_browser_creator.cc?ref=7a0dee9d17d0ee7fd1b40b017442f4952384a7c2"", ""patch"": ""@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n       pref.type = SessionStartupPref::LAST;\n   }\n \n-  if (pref.type == SessionStartupPref::LAST &&\n-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {\n     // We don't store session information when incognito. If the user has\n     // chosen to restore last session and launched incognito, fallback to\n     // default launch behavior.""}","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",C,"  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
","  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
",,"@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
       pref.type = SessionStartupPref::LAST;
   }
 
-  if (pref.type == SessionStartupPref::LAST &&
-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.",Chrome,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,278e05fafb1fc77c5d23425c3c1c5ee5a4082f17,1,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

  // IsChromeFirstRun() looks for a sentinel file to determine whether the user
  // is starting Chrome for the first time. On Chrome OS, the sentinel is stored
  // in a location shared by all users and the check is meaningless. Query the
  // UserManager instead to determine whether the user is new.
#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  // On ChromeOS restarts force the user to login again. The expectation is that
  // after a login the user gets clean state. For this reason we ignore
  // StartupBrowserCreator::WasRestarted(). However
  // StartupBrowserCreator::WasRestarted has to be called in order to correctly
  // update pref values.
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  // The pref has an OS-dependent default value. For the first run only, this
  // default is overridden with SessionStartupPref::DEFAULT so that first run
  // behavior (sync promo, welcome page) is consistently invoked.
  // This applies only if the pref is still at its default and has not been
  // set by the user, managed prefs or policy.
  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  // The switches::kRestoreLastSession command line switch is used to restore
  // sessions after a browser self restart (e.g. after a Chrome upgrade).
  // However, new profiles can be created from a browser process that has this
  // switch so do not set the session pref to SessionStartupPref::LAST for
  // those as there is nothing to restore.
  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  // A browser starting for a profile being unlocked should always restore.
  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
//flaw_line_below:
  if (pref.type == SessionStartupPref::LAST &&
//flaw_line_below:
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
//fix_flaw_line_below:
//  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",186366,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","The provided code defines a function that determines the session startup preferences for a browser based on various conditions, such as whether it's the first run, if the browser was restarted, and the profile type. It retrieves the user's preferences and checks if the current user is new or if the browser has been restarted. Depending on these checks, it sets the session type to either restore the last session or use default settings. Additionally, it considers whether the profile requires sign-in and whether incognito mode should be launched, ultimately returning the appropriate session startup preference.","The code defines a function that determines the startup preferences for a browser session based on several conditions, including whether it is the first time the browser is being run and if it has been restarted. It checks the user's profile status and adjusts the session type accordingly, opting to restore the last session or use default settings. Additionally, it evaluates whether the profile requires sign-in and considers the possibility of launching in incognito mode. Ultimately, the function returns the appropriate session startup preference based on these evaluations.","The vulnerability, identified as CWE-79, arises from improper handling of user input, which can lead to cross-site scripting (XSS) attacks. In the vulnerable code, the session startup preferences were set without adequate validation of the profile's attributes, potentially allowing an attacker to manipulate session data. The fix in the updated code introduces a check for whether the profile is off-the-record before setting the session type to restore the last session. This additional validation ensures that only appropriate profiles can influence session preferences, thereby mitigating the risk of XSS attacks by enforcing stricter controls on session management.","The vulnerability, classified as CWE-79, involves inadequate validation of user input, which can lead to cross-site scripting (XSS) attacks. In the vulnerable code, session preferences could be manipulated without proper checks, allowing an attacker to exploit this weakness through crafted HTML pages. The fix in the updated code introduces additional validation to ensure that only specific profile types can influence session preferences. By enforcing stricter conditions on which profiles can restore sessions, the revised code mitigates the risk of XSS attacks, thereby enhancing the overall security of the application against such exploits.","The vulnerability was fixed by adding a check for whether the profile is off-the-record before allowing the session type to be set to restore the last session. In the updated code, the condition that checks if the session type is set to ""LAST"" now includes a verification of the profile's status using the `profile->IsOffTheRecord()` function. This ensures that only appropriate profiles, which are not off-the-record, can influence session preferences. By implementing this additional validation, the code mitigates the risk of cross-site scripting attacks by preventing unauthorized manipulation of session data.","The vulnerability was addressed by introducing an additional validation step that restricts the conditions under which session preferences can be modified. Specifically, the updated code ensures that only profiles that are not off-the-record can set the session type to restore the last session. This added check prevents unauthorized or malicious profiles from influencing session management, thereby reducing the risk of cross-site scripting attacks. By enforcing stricter criteria for session restoration, the fix enhances the overall security of the application and protects against potential exploitation through crafted input.","5,5","4,4","4,4","4, 4"
6,6,186418,186418,,Remote,Not required,,CVE-2017-5008,https://www.cvedetails.com/cve/CVE-2017-5008/,CWE-79,Medium,,Partial,,2017-02-17,4.3,"Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed attacker controlled JavaScript to be run during the invocation of a private script method, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,6,https://github.com/chromium/chromium/commit/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,"Don't touch the prototype chain to get the private script controller.

Prior to this patch, private scripts attempted to get the
""privateScriptController"" property off the global object without verifying if
the property actually exists on the global. If the property hasn't been set yet,
this operation could descend into the prototype chain and potentially return
a named property from the WindowProperties object, leading to release asserts
and general confusion.

BUG=668552

Review-Url: https://codereview.chromium.org/2529163002
Cr-Commit-Position: refs/heads/master@{#434627}",6,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""1560d1019cd74abcf6c6d6d16fc0ed9e83f91c1b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,2 @@\n+ \n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552). If the test is successful, it should not crash.""}<_**next**_>{""sha"": ""1e410c0447a83fab2da5eb9fb6693d754719d9e8"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+<img name=\""privateScriptController\"">\n+<marquee></marquee>\n+<div>\n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552).\n+If the test is successful, it should not crash.\n+</div>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""eb4974e91d06882361bb7a1470c0d82fbb358bd7"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n-  v8::Local<v8::Value> privateScriptController =\n-      global->Get(context, v8String(isolate, \""privateScriptController\""))\n-          .ToLocalChecked();\n-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n-                 privateScriptController->IsObject());\n-  if (privateScriptController->IsObject()) {\n+  v8::Local<v8::String> key = v8String(isolate, \""privateScriptController\"");\n+\n+  if (global->HasOwnProperty(context, key).ToChecked()) {\n+    v8::Local<v8::Value> privateScriptController =\n+        global->Get(context, key).ToLocalChecked();\n+    CHECK(privateScriptController->IsObject());\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =""}<_**next**_>{""sha"": ""e2571f43f7722dbf99cb78d37b6c9948ff06e6aa"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -139,7 +139,7 @@ PrivateScriptController.prototype = {\n     },\n }\n \n-if (typeof window.privateScriptController === 'undefined')\n+if (!window.hasOwnProperty(\""privateScriptController\""))\n     window.privateScriptController = new PrivateScriptController();\n \n // This line must be the last statement of this JS file.""}","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",C,"  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
","  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
",,"@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
-  v8::Local<v8::Value> privateScriptController =
-      global->Get(context, v8String(isolate, ""privateScriptController""))
-          .ToLocalChecked();
-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
-                 privateScriptController->IsObject());
-  if (privateScriptController->IsObject()) {
+  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
+
+  if (global->HasOwnProperty(context, key).ToChecked()) {
+    v8::Local<v8::Value> privateScriptController =
+        global->Get(context, key).ToLocalChecked();
+    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =",Chrome,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,42839ee8c1195b25fbe327057e10c54f592b6693,1,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
//flaw_line_below:
  v8::Local<v8::Value> privateScriptController =
//flaw_line_below:
      global->Get(context, v8String(isolate, ""privateScriptController""))
//flaw_line_below:
          .ToLocalChecked();
//flaw_line_below:
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
//flaw_line_below:
                 privateScriptController->IsObject());
//flaw_line_below:
  if (privateScriptController->IsObject()) {
//fix_flaw_line_below:
//  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (global->HasOwnProperty(context, key).ToChecked()) {
//fix_flaw_line_below:
//    v8::Local<v8::Value> privateScriptController =
//fix_flaw_line_below:
//        global->Get(context, key).ToLocalChecked();
//fix_flaw_line_below:
//    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      // This is a memory leak, FunctionTemplates are eternal.
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",186418,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","The `compileAndRunPrivateScript` function compiles and executes a JavaScript script within a specified V8 context, utilizing a provided script class name and source code. It first retrieves a global object, checks for a `privateScriptController`, and sets an `import` function if it is undefined. The function then compiles the script using the V8 engine, handling any compilation errors by logging them. Finally, it runs the compiled script and returns the result, ensuring that any runtime errors are also captured and logged, maintaining robust error handling throughout the process.","The function compiles and executes a JavaScript script within a specific execution context, using a provided class name and source code. It first checks for a controller object in the global context and sets an import function if it is not already defined. The script is then compiled, with error handling to log any issues that arise during this process. After successful compilation, the function runs the script and captures the result, ensuring that any runtime errors are also logged, thereby maintaining a robust error management system throughout the execution.","The vulnerability in the original code stemmed from the lack of validation for the existence and type of the `privateScriptController` object in the global context, allowing an attacker to inject arbitrary scripts or HTML through crafted input, leading to a cross-site scripting (XSS) attack. In the fixed code, the addition of the `global->HasOwnProperty(context, key).ToChecked()` check ensures that the `privateScriptController` is verified to exist before being accessed. This prevents the execution of potentially malicious scripts by ensuring that only a valid object is processed, thereby mitigating the risk of unauthorized script execution.","The vulnerability in the original code allowed an attacker to inject arbitrary scripts or HTML due to insufficient validation of a critical object in the global context, enabling the execution of attacker-controlled JavaScript. This oversight could lead to cross-site scripting (XSS) attacks, where malicious content could be executed in the user's browser. The fixed code addresses this issue by implementing a check to ensure that the object exists and is of the correct type before it is accessed. This validation step effectively prevents unauthorized script execution, thereby mitigating the risk of exploitation through crafted input.","The vulnerability was fixed by adding a check to verify the existence of the `privateScriptController` object in the global context using `global->HasOwnProperty(context, key).ToChecked()`. This ensures that the code only proceeds if the object is present and valid, preventing the execution of potentially malicious scripts. Additionally, the code now asserts that `privateScriptController` is indeed an object with `CHECK(privateScriptController->IsObject())`, further safeguarding against improper access. These changes collectively enhance the security of the script execution process by ensuring that only legitimate objects are processed, thereby mitigating the risk of cross-site scripting attacks.","The vulnerability was fixed by implementing a validation check to ensure that a critical object exists in the global context before it is accessed. This check confirms that the object is present and of the correct type, preventing the execution of potentially malicious scripts. Additionally, the code now includes an assertion to verify that the object is indeed valid, further enhancing security. These modifications ensure that only legitimate and properly defined objects are processed, effectively mitigating the risk of cross-site scripting attacks and protecting against unauthorized script execution.","4,5","5,5","5,4","4,5"
7,7,186670,186670,,Remote,Not required,,CVE-2018-6051,https://www.cvedetails.com/cve/CVE-2018-6051/,CWE-79,Medium,Partial,,,2018-09-25,4.3,"XSS Auditor in Google Chrome prior to 64.0.3282.119, did not ensure the reporting URL was in the same origin as the page it was on, which allowed a remote attacker to obtain referrer details via a crafted HTML page.",2018-11-15,XSS ,7,https://github.com/chromium/chromium/commit/0da6dcdbe8e34740133773d20cc466b89d399d0a,0da6dcdbe8e34740133773d20cc466b89d399d0a,"Restrict the xss audit report URL to same origin

BUG=441275
R=tsepez@chromium.org,mkwst@chromium.org

Change-Id: I27bc8e251b9ad962c3b4fdebf084a2b9152f915d
Reviewed-on: https://chromium-review.googlesource.com/768367
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Jochen Eisinger <jochen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516666}",0,third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp,"{""sha"": ""f991b2454bb8761dcd41fdcbfccaba4aab310f42"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,11 @@\n+CONSOLE ERROR: Error parsing header X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=report-script-tag.html: reporting URL is not same scheme, host, and port as page at character position 10. The default protections will be applied.\n+CONSOLE ERROR: line 4: The XSS Auditor blocked access to 'http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=%3Cscript%3Ealert(String.fromCharCode(0x58,0x53,0x53))%3C/script%3E%3Cp%3EIf%20you%20see%20this%20message,%20no%20JavaScript%20alert(),%20and%20not%20dump%20of%20a%20report%20is%20displayed%20below,%20then%20the%20test%20PASSED.%3C/p%3E' because the source code of a script was found within the request. The server sent an 'X-XSS-Protection' header requesting this behavior.\n+This tests that the X-XSS-Protection reports are sent out properly\n+\n+\n+\n+--------\n+Frame: 'frame'\n+--------\n+Could not load the requested resource.\n+Error code: -28 (net::ERR_BLOCKED_BY_XSS_AUDITOR)""}<_**next**_>{""sha"": ""ca8a315df359e6b57849c3d798aa87496719b89f"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,25 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<script src=\""http://localhost:8000/security/xssAuditor/resources/utilities.js\""></script>\n+<script>\n+if (window.testRunner) {\n+    testRunner.dumpAsText();\n+    testRunner.dumpChildFramesAsText();\n+    testRunner.waitUntilDone();\n+    testRunner.setXSSAuditorEnabled(true);\n+}\n+\n+function notify() {\n+  if (window.testRunner) {\n+    setTimeout(testRunner.notifyDone.bind(testRunner), 0);\n+  }\n+}\n+</script>\n+</head>\n+<body>\n+<p>This tests that the X-XSS-Protection reports are sent out properly</p>\n+<iframe onload=\""notify()\"" name=\""frame\"" src=\""http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=<script>alert(String.fromCharCode(0x58,0x53,0x53))</script><p>If you see this message, no JavaScript alert(), and not dump of a report is displayed below, then the test PASSED.</p>\"">\n+</iframe>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""d3cb1524857b6ca8557df334e6feeb380123f922"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -13,6 +13,8 @@\n     print \""X-XSS-Protection: 1; mode=block\\n\"";\n } elsif ($cgi->param('enable-report')) {\n     print \""X-XSS-Protection: 1; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n+} elsif ($cgi->param('enable-report-cross-origin')) {\n+    print \""X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('enable-full-block-report')) {\n     print \""X-XSS-Protection: 1; mode=block; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('valid-header')) {""}<_**next**_>{""sha"": ""4005f3b4c046b0d63dd7c2dfdc71790ee4849bdf"", ""filename"": ""third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n+      if (!SecurityOrigin::Create(xss_protection_report_url)\n+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {\n+        error_details =\n+            \""reporting URL is not same scheme, host, and port as page\"";\n+        xss_protection_header = kReflectedXSSInvalid;\n+        xss_protection_report_url = KURL();\n+      }\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \""insecure reporting URL for secure page\"";""}","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",C,"      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
",,,"@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
+      if (!SecurityOrigin::Create(xss_protection_report_url)
+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
+        error_details =
+            ""reporting URL is not same scheme, host, and port as page"";
+        xss_protection_header = kReflectedXSSInvalid;
+        xss_protection_report_url = KURL();
+      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";",Chrome,0da6dcdbe8e34740133773d20cc466b89d399d0a,c99c6fa1c62d04fb36be582fae389b9f34c2c089,1,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  // In theory, the Document could have detached from the LocalFrame after the
  // XSSAuditor was constructed.
  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    // The URL can be empty when opening a new browser window or calling
    // window.open("""").
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
//fix_flaw_line_below:
//      if (!SecurityOrigin::Create(xss_protection_report_url)
//fix_flaw_line_below:
//               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
//fix_flaw_line_below:
//        error_details =
//fix_flaw_line_below:
//            ""reporting URL is not same scheme, host, and port as page"";
//fix_flaw_line_below:
//        xss_protection_header = kReflectedXSSInvalid;
//fix_flaw_line_below:
//        xss_protection_report_url = KURL();
//fix_flaw_line_below:
//      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",186670,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","The `XSSAuditor::Init` function initializes the XSS auditor for a given document, ensuring it operates on the main thread and is in an uninitialized state. It checks if the XSS auditor is enabled based on document settings and validates the document's URL and frame. The function parses the `X-XSS-Protection` HTTP header to determine the appropriate XSS protection strategy, counting usage metrics accordingly. It handles potential errors in header parsing, sets a reporting URL if applicable, and processes any HTTP body data. Finally, it sets the document's encoding, preparing the auditor for subsequent operations.","The provided code initializes an XSS auditor for a document, ensuring it runs on the main thread and is in the correct state. It checks if the auditor is enabled based on document settings and validates the document's URL and frame. The code parses a specific HTTP header to determine the XSS protection strategy, while also counting usage metrics based on the header's value. It handles any errors in parsing, sets a reporting URL if necessary, and processes any HTTP body data. Finally, it configures the document's encoding, preparing the auditor for its intended functionality.","The vulnerability in the original code stemmed from the lack of validation for the reporting URL, allowing it to be from a different origin than the document, which could lead to cross-site scripting attacks. Specifically, the code did not check if the reporting URL had the same scheme, host, and port as the document's security origin. The fix introduced a validation step using `SecurityOrigin::Create` to ensure the reporting URL matched the document's origin. This change prevents potential attackers from exploiting the XSS auditor to leak sensitive information, thereby enhancing the security of the application.","The vulnerability in the original code allowed a remote attacker to exploit the XSS auditor by not validating that the reporting URL was from the same origin as the document, potentially leading to cross-site scripting attacks. This oversight could enable attackers to access sensitive referrer information through crafted HTML pages. The fix addressed this issue by implementing a validation check to ensure that the reporting URL matched the document's origin in terms of scheme, host, and port. This enhancement effectively mitigated the risk of unauthorized access to sensitive data, thereby improving the overall security of the application.","The vulnerability was fixed by adding a validation step that checks whether the reporting URL is from the same origin as the document. This was achieved by using `SecurityOrigin::Create` to create a security origin for the reporting URL and then calling `IsSameSchemeHostPort` to compare it with the document's security origin. If the origins did not match, an error message was generated, and the reporting URL was marked as invalid. This change ensures that only reporting URLs from the same origin are accepted, thereby preventing potential cross-site scripting attacks and enhancing the security of the XSS auditor.","The vulnerability was fixed by implementing a validation mechanism to ensure that the reporting URL originates from the same scheme, host, and port as the document. This involved creating a security origin for the reporting URL and comparing it with the document's origin. If the origins did not match, the reporting URL was deemed invalid, and an appropriate error message was generated. This enhancement effectively prevents the acceptance of potentially malicious reporting URLs, thereby mitigating the risk of cross-site scripting attacks and improving the overall security of the application.","5, 5","5, 5","4,4","4,4"
8,8,186873,186873,,Remote,Not required,,CVE-2018-6070,https://www.cvedetails.com/cve/CVE-2018-6070/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Lack of CSP enforcement on WebUI pages in Bink in Google Chrome prior to 65.0.3325.146 allowed an attacker who convinced a user to install a malicious extension to bypass content security policy via a crafted Chrome Extension.,2019-10-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/f283cdf7c850f3db923a5303c7e01bd929d4117f,f283cdf7c850f3db923a5303c7e01bd929d4117f,"Move Initialize() to VaapiImageDecoder parent class.

This CL moves the implementation of Initialize() to VaapiImageDecoder,
since it is common to all implementing classes.

Bug: 877694
Test: jpeg_decode_accelerator_unittest
Change-Id: Ic99601953ae1c7a572ba8a0b0bf43675b2b0969d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1654249
Commit-Queue: Gil Dekel <gildekel@chromium.org>
Reviewed-by: Andres Calderon Jaramillo <andrescj@chromium.org>
Reviewed-by: Miguel Casas <mcasas@chromium.org>
Cr-Commit-Position: refs/heads/master@{#668645}",8,media/gpu/vaapi/vaapi_jpeg_decoder.cc,"{""sha"": ""7671f22290878c00f91af2e1d87d9de0140ae980"", ""filename"": ""media/gpu/vaapi/OWNERS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/OWNERS?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -4,3 +4,6 @@ posciak@chromium.org\n \n # (M)JPEG related stuff\n per-file *jpeg*=andrescj@chromium.org\n+\n+# General VA-API decoding related stuff\n+per-file *image_decoder*=andrescj@chromium.org""}<_**next**_>{""sha"": ""5bafbd695cceeb07b4e15d0812f1e3ecfb60573a"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -6,13 +6,37 @@\n \n #include <va/va.h>\n \n+#include \""base/logging.h\""\n #include \""media/gpu/vaapi/vaapi_wrapper.h\""\n \n namespace media {\n \n+namespace {\n+\n+VAProfile ConvertToVAProfile(VaapiImageDecoder::Type type) {\n+  switch (type) {\n+    case VaapiImageDecoder::Type::kJpeg:\n+      return VAProfileJPEGBaseline;\n+    case VaapiImageDecoder::Type::kWebP:\n+      return VAProfileVP8Version0_3;\n+    default:\n+      NOTREACHED() << \""Undefined Type value\"";\n+      return VAProfileNone;\n+  }\n+}\n+\n+}  // namespace\n+\n VaapiImageDecoder::VaapiImageDecoder()\n     : va_surface_id_(VA_INVALID_SURFACE), va_rt_format_(kInvalidVaRtFormat) {}\n \n VaapiImageDecoder::~VaapiImageDecoder() = default;\n \n+bool VaapiImageDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n+  const VAProfile va_profile = ConvertToVAProfile(GetType());\n+  vaapi_wrapper_ =\n+      VaapiWrapper::Create(VaapiWrapper::kDecode, va_profile, error_uma_cb);\n+  return !!vaapi_wrapper_;\n+}\n+\n }  // namespace media""}<_**next**_>{""sha"": ""68eaf26e7e53f695f831bf805696d423cb2da451"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -50,11 +50,17 @@ enum class VaapiImageDecodeStatus : uint32_t {\n // more implementing classes are added (e.g. VaapiWebPDecoder).\n class VaapiImageDecoder {\n  public:\n+  // Type of image decoder.\n+  enum class Type {\n+    kJpeg,\n+    kWebP,\n+  };\n+\n   virtual ~VaapiImageDecoder();\n \n-  // Initializes |vaapi_wrapper_| in kDecode mode with the appropriate VAAPI\n-  // profile and |error_uma_cb| for error reporting.\n-  virtual bool Initialize(const base::RepeatingClosure& error_uma_cb) = 0;\n+  // Uses GetType() to initialize |vaapi_wrapper_| in kDecode mode with the\n+  // appropriate VAAPI profile and |error_uma_cb| for error reporting.\n+  bool Initialize(const base::RepeatingClosure& error_uma_cb);\n \n   // Decodes a picture. It will fill VA-API parameters and call the\n   // corresponding VA-API methods according to the image in |encoded_image|.\n@@ -66,6 +72,9 @@ class VaapiImageDecoder {\n       base::span<const uint8_t> encoded_image,\n       VaapiImageDecodeStatus* status) = 0;\n \n+  // Returns the type of the current decoder.\n+  virtual Type GetType() const = 0;\n+\n  protected:\n   VaapiImageDecoder();\n ""}<_**next**_>{""sha"": ""53b26a84045c8af0fb54071850b5be48e0bad649"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 10, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {\n   }\n }\n \n-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n-                                        VAProfileJPEGBaseline, error_uma_cb);\n-  if (!vaapi_wrapper_) {\n-    VLOGF(1) << \""Failed initializing VAAPI\"";\n-    return false;\n-  }\n-  return true;\n-}\n-\n scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n     base::span<const uint8_t> encoded_image,\n     VaapiImageDecodeStatus* status) {\n@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n                                          base::DoNothing() /* release_cb */);\n }\n \n+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {\n+  return VaapiImageDecoder::Type::kJpeg;\n+}\n+\n std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(\n     uint32_t preferred_image_fourcc,\n     VaapiImageDecodeStatus* status) {""}<_**next**_>{""sha"": ""270a7481b9e75f7c4ce657b5c84b6a5d059c12e5"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -30,9 +30,9 @@ class VaapiJpegDecoder : public VaapiImageDecoder {\n   ~VaapiJpegDecoder() override;\n \n   // VaapiImageDecoder implementation.\n-  bool Initialize(const base::RepeatingClosure& error_uma_cb) override;\n   scoped_refptr<VASurface> Decode(base::span<const uint8_t> encoded_image,\n                                   VaapiImageDecodeStatus* status) override;\n+  Type GetType() const override;\n \n   // Get the decoded data from the last Decode() call as a ScopedVAImage. The\n   // VAImage's format will be either |preferred_image_fourcc| if the conversion""}","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",C,,"  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",,"@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {
   }
 }
 
-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
-                                        VAProfileJPEGBaseline, error_uma_cb);
-  if (!vaapi_wrapper_) {
-    VLOGF(1) << ""Failed initializing VAAPI"";
-    return false;
-  }
-  return true;
-}
-
 scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
     base::span<const uint8_t> encoded_image,
     VaapiImageDecodeStatus* status) {
@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
                                          base::DoNothing() /* release_cb */);
 }
 
+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {
+  return VaapiImageDecoder::Type::kJpeg;
+}
+
 std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(
     uint32_t preferred_image_fourcc,
     VaapiImageDecodeStatus* status) {",Chrome,f283cdf7c850f3db923a5303c7e01bd929d4117f,4f67ec23d9cf3ea7ab718a8dc7cd618674317472,1,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
//flaw_line_below:
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
//flaw_line_below:
                                        VAProfileJPEGBaseline, error_uma_cb);
//flaw_line_below:
  if (!vaapi_wrapper_) {
//flaw_line_below:
    VLOGF(1) << ""Failed initializing VAAPI"";
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:
  return true;
//flaw_line_below:
}
",186873,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","The `Initialize` function in the `VaapiJpegDecoder` class is responsible for setting up a VAAPI (Video Acceleration API) wrapper for JPEG decoding. It attempts to create an instance of `VaapiWrapper` configured for decoding with the baseline JPEG profile. If the creation of the `vaapi_wrapper_` fails, it logs an error message and returns `false`, indicating unsuccessful initialization. If successful, the function returns `true`, signaling that the decoder is ready for use. Additionally, it accepts a callback function, `error_uma_cb`, which is invoked in case of an error during the initialization process.","The provided code defines a function that initializes a video decoding component specifically for JPEG images using a hardware acceleration API. It attempts to create a wrapper for the decoding process, configured for a standard JPEG profile. If the creation of this wrapper fails, an error message is logged, and the function indicates that the initialization was unsuccessful. Conversely, if the wrapper is successfully created, the function confirms that the decoder is ready for operation. Additionally, it accepts a callback function that can be triggered in the event of an error during the initialization process.","The vulnerability, identified as CWE-79, arises from the lack of Content Security Policy (CSP) enforcement in WebUI pages, which allows attackers to inject malicious scripts through crafted Chrome extensions. In the vulnerable code, the absence of proper security measures meant that the `VaapiJpegDecoder::Initialize` function could be exploited to execute unauthorized actions. The fixed code likely introduced CSP headers or validation checks to ensure that only trusted content is executed, thereby mitigating the risk of script injection. This change enhances the security of the initialization process by preventing unauthorized access and manipulation of the decoding functionality.","The vulnerability, classified as CWE-79, stems from the absence of Content Security Policy (CSP) enforcement on specific web pages, enabling attackers to inject malicious scripts through crafted extensions. This lack of security allowed unauthorized scripts to execute, potentially compromising user data and system integrity. The fix involved implementing robust CSP measures to restrict the execution of untrusted content, thereby preventing script injection. By enforcing these security policies, the updated code ensures that only authorized and safe content can be executed, significantly reducing the risk of exploitation through malicious extensions and enhancing overall application security.","The vulnerability was fixed by enhancing the `VaapiJpegDecoder::Initialize` function to enforce stricter security measures, likely through the implementation of Content Security Policy (CSP) headers. This change ensures that any content loaded during the initialization process is validated against a defined policy, preventing unauthorized scripts from executing. By incorporating these security checks, the function mitigates the risk of script injection that could be exploited via malicious extensions. This proactive approach not only secures the initialization process but also protects the overall integrity of the application against potential attacks targeting the WebUI pages.","The vulnerability was addressed by implementing stricter security measures to enforce Content Security Policy (CSP) on the affected web pages. This involved adding validation checks that restrict the execution of untrusted content, thereby preventing the injection of malicious scripts. By establishing a defined policy for what content can be loaded and executed, the fix effectively mitigates the risk of exploitation through crafted extensions. This proactive approach enhances the overall security posture of the application, ensuring that only authorized and safe content is processed, thus protecting user data and system integrity from potential attacks.","3, 3","1, 1","2, 3","3, 2"
9,9,186880,186880,,Remote,Not required,,CVE-2018-6076,https://www.cvedetails.com/cve/CVE-2018-6076/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.,2018-12-19,XSS ,1,https://github.com/chromium/chromium/commit/f8f6ed59949be4451ee2f5443d8a313f102fde60,f8f6ed59949be4451ee2f5443d8a313f102fde60,"Percent-encode UTF8 characters in URL fragment identifiers.

This brings us into line with Firefox, Safari, and the spec.

Bug: 758523
Change-Id: I7e354ab441222d9fd08e45f0e70f91ad4e35fafe
Reviewed-on: https://chromium-review.googlesource.com/668363
Commit-Queue: Mike West <mkwst@chromium.org>
Reviewed-by: Jochen Eisinger <jochen@chromium.org>
Reviewed-by: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#507481}",3,url/url_canon_etc.cc,"{""sha"": ""fc7148cbdeb0750f0a4a6371d06f512679e0f321"", ""filename"": ""components/url_formatter/elide_url_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/elide_url_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -338,13 +338,14 @@ TEST(TextEliderTest, TestElisionSpecialCases) {\n \n       // Unescaping.\n       {\""http://www/%E4%BD%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" +\n+           kEllipsisStr},\n \n       // Invalid unescaping for path. The ref will always be valid UTF-8. We\n       // don't bother to do too many edge cases, since these are handled by the\n       // escaper unittest.\n       {\""http://www/%E4%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" + kEllipsisStr},\n   };\n \n   RunElisionTest(testcases);""}<_**next**_>{""sha"": ""522cb4576fc3fd45800effb5c5951d8914ef5a3a"", ""filename"": ""components/url_formatter/url_formatter_unittest.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 19, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/url_formatter_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -762,7 +762,7 @@ TEST(UrlFormatterTest, FormatUrl) {\n \n       {\""With a port number and a reference\"",\n        \""http://www.google.com:8080/#\\xE3\\x82\\xB0\"", default_format_type,\n-       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#\\x30B0\"", 7},\n+       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#%E3%82%B0\"", 7},\n \n       // -------- IDN tests --------\n       {\""Japanese IDN with ja\"", \""http://xn--l8jvb1ey91xtjb.jp\"",\n@@ -1027,9 +1027,10 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                      \""%E3%82%B0/?q=%E3%82%B0#\\xE3\\x82\\xB0\""),\n                 kFormatUrlOmitNothing, net::UnescapeRule::NONE,\n                 &parsed, nullptr, nullptr);\n-  EXPECT_EQ(WideToUTF16(\n-      L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/%E3%82%B0/?q=%E3%82%B0#\\x30B0\""), formatted);\n+  EXPECT_EQ(\n+      WideToUTF16(L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n+                  L\""/%E3%82%B0/?q=%E3%82%B0#%E3%82%B0\""),\n+      formatted);\n   EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""%E3%83%BC\""),\n@@ -1042,8 +1043,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=%E3%82%B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Unescape case.\n   formatted =\n@@ -1052,7 +1053,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, &parsed,\n                 nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0:\\x30FC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""\\x30FC\""),\n@@ -1065,8 +1067,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Omit_username_password + unescape case.\n   formatted =\n@@ -1075,7 +1077,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitUsernamePassword, net::UnescapeRule::NORMAL,\n                 &parsed, nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_FALSE(parsed.username.is_valid());\n   EXPECT_FALSE(parsed.password.is_valid());\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\\x30FC\\x30B0\\x30EB.jp\""),\n@@ -1086,8 +1089,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // View-source case.\n   formatted =\n@@ -1320,14 +1323,13 @@ TEST(UrlFormatterTest, FormatUrlWithOffsets) {\n       kFormatUrlOmitNothing, net::UnescapeRule::SPACES, unescape_offsets);\n \n   const size_t ref_offsets[] = {\n-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n-    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, kNpos, kNpos, 32, kNpos, kNpos,\n-    33\n-  };\n+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,\n+      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n+      34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49};\n   // Unescape to \""http://www.google.com/foo.html#\\x30B0\\x30B0z\"".\n-  CheckAdjustedOffsets(\n-      \""http://www.google.com/foo.html#\\xE3\\x82\\xB0\\xE3\\x82\\xB0z\"",\n-      kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, ref_offsets);\n+  CheckAdjustedOffsets(\""http://www.google.com/foo.html#%E3%82%B0%E3%82%B0z\"",\n+                       kFormatUrlOmitNothing, net::UnescapeRule::NORMAL,\n+                       ref_offsets);\n \n   const size_t omit_http_offsets[] = {\n     0, kNpos, kNpos, kNpos, kNpos, kNpos, kNpos, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,""}<_**next**_>{""sha"": ""7672b12a6db0bdccdb4ea8940cda31afe9969a87"", ""filename"": ""components/url_matcher/url_matcher_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_matcher/url_matcher_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -168,7 +168,7 @@ TEST(URLMatcherConditionFactoryTest, GURLCharacterSet) {\n   EXPECT_TRUE(base::IsStringASCII(url.host()));\n   EXPECT_TRUE(base::IsStringASCII(url.path()));\n   EXPECT_TRUE(base::IsStringASCII(url.query()));\n-  EXPECT_FALSE(base::IsStringASCII(url.ref()));\n+  EXPECT_TRUE(base::IsStringASCII(url.ref()));\n }\n \n TEST(URLMatcherConditionFactoryTest, Criteria) {""}<_**next**_>{""sha"": ""46aa9d9fba31d9c3fec30db76a89ac7516a52dbc"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""status"": ""renamed"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 248 PASS, 326 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 251 PASS, 323 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n FAIL URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n FAIL <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n@@ -565,12 +565,12 @@ FAIL <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#' assert_equa\n PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n-FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'"", ""previous_filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-setters-expected.txt""}<_**next**_>{""sha"": ""5422190a3d98f83155961158319fe379a4c4c8b3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -55,7 +55,7 @@\n     assert_equals(url.hash, '');\n \n     url.hash = '\\udc01\\ud802a';\n-    assert_equals(url.hash, '#\\ufffd\\ufffda');\n+    assert_equals(url.hash, '#%EF%BF%BD%EF%BF%BDa');\n }, 'hash with unmatched surrogates');\n \n </script>""}<_**next**_>{""sha"": ""6fe9c1b320ef5f270baf8b8ea1b45fed616bbcb9"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,11 +4,11 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.example.com/#hello, world') is 'http://www.example.com/#hello, world'\n-PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#\u00c2\u00a9'\n-PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#\ud800\udf00ss'\n+PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#%C3%82%C2%A9'\n+PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#%F0%90%8C%80ss'\n PASS canonicalize('http://www.example.com/#%41%a') is 'http://www.example.com/#%41%a'\n-PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#\\uFFFD\\u597D'\n-FAIL canonicalize('http://www.example.com/#a\\uFDD0') should be http://www.example.com/#a\ufdd0. Was http://www.example.com/#a\ufffd.\n+PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#%EF%BF%BD%E5%A5%BD'\n+PASS canonicalize('http://www.example.com/#a\\uFDD0') is 'http://www.example.com/#a%EF%BF%BD'\n PASS canonicalize('http://www.example.com/#asdf#qwer') is 'http://www.example.com/#asdf#qwer'\n PASS canonicalize('http://www.example.com/##asdf') is 'http://www.example.com/##asdf'\n PASS canonicalize('http://www.example.com/#a\\nb\\rc\\td') is 'http://www.example.com/#abcd'""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""2ad64ae1134a8b1bc2c2d40b9a0b3c9aa86ae481"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,11 +2,11 @@ description(\""Test URLs that have an anchor.\"");\n \n cases = [ \n   [\""hello, world\"", \""hello, world\""],\n-  [\""\\xc2\\xa9\"", \""\\xc2\\xa9\""],\n-  [\""\\ud800\\udf00ss\"", \""\\ud800\\udf00ss\""],\n+  [\""\\xc2\\xa9\"", \""%C3%82%C2%A9\""],\n+  [\""\\ud800\\udf00ss\"", \""%F0%90%8C%80ss\""],\n   [\""%41%a\"", \""%41%a\""],\n-  [\""\\\\ud800\\\\u597d\"", \""\\\\uFFFD\\\\u597D\""],\n-  [\""a\\\\uFDD0\"", \""a\\\\uFDD0\""],\n+  [\""\\\\ud800\\\\u597d\"", \""%EF%BF%BD%E5%A5%BD\""],\n+  [\""a\\\\uFDD0\"", \""a%EF%BF%BD\""],\n   [\""asdf#qwer\"", \""asdf#qwer\""],\n   [\""#asdf\"", \""#asdf\""],\n   [\""a\\\\nb\\\\rc\\\\td\"", \""abcd\""],""}<_**next**_>{""sha"": ""db9386372bec5d3ed93d777839f8eb630b282b86"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,8 +36,8 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xc2\""],\n-    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xc2\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n+    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""0fc34b79acb7eb8b99cf001b750ef13f12f5f3b5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,7 +36,7 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xef\\\\xbf\\\\xbd\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""af075a5c2c7ed601137bf0086f8efec691b7e3a7"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -98,7 +98,7 @@ cases = [\n   [\""/a%2fc\"",                                  [\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]],\n   [\""/a/%2f/c\"",                                [\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]],\n \n-  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\\u03B2\""]],\n+  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]],\n ];\n \n var originalBaseURL = canonicalize(\"".\"");""}<_**next**_>{""sha"": ""75e2422895ceeec756f849b049d4af98ab2b9f4c"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,7 +2,7 @@ description(\""Canonicalization of standard URLs\"");\n \n cases = [\n   [\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\""],\n-  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# \\u00bb\""],\n+  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# %C2%BB\""],\n   [\""http://[www.google.com]/\"", \""http://[www.google.com]/\""],\n   [\""http://www.google.com\"", \""http://www.google.com/\""],\n   // Disabled because whitespace gets treated different in this API.\n@@ -17,7 +17,7 @@ cases = [\n   // Backslashes should get converted to forward slashes.\n   [\""http:\\\\\\\\\\\\\\\\www.google.com\\\\\\\\foo\"", \""http://www.google.com/foo\""],\n   // Busted refs shouldn't make the whole thing fail.\n-  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#\\\\uFFFD\""],\n+  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#%EF%BF%BD\""],\n   // Basic port tests.\n   [\""http://foo:80/\"", \""http://foo/\""],\n   [\""http://foo:81/\"", \""http://foo:81/\""],""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""03c416b46404d8384da523031ab83e060ba769ef"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,8 +2,8 @@ Test how non-ASCII characters are encoded in relative URLs.\n \n 1 2 3 4 5\n 1. PASS\n-2. FAIL: http://127.0.0.1:8000/uri/resolve-encoding-relative.html#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+2. PASS\n 3. PASS\n 4. PASS\n-5. FAIL: http://127.0.0.1:8000/%D0%BF%D1%83%D1%82%D1%8C?%E7%E0%EF%F0%EE%F1#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+5. PASS\n ""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""1b7414e269228933412bab601cbb152ec66e4200"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 392 PASS, 121 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 395 PASS, 118 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""6c8cd6b4b4443053d60525e36956fee495b7b6f7"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""e331b5e2c7ad2956b78a496e1ae3723e6f7e358a"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n PASS canonicalize('file:filer/home\\\\me') is 'file://filer/home/me'\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""0fb1a0301f109feb9e6dd386dbf83a00c0343f05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""9373dcc8dfa2032009e78c8871ce6ddd45a5cbec"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""dc386c57ab5f3083b1b77947dd1116c7612a248d"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -61,7 +61,7 @@ TEST(KURLTest, Getters) {\n        // shouldn't return it in percent-encoded form.\n        \""http://www.google.com/foo/blah?bar=baz#\\xce\\xb1\\xce\\xb2\"", \""http\"",\n        \""www.google.com\"", 0, \""\"", 0, \""/foo/blah\"", \""blah\"", \""bar=baz\"",\n-       \""\\xce\\xb1\\xce\\xb2\"", true},\n+       \""%CE%B1%CE%B2\"", true},\n       {\""http://foo.com:1234/foo/bar/\"", \""http\"", \""foo.com\"", 1234, \""\"", 0,\n        \""/foo/bar/\"", \""bar\"", 0, 0, false},\n       {\""http://www.google.com?#\"", \""http\"", \""www.google.com\"", 0, \""\"", 0, \""/\"", 0,""}<_**next**_>{""sha"": ""5dc81052311965a922f571c59f9be0064328dc82"", ""filename"": ""url/url_canon_etc.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 7, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_etc.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,\n       // Normal ASCII characters are just appended.\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n-      // Non-ASCII characters are appended unescaped, but only when they are\n-      // valid. Invalid Unicode characters are replaced with the \""invalid\n-      // character\"" as IE seems to (ReadUTFChar puts the unicode replacement\n-      // character in the output on failure for us).\n-      unsigned code_point;\n-      ReadUTFChar(spec, &i, end, &code_point);\n-      AppendUTF8Value(code_point, output);\n+      AppendUTF8EscapedChar(spec, &i, end, output);\n     }\n   }\n ""}<_**next**_>{""sha"": ""feac82c44b350d5be2be6ff8730ea7c9352c422a"", ""filename"": ""url/url_canon_unittest.cc"", ""status"": ""modified"", ""additions"": 83, ""deletions"": 58, ""changes"": 141, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1274,21 +1274,23 @@ TEST(URLCanonTest, Ref) {\n   // Refs are trivial, it just checks the encoding.\n   DualComponentCase ref_cases[] = {\n       // Regular one, we shouldn't escape spaces, et al.\n-    {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12), true},\n+      {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12),\n+       true},\n       // UTF-8/wide input should be preserved\n-    {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#\\xc2\\xa9\"", Component(1, 2), true},\n+      {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#%C2%A9\"", Component(1, 6), true},\n       // Test a characer that takes > 16 bits (U+10300 = old italic letter A)\n-    {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#\\xF0\\x90\\x8C\\x80ss\"", Component(1, 6), true},\n+      {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#%F0%90%8C%80ss\"",\n+       Component(1, 14), true},\n       // Escaping should be preserved unchanged, even invalid ones\n-    {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n+      {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n       // Invalid UTF-8/16 input should be flagged and the input made valid\n-    {\""\\xc2\"", NULL, \""#\\xef\\xbf\\xbd\"", Component(1, 3), true},\n-    {NULL, L\""\\xd800\\x597d\"", \""#\\xef\\xbf\\xbd\\xe5\\xa5\\xbd\"", Component(1, 6), true},\n+      {\""\\xc2\"", NULL, \""#%EF%BF%BD\"", Component(1, 9), true},\n+      {NULL, L\""\\xd800\\x597d\"", \""#%EF%BF%BD%E5%A5%BD\"", Component(1, 18), true},\n       // Test a Unicode invalid character.\n-    {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a\\xef\\xbf\\xbd\"", Component(1, 4), true},\n+      {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a%EF%BF%BD\"", Component(1, 10), true},\n       // Refs can have # signs and we should preserve them.\n-    {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n-    {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n+      {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n+      {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n   };\n \n   for (size_t i = 0; i < arraysize(ref_cases); i++) {\n@@ -1351,49 +1353,56 @@ TEST(URLCanonTest, CanonicalizeStandardURL) {\n     const char* expected;\n     bool expected_success;\n   } cases[] = {\n-    {\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\"", true},\n-    {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n-    {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"", false},\n-    {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"", true},\n-    {\""www.google.com\"", \"":www.google.com/\"", false},\n-    {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n-    {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n-    {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n-    {\""http://%25DOMAIN:foobar@foodomain.com/\"", \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n+      {\""http://www.google.com/foo?bar=baz#\"",\n+       \""http://www.google.com/foo?bar=baz#\"", true},\n+      {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n+      {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"",\n+       false},\n+      {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"",\n+       true},\n+      {\""www.google.com\"", \"":www.google.com/\"", false},\n+      {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n+      {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n+      {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n+      {\""http://%25DOMAIN:foobar@foodomain.com/\"",\n+       \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n \n       // Backslashes should get converted to forward slashes.\n-    {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n+      {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n \n       // Busted refs shouldn't make the whole thing fail.\n-    {\""http://www.google.com/asdf#\\xc2\"", \""http://www.google.com/asdf#\\xef\\xbf\\xbd\"", true},\n+      {\""http://www.google.com/asdf#\\xc2\"",\n+       \""http://www.google.com/asdf#%EF%BF%BD\"", true},\n \n       // Basic port tests.\n-    {\""http://foo:80/\"", \""http://foo/\"", true},\n-    {\""http://foo:81/\"", \""http://foo:81/\"", true},\n-    {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n-    {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n-\n-    {\""https://foo:443/\"", \""https://foo/\"", true},\n-    {\""https://foo:80/\"", \""https://foo:80/\"", true},\n-    {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n-    {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n-    {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n-    {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n-    {\""ws://foo:80/\"", \""ws://foo/\"", true},\n-    {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n-    {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n-    {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n-    {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n-    {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n-    {\""wss://foo:443/\"", \""wss://foo/\"", true},\n-    {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n+      {\""http://foo:80/\"", \""http://foo/\"", true},\n+      {\""http://foo:81/\"", \""http://foo:81/\"", true},\n+      {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n+      {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n+\n+      {\""https://foo:443/\"", \""https://foo/\"", true},\n+      {\""https://foo:80/\"", \""https://foo:80/\"", true},\n+      {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n+      {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n+      {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n+      {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n+      {\""ws://foo:80/\"", \""ws://foo/\"", true},\n+      {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n+      {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n+      {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n+      {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n+      {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n+      {\""wss://foo:443/\"", \""wss://foo/\"", true},\n+      {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n \n       // This particular code path ends up \""backing up\"" to replace an invalid\n       // host ICU generated with an escaped version. Test that in the context\n       // of a full URL to make sure the backing up doesn't mess up the non-host\n       // parts of the URL. \""EF B9 AA\"" is U+FE6A which is a type of percent that\n       // ICU will convert to an ASCII one, generating \""%81\"".\n-    {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\""81:80/\"", \""ws://%29w%1ew%81/\"", false},\n+      {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\n+       \""81:80/\"",\n+       \""ws://%29w%1ew%81/\"", false},\n   };\n \n   for (size_t i = 0; i < arraysize(cases); i++) {\n@@ -1683,41 +1692,57 @@ TEST(URLCanonTest, CanonicalizeFileURL) {\n   } cases[] = {\n #ifdef _WIN32\n       // Windows-style paths\n-    {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n-    {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n-    {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7), Component(14, 5)},\n+      {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n+      {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n+      {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7),\n+       Component(14, 5)},\n       // CanonicalizeFileURL supports absolute Windows style paths for IE\n       // compatibility. Note that the caller must decide that this is a file\n       // URL itself so it can call the file canonicalizer. This is usually\n       // done automatically as part of relative URL resolving.\n-    {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n+      {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n+      {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n       // We should preserve the number of slashes after the colon for IE\n       // compatibility, except when there is none, in which case we should\n       // add one.\n-    {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n+      {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n       // Three slashes should be non-UNC, even if there is no drive spec (IE\n       // does this, which makes the resulting request invalid).\n-    {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(), Component(7, 12)},\n+      {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(),\n+       Component(7, 12)},\n       // TODO(brettw) we should probably fail for invalid host names, which\n       // would change the expected result on this test. We also currently allow\n       // colon even though it's probably invalid, because its currently the\n       // \""natural\"" result of the way the canonicalizer is written. There doesn't\n       // seem to be a strong argument for why allowing it here would be bad, so\n       // we just tolerate it and the load will fail later.\n-    {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false, Component(7, 2), Component(9, 16)},\n-    {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5), Component(12, 8)},\n+      {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false,\n+       Component(7, 2), Component(9, 16)},\n+      {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5),\n+       Component(12, 8)},\n       // Make sure relative paths can't go above the \""C:\""\n-    {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true, Component(), Component(7, 12)},\n+      {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true,\n+       Component(), Component(7, 12)},\n       // Busted refs shouldn't make the whole thing fail.\n-    {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xef\\xbf\\xbd\"", true, Component(), Component(7, 8)},\n+      {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%EF%BF%BD\"", true, Component(),\n+       Component(7, 8)},\n #else\n       // Unix-style paths\n     {\""file:///home/me\"", \""file:///home/me\"", true, Component(), Component(7, 8)},""}","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",C,"      AppendUTF8EscapedChar(spec, &i, end, output);
","      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
",,"@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
-      // Non-ASCII characters are appended unescaped, but only when they are
-      // valid. Invalid Unicode characters are replaced with the ""invalid
-      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
-      // character in the output on failure for us).
-      unsigned code_point;
-      ReadUTFChar(spec, &i, end, &code_point);
-      AppendUTF8Value(code_point, output);
+      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 ",Chrome,f8f6ed59949be4451ee2f5443d8a313f102fde60,0a918e900a759b04f177cc5b8bca668140751136,1,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    // Common case of no ref.
    *out_ref = Component();
    return;
  }

  // Append the ref separator. Note that we need to do this even when the ref
  // is empty but present.
  output->push_back('#');
  out_ref->begin = output->length();

  // Now iterate through all the characters, converting to UTF-8 and validating.
  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      // IE just strips NULLs, so we do too.
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      // Unline IE seems to, we escape control characters. This will probably
      // make the reference fragment unusable on a web page, but people
      // shouldn't be using control characters in their anchor names.
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
//flaw_line_below:
      // Non-ASCII characters are appended unescaped, but only when they are
//flaw_line_below:
      // valid. Invalid Unicode characters are replaced with the ""invalid
//flaw_line_below:
      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
//flaw_line_below:
      // character in the output on failure for us).
//flaw_line_below:
      unsigned code_point;
//flaw_line_below:
      ReadUTFChar(spec, &i, end, &code_point);
//flaw_line_below:
      AppendUTF8Value(code_point, output);
//fix_flaw_line_below:
//      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",186880,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","The `DoCanonicalizeRef` function processes a given character specification (`spec`) and a reference component (`ref`) to generate a canonicalized output while handling special characters. If the length of `ref` is negative, it initializes `out_ref` to an empty component and exits. The function begins by appending a '#' character to the output and records the starting position of the reference. It then iterates through the characters in `spec`, escaping non-printable characters, directly appending printable ASCII characters, and converting UTF-8 characters as needed. Finally, it calculates and sets the length of the canonicalized reference in `out_ref`.","The provided code defines a function that processes a character specification and a reference component to create a canonicalized output. It first checks if the reference length is valid; if not, it initializes an output reference and exits. The function then appends a specific character to the output and records the starting position of the reference. It iterates through the characters in the specification, handling non-printable characters by escaping them, appending printable characters directly, and converting multi-byte characters as necessary. Finally, it calculates and updates the length of the canonicalized reference in the output.","The vulnerability in the original code stemmed from insufficient encoding of URL fragment identifiers, which allowed for the injection of untrusted data into the output, leading to potential DOM-based XSS attacks. Specifically, the handling of multi-byte characters was inadequate, as it did not properly escape them, allowing attackers to manipulate the output. In the fixed code, the function was updated to use `AppendUTF8EscapedChar` instead of directly appending potentially unsafe characters, ensuring that all characters, including multi-byte ones, are properly escaped before being added to the output. This change mitigates the risk of XSS by ensuring that all output is safely encoded.","The vulnerability in the original code was due to inadequate encoding of URL fragment identifiers, which could allow an attacker to inject malicious content, leading to DOM-based XSS attacks. This occurred because the code did not properly escape certain characters, particularly multi-byte characters, when processing user input. The fix involved implementing a more robust escaping mechanism for all characters, ensuring that any potentially harmful input was safely encoded before being included in the output. This change effectively mitigated the risk of XSS by preventing untrusted data from being executed in the browser context.","The vulnerability was fixed by replacing the direct handling of multi-byte characters with a dedicated escaping function. In the original code, multi-byte characters were processed without proper escaping, which could lead to XSS attacks. The updated code introduced the use of `AppendUTF8EscapedChar`, ensuring that all characters, including those outside the ASCII range, are safely encoded before being added to the output. This change guarantees that potentially harmful characters are escaped, thus preventing them from being executed in the browser context and effectively mitigating the risk of DOM-based XSS vulnerabilities.","The vulnerability was addressed by implementing a more secure method for handling character encoding, particularly for multi-byte characters. The updated code introduced a dedicated escaping mechanism that ensures all characters, including those that could be potentially harmful, are properly encoded before being included in the output. This change prevents untrusted input from being executed in the browser context, effectively mitigating the risk of DOM-based XSS attacks. By ensuring that all characters are safely processed, the fix enhances the overall security of the application against injection vulnerabilities.","4,4","5,5","4,4","4,4"
10,10,186914,186914,,Remote,Not required,,CVE-2017-15427,https://www.cvedetails.com/cve/CVE-2017-15427/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a socially engineered user to XSS themselves by dragging and dropping a javascript: URL into the URL bar.,2018-11-02,XSS ,2,https://github.com/chromium/chromium/commit/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,"Strip JavaScript schemas on Linux text drop

When dropping text onto the Omnibox, any leading JavaScript schemes
should be stripped to avoid a ""self-XSS"" attack. This stripping already
occurs in all cases except when plaintext is dropped on Linux. This CL
corrects that oversight.

Bug: 768910
Change-Id: I43af24ace4a13cf61d15a32eb9382dcdd498a062
Reviewed-on: https://chromium-review.googlesource.com/685638
Reviewed-by: Justin Donnelly <jdonnelly@chromium.org>
Commit-Queue: Eric Lawrence <elawrence@chromium.org>
Cr-Commit-Position: refs/heads/master@{#504695}",1,chrome/browser/ui/views/omnibox/omnibox_view_views.cc,"{""sha"": ""98a8ac9c38531ee785f98f7ce297dde52f5ad7fa"", ""filename"": ""chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/omnibox/omnibox_view_views.cc?ref=16c719e0e275d2ee5d5c69e4962b744bcaf0fe40"", ""patch"": ""@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n+      base::string16 collapsed_text(\n+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;""}","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",C,"      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
","      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
",,"@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
+      base::string16 collapsed_text(
+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;",Chrome,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,4a165e1b93e099fceb38de3ade51e368ce949075,1,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
//flaw_line_below:
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
//fix_flaw_line_below:
//      base::string16 collapsed_text(
//fix_flaw_line_below:
//          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",186914,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","The `OnDrop` function in the `OmniboxViewViews` class handles drag-and-drop operations for URLs and text. It first checks if any text is currently being dragged; if so, it cancels the drop. If the dropped data contains a URL, it retrieves the URL and its title, strips any JavaScript schemas, and checks if the model can process the URL for navigation. If valid, it executes a ""Paste and Go"" action. Similarly, if the data contains a string, it collapses whitespace and checks its validity before pasting. If neither condition is met, it returns a ""no drop"" status.","The provided code defines a function that manages the behavior of drag-and-drop actions within a user interface component. It first checks if any text is currently being dragged; if so, it prevents the drop. If the dropped data includes a URL, the function retrieves it and verifies its format, allowing for navigation if valid. Similarly, if the data contains a string, it processes the text by removing unnecessary whitespace and checks its validity for navigation. If neither type of data is suitable for processing, the function indicates that the drop action is not allowed.","The vulnerability, identified as CWE-79, allowed users to execute cross-site scripting (XSS) attacks by dragging and dropping a JavaScript URL into the URL bar, which could lead to unintended script execution. In the fixed code, the function now includes a call to `StripJavascriptSchemas` on both the URL and any dropped string, effectively sanitizing the input by removing potentially harmful JavaScript schemas before processing. This ensures that only safe URLs or text are accepted for navigation, thereby preventing the execution of malicious scripts and mitigating the XSS risk.","The vulnerability, classified as CWE-79, allowed users to inadvertently execute cross-site scripting (XSS) attacks by dragging and dropping JavaScript URLs into the URL bar, which could lead to the execution of malicious scripts. This occurred due to a lack of proper input validation and sanitization for URLs. The fix implemented in the updated code involved adding a sanitization step that removes harmful JavaScript schemas from both URLs and text inputs before they are processed. This ensures that only safe and valid URLs are accepted, effectively mitigating the risk of XSS attacks and enhancing overall security.","The vulnerability was fixed by incorporating the `StripJavascriptSchemas` function to sanitize both URLs and strings before they are processed. In the updated code, after retrieving the URL and title, the function applies `StripJavascriptSchemas` to the URL to eliminate any potentially harmful JavaScript schemas. Additionally, when handling string data, the code also uses `StripJavascriptSchemas` on the collapsed text. This ensures that any malicious JavaScript content is removed, preventing users from inadvertently executing scripts through drag-and-drop actions, thereby effectively mitigating the risk of cross-site scripting (XSS) attacks.","The vulnerability was addressed by implementing a sanitization process that removes potentially harmful JavaScript schemas from both URLs and text inputs before they are processed. This involved adding a step to clean the input data, ensuring that any malicious content is stripped away. By validating and sanitizing the data, the updated code prevents users from inadvertently executing scripts through drag-and-drop actions. This enhancement effectively mitigates the risk of cross-site scripting (XSS) attacks, thereby improving the overall security of the application and protecting users from potential exploitation.","5,5","5, 5","4, 4","4,4"
